---
layout: post
title: Property-based testing with ScalaCheck - custom generators
date: '2014-09-19T11:33:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- testing
- ScalaCheck
- scala
modified_time: '2014-09-19T11:33:02.494+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2199646930772740089
blogger_orig_url: https://www.nurkiewicz.com/2014/09/property-based-testing-with-scalacheck.html
---

In the <a href="http://www.nurkiewicz.com/2014/09/property-based-testing-with-spock.html">previous article</a> we examined how <a href="http://code.google.com/p/spock/">Spock</a> can be used to implement property-based testing. One of the &quot;<em>hello, world</em>&quot; examples of property-based testing is making sure absolute value of arbitrary integer is always non-negative. We did that one as well. However our test didn't discover very important edge case. See for yourself, this time with <a href="http://scalacheck.org/">ScalaCheck</a> and <a href="http://www.scalatest.org/">ScalaTest</a>:<br/><br/><pre class="brush: scala">import org.scalatest.FunSuite<br />import org.scalatest.prop.Checkers<br /><br />class AbsSuite extends FunSuite with Checkers {<br /><br />    test(&quot;absolute value should not be negative&quot;) {<br />        check((somInt: Int) =&gt; {<br />            somInt.abs &gt;= 0<br />        })<br />    }<br />}<br /></pre> ...or with a different syntax:<br/><br/> <pre class="brush: scala">import org.scalatest.FunSuite<br />import org.scalatest.matchers.ShouldMatchers<br />import org.scalatest.prop.{GeneratorDrivenPropertyChecks, Checkers}<br /><br />class AbsSuite extends FunSuite with GeneratorDrivenPropertyChecks with ShouldMatchers{<br /><br />    test(&quot;absolute value should not be negative&quot;) {<br />        forAll((someInt: Int) =&gt; {<br />            someInt.abs should be &gt;= 0<br />        })<br />    }<br />}<br /></pre> The results are surprising:<br/><br/><pre class="brush: scala">GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.<br /> (AbsSuite.scala:7)<br />  Falsified after 8 successful property evaluations.<br />  Location: (AbsSuite.scala:7)<br />  Occurred when passed generated values (<br />    arg0 = -2147483648<br />  )<br /></pre> ScalaCheck tells us that our property is not met for input = <code>-2147483648</code>. What's so special about this number? <code>int</code>s aren't symmetric, <code>Integer.MIN_VALUE</code> = <code>-2147483648</code> while <code>Integer.MAX_VALUE</code> = <code>2147483647</code>. It's not possible to represent <code>2147483648</code> in <code>Int</code>:<br/><br/><pre class="brush: scala">scala&gt; (-2147483647).abs<br />res0: Int = 2147483647<br /><br />scala&gt; (-2147483648).abs<br />res0: Int = -2147483648<br /></pre> <hr />You got a taste of ScalaCheck combined with ScalaTest. ScalaCheck is much more advanced compared to our Groovy solution because it supports:<br/><br/><ul><li>parallelism - running examples in multiple threads</li><li>custom data generators - type safe and composable, resolved at compile time</li><li>shrinking - finding smallest input that exhibits erroneous behaviour</li><li>predictability - can re-run tests with the same examples later in case of rarely occurring bugs</li></ul>To test drive ScalaCheck we will work on a simple bank abstraction:<br/><br/><pre class="brush: scala">case class AccountNo(num: BigInt) extends AnyVal<br /><br />case class Account(accNo: AccountNo, balance: BigDecimal) {<br />    def withBalancePlus(amount: BigDecimal): Account =<br />        this.copy(balance = this.balance + amount)<br /><br />    def withBalanceMinus(amount: BigDecimal) = withBalancePlus(-amount)<br /><br />}<br /><br />class Bank(accounts: Map[AccountNo, Account]) {<br /><br />    def this(newAccounts: TraversableOnce[Account]) {<br />        this(newAccounts.map(acc =&gt; (acc.accNo, acc)).toMap)<br />    }<br /><br />    def transfer(from: AccountNo, to: AccountNo, amount: BigDecimal): Bank = {<br />        val modifiedFrom = accounts(from).withBalanceMinus(amount)<br />        val modifiedTo = accounts(to).withBalancePlus(amount)<br />        val newAccounts = accounts<br />            .updated(from, modifiedFrom)<br />            .updated(to, modifiedTo)<br />        new Bank(newAccounts)<br />    }<br /><br />    def totalMoney = accounts.values.map(_.balance).sum<br /><br />}<br /></pre> To stay with the spirit of functional programming, our <code>Bank</code> implementation is immutable (<code>accounts</code> is of <code>scala.collection.immutable.Map</code> type), as well as <code>Account</code> and <code>AccountNo</code>. Every time we call <code>Bank.transfer()</code>, new instance of <code>Bank</code> is created, almost exactly the same, but with <code>from</code> and <code>to</code> accounts modified. This greatly simplifies coding in multi-threaded environment. Code is quite simple: take <code>amount</code> of money from one account and put it on another. Assume we have few example based tests and we are confident this code works. But to be extra safe we are going to build property based test. What is the property that will be satisfied, no matter how many transfers we perform? The most important one is that the total money in the bank should remain the same, no matter how many intra-bank transfers are executed. After all, we don't want money to disappear or appear from nowhere.<br/><br/>Our test should prove that <em>any</em> bank, with <em>any</em> number of <em>arbitrary</em> transfers has the same total amount of money before and after executing transfers. We start with simple:<br/><br/><pre class="brush: scala">class BankSuite extends FunSuite with Checkers {<br /><br />    test(&quot;Total money should not change after arbitrary number of intra-bank transfers&quot;) {<br />        check((bank: Bank, transfers: List[Transfer]) =&gt; {<br />            val bankAfterTransfers = transfers.foldLeft(bank) { (curBank, transfer) =&gt;<br />                curBank.transfer(transfer.from, transfer.to, transfer.amount)<br />            }<br />            bank.totalMoney == bankAfterTransfers.totalMoney<br />        })<br />    }<br />}<br /><br />case class Transfer(from: AccountNo, to: AccountNo, amount: BigDecimal) <br /></pre> What we are saying is: for any <code>bank</code> and any <code>List</code> of <code>transfers</code>, <code>totalMoney</code> before and after should remain the same. We must <code>foldLeft()</code> because <code>Bank</code> is immutable and every transfer must be applied on a <code>Bank</code> instance returned from a previous one. ScalaCheck can generate random <code>Int</code>s (as we saw in <code>AbsSuite</code>) and other primitives, strings, etc. - and collections of these. But ScalaCheck has no idea how to create random <code>Bank</code> or <code>Transfer</code>:<br/><br/><pre class="brush: scala">Error:(34, 8) could not find implicit value for parameter a1: org.scalacheck.Arbitrary[com.nurkiewicz.banking.Bank]<br />        check((bank: Bank, transfers: List[Transfer]) =&gt; {<br />             ^<br /></pre> What the compiler is telling us is that it can't find a type class <a href="http://www.scalacheck.org/files/scalacheck_2.11-1.11.5-api/#org.scalacheck.Arbitrary"><code>org.scalacheck.Arbitrary[T]</code></a> type-parameterized with <code>Bank</code>. There are instances of this type class for primitives or collections, but obviously not for our <code>Bank</code>. There are actually two abstractions we need to provide: <code>Gen</code> implementation and <code>Arbitrary</code> type class wrapping it. Let's go through it step by step. <code>accountNoGen</code> generates random <code>AccountNo</code> with values ranging from <code>100000</code> and <code>999999</code>. <code>Gen</code> is like a stateless stream of data, it produces possibly infinite number of random values. You might wonder, why not just use <code>Math.rand()</code>? We can, but this way ScalaCheck can instrument all generated random data and e.g. allow replying it later, when the same random seed is used.<br/><br/><pre class="brush: scala">val accountNoGen: Gen[AccountNo] =<br />    Gen.choose(100000, 999999).map(n =&gt; AccountNo(BigInt(n)))<br /></pre> <code>moneyGen</code> generates arbitrary positive amount of money (up to cent precision). Having these we can compose <code>accountGen</code> by taking arbitrary account number and balance:<br/><br/><pre class="brush: scala">val moneyGen = for {<br />    value &lt;- Gen.chooseNum(0, 100000000)<br />    valueDecimal = BigDecimal.valueOf(value)<br />} yield valueDecimal / 100<br /><br />val accountGen: Gen[Account] = for {<br />    accNo &lt;- accountNoGen<br />    balance &lt;- moneyGen<br />} yield Account(accNo, balance)<br /></pre> We are now ready to generate random <code>Bank</code>. It takes an arbitrary number (<code>Gen.containerOf[List, Account]</code>) of arbitrary accounts (<code>accountGen</code>), but we don't want to generate empty banks or banks with too many accounts:<br/><br/><pre class="brush: scala">implicit val arbitraryBank = Arbitrary(<br />    for {<br />        accounts &lt;- Gen.containerOf[List, Account](accountGen)<br />        if !accounts.isEmpty<br />        if accounts.size &lt; 10000<br />    } yield new Bank(accounts)<br />)<br /></pre> The last piece is a random <code>Transfer</code>. This part is actually more complex. In order to generate arbitrary transfer we need two random accounts from a bank. But we don't know accounts yet, since bank with accounts was generated randomly. Thus our generator must be parameterized with a bank that was earlier randomized. The difference between <code>accountNoGen</code> and <code>accountNoInBankGen</code> is that the latter picks an existing account number from a given bank, rather than an arbitrary, random number. In <code>arbitraryTransfer</code> we don't have to pass <code>bank</code> explicitly because it is marked as <code>implicit</code>:<br/><br/><pre class="brush: scala">def accountNoInBankGen(implicit bank: Bank): Gen[AccountNo] = {<br />    val accNums = bank.accountNumbers.toSeq<br />    for {<br />        accNum &lt;- Gen.chooseNum(0, accNums.size - 1)<br />    } yield accNums(accNum)<br />}<br /><br />implicit def arbitraryTransfer(implicit bank: Bank) = Arbitrary {<br />    for {<br />        fromAcc &lt;- accountNoInBankGen<br />        toAcc &lt;- accountNoInBankGen<br />        amount &lt;- moneyGen<br />    } yield Transfer(fromAcc, toAcc, amount)<br />}<br /></pre> Unfortunately <code>check((bank: Bank, transfers: List[Transfer])</code> won't work. <code>Bank</code> and <code>List[Transfer]</code> are generated &quot;at the same time&quot;, so there is no way to pass generated <code>bank</code> to <code>transfers</code> generator. We have to go deeper, using different ScalaCheck syntax (<code>forAll</code>), abusing it slightly:<br/><br/><pre class="brush: scala">test(&quot;Total money should not change after arbitrary number of intra-bank transfers&quot;) {<br />    forAll((bank: Bank) =&gt; {<br />        implicit val anyBank = bank<br />        forAll((transfers: List[Transfer]) =&gt; {<br />            val bankAfterTransfers = transfers.foldLeft(bank) { (curBank, transfer) =&gt;<br />                curBank.transfer(transfer.from, transfer.to, transfer.amount)<br />            }<br />            bank.totalMoney should equal (bankAfterTransfers.totalMoney)<br />        })<br />    })<br />}<br /></pre> In outer <code>forAll()</code> clause we generate arbitrary <code>Bank</code>. We have to make it <code>implicit</code> and then in inner <code>forAll</code> we ask for random <code>transfers</code>. This was a lot of work! But hey, we found a bug, did you spot it?<br/><br/><pre class="brush: scala">GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.<br />  Message: TestFailedException was thrown during property evaluation.<br />  Message: 467626.69 did not equal 1352118.86<br />  Location: (BankChecks.scala:53)<br />  Occurred when passed generated values (<br />    arg0 = List(Transfer(AccountNo(664482),AccountNo(664482),884492.17)) // 1 shrink<br />  )<br />  Location: (GeneratorDrivenPropertyChecks.scala:837)<br />  Occurred when passed generated values (<br />    arg0 = Bank[Account(AccountNo(664482),467626.69)]<br />  )<br /></pre> Money doesn't add up! Looking carefully we see that the test failed with just one account and one transfer. By repeating the test we can easily find the pattern: single transfer with the same source and target account (<code>664482</code> this time)! Scroll back to our implementation and try to figure out why (remember about immutability):<br/><br/><pre class="brush: scala">def transfer(from: AccountNo, to: AccountNo, amount: BigDecimal): Bank = {<br />    val modifiedFrom = accounts(from).withBalanceMinus(amount)<br />    val modifiedTo = accounts(to).withBalancePlus(amount)<br />    val newAccounts = accounts<br />        .updated(from, modifiedFrom)<br />        .updated(to, modifiedTo)<br />    new Bank(newAccounts)<br />}<br /></pre> If <code>from == to</code>, changes to <code>modifiedFrom</code> are overwritten by changes in <code>modifiedTo</code>. Amazingly, if <code>Account</code> was mutable, this bug would not occur (!) Let's first go from red to green:<br/><br/><pre class="brush: scala">def transfer(from: AccountNo, to: AccountNo, amount: BigDecimal): Bank = {<br />    val modifiedFrom = accounts(from).withBalanceMinus(amount)<br />    val accountsMinusAmount = accounts.updated(from, modifiedFrom)<br />    val modifiedTo = accountsMinusAmount(to).withBalancePlus(amount)<br />    val accountsPlusAmount = accountsMinusAmount.updated(to, modifiedTo)<br />    new Bank(accountsPlusAmount)<br />}<br /></pre> Be sure you understand why the two code snippets are fundamentally different. Hint: compare <code>accounts(to)</code> and <code>accountsMinusAmount(to)</code>. OK, it works, but I see way too many identifiers and noise, let's go more functional:<br/><br/><pre class="brush: scala">def transfer(from: AccountNo, to: AccountNo, amount: BigDecimal): Bank = {<br />    this.<br />        update(from)(_.withBalanceMinus(amount)).<br />        update(to)  (_.withBalancePlus(amount))<br />}<br /><br />private def update(accNo: AccountNo)(transformation: Account =&gt; Account): Bank = {<br />    val account = accounts(accNo)<br />    val modified = transformation(account)<br />    val updatedAccounts = accounts.updated(accNo, modified)<br />    new Bank(updatedAccounts)<br />}<br /></pre> Private <code>Bank.update()</code> modifies one account by applying a custom function on top of it. We call this higher-order function twice, once to modify <code>from</code> account, later to modify <code>to</code> - but this second application works on top of already modified <code>Bank</code> instance.<br/><br/>One thing we haven't covered is shrinking (noticed <code>// 1 shrink</code> comment in test failure message?) ScalaCheck produces random, sometimes really large input, for example very long list of random transactions. Imagine just one transaction in hundreds causes error. If ScalaCheck finds such a list and reports it, discovering which particular transfer caused bug can be a challenge on its own. Thus ScalaCheck, using various heuristics, tries to shrink generated input in order to find the smallest one, still exhibiting erroneous behaviour. In our case it's a matter of selectively removing transfers from an input list (&quot;<em>shrinking</em>&quot; it), until we find the smallest subset still exposing a bug. This time-saving process is called &quot;<em>shrinking</em>&quot;. More importantly we can customize it, for example telling the framework how to shrink <code>Bank</code> to a smaller, still problematic instance.<br/><br/><hr />As you can see property based testing can be useful. It doesn't replace example based testing. Moreover, every time you find a bug using ScalaCheck, you should start with writing an example test that fails (and fails <em>all the time</em>, not <em>from time to time</em>). Remember that property based tests are randomized so they will not always find all bugs - and even worse, sometimes they will find bugs much later. Such tests are valuable, but they will never replace ordinary, predictable tests.<br/><br/> <script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>