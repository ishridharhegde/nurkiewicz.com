---
layout: post
title: Elegancki CRUD w jednej akcji Struts2 część 1/2
date: '2009-01-23T00:12:00.016+01:00'
author: Tomasz Nurkiewicz
tags:
- struts2
modified_time: '2009-03-28T22:21:27.672+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1006683487088819968
blogger_orig_url: https://www.nurkiewicz.com/2009/01/elegancki-crud-w-jednej-akcji-struts2.html
---

Elegancki CRUD w jednej akcji Struts2 część 1/2<br /><br />Wreszcie pojawiło się Struts2 w stabilnej wersji z gałęzi 2.1.x. Branch ten wprowadza wiele nowości, dlatego z niecierpliwością czekałem na edycją oznaczoną literkami GA miast beta. Chyba programiści się nieco pośpieszyli z oznaczeniem Struts 2.1.6 mianem gotowego produkcyjnie, ale nie przeszkodzi to nam w przedstawieniu krótkiego tuto riala tego znakomitego frameworku.<br /><br />Postanowiłem przedstawić Wam sposób na implementację całego procesu CRUD określonego obiektu dziedziny za pomocą jednej akcji. Pojedyncza klasa będzie zatem odpowiedzialna za cały cykl życia obiektu: utworzenie, edycję, podgląd, przeglądanie i usuwanie. Jako przykład wymyśliłem sobie portal filmowy i oczywiście obiekt <span style="font-family:courier new;">Movie</span>:<br /><br /><pre name="code" class="java"><br />public class Movie {<br /> private long id;<br /> private String title;<br /> private Calendar released;<br /> private String director;<br /> private Integer length;<br /> //get/set<br />}<br /></pre><br /><br />Ale od początku, zaczynamy od utworzenia szkieletu projektu za pomocą mavena:<br /><br /><span style="font-family:courier new;">mvn archetype:create -DgroupId=com.blogspot.nurkiewicz.film-portal -DartifactId=web -DarchetypeGroupId=org.apache.struts -DarchetypeArtifactId=struts2-archetype-starter -DarchetypeVersion=2.0.11.2-SNAPSHOT -DremoteRepositories=http://people.apache.org/repo/m2-snapshot-repository</span><br /><br />I ochoczo zmieniamy wersję Struts2 z 2.0.11.2 na 2.1.6, Javę na 1.6 i JUnit na 4.5. Budujemy projekt i… pierwszy kłopot. W groupId uzyłem myślnika <span style="font-family:courier new;">com.blogspot.nurkiewicz.film-portal</span>, a archetyp mavenowy bez zastanowienia wygenerował pakiet z myślnikiem… Nie wiem czy to problem z archetypem Struts2 czy ogólnie mavenowy. Póki co zgłosiłem zespołowi Struts2 (<a href="https://issues.apache.org/struts/browse/WW-2965">WW-2965 - Maven archetype produces malformed Java code when dashes occur in groupId</a>).<br /><br />Drobnostka, po niewielkich poprawek przystępujemy do prac właściwych. Najpierw konieczne zmiany we właściwościach projektu (<span style="font-family:courier new;">struts.properties</span>):<br /><br /><span style="font-family:courier new;">struts.locale=pl_PL</span><br /><span style="font-family:courier new;">struts.enable.SlashesInActionNames=true</span><br /><span style="font-family:courier new;">struts.action.extension=action,</span><br /><br />Pierwsza właściwość jest oczywista, bez niej z jakichś powodów Struts2 używał nieco innego <span style="font-family:courier new;">Locale</span> przy konwersji daty na String a innego przy operacji odwrotnej, co skutkowało błędami walidacji... Co prawda szukałem przyczyny dość długo debugując kod frameworku, jednak przyjrzę się temu problemowi jeszcze kiedy indziej.<br /><br />Druga włącza możliwość używania slashy w nazwach akcji - otwiera to przed nami bardzo ciekawe możliwości, o czym zaraz. I wreszcie ostatni parametr… Uważny czytelnik zauważy przecinek na końcu - o niego właśnie chodzi :-). De facto pozwalamy Strutsom na używanie akcji bez rozszerzenia <span style="font-family:courier new;">.action</span> w adresach. Po cóż nam te dziwne ustawienia? Otóż dzięki nim nasza aplikacja webowa zyska "niemal przyjazne" adresy, przykładowo:<br /><br /><a href="http://localhost:8080/web/movie/create">http://localhost:8080/web/movie/create</a><br /><br />Zamiast standardowego:<br /><br /><a href="http://localhost:8080/web/createMovie.action">http://localhost:8080/web/createMovie.action</a><br /><br />Prawda, że ładniej? :-) Czas odkryć karty - stworzymy jedną akcję <span style="font-family:courier new;">MoviesAction</span>, która będzie miała zamiast jednej metody <span style="font-family:courier new;">execute()</span> szereg metod odpowiadających odpowiednim funkcjom cyklu życia obiektu, np. <span style="font-family:courier new;">create()</span>, <span style="font-family:courier new;">update()</span>, <span style="font-family:courier new;">show()</span>. Każda z tych metod będzie tworzyła logicznie jedną akcję dostępną odpowiednio pod nazwą: movie/create, <span style="font-family:courier new;">movie/update</span> czy <span style="font-family:courier new;">movie/show</span>. Ponadto dodamy metodę <span style="font-family:courier new;">list()</span> do przeglądania wszystkich filmów. Potrzebujemy jednak jeszcze kilku, nie do końca trywialnych zabiegów. Przede wszystkim serce aplikacji, czyli <span style="font-family:courier new;">struts.xml</span> - dodajemy do domyślnego pakietu następujące deklaracje konfiguracyjne:<br /><pre name="code" class="xml"><br />&lt;interceptors&gt;<br /> &lt;interceptor-stack name="crudStack"&gt;<br />   &lt;interceptor-ref name="paramsPrepareParamsStack"&gt;<br />     &lt;param name="validation.excludeMethods"&gt;list,create&lt;/param&gt;<br />     &lt;param name="workflow.excludeMethods"&gt;list,create&lt;/param&gt;<br />   &lt;/interceptor-ref&gt;<br />   &lt;interceptor-ref name="store"&gt;<br />     &lt;param name="operationMode"&gt;AUTOMATIC&lt;/param&gt;<br />   &lt;/interceptor-ref&gt;<br /> &lt;/interceptor-stack&gt;<br />&lt;/interceptors&gt;<br /><br />&lt;default-interceptor-ref name="crudStack" /&gt;<br /><br />&lt;default-action-ref name="index" /&gt;<br /><br />&lt;global-results&gt;<br /> &lt;result name="error"&gt;/common/error.jsp&lt;/result&gt;<br />&lt;/global-results&gt;<br /><br />&lt;global-exception-mappings&gt;<br /> &lt;exception-mapping exception="java.lang.Throwable" result="error" /&gt;<br />&lt;/global-exception-mappings&gt;<br /><br />&lt;action name="index"&gt;<br /> &lt;result type="redirectAction"&gt;movie/list&lt;/result&gt;<br />&lt;/action&gt;<br /></pre><br />Na widok takiej dawki XMLa zapewne powiało grozą, albo jeszcze gorzej, przypomniało się Wam EJB 2.1 ;-). Nie jest jednak tak źle - pierwszy element, <span style="font-family:courier new;">interceptor-stack</span>, definiujemy stos interceptorów, jakiego chcemy używać. Jak działa stos interceptorów i dlaczego jest tak ważny to temat na zupełnie osobny artykuł - omówię zatem jedynie różnice w stosunku do stosu domyślnego. Po pierwsze zamiast <span style="font-family:courier new;">defaultStack</span> jako bazę wybrałem <span style="font-family:courier new;">paramsPrepareParamsStack </span>- o zmyślnej sztuczce tego stosu opowiem przy okazji akcji <span style="font-family:courier new;">update()</span>.<br /><br />Druga ważna zmiana to dodanie interceptora <span style="font-family:courier new;">store</span>, który jest zdefiniowany w <span style="font-family:courier new;">struts-default.xml</span>, jednak nie należy do żadnego gotowego stosu interceptorów - chociaż są plany, by w gałęzy 2.2 Strutsów był już w stosie domyślnym, właśnie z taką konfiguracją. A co robi? Bardzo sprytną rzecz - otóż jeśli w naszej akcji dodamy jakieś komunikaty (<span style="font-family:courier new;">addActionMessage()</span> bądź <span style="font-family:courier new;">addActionError()</span>) przepadną one jeśli wyślemy do klienta komunikat redirect (mają one bowiem zasięg pojedynczego żądania). Wyobraźmy sobie jednak dowolną akcję, która modyfikuje bazę danych (a zatem do dobrego smaku należy zastosowanie wzorca GET after POST) i chce poinformować użytkownika o sukcesie właśnie takim komunikatem. Niestety - nie jest to możliwe, ponieważ zaraz po modyfikacji wykonuje redirect i dodany chwilę wcześniej komunikat przepada. Właśnie taki, całkiem częsty scenariusz, obsługuje <a href="http://struts.apache.org/2.x/struts2-core/apidocs/org/apache/struts2/interceptor/MessageStoreInterceptor.html">MessageStoreInterceptor</a>: przed wykonaniem redirecta zachowuje wszystkie komunikaty w sesji by potem automatycznie - przy następnym żądaniu - odczytać je i dodać do strony. Sprytne, prawda?<br /><br />Kolejna ciekawostka to ustawienie parametru <span style="font-family:courier new;">excludeMethods</span> interceptorów <span style="font-family:courier new;">validation </span>i <span style="font-family:courier new;">workflow</span>. Tutaj rozwiązujemy problem zbyt gorliwej walidacji. Otóż walidację w Struts2 definiuje się dla całej klasy akcji, nie da się bezpośrednio ograniczyć reguł walidacji (tak w XML, jak i w adnotacjach) do poszczególnych metod będących akcjami logicznymi. A to prowadzi do dziwnych błędów - np. przy wyświetlaniu ekranu do wprowadzenia nowego filmu na dzień dobry dostajemy błąd walidacji, że pole tytuł jest puste (taką regułę dodamy). Dlatego dla metody <span style="font-family:courier new;">create </span>(wprowadzanie nowego filmy) oraz <span style="font-family:courier new;">list </span>(wyświetlanie listy filmów) walidacja została wyłączona.<br /><br />Przy okazji mrożąca krew w żyłach ciekawostka: Struts2 przeprowadza walidację w aż czterech różnych interceptorach… Najpierw interceptor <span style="font-family:courier new;">params </span>"przepisuje" wartości z requestu HTTP do pól dostępnych na stosie wartości (ValueStack), przy okazji zapisując w kontekście akcji błędy konwersji. Następnie <span style="font-family:courier new;">conversionError </span>konwertuje błędy z kontekstu na omawiane wcześniej komunikaty (<span style="font-family:courier new;">addActionError()</span>). Dalej interceptor (werble!) <span style="font-family:courier new;">validation </span>wykonuje walidację deklaratywną (XML i/lub adnotacje). Na samym końcu interceptor <span style="font-family:courier new;">workflow</span> uruchamia metodę <span style="font-family:courier new;">validate()</span> akcji… Uff… Na każdym z tych etapów pojawienie się błędów skutkuje przerwaniem dalszego przetwarzania interceptorów (a tym bardziej wywołania akcji) i natychmiastowym zwróceniem rezultatu INPUT, który powinien prowadzić z powrotem do felernego formularza z błędami. <span style="font-style: italic;">Chain-of-responsibility</span> w całej krasie, :-)<br /><br />Zamykamy konfigurację stosu interceptorów, od tej pory będzie już naszym najlepszym przyjacielem. Ustawiamy tak zdefiniowany stos jako domyślny (<span style="font-family:courier new;">default-interceptor-ref</span>) i wskazujemy domyślną akcję, jeśli użytkownik nie poda żadnej lub poda błędną. I tu przykre zaskoczenie. Skoro akcja <span style="font-family:courier new;">index </span>wykonuje jedynie redirect do akcji <span style="font-family:courier new;">movie/list</span>, to czemu nie ustawić od razu tej akcji jako domyślnej? Próbowałem… i otworzyłem kolejne zgłoszenie buga :-( <a href="https://issues.apache.org/struts/browse/WW-2963">WW-2963 - default-action-ref fails to find wildcard named actions</a>.<br /><br />W tym momencie chciałbym jeszcze zwrócić uwagę na brak atrybutu <span style="font-family:courier new;">class </span>w akcji <span style="font-family:courier new;">index</span>. Jest to zupełnie poprawna konstrukcja, zwyczajnie tworzymy akcję o pustej implementacji (używana jest klasa <span style="font-family:courier new;">com.opensymphony.xwork2.ActionSupport</span>, którą można przedefiniować używając taga &lt;default-class-ref&gt;). Nawet więcej - nie tylko poprawna, ale wręcz zalecana - zawsze powinniśmy kierować użytkownika do akcji, a nie od razu do JSP - uzyskamy spójne adresy URL, pliki JSP będą wzbogacone o kilka dodatkowych funkcji dodanych przez Struts (przejdą bowiem przez pełen stos interceptorów) oraz lepiej odesparujemy logikę od widoku.<br /><br />Na koniec opowiem jeszcze o tagach &lt;global-results&gt; oraz &lt;global-exception-mappings&gt;, które znakomicie się uzupełniają. Ten drugi mapuje wyjątki rzucone przez nasze akcje bądź interceptory na rezultaty. Przykładowo jeśli nasza akcja rzuca wyjątkiem, nie musimy ręcznie go łapać i zwracać ERROR zamiast SUCCESS. Zrobi to za nas interceptor <span style="font-family:courier new;">exception </span>(to dlatego zawsze powinien być na samym dole stosu - by łapać wyjątki od wszystkich interceptorów i akcji nad nim), który złapie wyjątek dużo niżej i zamieni go na zdefiniowany rezultat. Jeśli dodamy do tego globalne mapowanie wskazanego rezultatu na określony widok, możemy uzyskać ładnie wyglądającą stronę z błędem (oksymoron?) zamiast błędu serwera i śladu stosu.<br /><br />Tyle na dzisiaj, rozpisałem się niemiłosiernie o zwykłym CRUDzie, a nawet nie doszliśmy do akcji. Obiecuję, że w drugiej, ostatniej części dokończę przykład, może nawet napiszemy coś w Javie? ;-) Na pocieszenie dodam, że całą tą konfigurację robi się raz dla całego pakietu (zbioru akcji), a jeśli dodać do tego możliwość dziedziczenia pakietów, cały ten XML nie jest już nam taki straszny.