---
layout: post
title: Loading files with backpressure - RxJava FAQ
date: '2017-08-31T21:38:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- StAX
- backpressure
- rxjava
modified_time: '2017-08-31T21:38:32.476+02:00'
thumbnail: https://4.bp.blogspot.com/-x-qcsPjpLLc/WahlN8uXyXI/AAAAAAAAEDs/PdPbMjXCbww5M59-At6iXlAf9_rIFYUOQCLcBGAs/s72-c/2016-09-07%2B12.54.23.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5339580397662156286
blogger_orig_url: https://www.nurkiewicz.com/2017/08/loading-files-with-backpressure-rxjava.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://4.bp.blogspot.com/-x-qcsPjpLLc/WahlN8uXyXI/AAAAAAAAEDs/PdPbMjXCbww5M59-At6iXlAf9_rIFYUOQCLcBGAs/s1600/2016-09-07%2B12.54.23.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="901" data-original-width="1600" height="112" src="https://4.bp.blogspot.com/-x-qcsPjpLLc/WahlN8uXyXI/AAAAAAAAEDs/PdPbMjXCbww5M59-At6iXlAf9_rIFYUOQCLcBGAs/s200/2016-09-07%2B12.54.23.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Oslofjord</td></tr></tbody></table>Processing file as a stream turns out to be tremendously effective and convenient. Many people seem to forget that since Java 8 (3+ years!) we can very easily turn any file into a stream of lines:<br /><br /><pre class="brush: java">String filePath = "foobar.txt";<br />try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {<br />    reader.lines()<br />            .filter(line -&gt; !line.startsWith("#"))<br />            .map(String::toLowerCase)<br />            .flatMap(line -&gt; Stream.of(line.split(" ")))<br />            .forEach(System.out::println);<br />}</pre><code>reader.lines()</code> returns a <code>Stream&lt;String&gt;</code> which you can further transform. In this example, we discard lines starting with <code>"#"</code> and <em>explode</em> each line by splitting it into words. This way we achieve stream of words as opposed to stream of lines. Working with text files is almost as simple as working with normal Java collections. In RxJava <a href="http://www.nurkiewicz.com/2017/08/generating-backpressure-aware-streams.html">we already learned</a> about <code>generate()</code> operator. It can be used here as well to create robust stream of lines from a file:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; file = Flowable.generate(<br />        () -&gt; new BufferedReader(new FileReader(filePath)),<br />        (reader, emitter) -&gt; {<br />            final String line = reader.readLine();<br />            if (line != null) {<br />                emitter.onNext(line);<br />            } else {<br />                emitter.onComplete();<br />            }<br />        },<br />        reader -&gt; reader.close()<br />);</pre><code>generate()</code> operator in aforementioned example is a little bit more complex. The first argument is a state factory. Every time someone subscribes to this stream, a factory is invoked and stateful <code>BufferedReader</code> is created. Then when downstream operators or subscribers wish to receive some data, second lambda (with two parameters) is invoked. This lambda expression tries to <em>pull</em> exactly one line from a file and either send it downstream (<code>onNext()</code>) or complete when end of file is encountered. It's fairly straightforward. The third optional argument to <code>generate()</code> is a lambda expression that can do some cleanup with state. It's very convenient in our case as we have to close the file not only when end of file is reached but also when consumers prematurely unsubscribe.<br /><br /><h2 id="meet-flowable.using-operator">Meet <code>Flowable.using()</code> operator</h2>This seems like a lot of work, especially when we already have a stream of lines from JDK 8. Turns out there is a similar factory operator named <code>using()</code> that is quite handy. First of all the simplest way of translating <code>Stream</code> from Java to <code>Flowable</code> is by converting <code>Stream</code> to an <code>Iterator</code> (checked exception handling ignored):<br /><br /><pre class="brush: java">Flowable.fromIterable(new Iterable&lt;String&gt;() {<br />    @Override<br />    public Iterator&lt;String&gt; iterator() {<br />        final BufferedReader reader = new BufferedReader(new FileReader(filePath));<br />        final Stream&lt;String&gt; lines = reader.lines();<br />        return lines.iterator();<br />    }<br />});</pre>This can be simplified to:<br /><br /><pre class="brush: java">Flowable.&lt;String&gt;fromIterable(() -&gt; {<br />    final BufferedReader reader = new BufferedReader(new FileReader(filePath));<br />    final Stream&lt;String&gt; lines = reader.lines();<br />    return lines.iterator();<br />});</pre>But we forgot about closing <code>BufferedReader</code> thus <code>FileReader</code> thus file handle. Thus we introduced resource leak. Under such circumstances <code>using()</code> operator works like a charm. In a way it's similar to <code>try-with-resources</code> statement. You can create a stream based on some external resource. The lifecycle of this resource (creation and disposal) will be managed for you when someone subscribes or unsubscribes:<br /><br /><pre class="brush: java">Flowable.using(<br />        () -&gt; new BufferedReader(new FileReader(filePath)),<br />        reader -&gt; Flowable.fromIterable(() -&gt; reader.lines().iterator()),<br />        reader -&gt; reader.close()<br />);</pre>It's fairly similar to last <code>generate()</code> example, however the most important lambda expression in the middle is quite different. We get a resource (<code>reader</code>) as an argument and are suppose to return a <code>Flowable</code> (not a single element). This lambda is called only once, not every time downstream requests new item. What <code>using()</code> operator gives us is managing <code>BufferedReaders</code>'s lifecycle. <code>using()</code> is useful when we have a piece of state (just like with <code>generate()</code>) that is capable of producing whole <code>Flowable</code> at once, as opposed to one item at a time.<br /><br /><h2 id="streaming-xml-files">Streaming XML files</h2>...or JSON for that matter. Imagine you have a very large XML file that consists of the following entries, hundreds of thousands of them:<br /><br /><pre class="brush: java">&lt;trkpt lat="52.23453" lon="21.01685"&gt;<br />    &lt;ele&gt;116&lt;/ele&gt;<br />&lt;/trkpt&gt;<br />&lt;trkpt lat="52.23405" lon="21.01711"&gt;<br />    &lt;ele&gt;116&lt;/ele&gt;<br />&lt;/trkpt&gt;<br />&lt;trkpt lat="52.23397" lon="21.0166"&gt;<br />    &lt;ele&gt;116&lt;/ele&gt;<br />&lt;/trkpt&gt;</pre>This is a snippet from standard <a href="https://en.wikipedia.org/wiki/GPS_Exchange_Format">GPS Exchange Format</a> that can describe geographical routes of arbitrary length. Each <code>&lt;trkpt&gt;</code> is a single point with latitude, longitude and elevation. We would like to have a stream of track points (ignoring elevation for simplicity) so that the file can be consumed partially, as opposed to loading everything at once. We have three choices:<br /><br /><ul><li>DOM/JAXB - everything must be loaded into memory and mapped to Java objects. Won't work for infinitely long files (or even very large ones)</li><li>SAX - a push-based library that invokes callbacks whenever it discovers XML tag opening or closing. Seems a bit better but can't possibly support backpressure - it's the library that decides when to invoke callbacks and there is no way of slowing it down</li><li>StAX - like SAX, but we must actively pull for data from XML file. This is essential to support backpressure - we decide when to read next chunk of data</li></ul>Let's try to implement parsing and streaming of possibly very large XML file using StAX and RxJava. First we must learn <a href="http://www.nurkiewicz.com/2014/07/testing-code-for-excessively-large.html">how to use StAX</a> in the first place. The parser is called <code>XMLStreamReader</code> and is created with the following sequence of spells and curses:<br /><br /><pre class="brush: java">XMLStreamReader staxReader(String name) throws XMLStreamException {<br />    final InputStream inputStream = new BufferedInputStream(new FileInputStream(name));<br />    return XMLInputFactory.newInstance().createXMLStreamReader(inputStream);<br />}</pre>Just close your eyes and make sure you always have a place to copy-paste the snippet above from. It gets even worse. In order to read the first <code>&lt;trkpt&gt;</code> tag including its attributes we must write quite some complex code:<br /><br /><pre class="brush: java">import lombok.Value;<br /><br />@Value<br />class Trackpoint {<br />    private final BigDecimal lat;<br />    private final BigDecimal lon;<br />}<br /><br />Trackpoint nextTrackpoint(XMLStreamReader r) {<br />    while (r.hasNext()) {<br />        int event = r.next();<br />        switch (event) {<br />            case XMLStreamConstants.START_ELEMENT:<br />                if (r.getLocalName().equals("trkpt")) {<br />                    return parseTrackpoint(r);<br />                }<br />                break;<br />            case XMLStreamConstants.END_ELEMENT:<br />                if (r.getLocalName().equals("gpx")) {<br />                    return null;<br />                }<br />                break;<br />        }<br />    }<br />    return null;<br />}<br /><br />Trackpoint parseTrackpoint(XMLStreamReader r) {<br />    return new Trackpoint(<br />            new BigDecimal(r.getAttributeValue("", "lat")),<br />            new BigDecimal(r.getAttributeValue("", "lon"))<br />    );<br />}</pre>The API is quote low-level and almost adorably antique. Everything happens in a gigantic loop that reads... <em>something</em> of type <code>int</code>. This <code>int</code> can be <code>START_ELEMENT</code>, <code>END_ELEMENT</code> or few other things which we are not interested in. Remember we are reading XML file, but not line-by-line or char-by-char but by logical XML tokens (tags). So, if we discover opening of <code>&lt;trkpt&gt;</code> element we parse it, otherwise we continue. The second important condition is when we find closing <code>&lt;/gpx&gt;</code> which should be the last thing in GPX file. We return <code>null</code> in such case, signaling end-of-XML-file.<br /><br />Feels complex? This is actually the simplest way to read large XML with constant memory usage, irrespective to file size. How does all of this relate to RxJava? At this point we can very easily build a <code>Flowable&lt;Trackpoint&gt;</code>. Yes, <code>Flowable</code>, not <code>Observable</code> (see: <a href="http://www.nurkiewicz.com/2017/08/1x-to-2x-migration-observable-vs.html"><code>Obsevable</code> vs. <code>Observable</code></a>). Such a stream will have full support for backpressure, meaning it will read file at appropriate speed:<br /><br /><pre class="brush: java">Flowable&lt;Trackpoint&gt; trackpoints = generate(<br />        () -&gt; staxReader("track.gpx"),<br />        this::pushNextTrackpoint,<br />        XMLStreamReader::close);<br /><br />void pushNextTrackpoint(XMLStreamReader reader, Emitter&lt;Trackpoint&gt; emitter) {<br />    final Trackpoint trkpt = nextTrackpoint(reader);<br />    if (trkpt != null) {<br />        emitter.onNext(trkpt);<br />    } else {<br />        emitter.onComplete();<br />    }<br />}</pre>Wow, so simple, such backpressure!<sup><a href="http://knowyourmeme.com/memes/doge">[1]</a></sup> We first create an <code>XMLStreamReader</code> and make sure it's being closed when file ends or someone unsubscribes. Remember that each subscriber will open and start parsing the same file over and over again. The lambda expression in the middle simply takes the state variables (<code>XMLStreamReader</code>) and emits one more trackpoint. All of this seems quite obscure and it is! But we now have a backpresure-aware stream taken from a possibly very large file using very little resources. We can process trackpoint concurrently or combine them with other sources of data. In the next article we will learn how to load JSON in very similar way.<br /><br /><script>SyntaxHighlighter.highlight();</script>