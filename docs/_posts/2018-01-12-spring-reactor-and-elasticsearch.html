---
layout: post
title: 'Spring, Reactor and Elasticsearch: bechmarking with fake test data'
date: '2018-01-12T07:04:00.002+01:00'
author: Tomasz Nurkiewicz
tags:
- elasticsearch
- jfairy
- reactor
modified_time: '2018-01-25T09:18:29.959+01:00'
thumbnail: https://3.bp.blogspot.com/-vG5piI8VUr8/WlhPv7Ect9I/AAAAAAAAVjU/MvuWzEAVxB0qeuqcwvfCiDdDFM3BupE_QCLcBGAs/s72-c/2016-10-23%2B14.40.41.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4517248198959573721
blogger_orig_url: https://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-vG5piI8VUr8/WlhPv7Ect9I/AAAAAAAAVjU/MvuWzEAVxB0qeuqcwvfCiDdDFM3BupE_QCLcBGAs/s1600/2016-10-23%2B14.40.41.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="901" data-original-width="1600" height="112" src="https://3.bp.blogspot.com/-vG5piI8VUr8/WlhPv7Ect9I/AAAAAAAAVjU/MvuWzEAVxB0qeuqcwvfCiDdDFM3BupE_QCLcBGAs/s200/2016-10-23%2B14.40.41.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Bieszczady Moutains</td></tr></tbody></table>In the <a href="http://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch-from.html">previous article</a> we created a simple adapter from ElasticSearch's API to Reactor's <code>Mono</code>, that looks like this:<br /><br /><pre class="brush: java">import reactor.core.publisher.Mono;<br /><br />private Mono&lt;IndexResponse&gt; indexDoc(Doc doc) {<br />    //...<br />}</pre>Now we would like to run this method at controlled concurrency level, millions of times. Basically, we want to see how our indexing code behaves under load, benchmark it.<br /><br /><h2 id="fake-data-with-jfairy">Fake data with jFairy</h2>First, we need some good looking test data. For that purpose, we'll use a handy <a href="https://devskiller.github.io/jfairy/">jFairy</a> library. The document we'll index is a simple POJO:<br /><br /><pre class="brush: java">@Value<br />class Doc {<br />    private final String username;<br />    private final String json;<br />}</pre>The generation logic is wrapped inside a Java class:<br /><br /><pre class="brush: java">import io.codearte.jfairy.Fairy;<br />import io.codearte.jfairy.producer.person.Address;<br />import io.codearte.jfairy.producer.person.Person;<br />import org.apache.commons.lang3.RandomUtils;<br /><br /><br />@Component<br />class PersonGenerator {<br /><br />    private final ObjectMapper objectMapper;<br />    private final Fairy fairy;<br /><br />    private Doc generate() {<br />        Person person = fairy.person();<br />        final String username = person.getUsername() + RandomUtils.nextInt(1_000_000, 9_000_000);<br />        final ImmutableMap&lt;String, Object&gt; map = ImmutableMap.&lt;String, Object&gt;builder()<br />                .put("address", toMap(person.getAddress()))<br />                .put("firstName", person.getFirstName())<br />                .put("middleName", person.getMiddleName())<br />                .put("lastName", person.getLastName())<br />                .put("email", person.getEmail())<br />                .put("companyEmail", person.getCompanyEmail())<br />                .put("username", username)<br />                .put("password", person.getPassword())<br />                .put("sex", person.getSex())<br />                .put("telephoneNumber", person.getTelephoneNumber())<br />                .put("dateOfBirth", person.getDateOfBirth())<br />                .put("company", person.getCompany())<br />                .put("nationalIdentityCardNumber", person.getNationalIdentityCardNumber())<br />                .put("nationalIdentificationNumber", person.getNationalIdentificationNumber())<br />                .put("passportNumber", person.getPassportNumber())<br />                .build();<br />        final String json = objectMapper.writeValueAsString(map);<br />        return new Doc(username, json);<br />    }<br /><br />    private ImmutableMap&lt;String, Object&gt; toMap(Address address) {<br />        return ImmutableMap.&lt;String, Object&gt;builder()<br />                .put("street", address.getStreet())<br />                .put("streetNumber", address.getStreetNumber())<br />                .put("apartmentNumber", address.getApartmentNumber())<br />                .put("postalCode", address.getPostalCode())<br />                .put("city", address.getCity())<br />                .put("lines", Arrays.asList(address.getAddressLine1(), address.getAddressLine2()))<br />                .build();<br />    }<br /><br />}</pre>Quite a bit of boring code which actually does something cool. Every time we run it, it generates random, but reasonable JSON like so:<br /><br /><pre class="brush: javascript">{<br />  "address": {<br />    "street": "Ford Street",<br />    "streetNumber": "32",<br />    "apartmentNumber": "",<br />    "postalCode": "63913",<br />    "city": "San Francisco",<br />    "lines": [<br />      "32 Ford Street",<br />      "San Francisco 63913"<br />    ]<br />  },<br />  "firstName": "Evelyn",<br />  "middleName": "",<br />  "lastName": "Pittman",<br />  "email": "pittman@mail.com",<br />  "companyEmail": "evelyn.pittman@woodsllc.eu",<br />  "username": "epittman5795354",<br />  "password": "VpEfFmzG",<br />  "sex": "FEMALE",<br />  "telephoneNumber": "368-005-109",<br />  "dateOfBirth": "1917-05-14T16:47:06.273Z",<br />  "company": {<br />    "name": "Woods LLC",<br />    "domain": "woodsllc.eu",<br />    "email": "contact@woodsllc.eu",<br />    "vatIdentificationNumber": "30-0005081",<br />    "url": "http://www.woodsllc.eu"<br />  },<br />  "nationalIdentityCardNumber": "713-79-5185",<br />  "nationalIdentificationNumber": "",<br />  "passportNumber": "jVeyZLSt3"<br />}</pre>Neat! Unfortunately, it's not documented whether <a href="https://github.com/Devskiller/jfairy/issues/95">jFairy is thread safe</a> so just in case in real code, I'm using <code>ThreadLocal</code>. OK, so we have one document, but we need millions! Using <code>for</code>-loop is so old-fashioned. What will you tell about an infinite stream of random people?<br /><br /><pre class="brush: java">import reactor.core.scheduler.Scheduler;<br />import reactor.core.scheduler.Schedulers;<br /><br />private final Scheduler scheduler = Schedulers.newParallel(PersonGenerator.class.getSimpleName());<br /><br />Mono&lt;Doc&gt; generateOne() {<br />    return Mono<br />            .fromCallable(this::generate)<br />            .subscribeOn(scheduler);<br />}<br /><br />Flux&lt;Doc&gt; infinite() {<br />    return generateOne().repeat();<br />}</pre><code>generateOne()</code> wraps blocking <code>generate()</code> method in a <code>Mono&lt;Doc&gt;</code>. Additionally <code>generate()</code> is run on <code>parallel</code> <code>Scheduler</code>. Why? It turned out that jFairy wasn't fast-enough on a single core (lots of random number generation, table lookups, etc.) so I had to parallelize data generation. Shouldn't normally be an issue. But when generating fake data is slower than your reactive application that touches external server - it tells you something about the performance of Netty-based Spring web-flux (!)<br /><br /><h2 id="calling-elasticsearch-concurrently">Calling ElasticSearch concurrently</h2>All right, having an infinite stream of good looking fake test data we now want to index it in ElasticSearch.<br /><br /><pre class="brush: java">@PostConstruct<br />void startIndexing() {<br />    index(1_000_000, 1_000);<br />}<br /><br />private void index(int count, int maxConcurrency) {<br />    personGenerator<br />            .infinite()<br />            .take(count)<br />            .flatMap(this::indexDocSwallowErrors, maxConcurrency)<br />            .window(Duration.ofSeconds(1))<br />            .flatMap(Flux::count)<br />            .subscribe(winSize -&gt; log.debug("Got {} responses in last second", winSize));<br />}<br /><br />private Mono&lt;IndexResponse&gt; indexDocSwallowErrors(Doc doc) {<br />    return indexDoc(doc)<br />            .doOnError(e -&gt; log.error("Unable to index {}", doc, e))<br />            .onErrorResume(e -&gt; Mono.empty());<br />}</pre>When the application starts it initiates indexing of 1 million documents. Notice how easy it is to tell Reactor (same for RxJava) that it should invoke up to one thousand concurrent requests to ElasticSearch. Once every second we count how many responses we received:<br /><br /><pre class="brush: plain">Got 2925 responses in last second<br />Got 2415 responses in last second<br />Got 3336 responses in last second<br />Got 2199 responses in last second<br />Got 1861 responses in last second</pre>Not bad! Especially when you consider that there are up to <strong>one thousand</strong> concurrent HTTP requests and our application started barely 30 threads peak (!) Alright, it's <code>localhost</code> &lt;-&gt; <code>localhost</code>, guilty! But how do we actually know all of that? Logging is fine, but it's XXI century, we can do better! <a href="http://www.nurkiewicz.com/2018/01/monitoring-and-measuring-reactive.html">Monitoring will be the subject of next instalment</a>.<br /><br />The source code is available <a href="https://github.com/nurkiewicz/elastic-flux">github.com/nurkiewicz/elastic-flux</a> in <a href="https://github.com/nurkiewicz/elastic-flux/tree/reactive-elastic-search"><p>This is part of a longer series:</p> <ul> <li><a href="http://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch-from.html">Spring, Reactor and ElasticSearch: from callbacks to reactive streams</a></li> <li>Spring, Reactor and ElasticSearch: bechmarking with fake test data</li> <li><a href="http://www.nurkiewicz.com/2018/01/monitoring-and-measuring-reactive.html">Monitoring and measuring reactive application with Dropwizard Metrics</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/spring-boot-2-migrating-from-dropwizard.html">Spring Boot 2: Migrating from Dropwizard metrics to Micrometer</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/spring-boot-2-fluxes-from-elasticsearch.html">Spring Boot 2: Fluxes, from Elasticsearch to controller</a></li></ul>  <code>reactive-elastic-search</code></a> branch. <script>SyntaxHighlighter.highlight();</script>