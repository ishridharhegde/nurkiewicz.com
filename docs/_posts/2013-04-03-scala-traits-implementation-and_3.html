---
layout: post
title: 'Scala traits implementation and interoperability. Part II: Traits linearization'
date: '2013-04-03T22:32:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
- traits
modified_time: '2013-04-07T13:14:40.532+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2680263771961678108
blogger_orig_url: https://www.nurkiewicz.com/2013/04/scala-traits-implementation-and_3.html
---

This is a continuation of <a href="http://nurkiewicz.blogspot.no/2013/04/scala-traits-implementation-and.html">Scala traits implementation and interoperability. Part I: Basics</a>. Dreadful <a href="http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">diamond problem</a> can be mitigated using Scala traits and a process called <i>linearization</i>. Take the following example:<br /><br /><pre class="brush: scala">trait Base {<br />    def msg = "Base"<br />}<br /><br />trait Foo extends Base {<br />    abstract override def msg = "Foo -&gt; " + super.msg<br />}<br /><br />trait Bar extends Base {<br />    abstract override def msg = "Bar -&gt; " + super.msg<br />}<br /><br />trait Buzz extends Base {<br />    abstract override def msg = "Buzz -&gt; " + super.msg<br />}<br /><br />class Riddle extends Base with Foo with Bar with Buzz {<br />    override def msg = "Riddle -&gt; " + super.msg<br />}<br /></pre>Now let me ask you a little question: what is the output of <code>(new Riddle).msg</code>?<br /><br /><ol><li><code>Riddle -&gt; Base</code></li><li><code>Riddle -&gt; Buzz -&gt; Base</code></li><li><code>Riddle -&gt; Foo -&gt; Base</code></li><li><code>Riddle -&gt; Buzz -&gt; Bar -&gt; Foo -&gt; Base</code></li></ol>It's not (1) because <code>Base.msg</code> is overriden by all traits we extend, so that shouldn't be a surprise. But it's also not (2) and (3). One might expect that either <code>Buzz</code> or <code>Foo</code> is printed, remembering that you can stack traits and either first or last (actually: last) wins. So why <code>Riddle -&gt; Buzz -&gt; Base</code> is incorrect? Isn't <code>Buzz.msg</code> calling <code>super.msg</code> and <code>Buzz</code> explicitly states <code>Base</code> being it's parent? There is a bit of magic here.<br /><br />When you stack multiple traits as we did (<code>extends Base with Foo with Bar with Buzz</code>) Scala compiler orders them (<i>linearizes</i>) so that there is always one path from every class to the parent (<code>Base</code>). The order is determined by the reversed order of traits mixed in (last one <i>wins</i> and becomes first). Why would you ever...? Turns out stackable traits are great for implementing several layers of decoration around real object. You can easily add decorators and move them around.<br /><br />We have a simple calculator abstraction and one implementation:<br /><br /><a name='more'></a><br /><br /><pre class="brush: scala">trait Calculator {<br />    def increment(x: Int): Int<br />}<br /><br />class RealCalculator extends Calculator {<br />    override def increment(x: Int) = {<br />        println(s"increment($x)")<br />        x + 1<br />    }<br />}<br /></pre>We came up with three aspect we would like to selectively apply depending on some circumstances: logging all <code>increment()</code> invocations, caching and validation. First let's define all of them:<br /><br /><pre class="brush: scala">trait Logging extends Calculator {<br />    abstract override def increment(x: Int) = {<br />        println(s"Logging: $x")<br />        super.increment(x)<br />    }<br />}<br /><br />trait Caching extends Calculator {<br />    abstract override def increment(x: Int) = <br />        if(x &lt; 10) {    //silly caching...<br />            println(s"Cache hit: $x")<br />            x + 1<br />        } else {<br />            println(s"Cache miss: $x")<br />            super.increment(x)<br />        }<br />}<br /><br />trait Validating extends Calculator {<br />    abstract override def increment(x: Int) = <br />        if(x &gt;= 0) {<br />            println(s"Validation OK: $x")<br />            super.increment(x)<br />        } else<br />            throw new IllegalArgumentException(x.toString)<br />}<br /></pre>Creating "raw" calculator is of course possible:<br /><br /><pre class="brush: scala">val calc = new RealCalculator<br />calc: RealCalculator = RealCalculator@bbd9e6<br /><br />scala&gt; calc increment 17<br />increment(17)<br />res: Int = 18<br /></pre>But we are free to mix-in as many trait mixins as we want, in any order:<br /><br /><pre class="brush: scala">scala&gt; val calc = new RealCalculator with Logging with Caching with Validating<br />calc: RealCalculator with Logging with Caching with Validating = $anon$1@1aea543<br /><br />scala&gt; calc increment 17<br />Validation OK: 17<br />Cache miss: 17<br />Logging: 17<br />increment(17)<br />res: Int = 18<br /><br />scala&gt; calc increment 9<br />Validation OK: 9<br />Cache hit: 9<br />res: Int = 10<br /></pre>See how subsequent mixins kick in? Of course each mixin can skip <code>super</code> call, e.g. on cache hit or validation failure. Just to be clear here - it doesn't matter that each of decorating mixins have <code>Calculator</code> defined as a base trait. <code>super.increment()</code> is always routed to next trait in stack (previous one in the class declaration). That means <code>super</code> is more dynamic and dependant on target usage rather than declaration. We will explain this later but first another example: let's put logging before caching so no matter whether there was cache hit or miss, we always get logging. Moreover we "disable" validation by simply skipping it:<br /><br /><pre class="brush: scala">scala&gt; class VerboseCalculator extends RealCalculator with Caching with Logging<br />defined class VerboseCalculator<br /><br />scala&gt; val calc = new VerboseCalculator<br />calc: VerboseCalculator = VerboseCalculator@f64dcd<br /><br />scala&gt; calc increment 42<br />Logging: 42<br />Cache miss: 42<br />increment(42)<br />res: Int = 43<br /><br />scala&gt; calc increment 4<br />Logging: 4<br />Cache hit: 4<br />res: Int = 5<br /></pre>I promised to explain how stacking works underneath. You should be really curious how this "funky" <code>super</code> is implemented as it cannot simply rely on <code>invokespecial</code> bytecode instruction, used with normal <code>super</code>. Unfortunately it's complex, but worth to know and understand, especially when stacking doesn't work as expected. <code>Calculator</code> and <code>RealCalculator</code> compile pretty much exactly to what you might have expected:<br /><br /><pre class="brush: java">public interface Calculator {<br />    int increment(int i);<br />}<br /><br />public class RealCalculator implements Calculator {<br />    public int increment(int x) {<br />        return x + 1;<br />    }<br />}<br /></pre>But how would the following class be implemented? <br /><br /><pre class="brush: scala">class FullBlownCalculator <br />    extends RealCalculator <br />       with Logging <br />       with Caching <br />       with Validating<br /></pre>Let's start from the class itself:<br /><br /><pre class="brush: java">public class FullBlownCalculator extends RealCalculator implements Logging, Caching, Validating {<br />    public int increment(int x) {<br />        return Validating$class.increment(this, x);<br />    }<br /><br />    public int Validating$$super$increment(int x) {<br />        return Caching$class.increment(this, x);<br />    }<br /><br />    public int Caching$$super$increment(int x) {<br />        return Logging$class.increment(this, x);<br />    }<br /><br />    public int Logging$$super$increment(int x) {<br />        return super.increment(x);<br />    }<br />}<br /></pre>Can you see what's going on here? Before I show the implementations of all these <code>*$class</code> classes, spend a little bit of time confronting class declaration (trait order in particular) and these awkward <code>*$$super$*</code> methods. Here is the missing piece that will allow us to connect all the dots:<br /><br /><pre class="brush: java">public abstract class Logging$class {<br />    public static int increment(Logging that, int x) {<br />        return that.Logging$$super$increment(x);<br />    }<br />}<br /><br />public abstract class Caching$class {<br />    public static int increment(Caching that, int x) {<br />        return that.Caching$$super$increment(x);<br />    }<br />}<br /><br />public abstract class Validating$class {<br />    public static int increment(Validating that, int x) {<br />        return that.Validating$$super$increment(x);<br />    }<br />}<br /></pre>Not helpful? Let's go slowly through the first step. When you call <code>FullBlownCalculator</code>, according to trait stacking rules, <code>RealBlownCalculator.increment()</code> should call <code>Validating.increment()</code>. As you can see, <code>Validating.increment()</code> forwards <code>this</code> (itself) to static <code>Validating$class.increment()</code> hidden class. This class expects an instance of <code>Validating</code>, but since <code>FullBlownCalculator</code> also extends that trait, passing <code>this</code> is fine.<br /><br />Now look at the <code>Validating$class.increment()</code>. It barely forwards <code>FullBlownCalculator.Validating$$super$increment(x)</code>. And when we, again, go back to <code>FullBlownCalculator</code> we will notice that this method delegates to static <code>Caching$class.increment()</code>. From here the process is similar. Why the extra delegation through <code>static</code> method? Mixins don't know which class is going to be next in the stack ("next <code>super</code>"). Thus they simply delegate to appropriate virtual <code>$$super$</code> family of methods. Each class using these mixins is obligated to implement them, providing correct "super".<br /><br />To put that into perspective: compiler cannot simply delegate straight from <code>Validating$class.increment()</code> to <code>Caching$class.increment()</code>, even though that's the <code>FullBlowCalculator</code> workflow. However if we create another class that reverses these mixins (<code>RealCalculator with Validating with Caching</code>) hardcoded dependency between mixins is no longer valid. This it's the responsibility of the class, not mixin, to declare the order.<br /><br />If you still don't follow, here is the complete call stack for <code>FullBlownCalculator.increment()</code>:<br /><br /><pre class="brush: plain">val calc = new FullBlownCalculator<br />calc increment 42<br /><br />FullBlownCalculator.increment(42)<br />`- Validating$class.increment(calc, 42)<br />   `- Validating.Validating$$super$increment(42) (on calc)<br />      `- Caching$class.increment(calc, 42)<br />         `- Caching.Caching$$super$increment(42) (on calc)<br />            `- Logging$class.increment(calc, 42)<br />               `- Logging.Logging$$super$increment(42) (on calc)<br />                  `- super.increment(42)<br />                     `- RealCalculator.increment(42) (on calc)<br /></pre>Now you see why it's called "<i>linearization</i>"!  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>