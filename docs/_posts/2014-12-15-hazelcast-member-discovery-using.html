---
layout: post
title: Hazelcast member discovery using Curator and ZooKeeper
date: '2014-12-15T21:38:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- Hazelcast
- spring boot
- spring
- ZooKeeper
- Curator
modified_time: '2014-12-15T21:38:29.052+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2181693461802906756
blogger_orig_url: https://www.nurkiewicz.com/2014/12/hazelcast-member-discovery-using.html
---

At one project I was setting up Hazelcast cluster in a private cloud. Within cluster all nodes must see each other, so during bootstrapping Hazelcast will try to locate other cluster members. There is no server and all nodes are made equal. There are couple techniques of discovering members implemented in Hazelcast; unfortunately it wasn't AWS so we couldn't use <a href="http://docs.hazelcast.org/docs/latest/manual/html/ec2autodiscovery.html#ec2-auto-discovery">EC2 autodiscovery</a> and multicast was blocked so built-in <a href="http://docs.hazelcast.org/docs/latest/manual/html/faq.html#how-do-nodes-discover-each-other">multicast support</a> was useless. The last resort was <a href="http://docs.hazelcast.org/docs/latest/manual/html/networkconfig.html#configuring-tcpip-cluster">TCP/IP cluster</a> where addresses of all nodes need to be hard-coded in XML configuration:<br/><br/><pre class="brush: xml">&lt;tcp-ip enabled=&quot;true&quot;&gt;<br />    &lt;member&gt;machine1&lt;/member&gt;<br />    &lt;member&gt;machine2&lt;/member&gt;<br />    &lt;member&gt;machine3:5799&lt;/member&gt;<br />    &lt;member&gt;192.168.1.0-7&lt;/member&gt;<br />    &lt;member&gt;192.168.1.21&lt;/member&gt;<br />&lt;/tcp-ip&gt;<br /></pre> This doesn't scale very well, also nodes in our cloud were assigned dynamically, thus it was not possible to figure out addresses prior runtime. Here I present proof of concept based on <a href="http://curator.apache.org/curator-x-discovery/index.html">Curator Service Discovery</a> and <a href="http://zookeeper.apache.org/">ZooKeeper</a> underneath. First of all let's skip <code>hazelcast.xml</code> configuration and bootstrap cluster in plain old Java code:<br/><br/><pre class="brush: java">@Configuration<br />public class HazelcastConfiguration {<br /><br />    @Bean(destroyMethod = &quot;shutdown&quot;)<br />    HazelcastInstance hazelcast(Config config) {<br />        return Hazelcast.newHazelcastInstance(config);<br />    }<br /><br />    @Bean<br />    Config config(ApplicationContext applicationContext, NetworkConfig networkConfig) {<br />        final Config config = new Config();<br />        config.setNetworkConfig(networkConfig);<br />        config.getGroupConfig().setName(applicationContext.getId());<br />        return config;<br />    }<br /><br />    @Bean<br />    NetworkConfig networkConfig(@Value(&quot;${hazelcast.port:5701}&quot;) int port, JoinConfig joinConfig) {<br />        final NetworkConfig networkConfig = new NetworkConfig();<br />        networkConfig.setJoin(joinConfig);<br />        networkConfig.setPort(port);<br />        return networkConfig;<br />    }<br /><br />    @Bean<br />    JoinConfig joinConfig(TcpIpConfig tcpIpConfig) {<br />        final JoinConfig joinConfig = disabledMulticast();<br />        joinConfig.setTcpIpConfig(tcpIpConfig);<br />        return joinConfig;<br />    }<br /><br />    private JoinConfig disabledMulticast() {<br />        JoinConfig join = new JoinConfig();<br />        final MulticastConfig multicastConfig = new MulticastConfig();<br />        multicastConfig.setEnabled(false);<br />        join.setMulticastConfig(multicastConfig);<br />        return join;<br />    }<br /><br />    @Bean<br />    TcpIpConfig tcpIpConfig(ApplicationContext applicationContext, ServiceDiscovery&lt;Void&gt; serviceDiscovery) throws Exception {<br />        final TcpIpConfig tcpIpConfig = new TcpIpConfig();<br />        final List&lt;String&gt; instances = queryOtherInstancesInZk(applicationContext.getId(), serviceDiscovery);<br />        tcpIpConfig.setMembers(instances);<br />        tcpIpConfig.setEnabled(true);<br />        return tcpIpConfig;<br />    }<br /><br />    private List&lt;String&gt; queryOtherInstancesInZk(String name, ServiceDiscovery&lt;Void&gt; serviceDiscovery) throws Exception {<br />        return serviceDiscovery<br />                .queryForInstances(name)<br />                .stream()<br />                .map(ServiceInstance::buildUriSpec)<br />                .collect(toList());<br />    }<br /><br />}<br /></pre> I use <code>applicationContext.getId()</code> to avoid hard-coding application name. In Spring Boot it can be replaced with <code>--spring.application.name=...</code> It's also a good idea to assign name to cluster <code>config.getGroupConfig().setName(...)</code> - this will allow us to run multiple clusters within the same network, even with multicast enabled. Last method <code>queryOtherInstancesInZk()</code> is most interesting. When creating <code>TcpIpConfig</code> we manually provide a list of TCP/IP addresses where other cluster members reside. Rather than hard-coding this list (as in XML example above), we query <code>ServiceDiscovery</code> from Curator. We ask for all instances of our application and pass it to <code>TcpIpConfig</code>. Before we jump into Curator configuration, few words of explanation how Hazelcast uses TCP/IP configuration. Obviously all nodes are not starting at the same time. When first node starts, Curator will barely return one instance (ourselves), so cluster will have only one member. When second node starts up, it will see already started node and try to form a cluster with it. Obviously first node will discover second one just connecting to it. Induction continues - when more nodes start up, they get existing nodes from Curator service discovery and join with them. Hazelcast will take care of spurious crashes of members by removing them from cluster and rebalancing data. Curator on the other hand will remove them from ZooKeeper.<br/><br/>OK, now where <code>ServiceDiscovery&lt;Void&gt;</code> comes from? Here is a full configuration:<br/><br/><pre class="brush: java">@Configuration<br />public class CuratorConfiguration {<br /><br />    @BeanWithLifecycle<br />    ServiceDiscovery&lt;Void&gt; serviceDiscovery(CuratorFramework curatorFramework, ServiceInstance&lt;Void&gt; serviceInstance) throws Exception {<br />        return ServiceDiscoveryBuilder<br />                .builder(Void.class)<br />                .basePath(&quot;hazelcast&quot;)<br />                .client(curatorFramework)<br />                .thisInstance(serviceInstance)<br />                .build();<br />    }<br /><br />    @BeanWithLifecycle<br />    CuratorFramework curatorFramework(@Value(&quot;${zooKeeper.url:localhost:2181}&quot;) String zooKeeperUrl) {<br />        ExponentialBackoffRetry retryPolicy = new ExponentialBackoffRetry(1000, 3);<br />        return CuratorFrameworkFactory.newClient(zooKeeperUrl, retryPolicy);<br />    }<br /><br />    @Bean<br />    ServiceInstance&lt;Void&gt; serviceInstance(@Value(&quot;${hazelcast.port:5701}&quot;) int port, ApplicationContext applicationContext) throws Exception {<br />        final String hostName = InetAddress.getLocalHost().getHostName();<br />        return ServiceInstance<br />                .&lt;Void&gt;builder()<br />                .name(applicationContext.getId())<br />                .uriSpec(new UriSpec(&quot;{address}:{port}&quot;))<br />                .address(hostName)<br />                .port(port)<br />                .build();<br />    }<br /><br />}<br /></pre> Hazelcast by default listens on 5701 but if specified port is occupied it will try subsequent ones. On startup we register ourselves in Curator, providing <a href="http://stackoverflow.com/questions/5596788">our host name</a> and Hazelcast port. When other instances of our application start up, they will see previously registered instances. When application goes down, Curator will unregister us, using ephemeral node mechanism in ZooKeeper. BTW <code>@BeanWithLifecycle</code> doesn't come from Spring or Spring Boot, I created it myself to avoid repetition:<br/><br/><pre class="brush: java">@Target({METHOD, ANNOTATION_TYPE})<br />@Retention(RUNTIME)<br />@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;close&quot;)<br />@interface BeanWithLifecycle { }<br /></pre> Having ZooKeeper running (by default on <code>localhost:2181</code>) we can start arbitrary number nodes and they will find each other in no time. The only shared information is ZooKeeper URL.<br/><br/> <script>SyntaxHighlighter.highlight();</script>