---
layout: post
title: '1.x to 2.x migration: Observable vs. Observable: RxJava FAQ'
date: '2017-08-14T22:40:00.001+02:00'
author: Tomasz Nurkiewicz
tags:
- rxjava
modified_time: '2017-08-14T22:40:39.785+02:00'
thumbnail: https://2.bp.blogspot.com/-J_uaRlu3lJI/WZIKmJNVavI/AAAAAAAAEB8/ux7SO_3DQbMJ6hU3Nh-O7FiCjT0QU7V1gCLcBGAs/s72-c/2016-04-22%2B15.33.14.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7008027362643006896
blogger_orig_url: https://www.nurkiewicz.com/2017/08/1x-to-2x-migration-observable-vs.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-J_uaRlu3lJI/WZIKmJNVavI/AAAAAAAAEB8/ux7SO_3DQbMJ6hU3Nh-O7FiCjT0QU7V1gCLcBGAs/s1600/2016-04-22%2B15.33.14.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="900" data-original-width="1600" height="112" src="https://2.bp.blogspot.com/-J_uaRlu3lJI/WZIKmJNVavI/AAAAAAAAEB8/ux7SO_3DQbMJ6hU3Nh-O7FiCjT0QU7V1gCLcBGAs/s200/2016-04-22%2B15.33.14.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">View from&nbsp;Basilica of Notre-Dame de Fourvi√®re</td></tr></tbody></table>The title is not a mistake. <code>rx.Observable</code> from RxJava 1.x is a completely different beast than <code>io.reactivex.Observable</code> from 2.x. Blindly upgrading <code>rx</code> dependency and renaming all imports in your project will compile (with minor changes) but does not guarantee the same behavior. In the very early days of the project <code>Observable</code> in 1.x had no notion of backpressure but later on backpressure was included. What does it actually mean? Let's imagine we have a stream that produces one event every 1 millisecond but it takes 1 <strong>second</strong> to process one such item. You see it can't possibly work this way in the long run:<br /><br /><pre class="brush: java">import rx.Observable;  //RxJava 1.x<br />import rx.schedulers.Schedulers;<br /><br />Observable<br />        .interval(1, MILLISECONDS)<br />        .observeOn(Schedulers.computation())<br />        .subscribe(<br />                x -&gt; sleep(Duration.ofSeconds(1)));</pre><code>MissingBackpressureException</code> creeps in within few hundred milliseconds. But what does this exception mean? Well, basically it's a safety net (or sanity check if you will) that prevents you from hurting your application. RxJava automatically discovers that producer is overflowing the consumer and proactively terminates the stream to avoid further damage. So what if we simply <em>search and replace</em> few imports here and there?<br /><br /><pre class="brush: java">import io.reactivex.Observable;     //RxJava 2.x<br />import io.reactivex.schedulers.Schedulers;<br /><br />Observable<br />        .interval(1, MILLISECONDS)<br />        .observeOn(Schedulers.computation())<br />        .subscribe(<br />                x -&gt; sleep(Duration.ofSeconds(1)));</pre>The exception is gone! So is our throughput... The application stalls after a while, staying in an endless GC loop. You see, <code>Observable</code> in RxJava 1.x has assertions (bounded queues, checks, etc.) all over the place, making sure you are not overflowing anywhere. For example <code>observeOn()</code> operator in 1.x has a queue limited to 128 elements by default. When backpressure is properly implemented across the whole stack, <code>observeOn()</code> operator asks upstream to deliver not more than 128 elements to fill in its internal buffer. Then separate threads (workers) from this scheduler are picking up events from this queue. When queue becomes almost empty, <code>observeOn()</code> operator asks (<code>request()</code> method) for more. This mechanism breaks apart when producer does not respect backpressure requests and sends more data than it was allowed, effectively overflowing the consumer. The internal queue inside <code>observeOn()</code> operator is full, yet <code>interval()</code> operator keeps emitting new events - because that's what <code>interval()</code> is suppose to do.<br /><br /><code>Observable</code> in 1.x discovers such overflow and fails fast with <code>MissingBackpressureException</code>. It literally means: <em>I tried so hard to keep the system in healthy state, but my upstream is not respecting backpressure - backpressure implementation is missing</em>. However <code>Observable</code> in 2.x has no such safety mechanism. It's a vanilla stream that hopes you will be a good citizen and either have slow producers or fast consumers. When system is healthy, both <code>Observable</code>s behave the same way. However under load 1.x fails fast, 2.x fails slowly and painfully.<br /><br />Does it mean RxJava 2.x is a step back? Quite the contrary! In 2.x an important distinction was made:<br /><br /><ul><li><code>Observable</code> doesn't care about backpressure, which greatly simplifies its design and implementation. It should be used to model streams that can't support backpressure by definition, e.g. user interface events</li><li><code>Flowable</code> does support backpressure and has all the safety measures in place. In other words all steps in computation pipeline make sure you are not overflowing the consumer.</li></ul>2.x makes an important distinction between streams that can support backpressure ("<em>can slow down if needed</em>" in simple words) and those that don't. From the type system perspective it becomes clear what kind of source are we dealing with and what are its guarantees. So how should we migrate our <code>interval()</code> example to RxJava 2.x? Easier than you think:<br /><br /><pre class="brush: java">Flowable<br />        .interval(1, MILLISECONDS)<br />        .observeOn(Schedulers.computation())<br />        .subscribe(<br />                x -&gt; sleep(Duration.ofSeconds(1)));</pre>That simple. You may ask yourself a question, how come <code>Flowable</code> can have <code>interval()</code> operator that, by definition, can't support backpressure? After all <code>interval()</code> is suppose to deliver events at constant rate, it can't slow down! Well, if you look at the declaration of <code>interval()</code> you'll notice:<br /><br /><pre class="brush: java">@BackpressureSupport(BackpressureKind.ERROR)</pre>Simply put this tells us that whenever backpressure can no longer be guaranteed, RxJava will take care of it and throw <code>MissingBackpressureException</code>. That's precisely what happens when we run <code>Flowable.interval()</code> program - it fails fast, as opposed to destabilizing whole application.<br /><br />So, to wrap up, whenever you see an <code>Observable</code> from 1.x, what you probably want is <code>Flowable</code> from 2.x. At least unless your stream by definition does not support backpressure. Despite same name, <code>Observable</code>s in these two major releases are quite different. But once you do a <em>search and replace</em> from <code>Observable</code> to <code>Flowable</code> you'll notice that migration isn't that straightforward. It's not about API changes, the differences are more profound.<br /><br />There is no simple <code>Flowable.create()</code> directly equivalent to <code>Observable.create()</code> in 2.x. I made a mistake myself to overuse <code>Observable.create()</code> factory method in the past. <code>create()</code> allows you to emit events at an arbitrary rate, entirely ignoring backpressure. 2.x has some friendly facilities to deal with backpressure requests, but they require careful design of your streams. This will be covered in the next FAQ.<br /><br /><script>SyntaxHighlighter.highlight();</script>