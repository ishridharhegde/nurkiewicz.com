---
layout: post
title: String memory internals
date: '2012-07-28T19:39:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- bytecode
- jvm
modified_time: '2012-07-30T10:42:50.218+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5865214688104815042
blogger_orig_url: https://www.nurkiewicz.com/2012/07/string-memory-internals.html
---

This article is based on <a href="http://stackoverflow.com/a/11701016/605744">my answer on StackOverflow</a>. I am trying to explain how <code>String</code> class stores the texts, how interning and constant pool works.<br />The main point to understand here is the distinction between <code>String</code> Java object and its contents - <code>char[]</code> under <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/String.java#String.0value" rel="nofollow">private <code>value</code> field</a>. <code>String</code> is basically a wrapper around <code>char[]</code> array, encapsulating it and making it impossible to modify so the <code>String</code> can remain immutable. Also the <code>String</code> class remembers which parts of this array is actually used (see below). This all means that you can have two different <code>String</code> objects (quite lightweight) pointing to the same <code>char[]</code>.<br />I will show you few examples, together with <code>hashCode()</code> of each <code>String</code> and <code>hashCode()</code> of internal <code>char[] value</code> field (I will call it <i>text</i> to distinguish it from string). Finally I'll show <code>javap -c -verbose</code> output, together with constant pool for my test class. Please do not confuse class constant pool with string literal pool. They are not quite the same. See also <a href="http://stackoverflow.com/questions/5546280">Understanding javap's output for the Constant Pool</a>.<br /><h4><i>Prerequisites</i></h4>For the purpose of testing I created such a utility method that breaks <code>String</code> encapsulation:<br /><pre class="brush: java">private int showInternalCharArrayHashCode(String s) {<br />    final Field value = String.class.getDeclaredField("value");<br />    value.setAccessible(true);<br />    return value.get(s).hashCode();<br />}<br /></pre>It will print <code>hashCode()</code> of <code>char[] value</code>, effectively helping us understand whether this particular <code>String</code> points to the same <code>char[]</code> text or not.<br /><h4>Two string literals in a class</h4>Let's start from the simplest example.<br /><h5>Java code</h5><pre class="brush: java">String one = "abc";<br />String two = "abc";<br /></pre>BTW if you simply write <code>"ab" + "c"</code>, Java compiler will perform concatenation at compile time and the generated code will be exactly the same. This only works if all strings are known at compile time.<br /><h5>Class constant pool</h5>Each class has its own <a href="http://en.wikipedia.org/wiki/Java_class_file#The_constant_pool" rel="nofollow">constant pool</a> - a list of constant values that can be reused if they occur several times in the source code. It includes common strings, numbers, method names, etc.<br />Here are the contents of the constant pool in our example above:<br /><a name='more'></a><br /><pre class="brush: plain">const #2 = String   #38;    //  abc<br />//...<br />const #38 = Asciz   abc;<br /></pre>The important thing to note is the distinction between <code>String</code> constant object (<code>#2</code>) and Unicode encoded text <code>"abc"</code> (<code>#38</code>) that the string points to.<br /><h5>Byte code</h5>Here is generated byte code. Note that both <code>one</code> and <code>two</code> references are assigned with the same <code>#2</code> constant pointing to <code>"abc"</code> string:<br /><pre class="brush: plain">ldc #2; //String abc<br />astore_1    //one<br />ldc #2; //String abc<br />astore_2    //two<br /></pre><h5>Output</h5>For each example I am printing the following values:<br /><pre class="brush: java">System.out.println("one.value: " + showInternalCharArrayHashCode(one));<br />System.out.println("two.value: " + showInternalCharArrayHashCode(two));<br />System.out.println("one" + System.identityHashCode(one));<br />System.out.println("two" + System.identityHashCode(two));<br /></pre>No surprise that both pairs are equal:<br /><pre class="brush: plain">one.value: 23583040<br />two.value: 23583040<br />one: 8918249<br />two: 8918249<br /></pre>Which means that not only both objects point to the same <code>char[]</code> (the same text underneath) so <code>equals()</code> test will pass. But even more, <code>one</code> and <code>two</code> are the exact same references! So <code>one == two</code> is true as well. Obviously if <code>one</code> and <code>two</code> point to the same object then <code>one.value</code> and <code>two.value</code> must be equal.<br /><h4>Literal and <code>new String()</code></h4><h5>Java code</h5>Now the example we all waited for - one string literal and one new <code>String</code> using the same literal. How will this work?<br /><pre class="brush: java">String one = "abc";<br />String two = new String("abc");<br /></pre>The fact that <code>"abc"</code> constant is used two times in the source code should give you some hint...<br /><h5>Class constant pool</h5>Same as above.<br /><h5>Byte code</h5><pre class="brush: plain">ldc #2; //String abc<br />astore_1    //one<br /><br />new #3; //class java/lang/String<br />dup<br />ldc #2; //String abc<br />invokespecial   #4; //Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V<br />astore_2    //two<br /></pre>Look carefully! The first object is created the same way as above, no surprise. It just takes a constant reference to already created <code>String</code> (<code>#2</code>) from the constant pool. However the second object is created via normal constructor call. But! The first <code>String</code> is passed as an argument. This can be decompiled to:<br /><pre class="brush: java">String two = new String(one);<br /></pre><h5>Output</h5>The output is a bit surprising. The second pair, representing references to <code>String</code> object is understandable - we created two <code>String</code> objects - one was created for us in the constant pool and the second one was created manually for <code>two</code>. But why, on earth the first pair suggests that both <code>String</code> objects point to the same <code>char[] value</code> array?!<br /><pre class="brush: plain">one.value: 41771<br />two.value: 41771<br />one: 8388097<br />two: 16585653<br /></pre>It becomes clear when you look at how <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/String.java#String.%3Cinit%3E%28java.lang.String%29" rel="nofollow"><code>String(String)</code> constructor works</a> (greatly simplified here):<br /><pre class="brush: java">public String(String original) {<br />    this.offset = original.offset;<br />    this.count = original.count;<br />    this.value = original.value;<br />}<br /></pre>See? When you are creating new <code>String</code> object based on existing one, it <b>reuses</b> <code>char[] value</code>. <code>String</code>s are immutable, there is no need to copy data structure that is known to be never modified. Moreover, since <code>new String(someString)</code> creates an exact copy of existing string and strings are immutable, there is clearly no reason for the two to exist at the same time.<br />I think this is the clue of some misunderstandings: even if you have two <code>String</code> objects, they might still point to the same contents. And as you can see the <code>String</code> object itself is quite small. <br /><h4>Runtime modification and <code>intern()</code></h4><h5>Java code</h5>Let's say you initially used two different strings but after some modifications they are all the same:<br /><pre class="brush: java">String one = "abc";<br />String two = "?abc".substring(1);  //also two = "abc"<br /></pre>The Java compiler (at least mine) is not clever enough to perform such operation at compile time, have a look:<br /><h5>Class constant pool</h5>Suddenly we ended up with two constant strings pointing to two different constant texts:<br /><pre class="brush: plain">const #2 = String   #44;    //  abc<br />const #3 = String   #45;    //  ?abc<br />const #44 = Asciz   abc;<br />const #45 = Asciz   ?abc;<br /></pre><h5>Byte code</h5><pre class="brush: plain">ldc #2; //String abc<br />astore_1    //one<br /><br />ldc #3; //String ?abc<br />iconst_1<br />invokevirtual   #4; //Method String.substring:(I)Ljava/lang/String;<br />astore_2    //two<br /></pre>The fist string is constructed as usual. The second is created by first loading the constant <code>"?abc"</code> string and then calling <code>substring(1)</code> on it. <br /><h5>Output</h5>No surprise here - we have two different strings, pointing to two different <code>char[]</code> texts in memory:<br /><pre class="brush: plain">one.value: 27379847<br />two.value: 7615385<br />one: 8388097<br />two: 16585653<br /></pre>Well, the texts aren't really <i>different</i>, <code>equals()</code> method will still yield <code>true</code>. We have two unnecessary copies of the same text.<br />Now we should run two exercises. First, try running:<br /><pre class="brush: java">two = two.intern();<br /></pre>before printing hash codes. Not only both <code>one</code> and <code>two</code> point to the same text, but they are the same reference!<br /><pre class="brush: plain">one.value: 11108810<br />two.value: 11108810<br />one: 15184449<br />two: 15184449<br /></pre>This means both <code>one.equals(two)</code> and <code>one == two</code> tests will pass. Also we saved some memory because <code>"abc"</code> text appears only once in memory (the second copy will be garbage collected).<br />The second exercise is slightly different, check out this:<br /><pre class="brush: java">String one = "abc";<br />String two = "abc".substring(1);<br /></pre>Obviously <code>one</code> and <code>two</code> are two different objects, pointing to two different texts. But how come the output suggests that they both point to the same <code>char[]</code> array?!?<br /><pre class="brush: plain"><br />one.value: 23583040<br />two.value: 23583040<br />one: 11108810<br />two: 8918249<br /></pre>I'll leave the answer to you. It'll teach you how <code>substring()</code> works, what are the advantages of such approach and when it can <a href="http://stackoverflow.com/a/1281569">lead to big troubles</a>.<br /><h4>Lessons learnt</h4><ul><li><code>String</code> object itself is rather cheap. It's the text it points to that consumes most of the memory</li><li><code>String</code> is just a thin wrapper around <code>char[]</code> to preserve immutability</li><li><code>new String("abc")</code> isn't really <i>that</i> expensive as the internal text representation is reused. But still avoid such construct.</li><li>When <code>String</code> is concatenated from constant values known at compile time, concatenation is done by the compiler, not by the JVM</li><li><code>substring()</code> is tricky, but most importantly, it is very cheap, both in terms of used memory and run time (constant in both cases)</li></ul>