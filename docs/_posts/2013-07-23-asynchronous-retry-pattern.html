---
layout: post
title: Asynchronous retry pattern
date: '2013-07-23T20:39:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- java 8
- spring
- functional programming
- concurrency
modified_time: '2013-07-23T20:40:36.835+02:00'
thumbnail: http://3.bp.blogspot.com/-Uj-BAXFfMRM/Ue7NJBUPPiI/AAAAAAAAAzw/ayUT6eOYKQM/s72-c/snaroya-1.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7287354696116941099
blogger_orig_url: https://www.nurkiewicz.com/2013/07/asynchronous-retry-pattern.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-Uj-BAXFfMRM/Ue7NJBUPPiI/AAAAAAAAAzw/ayUT6eOYKQM/s1600/snaroya-1.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="149" src="http://3.bp.blogspot.com/-Uj-BAXFfMRM/Ue7NJBUPPiI/AAAAAAAAAzw/ayUT6eOYKQM/s200/snaroya-1.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Office building in Fornebu</td></tr></tbody></table>When you have a piece of code that often fails and must be retried, this Java 7/8 library provides rich and unobtrusive API with fast and scalable solution to this problem:<br /><br /><pre class="brush: java">ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();<br />RetryExecutor executor = new AsyncRetryExecutor(scheduler).<br />    retryOn(SocketException.class).<br />    withExponentialBackoff(500, 2).     //500ms times 2 after each retry<br />    withMaxDelay(10_000).               //10 seconds<br />    withUniformJitter().                //add between +/- 100 ms randomly<br />    withMaxRetries(20);<br /></pre>You can now run arbitrary block of code and the library will retry it for you in case it throws <code>SocketException</code>:<br /><br /><pre class="brush: java">final CompletableFuture&lt;Socket&gt; future = executor.getWithRetry(() -&gt;<br />        new Socket("localhost", 8080)<br />);<br /><br />future.thenAccept(socket -&gt;<br />        System.out.println("Connected! " + socket)<br />);<br /></pre>Please look carefully! <code>getWithRetry()</code> does not block. It returns <code>CompletableFuture</code> immediately and invokes given function asynchronously. You can listen for that <code>Future</code> or even for multiple futures at once and do other work in the meantime. So what this code does is: trying to connect to <code>localhost:8080</code> and if it fails with <code>SocketException</code> it will retry after 500 milliseconds (with some random jitter), doubling delay after each retry, but not above 10 seconds.<br /><br />Equivalent but more concise syntax:<br /><a name='more'></a><br /><br /><pre class="brush: java">executor.<br />        getWithRetry(() -&gt; new Socket("localhost", 8080)).<br />        thenAccept(socket -&gt; System.out.println("Connected! " + socket));<br /></pre>This is a sample output that you might expect:<br /><br /><pre class="brush: java">TRACE | Retry 0 failed after 3ms, scheduled next retry in 508ms (Sun Jul 21 21:01:12 CEST 2013)<br />java.net.ConnectException: Connection refused<br />    at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0-ea]<br />    //...<br /><br />TRACE | Retry 1 failed after 0ms, scheduled next retry in 934ms (Sun Jul 21 21:01:13 CEST 2013)<br />java.net.ConnectException: Connection refused<br />    at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0-ea]<br />    //...<br /><br />TRACE | Retry 2 failed after 0ms, scheduled next retry in 1919ms (Sun Jul 21 21:01:15 CEST 2013)<br />java.net.ConnectException: Connection refused<br />    at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0-ea]<br />    //...<br /><br />TRACE | Successful after 2 retries, took 0ms and returned: Socket[addr=localhost/127.0.0.1,port=8080,localport=46332]<br /><br />Connected! Socket[addr=localhost/127.0.0.1,port=8080,localport=46332]<br /></pre>Imagine you connect to two different systems, one is <i>slow</i>, second <i>unreliable</i> and fails often:<br /><br /><pre class="brush: java">CompletableFuture&lt;String&gt; stringFuture = executor.getWithRetry(ctx -&gt; unreliable());<br />CompletableFuture&lt;Integer&gt; intFuture = executor.getWithRetry(ctx -&gt; slow());<br /><br />stringFuture.thenAcceptBoth(intFuture, (String s, Integer i) -&gt; {<br />    //both done after some retries<br />});<br /></pre><code>thenAcceptBoth()</code> callback is executed asynchronously when both slow and unreliable systems finally reply without any failure. Similarly (using <code>CompletableFuture.acceptEither()</code>) you can call two or more unreliable servers asynchronously at the same time and be notified when the first one succeeds after some number of retries.<br /><br />I can’t emphasize this enough - retries are executed asynchronously and effectively use thread pool, rather than sleeping blindly.<br /><br /><h1>Rationale</h1>Often we are forced to <a href="http://servicedesignpatterns.com/WebServiceInfrastructures/IdempotentRetry">retry</a> given piece of code because it failed and we must try again, typically with a small delay to spare CPU. This requirement is quite common and there are few ready-made generic implementations with <a href="http://static.springsource.org/spring-batch/reference/html/retry.html">retry support in Spring Batch</a> through <a href="http://static.springsource.org/spring-batch/2.1.x/apidocs/org/springframework/batch/retry/support/RetryTemplate.html"><code>RetryTemplate</code></a> class being best known. But there are few other, quite similar approaches (<a href="http://fahdshariff.blogspot.no/2009/08/retrying-operations-in-java.html">[1]</a>, <a href="https://github.com/Ninja-Squad/ninja-core/tree/master/src/main/java/com/ninja_squad/core/retry">[2]</a>). All of these attempts (and I bet many of you implemented similar tool yourself!) suffer the same issue - they are blocking, thus wasting a lot of resources and not scaling well.<br /><br />This is not bad <i>per se</i> because it makes programming model much simpler - the library takes care of retrying and you simply have to wait for return value longer than usual. But not only it creates leaky abstraction (method that is typically very fast suddenly becomes slow due to retries and delay), but also wastes valuable threads since such facility will spend most of the time sleeping between retries. Therefore <a href="https://github.com/nurkiewicz/async-retry"><code>Async-Retry</code></a> utility was created, targeting <b>Java 8</b> (with <a href="https://github.com/nurkiewicz/async-retry/tree/java7">Java 7 backport</a> existing) and addressing issues above.<br /><br />The main abstraction is <a href="https://github.com/nurkiewicz/async-retry/blob/master/src/main/java/com/blogspot/nurkiewicz/asyncretry/RetryExecutor.java"><code>RetryExecutor</code></a> that provides simple API:<br /><br /><pre class="brush: java">public interface RetryExecutor {<br /><br />    CompletableFuture&lt;Void&gt; doWithRetry(RetryRunnable action);<br /><br />    &lt;V&gt; CompletableFuture&lt;V&gt; getWithRetry(Callable&lt;V&gt; task);<br /><br />    &lt;V&gt; CompletableFuture&lt;V&gt; getWithRetry(RetryCallable&lt;V&gt; task);<br /><br />    &lt;V&gt; CompletableFuture&lt;V&gt; getFutureWithRetry(RetryCallable&lt;CompletableFuture&lt;V&gt;&gt; task);<br />}<br /></pre>Don’t worry about <a href="https://github.com/nurkiewicz/async-retry/blob/master/src/main/java/com/blogspot/nurkiewicz/asyncretry/function/RetryRunnable.java"><code>RetryRunnable</code></a> and <a href="https://github.com/nurkiewicz/async-retry/blob/master/src/main/java/com/blogspot/nurkiewicz/asyncretry/function/RetryCallable.java"><code>RetryCallable</code></a> - they allow checked exceptions for your convenience and most of the time we will use lambda expressions anyway.<br /><br />Please note that it returns <a href="http://nurkiewicz.blogspot.no/2013/05/java-8-definitive-guide-to.html"><code>CompletableFuture</code></a>. We no longer pretend that calling faulty method is fast. If the library encounters an exception it will retry our block of code with preconfigured backoff delays. The invocation time will sky-rocket from milliseconds to several seconds. <code>CompletableFuture</code> clearly indicates that. Moreover it’s not a dumb <a href="http://nurkiewicz.blogspot.no/2013/02/javautilconcurrentfuture-basics.html"><code>java.util.concurrent.Future</code></a> we all know - <a href="http://nurkiewicz.blogspot.no/2013/05/java-8-completablefuture-in-action.html"><code>CompletableFuture</code> in Java 8 is very powerful</a> and most importantly - non-blocking by default.<br /><br />If you need blocking result after all, just call <code>.get()</code> on <code>Future</code> object.<br /><br /><h1>Basic API</h1>The API is very simple. You provide a block of code and the library will run it multiple times until it returns normally rather than throwing an exception. It may also put configurable delays between retries:<br /><br /><pre class="brush: java">RetryExecutor executor = //...<br /><br />executor.getWithRetry(() -&gt; new Socket("localhost", 8080));<br /></pre>Returned <code>CompletableFuture&lt;Socket&gt;</code> will be resolved once connecting to <code>localhost:8080</code> succeeds. Optionally we can consume <a href="https://github.com/nurkiewicz/async-retry/blob/master/src/main/java/com/blogspot/nurkiewicz/asyncretry/RetryContext.java"><code>RetryContext</code></a> to get extra context like which retry is currently being executed:<br /><br /><pre class="brush: java">executor.<br />    getWithRetry(ctx -&gt; new Socket("localhost", 8080 + ctx.getRetryCount())).<br />    thenAccept(System.out::println);<br /></pre>This code is more clever than it looks. During first execution <code>ctx.getRetryCount()</code> returns <code>0</code>, therefore we try to connect to <code>localhost:8080</code>. If this fails, next retry will try <code>localhost:8081</code> (<code>8080 + 1</code>) and so on. And if you realize that all of this happens asynchronously you can scan ports of several machines and be notified about first responding port on each host:<br /><br /><pre class="brush: java">Arrays.asList("host-one", "host-two", "host-three").<br />    stream().<br />    forEach(host -&gt;<br />        executor.<br />            getWithRetry(ctx -&gt; new Socket(host, 8080 + ctx.getRetryCount())).<br />            thenAccept(System.out::println)<br />    );<br /></pre>For each host <code>RetryExecutor</code> will attempt to connect to port 8080 and retry with higher ports. <br /><br /><code>getFutureWithRetry()</code> requires special attention. I you want to retry method that already returns <code>CompletableFuture&lt;V&gt;</code>: e.g. result of asynchronous HTTP call:<br /><br /><pre class="brush: java">private CompletableFuture&lt;String&gt; asyncHttp(URL url) { /*...*/}<br /><br />//...<br /><br />final CompletableFuture&lt;CompletableFuture&lt;String&gt;&gt; response = <br />    executor.getWithRetry(ctx -&gt; <br />        asyncHttp(new URL("http://example.com")));<br /></pre>Passing <code>asyncHttp()</code> to <code>getWithRetry()</code> will yield <code>CompletableFuture&lt;CompletableFuture&lt;V&gt;&gt;</code>. Not only it’s awkward to work with, but also broken. The library will barely call <code>asyncHttp()</code> and retry only if it fails, but not if returned <code>CompletableFuture&lt;String&gt;</code> fails. The solution is simple:<br /><br /><pre class="brush: java">final CompletableFuture&lt;String&gt; response =<br />    executor.getFutureWithRetry(ctx -&gt;<br />        asyncHttp(new URL("http://example.com")));<br /></pre>In this case <code>RetryExecutor</code> will understand that whatever was returned from <code>asyncHttp()</code> is the actually just a <code>Future</code> and will (asynchronously) wait for result or failure. This library is much more powerful, so let’s dive into:<br /><br /><h2>Configuration options</h2>In general there are two important factors you can configure: <a href="https://github.com/nurkiewicz/async-retry/blob/master/src/main/java/com/blogspot/nurkiewicz/asyncretry/policy/RetryPolicy.java"><code>RetryPolicy</code></a> that controls whether next retry attempt should be made and <a href="https://github.com/nurkiewicz/async-retry/blob/master/src/main/java/com/blogspot/nurkiewicz/asyncretry/backoff/Backoff.java"><code>Backoff</code></a> - that optionally adds delay between subsequent retry attempts.<br /><br />By default <code>RetryExecutor</code> repeats user task infinitely on every <code>Throwable</code> and adds 1 second delay between retry attempts.<br /><br /><h3>Creating an instance of <code>RetryExecutor</code></h3>Default implementation of <code>RetryExecutor</code> is <a href="https://github.com/nurkiewicz/async-retry/blob/master/src/main/java/com/blogspot/nurkiewicz/asyncretry/AsyncRetryExecutor.java"><code>AsyncRetryExecutor</code></a> which you can create directly:<br /><br /><pre class="brush: java">ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();<br /><br />RetryExecutor executor = new AsyncRetryExecutor(scheduler);<br /><br />//...<br /><br />scheduler.shutdownNow();<br /></pre>The only required dependency is standard <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html"><code>ScheduledExecutorService</code> from JDK</a>. One thread is enough in many cases but if you want to concurrently handle retries of hundreds or more tasks, consider increasing the pool size.<br /><br />Notice that the <code>AsyncRetryExecutor</code> does not take care of shutting down the <code>ScheduledExecutorService</code>. This is a conscious design decision which will be explained later.<br /><br /><code>AsyncRetryExecutor</code> has few other constructors but most of the time altering the behaviour of this class is most convenient with calling chained <code>with*()</code> methods. You will see plenty of examples written this way. Later on we will simply use <code>executor</code> reference without defining it. Assume it’s of <code>RetryExecutor</code> type.<br /><br /><h3>Retrying policy</h3><h4>Exceptions</h4>By default every <code>Throwable</code> (except special <code>AbortRetryException</code>) thrown from user task causes retry. Obviously this is configurable. For example in JPA you may want to retry a transaction that failed due to <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/OptimisticLockException.html"><code>OptimisticLockException</code></a> - but every other exception should fail immediately:<br /><br /><pre class="brush: java">executor.<br />    retryOn(OptimisticLockException.class).<br />    withNoDelay().<br />    getWithRetry(ctx -&gt; dao.optimistic());<br /></pre>Where <code>dao.optimistic()</code> may throw <code>OptimisticLockException</code>. In that case you probably don’t want any delay between retries, more on that later. If you don’t like the default of retrying on every <code>Throwable</code>, just restrict that using <code>retryOn()</code>:<br /><br /><pre class="brush: java">executor.retryOn(Exception.class)<br /></pre>Of course the opposite might also be desired - to abort retrying and fail immediately in case of certain exception being thrown rather than retrying. It’s that simple:<br /><br /><pre class="brush: java">executor.<br />        abortOn(NullPointerException.class).<br />        abortOn(IllegalArgumentException.class).<br />        getWithRetry(ctx -&gt; dao.optimistic());<br /></pre>Clearly you don’t want to retry <code>NullPointerException</code> or <code>IllegalArgumentException</code> as they indicate programming bug rather than transient failure. And finally you can combine both retry and abort policies. User code will retry in case of any <code>retryOn()</code> exception (or subclass) unless it should <code>abortOn()</code> specified exception. For example we want to retry every <code>IOException</code> or <code>SQLException</code> but abort if <code>FileNotFoundException</code> or <code>java.sql.DataTruncation</code> is encountered (order is irrelevant):<br /><br /><pre class="brush: java">executor.<br />    retryOn(IOException.class).<br />    abortIf(FileNotFoundException.class).<br />    retryOn(SQLException.class).<br />    abortIf(DataTruncation.class).<br />    getWithRetry(ctx -&gt; dao.load(42));<br /></pre>If this is not enough you can provide custom predicate that will be invoked on each failure:<br /><br /><pre class="brush: java">executor.<br />    abortIf(throwable -&gt;<br />        throwable instanceof SQLException &amp;&amp;<br />                throwable.getMessage().contains("ORA-00911")<br />    );<br /></pre><h4>Max number of retries</h4>Another way of interrupting retrying “loop” (remember that this process is asynchronous, there is no blocking <i>loop</i>) is by specifying maximum number of retries:<br /><br /><pre class="brush: java">executor.withMaxRetries(5)<br /></pre>In rare cases you may want to disable retries and barely take advantage from asynchronous execution. In that case try:<br /><br /><pre class="brush: java">executor.dontRetry()<br /></pre><h3>Delays between retries (backoff)</h3>Retrying immediately after failure is sometimes desired (see <code>OptimisticLockException</code> example) but in most cases it’s a bad idea. If you can’t connect to external system, waiting a little bit before next attempt sounds reasonably. You save CPU, bandwidth and other server’s resources. But there are quite a few options to consider: <br /><br /><ul><li>should we retry with constant intervals or <a href="http://en.wikipedia.org/wiki/Exponential_backoff">increase delay after each failure</a>?<br /><br /></li><li>should there be a lower and upper limit on waiting time?<br /><br /></li><li>should we add random “jitter” to delay times to spread retries of many tasks in time?<br /><br /></li></ul>This library answers all these questions.<br /><br /><h4>Fixed interval between retries</h4>By default each retry is preceded by 1 second waiting time. So if initial attempt fails, first retry will be executed after 1 second. Of course we can change that default, e.g. to 200 milliseconds:<br /><br /><pre class="brush: java">executor.withFixedBackoff(200)<br /></pre>If we are already here, by default backoff is applied after executing user task. If user task itself consumes some time, retries will be less frequent. For example with retry delay of 200ms and average time it takes before user task fails at about 50ms <code>RetryExecutor</code> will retry about 4 times per second (50ms + 200ms). However if you want to keep retry frequency at more predictable level you can use <code>fixedRate</code> flag:<br /><br /><pre class="brush: java">executor.<br />        withFixedBackoff(200).<br />        withFixedRate()<br /></pre>This is similar to “fixed rate” vs. “fixed delay” approaches in <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html"><code>ScheduledExecutorService</code></a>. BTW don’t expect <code>RetryExecutor</code> to be very precise, it does it’s best but it heavily depends on aforementioned <code>ScheduledExecutorService</code> accuracy.<br /><br /><h4>Exponentially growing intervals between retries</h4>It’s probably an active research subject, but in general you may wish to expand retry delay over time, assuming that if the user task fails several times we should try less frequently. For example let’s say we start with 100ms delay until first retry attempt is made but if that one fails as well, we should wait two times more (200ms). And later 400ms, 800ms… You get the idea:<br /><br /><pre class="brush: java">executor.withExponentialBackoff(100, 2)<br /></pre>This is an exponential function that can grow very fast. Thus it’s useful to set maximum backoff time at some reasonable level, e.g. 10 seconds:<br /><br /><pre class="brush: java">executor.<br />    withExponentialBackoff(100, 2).<br />    withMaxDelay(10_000)      //10 seconds<br /></pre><h4>Random jitter</h4>One phenomena often observed during major outages is that systems tend to synchronize. Imagine a busy system that suddenly stops responding. Hundreds or thousands of requests fail and are retried. It depends on your backoff but by default all these requests will retry exactly after one second producing huge wave of traffic at one point in time. Finally such failures are propagated to other systems that, in turn, synchronize as well.<br /><br />To avoid this problem it’s useful to spread retries over time, flattening the load. A simple solution is to add random jitter to delay time so that not all request are scheduled for retry at the exact same time. You have choice between uniform jitter (random value from -100ms to 100ms):<br /><br /><pre class="brush: java">executor.withUniformJitter(100)     //ms<br /></pre>…and proportional jitter, multiplying delay time by random factor, by default between 0.9 and 1.1 (10%):<br /><br /><pre class="brush: java">executor.withProportionalJitter(0.1)        //10%<br /></pre>You may also put hard lower limit on delay time to avoid to short retry times being scheduled:<br /><br /><pre class="brush: java">executor.withMinDelay(50)   //ms<br /></pre><h2>Implementation details</h2>This library was built with Java 8 in mind to take advantage of lambdas and new <code>CompletableFuture</code> abstraction (but <a href="https://github.com/nurkiewicz/async-retry/tree/java7">Java 7 port with Guava dependency exists</a>). It uses <code>ScheduledExecutorService</code> underneath to run tasks and schedule retries in the future - which allows best thread utilization.<br /><br />But what is really interesting is that the whole library is fully immutable, there is no single mutable field, at all. This might be counter-intuitive at first, take for example this trivial code sample:<br /><br /><pre class="brush: java">ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();<br /><br />AsyncRetryExecutor first = new AsyncRetryExecutor(scheduler).<br />    retryOn(Exception.class).<br />    withExponentialBackoff(500, 2);<br /><br />AsyncRetryExecutor second = first.abortOn(FileNotFoundException.class);<br /><br />AsyncRetryExecutor third = second.withMaxRetries(10);<br /></pre>It might seem that all <code>with*()</code> methods or <code>retryOn()</code>/<code>abortOn()</code> mutate existing executor. But that’s not the case, each configuration change <b>creates new instance</b>, leaving the old one untouched. So for example while <code>first</code> executor will retry on <code>FileNotFoundException</code>, the <code>second</code> and <code>third</code> won’t. However they all share the same <code>scheduler</code>. This is the reason why <code>AsyncRetryExecutor</code> does not shut down <code>ScheduledExecutorService</code> (it doesn’t even have any <code>close()</code> method). Since we have no idea how many copies of <code>AsyncRetryExecutor</code> exist pointing to the same scheduler, we don’t even try to manage its lifecycle. However this is typically not a problem (see <i>Spring integration</i> below).<br /><br />You might be wondering, why such an awkward design decision? There are three reasons:<br /><br /><ul><li>when writing a concurrent code immutability can greatly reduce risk of multi-threading bugs. For example <code>RetryContext</code> holds number of retries. But instead of mutating it we simply create new instance (copy) with incremented but <code>final</code> counter. No race condition or visibility can ever occur.<br /><br /></li><li>if you are given an existing <code>RetryExecutor</code> which is almost exactly what you want but you need one minor tweak, you simply call <code>executor.with...()</code> and get a fresh copy. You don’t have to worry about other places where the same executor was used (see: <i>Spring integration</i> for further examples)<br /><br /></li><li>functional programming and immutable data structures are <i>sexy</i> these days ;-).<br /><br /></li></ul>N.B.: <code>AsyncRetryExecutor</code> is <b>not</b> marked <code>final</code>, does you can break immutability by subclassing it and adding mutable state. Please don’t do this, subclassing is only permitted to alter behaviour.<br /><br /><h2>Dependencies</h2>This library requires Java 8 and <a href="http://www.slf4j.org/">SLF4J</a> for logging. Java 7 port additionally depends on <a href="http://code.google.com/p/guava-libraries/">Guava</a>.<br /><br /><h2>Spring integration</h2>If you are just about to use <code>RetryExecutor</code> in Spring - feel free, but the configuration API might not work for you. Spring promotes (or used to promote) the convention of mutable services with plenty of setters. In XML you define bean and invoke setters (via <code>&lt;property name="..."/&gt;</code>) on it. This convention assumes the existence of mutating setters. But I found this approach error-prone and counter-intuitive under some circumstances.<br /><br />Let’s say we globally defined <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/transaction/support/TransactionTemplate.html"><code>org.springframework.transaction.support.TransactionTemplate</code></a> bean and injected it in multiple places. Great. Now there is this one single request that requires slightly different timeout:<br /><br /><pre class="brush: java">@Autowired<br />private TransactionTemplate template;<br /></pre>and later in the same class:<br /><br /><pre class="brush: java">final int oldTimeout = template.getTimeout();<br />template.setTimeout(10_000);<br />//do the work<br />template.setTimeout(oldTimeout);<br /></pre>This code is wrong on so many levels! First of all if something fails we never restore <code>oldTimeout</code>. OK, <code>finally</code> to the rescue. But also notice how we changed global, shared <code>TransactionTemplate</code> instance. Who knows how many other beans and threads are just about to use it, unaware of changed configuration?<br /><br />And even if you do want to globally change the transaction timeout, fair enough, but it’s still wrong way to do this. <code>private timeout</code> field is not <code>volatile</code> and thus changes made to it may or may not be visible to other threads. What a mess! The same problem appears with many other classes like <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/jms/core/JmsTemplate.html"><code>JmsTemplate</code></a>.<br /><br />You see where I’m going? Just create one, immutable service class and safely adjust it by creating copies whenever you need it. And using such services is equally simple these days:<br /><br /><pre class="brush: java">@Configuration<br />class Beans {<br /><br />    @Bean<br />    public RetryExecutor retryExecutor() {<br />        return new AsyncRetryExecutor(scheduler()).<br />            retryOn(SocketException.class).<br />            withExponentialBackoff(500, 2);<br />    }<br /><br />    @Bean(destroyMethod = "shutdownNow")<br />    public ScheduledExecutorService scheduler() {<br />        return Executors.newSingleThreadScheduledExecutor();<br />    }<br /><br />}<br /></pre>Hey! It’s 21st century, we don’t need XML in Spring any more. Bootstrap is simple as well:<br /><br /><pre class="brush: java">final ApplicationContext context = new AnnotationConfigApplicationContext(Beans.class);<br />final RetryExecutor executor = context.getBean(RetryExecutor.class);<br />//...<br />context.close();<br /></pre>As you can see integrating modern, immutable services with Spring is just as simple. BTW if you are not prepared for such a big change when designing your own services, at least consider <a href="http://nurkiewicz.blogspot.no/2011/09/evolution-of-spring-dependency.html">constructor injection</a>.<br /><br /><h2>Maturity</h2>This library is covered with a strong battery of unit tests. However it wasn’t yet used in any production code and the API is subject to change. Of course you are encouraged to submit <a href="https://github.com/nurkiewicz/async-retry/issues">bugs, feature requests</a> and <a href="https://github.com/nurkiewicz/async-retry/pulls">pull requests</a>. It was developed with Java 8 in mind but <a href="https://github.com/nurkiewicz/async-retry/tree/java7">Java 7 backport</a> exists with slightly more verbose API and mandatory Guava dependency (<a href="http://nurkiewicz.blogspot.no/2013/02/listenablefuture-in-guava.html"><code>ListenableFuture</code></a> instead of <a href="http://nurkiewicz.blogspot.no/2013/05/java-8-definitive-guide-to.html"><code>CompletableFuture</code> from Java 8</a>).<br /><br /><a href="https://github.com/nurkiewicz/async-retry">Full source code on GitHub.</a><br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>