---
layout: post
title: 'State pattern: introducing domain-driven design'
date: '2009-09-27T14:46:00.006+02:00'
author: Tomasz Nurkiewicz
tags:
- design patterns
- ddd
modified_time: '2013-04-07T13:23:12.039+02:00'
thumbnail: http://4.bp.blogspot.com/_P3ewsGQzHn0/Sr9iq0Gv_fI/AAAAAAAAAOA/vHT-8PucMFM/s72-c/state_statuses.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5561718808315316801
blogger_orig_url: https://www.nurkiewicz.com/2009/09/state-pattern-introducing-domain-driven.html
---

Some domain objects in many enterprises applications include a concept of state. State has two main characteristics: the behavior of domain object (how it responds to business methods) depends on the state and business methods may change the state forcing the object to behave differently after being invoked.<br /><br />If you can’t image any real-life example of domain objects’ state, think of a <span style="font-family:courier new;">Car </span>entity in rental company. The <span style="font-family:courier new;">Car</span>, while remaining the same object, has additional flag called status, which is crucial for the company. The flag may have three values: <span style="font-family:courier new;">AVAILABLE</span>, <span style="font-family:courier new;">RENTED </span>and <span style="font-family:courier new;">MISSING</span>. It is obvious that the <span style="font-family:courier new;">Car </span>in <span style="font-family:courier new;">RENTED </span>or <span style="font-family:courier new;">MISSING </span>state cannot be rented at the moment and <span style="font-family:courier new;">rent()</span> method should fail. But when the car is back and its status is <span style="font-family:courier new;">AVAILABLE</span>, calling rent() on <span style="font-family:courier new;">Car </span>instance should clearly, apart from remembering customer who rented the car, changing the car status to <span style="font-family:courier new;">RENTED</span>. The status flag (probably single character or int in your database) is an example of objects’ state, as it influences the business methods and vice-versa, business methods can change it.<br /><br />Now think for a while, how would you implement this scenario which, I am sure, you have seen many times at work. You have many business methods depending on current state and probably many states. If you love object oriented programming, you might immediately thought about inheritance and creating <span style="font-family:courier new;">AvailableCar</span>, <span style="font-family:courier new;">RentedCar </span>and <span style="font-family:courier new;">MissingCar </span>extending <span style="font-family:courier new;">Car</span>. It looks good, but is very impractical, especially when <span style="font-family:courier new;">Car </span>is persistent object. And actually this approach is not well designed: it is not the whole object that changes, but only a piece of its internal state – we are not replacing object, only changing it. Maybe you thought about cascade of <span style="font-family:courier new;">if-else-if-else</span>... in each method performing different task depending on state. Don’t go there, believe me, it is the path to the <span style="font-style: italic;">Code Maintenance Hell</span>.<br /><br />But we are going to use inheritance and polymorphism though, but in more clever way: using State GoF pattern. As an example I have chosen <span style="font-family:courier new;">Reservation </span>entity which can have following statuses:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_P3ewsGQzHn0/Sr9iq0Gv_fI/AAAAAAAAAOA/vHT-8PucMFM/s1600-h/state_statuses.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 128px; height: 200px;" src="http://4.bp.blogspot.com/_P3ewsGQzHn0/Sr9iq0Gv_fI/AAAAAAAAAOA/vHT-8PucMFM/s200/state_statuses.png" alt="" id="BLOGGER_PHOTO_ID_5386132167039385074" border="0" /></a><br /><br /><br />Flow is simple – when the reservation is created, it has <span style="font-family:courier new;">NEW </span>status (state). Then some authorized person can accept the reservation, causing (let’s say) seat to be temporarily reserved and sending user an e-mail asking to pay for the reservation. Then, when user performs money transfer, money is accounted, ticket printed and second e-mail sent to the client. Of course you are aware that some actions have dramatically different side-effects depending on Reservation current status. For example you can cancel reservation at any time, but depending on Reservation status this may result in transferring money back and cancelling reservation or only in sending user an e-mail. Also some actions have no sense in particular statuses (what if user transferred money to already-cancelled reservation?) or should be ignored. Now image how hard it would be to write each business method exposed on state machine diagram above, if you had to use if-else construct for every status and every method...<br /><br />Unlike my previous posts I will not explain<a href="http://en.wikipedia.org/wiki/State_pattern"> original</a> GoF State design pattern. Instead I will introduce my little variation over this pattern using Java 5 enum capabilities. In lieu of creating abstract class/interface for state abstraction and writing implementation for each state, I have simply created enum containing all available states/statuses:<br /><br /><br /><pre name="code" class="java">public enum ReservationStatus {<br /><br /> NEW,<br /><br /> ACCEPTED,<br /><br /> PAID,<br /><br /> CANCELLED;<br /><br />}</pre><br /><br />Also I created interface for all business methods depending on status, which seems to be a good idea. Treat this interface as abstract base for all states, but we are going to use it in a bit different way:<br /><br /><pre name="code" class="java">public interface ReservationStatusOperations {<br /><br /> ReservationStatus accept(Reservation reservation);<br /><br /> ReservationStatus charge(Reservation reservation);<br /><br /> ReservationStatus cancel(Reservation reservation);<br /><br />}</pre><br /><br />And finally <span style="font-family:courier new;">Reservation </span>domain object, which happens to be JPA entity (getters/setters omitted, or maybe we can just use Groovy and forget about them?):<br /><br /><pre name="code" class="java">public class Reservation {<br /><br /> private int id;<br /><br /> private String name;<br /><br /> private Calendar date;<br /><br /> private BigDecimal price;<br /><br /> private ReservationStatus status = ReservationStatus.NEW;<br /><br /><br /><br /> //getters/setters<br /><br /><br /><br />}</pre><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_P3ewsGQzHn0/Sr9jCkMmMSI/AAAAAAAAAOI/KymGcgu5YJ8/s1600-h/state_classes.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 131px;" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/Sr9jCkMmMSI/AAAAAAAAAOI/KymGcgu5YJ8/s200/state_classes.png" alt="" id="BLOGGER_PHOTO_ID_5386132575085801762" border="0" /></a><br /><br />If <span style="font-family:courier new;">Reservation </span>is persistent domain object, its status (<span style="font-family:courier new;">ReservationStatus</span>) should obviously be persistent as well. This observation brings us to the first big advantage of using enum instead of abstract class: JPA/Hibernate can easily serialize and persist Java enum in database using enum’s name or ordinal value (by default). In original GoF pattern we would rather put <span style="font-family:courier new;">ReservationStatusOperations </span>direcly in domain object and switch implementations when status changes. I suggest to use enum and only change enum value. Another (less framework-centric and more important) advantage of using enum is that all possible states are listed in one place. You don’t have to crawl your source code in search for all implementations of base <span style="font-family:courier new;">State </span>class – everything can be seen in one, comma-separated list.<br /><br />OK, take a deep breath, now I will explain how all the pieces work together and why, on earth, business operations in <span style="font-family:courier new;">ReservationStatusOperations </span>return <span style="font-family:courier new;">ReservationStatus</span>. First, you must recall what actually enum’s are. They are not just a collection of constants in single namespace like in C/C++. In Java, enum is rather a closed set of classes that inherit from common base class (e.g. <span style="font-family:courier new;">ReservationStatus</span>), which in turns inherits from <a href="http://java.sun.com/javase/6/docs/api/java/lang/Enum.html">Enum</a>. So while using enums, we might take advantage of polymorphism and inheritance:<br /><br /><pre name="code" class="java">public enum ReservationStatus implements ReservationStatusOperations {<br /><br /><br /><br /> NEW {<br /><br />   public ReservationStatus accept(Reservation reservation) {<br /><br />       //..<br /><br />   }<br /><br /><br /><br />   public ReservationStatus charge(Reservation reservation) {<br /><br />       //..<br /><br />   }<br /><br /><br /><br />   public ReservationStatus cancel(Reservation reservation) {<br /><br />       //..<br /><br />   }<br /><br /> },<br /><br /><br /><br /> ACCEPTED {<br /><br />   public ReservationStatus accept(Reservation reservation) {<br /><br />    //..<br /><br />   }<br /><br /><br /><br />   public ReservationStatus charge(Reservation reservation) {<br /><br />       //..<br /><br />   }<br /><br /><br /><br />   public ReservationStatus cancel(Reservation reservation) {<br /><br />       //..<br /><br />   }<br /><br /> },<br /><br /><br /><br /> PAID {/*...*/},<br /><br /><br /><br /> CANCELLED {/*...*/};<br /><br />}</pre><br /><br />Although it’s tempting to write <span style="font-family:courier new;">ReservationStatusOperations </span>in such a manner, it’s a bad idea for a long term development. Not only the enum source code would be extensively long (total number of implemented methods would be equal to a number of statuses multiplied by number of business methods), but also badly designed (business logic for all states in single class). Also, enum implementing interface and rest of this fancy syntax may be counterintuitive for anyone who didn’t passed SCJP exam in last 2 weeks. Instead, we will provide some simple level of indirection, because "<span style="font-style: italic;">Any problem in computer science can be solved with another layer of indirection</span>" <a href="http://en.wikipedia.org/wiki/David_Wheeler_%28computer_scientist%29">[*]</a>:<br /><br /><pre name="code" class="java">public enum ReservationStatus implements ReservationStatusOperations {<br /><br /><br /><br />  NEW(new NewRso()),<br /><br />  ACCEPTED(new AcceptedRso()),<br /><br />  PAID(new PaidRso()),<br /><br />  CANCELLED(new CancelledRso());<br /><br /><br /><br />  private final ReservationStatusOperations operations;<br /><br /><br /><br />  ReservationStatus(ReservationStatusOperations operations) {<br /><br />     this.operations = operations;<br /><br />  }<br /><br /><br /><br />  @Override<br /><br />  public ReservationStatus accept(Reservation reservation) {<br /><br />     return operations.accept(reservation);<br /><br />  }<br /><br /><br /><br />  @Override<br /><br />  public ReservationStatus charge(Reservation reservation) {<br /><br />     return operations.charge(reservation);<br /><br />  }<br /><br /><br /><br />  @Override<br /><br />  public ReservationStatus cancel(Reservation reservation) {<br /><br />     return operations.cancel(reservation);<br /><br />  }<br /><br />}</pre><br /><br />This is the final source code for our <span style="font-family:courier new;">ReservationStatus </span>enum (implementing <span style="font-family:courier new;">ReservationStatusOperations </span>is not necessary). To put things simple: each enum value has its own distinct implementation of <span style="font-family:courier new;">ReservationStatusOperations </span>(<span style="font-family:courier new;">Rso </span>for short); this implementation is passed as a constructor argument and assigned to final field <span style="font-family:courier new;">operations</span>. Now, whenever business method is called on enum, it will be delegated to <span style="font-family:courier new;">ReservationStatusOperations </span>implementation dedicated to this enum:<br /><br /><pre name="code" class="java">ReservationStatus.NEW.accept(reservation);        //will call NewRso.accept()<br /><br />ReservationStatus.ACCEPTED.accept(reservation);        //will call AcceptedRso.accept()</pre><br /><br />The last piece of the puzzle is <span style="font-family:courier new;">Reservation </span>domain object including business methods:<br /><br /><pre name="code" class="java">public void accept() {<br /><br />  setStatus(status.accept(this));<br /><br />}<br /><br /><br /><br />public void charge() {<br /><br />  setStatus(status.charge(this));<br /><br />}<br /><br /><br /><br />public void cancel() {<br /><br />  setStatus(status.cancel(this));<br /><br />}<br /><br /><br /><br />public void setStatus(ReservationStatus status) {<br /><br />  if (status != null &amp;&amp; status != this.status) {<br /><br />     log.debug("Reservation#" + id + ": changing status from " + this.status + " to " + status);<br /><br />     this.status = status;<br /><br />  }<br /><br /></pre><br /><br />What happens here? When you call any business method on <span style="font-family:courier new;">Reservation </span>domain object instance, corresponding method is being called on <span style="font-family:courier new;">ReservationStatus </span>enum value. Depending on current status, different method (of different <span style="font-family:courier new;">ReservationStatusOperations</span> implementation) will be called. But there is no <span style="font-family:courier new;">switch-case</span> or <span style="font-family:courier new;">if-else</span> construct, only pure polymorphism. For example if you call <span style="font-family:courier new;">charge() </span>when status field points to <span style="font-family:courier new;">ReservationStatus.ACCEPTED</span>, <span style="font-family:courier new;">AcceptedRso.charge()</span> is being called, the customer who made the reservation will be charged and reservation status changes to <span style="font-family:courier new;">PAID</span>. But what happens if we call <span style="font-family:courier new;">charge()</span> again on the same instance? <span style="font-family:courier new;">status </span>field now points to <span style="font-family:courier new;">ReservationStatus.PAID</span>, so <span style="font-family:courier new;">PaidRso.charge()</span> will be executed, which throws exception (charging already paid reservation is invalid). With no conditional code, we implemented state-aware domain object with business methods included in the object itself.<br /><br />One thing I haven’t mentioned yet is how to change the status from business method. This is the second difference from original GoF pattern. Instead of passing <span style="font-family:courier new;">StateContext </span>instance to each state-aware operation (like <span style="font-family:courier new;">accept()</span> or <span style="font-family:courier new;">charge()</span>), which can be used to change the status, I simply return new status from business method. If the status is not <span style="font-family:courier new;">null </span>and different from the previous one (<span style="font-family:courier new;">setStatus()</span> method), reservation transits to a given status. Let’s take a look at how it works on <span style="font-family:courier new;">AcceptedRso </span>object (its methods are being executed when <span style="font-family:courier new;">Reservation </span>is in <span style="font-family:courier new;">ReservationStatus.ACCEPTED</span> status):<br /><br /><pre name="code" class="java">public class AcceptedRso implements ReservationStatusOperations {<br /><br /><br /><br />@Override<br /><br />public ReservationStatus accept(Reservation reservation) {<br /><br />   throw new UnsupportedStatusTransitionException("accept", ReservationStatus.ACCEPTED);<br /><br />}<br /><br /><br /><br />@Override<br /><br />public ReservationStatus charge(Reservation reservation) {<br /><br />   //charge client's credit card<br /><br />   //send e-mail<br /><br />   //print ticket<br /><br />   return ReservationStatus.PAID;<br /><br />}<br /><br /><br /><br />@Override<br /><br />public ReservationStatus cancel(Reservation reservation) {<br /><br />   //send cancellation e-mail<br /><br />   return ReservationStatus.CANCELLED;<br /><br />}<br /><br /><br /><br />}</pre><br /><br />Behavior of <span style="font-family:courier new;">Reservation </span>in <span style="font-family:courier new;">ACCEPTED </span>status can be easily followed by reading class above: accepting for the second time (reservation is already accepted) will throw an exception, charging will charge client’s credit card, print him a ticket and send e-mail etc. Also, charging returns <span style="font-family:courier new;">PAID </span>status, which will cause the <span style="font-family:courier new;">Reservation </span>to transit to this state. This means another call to <span style="font-family:courier new;">charge()</span> will be handled by different <span style="font-family:courier new;">ReservationStatusOperations </span>implementation (<span style="font-family:courier new;">PaidRso</span>) with no conditional code.<br /><br />This would be all about the State pattern. If you are not convinced to this design pattern, compare the amount of work and how error-prone it is with classic approach using conditional code. Also think for a while what is needed when adding new state or state-dependent operation and how easy it is to read such a code.<br /><br />I didn’t show all <span style="font-family:courier new;">ReservationStatusOperations </span>implementations, but if you would like to introduce this approach in your Spring or EJB based JEE application, you have probably saw a big lie out there. I gave comments on what should happen in each business methods, but not provided actual implementations. I didn’t, because I would come across big problem: Reservation instance is created by hand (using new) or by persistence framework like Hibernate. It uses statically created enum which creates manually <span style="font-family:courier new;">ReservationStatusOperations</span> implementations. There is no way to inject any dependencies, DAOs and services, to this classes, as their lifecycle is controlled out of the Spring or EJB container scope. Actually, there is a simple yet powerful solution, using Spring and AspectJ. But be patient, I will explain it in details in the next post soon, adding some domain-driven flavor to our application.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>