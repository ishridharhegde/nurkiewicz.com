---
layout: post
title: Advanced ListenableFuture capabilities
date: '2013-02-28T23:34:00.001+01:00'
author: Tomasz Nurkiewicz
tags:
- guava
- multithreading
- concurrency
modified_time: '2013-02-28T23:34:59.408+01:00'
thumbnail: http://3.bp.blogspot.com/-1y49PaUo0RE/US_aqvDgqgI/AAAAAAAAAvI/jCkobYKNxnw/s72-c/176491_137343262998152_2729257_o.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-6548377248676725214
blogger_orig_url: https://www.nurkiewicz.com/2013/02/advanced-listenablefuture-capabilities.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-1y49PaUo0RE/US_aqvDgqgI/AAAAAAAAAvI/jCkobYKNxnw/s1600/176491_137343262998152_2729257_o.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://3.bp.blogspot.com/-1y49PaUo0RE/US_aqvDgqgI/AAAAAAAAAvI/jCkobYKNxnw/s320/176491_137343262998152_2729257_o.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Holmenkollen district</td></tr></tbody></table>Last time we <a href="http://nurkiewicz.blogspot.no/2013/02/listenablefuture-in-guava.html">familiarized ourselves with <code>ListenableFuture</code></a>. I promised to introduced more advanced techniques, namely transformations and chaining. Let's start from something straightforward. Say we have our <code>ListenableFuture&lt;String&gt;</code> which we got from some asynchronous service. We also have a simple method:<br /><br /><pre class="brush: java">Document parse(String xml) {//...<br /></pre>We don't need <code>String</code>, we need <code>Document</code>. One way would be to simply resolve <code>Future</code> (<i>wait</i> for it) and do the processing on <code>String</code>. But much more elegant solution is to apply transformation once the results are available and treat our method as if was always returning <code>ListenableFuture&lt;Document&gt;</code>. This is pretty straightforward:<br /><br /><pre class="brush: java">final ListenableFuture&lt;String&gt; future = //...<br /><br />final ListenableFuture&lt;Document&gt; documentFuture = Futures.transform(future, new Function&lt;String, Document&gt;() {<br />    @Override<br />    public Document apply(String contents) {<br />        return parse(contents);<br />    }<br />});<br /></pre>or more readable:<br /><br /><pre class="brush: java">final Function&lt;String, Document&gt; parseFun = new Function&lt;String, Document&gt;() {<br />    @Override<br />    public Document apply(String contents) {<br />        return parse(contents);<br />    }<br />};<br /><br />final ListenableFuture&lt;String&gt; future = //...<br /><br />final ListenableFuture&lt;Document&gt; documentFuture = Futures.transform(future, parseFun);<br /></pre>Java syntax is a bit limiting, but please focus on what we just did. <code>Futures.transform()</code> doesn't wait for underlying <code>ListenableFuture&lt;String&gt;</code> to apply <code>parse()</code> transformation. Instead, under the hood, it registers a callback, wishing to be notified whenever given future finishes. This transformation is applied dynamically and transparently for us at right moment. We still have <code>Future</code>, but this time wrapping <code>Document</code>.<br /><br />So let's go one step further. We also have an asynchronous, possibly long-running method that calculates <i>relevance</i> (whatever that is in this context) of a given <code>Document</code>:<br /><br /><pre class="brush: java">ListenableFuture&lt;Double&gt; calculateRelevance(Document pageContents) {//...<br /></pre>Can we somehow chain it with <code>ListenableFuture&lt;Document&gt;</code> we already have? First attempt:<br /><a name='more'></a><br /><br /><pre class="brush: java">final Function&lt;Document, ListenableFuture&lt;Double&gt;&gt; relevanceFun = new Function&lt;Document, ListenableFuture&lt;Double&gt;&gt;() {<br />    @Override<br />    public ListenableFuture&lt;Double&gt; apply(Document input) {<br />        return calculateRelevance(input);<br />    }<br />};<br /><br />final ListenableFuture&lt;String&gt; future = //...<br />final ListenableFuture&lt;Document&gt; documentFuture = Futures.transform(future, parseFun);<br />final ListenableFuture&lt;ListenableFuture&lt;Double&gt;&gt; relevanceFuture = Futures.transform(documentFuture, relevanceFun);<br /></pre>Ouch! <i>Future of future of <code>Double</code></i>, that doesn't look good. Once we resolve outer future we need to wait for inner one as well. Definitely not elegant. Can we do better?<br /><br /><pre class="brush: java">final AsyncFunction&lt;Document, Double&gt; relevanceAsyncFun = new AsyncFunction&lt;Document, Double&gt;() {<br />    @Override<br />    public ListenableFuture&lt;Double&gt; apply(Document pageContents) throws Exception {<br />        return calculateRelevance(pageContents);<br />    }<br />};<br /><br />final ListenableFuture&lt;String&gt; future = //comes from ListeningExecutorService<br />final ListenableFuture&lt;Document&gt; documentFuture = Futures.transform(future, parseFun);<br />final ListenableFuture&lt;Double&gt; relevanceFuture = Futures.transform(documentFuture, relevanceAsyncFun);<br /></pre>Please look very carefully at all types and results. Notice the difference between <code>Function</code> and <code>AsyncFunction</code>. Initially we got an asynchronous method returning future of <code>String</code>. Later on we transformed it to seamlessly turn <code>String</code> into XML <code>Document</code>. This transformation happens asynchronously, when inner future completes. Having future of <code>Document</code> we would like to call a method that requires <code>Document</code> and returns future of <code>Double</code>.<br /><br />If we call <code>relevanceFuture.get()</code>, our <code>Future</code> object will first wait for inner task to complete and having its result (<code>String</code> -&gt; <code>Document</code>) will wait for outer task and return <code>Double</code>. We can also register callbacks on <code>relevanceFuture</code> which will fire when outer task (<code>calculateRelevance()</code>) finishes. If you are still here, the are even more crazy transformations. <br /><br />Remember that all this happens in a loop. For each web site we got <code>ListenableFuture&lt;String&gt;</code> which we asynchronously transformed to <code>ListenableFuture&lt;Double&gt;</code>. So in the end we work with a <code>List&lt;ListenableFuture&lt;Double&gt;&gt;</code>. This also means that in order to extract all the results we either have to register listener for each and every <code>ListenableFuture</code> or wait for each of them. Which doesn't progress us at all. But what if we could easily transform from <code>List&lt;ListenableFuture&lt;Double&gt;&gt;</code> to <code>ListenableFuture&lt;List&lt;Double&gt;&gt;</code>? Read carefully - from list of futures to future of list. In other words, rather than having a bunch of small futures we have one future that will complete when all child futures complete - and the results are mapped one-to-one to target list. Guess what, Guava can do this!<br /><br /><pre class="brush: java">final List&lt;ListenableFuture&lt;Double&gt;&gt; relevanceFutures = //...;<br />final ListenableFuture&lt;List&lt;Double&gt;&gt; futureOfRelevance = Futures.allAsList(relevanceFutures);<br /></pre>Of course there is no waiting here as well. Wrapper <code>ListenableFuture&lt;List&lt;Double&gt;&gt;</code> will be notified every time one of its <i>child</i> futures complete. The moment the last child <code>ListenableFuture&lt;Double&gt;</code> completes, outer future completes as well. Everything is event-driven and completely hidden from you.<br /><br />Do you think that's it? Say we would like to compute the biggest relevance in the whole set. As you probably know by now, we won't wait for a <code>List&lt;Double&gt;</code>. Instead we will register transformation from <code>List&lt;Double&gt;</code> to <code>Double</code>!<br /><br /><pre class="brush: java">final ListenableFuture&lt;Double&gt; maxRelevanceFuture = Futures.transform(futureOfRelevance, new Function&lt;List&lt;Double&gt;, Double&gt;() {<br />    @Override<br />    public Double apply(List&lt;Double&gt; relevanceList) {<br />        return Collections.max(relevanceList);<br />    }<br />});<br /></pre>Finally, we can listen for completion event of <code>maxRelevanceFuture</code> and e.g. send results (asynchronously!) using JMS. Here is a complete code if you lost track:<br /><br /><pre class="brush: java">private Document parse(String xml) {<br />    return //...<br />}<br /><br />private final Function&lt;String, Document&gt; parseFun = new Function&lt;String, Document&gt;() {<br />    @Override<br />    public Document apply(String contents) {<br />        return parse(contents);<br />    }<br />};<br /><br />private ListenableFuture&lt;Double&gt; calculateRelevance(Document pageContents) {<br />    return //...<br />}<br /><br />final AsyncFunction&lt;Document, Double&gt; relevanceAsyncFun = new AsyncFunction&lt;Document, Double&gt;() {<br />    @Override<br />    public ListenableFuture&lt;Double&gt; apply(Document pageContents) throws Exception {<br />        return calculateRelevance(pageContents);<br />    }<br />};<br /><br />//...<br /><br />final ListeningExecutorService pool = MoreExecutors.listeningDecorator(<br />    Executors.newFixedThreadPool(10)<br />);<br /><br />final List&lt;ListenableFuture&lt;Double&gt;&gt; relevanceFutures = new ArrayList&lt;&gt;(topSites.size());<br />for (final URL siteUrl : topSites) {<br />    final ListenableFuture&lt;String&gt; future = pool.submit(new Callable&lt;String&gt;() {<br />        @Override<br />        public String call() throws Exception {<br />            return IOUtils.toString(siteUrl, StandardCharsets.UTF_8);<br />        }<br />    });<br />    final ListenableFuture&lt;Document&gt; documentFuture = Futures.transform(future, parseFun);<br />    final ListenableFuture&lt;Double&gt; relevanceFuture = Futures.transform(documentFuture, relevanceAsyncFun);<br />    relevanceFutures.add(relevanceFuture);<br />}<br /><br />final ListenableFuture&lt;List&lt;Double&gt;&gt; futureOfRelevance = Futures.allAsList(relevanceFutures);<br />final ListenableFuture&lt;Double&gt; maxRelevanceFuture = Futures.transform(futureOfRelevance, new Function&lt;List&lt;Double&gt;, Double&gt;() {<br />    @Override<br />    public Double apply(List&lt;Double&gt; relevanceList) {<br />        return Collections.max(relevanceList);<br />    }<br />});<br /><br />Futures.addCallback(maxRelevanceFuture, new FutureCallback&lt;Double&gt;() {<br />    @Override<br />    public void onSuccess(Double result) {<br />        log.debug("Result: {}", result);<br />    }<br /><br />    @Override<br />    public void onFailure(Throwable t) {<br />        log.error("Error :-(", t);<br />    }<br />});<br /></pre>Was it worth it? <i>Yes</i> and <i>no</i>. <i>Yes</i>, because we learned some really important constructs and primitives used together with futures/promises: chaining, mapping (transforming) and reducing. The solution is beautiful in terms of CPU utilization - no waiting, blocking, etc. Remember that the biggest strength of <a href="http://nodejs.org/">Node.js</a> is its "no-blocking" policy. Also in <a href="http://netty.io/">Netty</a> futures are ubiquitous. Last but not least, it feels very <i>functional</i>.<br /><br />On the other hand, mainly due to Java syntax verbosity and lack of type inference (yes, we will jump into Scala soon) code seems very unreadable, hard to follow and maintain. Well, to some degree this holds true for all message driven systems. But as long as we don't invent better APIs and primitives, we must learn to live and take advantage of asynchronous, highly parallel computations.<br /><br />If you want to experiment with <code>ListenableFuture</code> even more, don't forget to read <a href="http://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained">official documentation</a>.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>