---
layout: post
title: flatMap() and the order of events - RxJava FAQ
date: '2017-08-07T08:00:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- rxjava
modified_time: '2017-08-07T21:31:41.955+02:00'
thumbnail: https://3.bp.blogspot.com/-uEENp3eKFZs/WYgUqxeEmFI/AAAAAAAAD-Y/B56upr5_PR4ddeGDyyrqByEAB_aMnEaNgCLcBGAs/s72-c/2016-04-20%2B17.13.54.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5460042165663230766
blogger_orig_url: https://www.nurkiewicz.com/2017/08/flatmap-and-order-of-events-rxjava-faq.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-uEENp3eKFZs/WYgUqxeEmFI/AAAAAAAAD-Y/B56upr5_PR4ddeGDyyrqByEAB_aMnEaNgCLcBGAs/s1600/2016-04-20%2B17.13.54.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="900" data-original-width="1600" height="112" src="https://3.bp.blogspot.com/-uEENp3eKFZs/WYgUqxeEmFI/AAAAAAAAD-Y/B56upr5_PR4ddeGDyyrqByEAB_aMnEaNgCLcBGAs/s200/2016-04-20%2B17.13.54.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Parc de la Tête d'Or, Lyon</td></tr></tbody></table>As we already discovered, <code>flatMap()</code> does not preserve the order of original stream. Let's illustrate this using the <a href="http://www.geonames.org/export/web-services.html">GeoNames API</a> example <a href="http://www.nurkiewicz.com/2017/08/flatmap-vs-concatmap-vs-concatmapeager.html">from previous article</a>: <br /><pre class="brush: java">public interface GeoNames {<br /><br />    Flowable&lt;Long&gt; populationOf(String city);<br /><br />}</pre>By requesting population of multiple cities using <code>flatMap()</code> we have no guarantee that they will arrive in order:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; cities = Flowable.just("Warsaw", "Paris", "London", "Madrid");<br /><br />cities<br />        .flatMap(geoNames::populationOf)<br />        .subscribe(response -&gt; log.info("Population: {}", response));</pre>The output is somewhat surprising:<br /><br /><pre class="brush: java">17:09:49.838 | Rx-3 | --&gt; GET .../searchJSON?q=London http/1.1<br />17:09:49.838 | Rx-1 | --&gt; GET .../searchJSON?q=Warsaw http/1.1<br />17:09:49.838 | Rx-4 | --&gt; GET .../searchJSON?q=Madrid http/1.1<br />17:09:49.838 | Rx-2 | --&gt; GET .../searchJSON?q=Paris http/1.1<br />17:09:49.939 | Rx-4 | &lt;-- 200 OK .../searchJSON?q=Madrid (98ms)<br />17:09:49.939 | Rx-3 | &lt;-- 200 OK .../searchJSON?q=London (98ms)<br />17:09:49.956 | Rx-3 | Population: 7556900<br />17:09:49.958 | Rx-3 | Population: 3255944<br />17:09:51.099 | Rx-2 | &lt;-- 200 OK .../searchJSON?q=Paris (1258ms)<br />17:09:51.100 | Rx-1 | &lt;-- 200 OK .../searchJSON?q=Warsaw (1259ms)<br />17:09:51.100 | Rx-2 | Population: 2138551<br />17:09:51.100 | Rx-2 | Population: 1702139</pre>After some time we receive response for Madrid followed by London which are later received by subscriber. 7556900 (population of London) and 3255944 (Madrid) come first After a while Paris and Warsaw arrive as well. On one hand it's good that we can proceed with each population immediately when it arrives. This makes the system seem like more responsive. But we lost something. The input stream was <code>"Warsaw"</code>, <code>"Paris"</code>, <code>"London"</code>, <code>"Madrid"</code> whereas the resulting stream contains population of <code>"London"</code>, <code>"Madrid"</code>, <code>"Paris"</code>, <code>"Warsaw"</code>. How can we tell which number represents which city?<br /><br />Obviously the following solution is <em>plain wrong</em>, yet it's not unheard of in real code bases:<br /><br /><pre class="brush: java">Flowable&lt;Long&gt; populations = cities.flatMap(geoNames::populationOf);<br />cities<br />        .zipWith(populations, Pair::of)<br />        .subscribe(response -&gt; log.info("Population: {}", response));</pre>It compiles, it runs, it even produces some results. Unfortunately these results are entirely wrong:<br /><br /><pre class="brush: java">17:20:03.778 | Rx-2 | --&gt; GET .../searchJSON?q=Paris http/1.1<br />17:20:03.778 | Rx-3 | --&gt; GET .../searchJSON?q=London http/1.1<br />17:20:03.778 | Rx-4 | --&gt; GET .../searchJSON?q=Madrid http/1.1<br />17:20:03.778 | Rx-1 | --&gt; GET .../searchJSON?q=Warsaw http/1.1<br />17:20:03.953 | Rx-4 | &lt;-- 200 OK .../searchJSON?q=Madrid (172ms)<br />17:20:03.959 | Rx-2 | &lt;-- 200 OK .../searchJSON?q=Paris (179ms)<br />17:20:03.975 | Rx-2 | Population: (Warsaw,2138551)<br />17:20:03.976 | Rx-2 | Population: (Paris,3255944)<br />17:20:03.988 | Rx-3 | &lt;-- 200 OK .../searchJSON?q=London (207ms)<br />17:20:03.988 | Rx-3 | Population: (London,7556900)<br />17:20:04.080 | Rx-1 | &lt;-- 200 OK .../searchJSON?q=Warsaw (299ms)<br />17:20:04.080 | Rx-1 | Population: (Madrid,1702139)</pre>We combine cities with some random permutation of their population's. To make matters worse I managed to get wrong results after maybe dozen attempts. For some reason this program was <em>working on my machine</em> most of the time. Worst kind of bug you can imagine.<br /><br />The problem with <code>flatMap()</code> is that it looses the original request. Imagine an asynchronous system where you receive a response on some sort of queue but have no idea what the request was. An obvious solution is to somehow attach some sort of correlation ID or even the whole request to the response. Unfortunately <code>populationOf(String city)</code> doesn't return the original request (<code>city</code>), only response (<code>population</code>). It would be so much easier if it returned something like <code>CityWithPopulation</code> value object or even <code>Pair&lt;String, Long&gt;</code>. So now imagine we are enhancing the original method by attaching the request (<code>city</code>):<br /><br /><pre class="brush: java">Flowable&lt;Pair&lt;String, Long&gt;&gt; populationOfCity(String city) {<br />    Flowable&lt;Long&gt; population = geoNames.populationOf(city);<br />    return population.map(p -&gt; Pair.of(city, p));<br />}</pre>We can now take advantage of this method for larger stream of cities:<br /><br /><pre class="brush: java">cities<br />        .flatMap(this::populationOfCity)<br />        .subscribe(response -&gt; log.info("Population: {}", response));</pre>...or to avoid extra helper method:<br /><br /><pre class="brush: java">    cities<br />            .flatMap(city -&gt; geoNames<br />                    .populationOf(city)<br />                    .map(p -&gt; Pair.of(city, p))<br />            )<br />            .subscribe(response -&gt; log.info("Population: {}", response));</pre>The <code>result</code> variable this time is <code>Pair&lt;String, Long&gt;</code> but you are encouraged to use more expressive value object.<br /><br /><pre class="brush: java">17:20:03.778 | Rx-2 | --&gt; GET .../searchJSON?q=Paris http/1.1<br />17:20:03.778 | Rx-3 | --&gt; GET .../searchJSON?q=London http/1.1<br />17:20:03.778 | Rx-4 | --&gt; GET .../searchJSON?q=Madrid http/1.1<br />17:20:03.778 | Rx-1 | --&gt; GET .../searchJSON?q=Warsaw http/1.1<br />17:20:03.953 | Rx-4 | &lt;-- 200 OK .../searchJSON?q=Madrid (172ms)<br />17:20:03.959 | Rx-2 | &lt;-- 200 OK .../searchJSON?q=Paris (179ms)<br />17:20:03.975 | Rx-2 | Population: (Paris,2138551)<br />17:20:03.976 | Rx-2 | Population: (Madrid,3255944)<br />17:20:03.988 | Rx-3 | &lt;-- 200 OK .../searchJSON?q=London (207ms)<br />17:20:03.988 | Rx-3 | Population: (London,7556900)<br />17:20:04.080 | Rx-1 | &lt;-- 200 OK .../searchJSON?q=Warsaw (299ms)<br />17:20:04.080 | Rx-1 | Population: (Warsaw,1702139)</pre>I found <code>flatMap()</code> with nested <code>map()</code> adding additional context to be the most effective way of dealing with out-of-order results. Surely it's not the most readable piece of reactive code so make sure you hide this complexity behind some facade.<br /><br /><h2 id="update">UPDATE</h2>As noted by <a href="http://akarnokd.blogspot.com/">Dávid Karnok</a> in <a href="http://www.nurkiewicz.com/2017/08/flatmap-and-order-of-events-rxjava-faq.html?showComment=1502103150049">his comment to this post</a>, the <code>map()</code> operator inside <code>flatMap()</code> is such a common idiom that a specialized <code>flatMap()</code> overload exists. Apart from standard transformation function (in our case <code>String -&gt; Flowable&lt;Long&gt;</code>) it also takes combiner bi-function (e.g. <code>(String, Long) -&gt; SomeType</code>). The purpose of this function is to provide a transformation that combines input item with each output item generated by transformation. This is precisely what we did with nested <code>map()</code> (enriching population with the name of city it corresponds to), but much shorter:<br /><br /><pre class="brush: java">Flowable&lt;Pair&lt;String, Long&gt;&gt; populations = cities<br />        .flatMap(city -&gt; geoNames.populationOf(city), (city, pop) -&gt; Pair.of(city, pop));</pre>The second lambda expression (<code>(city, pop) -&gt; Pair.of(city, pop)</code>) is executed for every downstream event produced by <code>populationOf()</code>. If you go to the extreme, you can use method references:<br /><br /><pre class="brush: java">Flowable&lt;Pair&lt;String, Long&gt;&gt; populations = cities<br />        .flatMap(geoNames::populationOf, Pair::of);</pre>Take a moment to study the last example, it's actually beautifully simple once you grasp it:<br /><br /><ul><li>for each <code>city</code> find its population <code>pop</code></li><li>for each population combine it with <code>city</code> by forming a <code>Pair&lt;String, Long&gt;</code></li></ul><br /><br />PS: This was 200th post in 9 years!<br /><script>SyntaxHighlighter.highlight();</script>