---
layout: post
title: Fixed-rate vs. fixed-delay - RxJava FAQ
date: '2017-09-07T10:48:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- scheduling
- rxjava
modified_time: '2017-09-07T10:48:17.781+02:00'
thumbnail: https://4.bp.blogspot.com/-ndD6V5Zc5xM/WavHhleSMmI/AAAAAAAAEEM/xXq9kKJh7agWnzSLv5QSN5RNZ56mc4yXwCLcBGAs/s72-c/2016-09-18%2B10.43.35.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7887793603846116373
blogger_orig_url: https://www.nurkiewicz.com/2017/09/fixed-rate-vs-fixed-delay-rxjava-faq.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://4.bp.blogspot.com/-ndD6V5Zc5xM/WavHhleSMmI/AAAAAAAAEEM/xXq9kKJh7agWnzSLv5QSN5RNZ56mc4yXwCLcBGAs/s1600/2016-09-18%2B10.43.35.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="901" data-original-width="1600" height="112" src="https://4.bp.blogspot.com/-ndD6V5Zc5xM/WavHhleSMmI/AAAAAAAAEEM/xXq9kKJh7agWnzSLv5QSN5RNZ56mc4yXwCLcBGAs/s200/2016-09-18%2B10.43.35.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Topiło lake in Białowieża Forest</td></tr></tbody></table>If you are using plain Java, since version 5 we have a handy scheduler class that allows running tasks at fixed rate or with fixed delay:<br /><br /><pre class="brush: java">import java.util.concurrent.Executors;<br />import java.util.concurrent.ScheduledExecutorService;<br /><br />ScheduledExecutorService scheduler = <br />        Executors.newScheduledThreadPool(10);</pre>Basically it supports two types of operations:<br /><br /><pre class="brush: java">scheduler.scheduleAtFixedRate(() -&gt; doStuff(), 2, 1, SECONDS);<br />scheduler.scheduleWithFixedDelay(() -&gt; doStuff(), 2, 1, SECONDS);</pre><code>scheduleAtFixedRate()</code> will make sure <code>doStuff()</code> is invoked precisely every second with an initial delay of two seconds. Of course garbage collection, context-switching, etc. still can affect the precision. <code>scheduleWithFixedDelay()</code> is seemingly similar, however it takes <code>doStuff()</code> processing time into account. For example, if <code>doStuff()</code> runs for 200ms, fixed rate will wait only 800ms until next retry. <code>scheduleWithFixedDelay()</code> on the other hand, always waits for the same amount of time (1 second in our case) between retries. Both behaviours are of course desirable under different circumstances. Only remember that when <code>doStuff()</code> is slower than 1 second <code>scheduleAtFixedRate()</code> will not preserve desired frequency. Even though our <code>ScheduledExecutorService</code> has 10 threads, <code>doStuff()</code> will never be invoked concurrently and overlap with previous execution. Therefore, in this case, the rate will actually be smaller than configured.<br /><br /><h1 id="scheduling-in-rxjava">Scheduling in RxJava</h1>Simulating <code>scheduleAtFixedRate()</code> with RxJava is very simple with <code>interval()</code> operator. With a few caveats:<br /><br /><pre class="brush: java">Flowable<br />        .interval(2, 1, SECONDS)<br />        .subscribe(i -&gt; doStuff());</pre>If <code>doStuff()</code> is slower than 1 second, bad things happen. First of all, we are using <code>Schedulers.computation()</code> thread pool, default one inherited from <code>interval()</code> operator. It's a bad idea, this thread pool should only be used for CPU-intensive tasks and is shared across whole RxJava. A better idea is to use your own scheduler (or at least <code>io()</code>):<br /><br /><pre class="brush: java">Flowable<br />        .interval(2, 1, SECONDS)<br />        .observeOn(Schedulers.io())<br />        .subscribe(i -&gt; doStuff());</pre><code>observeOn()</code> switches from <code>computation()</code> scheduler used by <code>interval()</code> to <code>io()</code> scheduler. Because <code>subscribe()</code> method is never invoked concurrently by design, <code>doStuff()</code> is never invoked concurrently, just like with <code>scheduleAtFixedRate()</code>. However, <code>interval()</code> operator tries very hard to keep the constant frequency. This means if <code>doStuff()</code> is slower than 1 second after a while we should expect <code>MissingBackpressureException</code>... RxJava basically tells us that our subscriber is too slow, but <code>interval()</code> (by design) can't slow down. If you tolerate (or even expect) overlapping concurrent executions of <code>doStuff()</code>, it's very simple to fix. First, you must wrap blocking <code>doStuff()</code> with non-blocking <code>Completable</code>. Technically,&nbsp;<code>Flowable</code> <code>Single</code> or <code>Maybe</code> would work just as well, but since <code>doStuff()</code> is <code>void</code>, <code>Completable</code> sounds fine:<br /><br /><pre class="brush: java">import io.reactivex.Completable;<br />import io.reactivex.schedulers.Schedulers;<br /><br />Completable doStuffAsync() {<br />    return Completable<br />            .fromRunnable(this::doStuff)<br />            .subscribeOn(Schedulers.io())<br />            .doOnError(e -&gt; log.error("Stuff failed", e))<br />            .onErrorComplete();<br />}</pre>It's important to catch and swallow exceptions, otherwise a single error will cause whole <code>interval()</code> to interrupt. <code>doOnError()</code> allows logging, but it passes the exception through downstream. <code>doOnComplete()</code> on the other hand, simply swallows the exception. We can now simply run this operation at each interval event:<br /><br /><pre class="brush: java">Flowable<br />        .interval(2, 1, SECONDS)<br />        .flatMapCompletable(i -&gt; doStuffAsync())<br />        .subscribe();</pre>If you don't <code>subscribe()</code> loop will never start - but that's RxJava 101. Notice that if <code>doStuffAsync()</code> takes more than one second to complete we will get overlapping, concurrent executions. There is nothing wrong with that, you just have to be aware of it. But what if what you really need is a fixed delay?<br /><br /><h1 id="fixed-delays-in-rxjava">Fixed delays in RxJava</h1>In some cases you need fixed delay: tasks should not overlap and we should keep some breathing time between executions. No matter how slow periodic task is, there should always be a constant time pause. <code>interval()</code> operator is not suitable to implement this requirement. However if turns out the solution in RxJava is embarrassingly simple. Think about it: you need to sleep for a while, run some task and when this task completes, repeat. Let me tell it again:<br /><br /><br /><ul><li>sleep for a while (have some sort of a <code>timer()</code>)&nbsp;</li><li>run some task and wait for it to <code>complete()</code>&nbsp;</li><li><code>repeat()</code></li></ul><br /><br />That's it!<br /><br /><pre class="brush: java">Flowable<br />        .timer(1, SECONDS)<br />        .flatMapCompletable(i -&gt; doStuffAsync())<br />        .repeat()<br />        .subscribe();</pre><code>timer()</code> operator emits a single event (<code>0</code> of type <code>Long</code>) after a second. We use this event to trigger <code>doStuffAsync()</code>. When our <em>stuff</em> is done, the whole stream completes - but we would like to repeat! Well, <code>repeat()</code> operator does just that: when it receives completion notification from upstream, it resubscribes. Resubscription basically means: wait 1 second more, fire <code>doStuffAsync()</code> - and so on.<br /><br /><script>SyntaxHighlighter.highlight();</script>