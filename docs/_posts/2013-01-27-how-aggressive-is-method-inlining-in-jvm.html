---
layout: post
title: How aggressive is method inlining in JVM?
date: '2013-01-27T22:09:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- benchmarks
- jvm
- caliper
- intellij idea
modified_time: '2013-01-27T22:12:51.788+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5611079508464021265
blogger_orig_url: https://www.nurkiewicz.com/2013/01/how-aggressive-is-method-inlining-in-jvm.html
---

<kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>M</kbd> is used in <a href="http://www.jetbrains.com/idea/webhelp/extract-method.html">IntelliJ IDEA to extract method</a>. <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>M</kbd>. It's as simple as selecting a piece of code and hitting this combination. <a href="http://help.eclipse.org/juno/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-ExtractMethod.htm">Eclipse also has it</a>. I hate long methods. To the point where this smells way too long for me:<br /><br /><pre class="brush: java">public void processOnEndOfDay(Contract c) {<br />    if (DateUtils.addDays(c.getCreated(), 7).before(new Date())) {<br />        priorityHandling(c, OUTDATED_FEE);<br />        notifyOutdated(c);<br />        log.info("Outdated: {}", c);<br />    } else {<br />        if(sendNotifications) {<br />            notifyPending(c);<br />        }<br />        log.debug("Pending {}", c);<br />    }<br />}<br /></pre>First of all it has unreadable condition. Doesn't matter how it's implemented, what it does is what matters. So let's extract it first:<br /><br /><pre class="brush: java; highlight: 2">public void processOnEndOfDay(Contract c) {<br />    if (isOutdated(c)) {<br />        priorityHandling(c, OUTDATED_FEE);<br />        notifyOutdated(c);<br />        log.info("Outdated: {}", c);<br />    } else {<br />        if(sendNotifications) {<br />            notifyPending(c);<br />        }<br />        log.debug("Pending {}", c);<br />    }<br />}<br /><br />private boolean isOutdated(Contract c) {<br />    return DateUtils.addDays(c.getCreated(), 7).before(new Date());<br />}<br /></pre>Apparently this method doesn't really belong here (<code>F6</code> - move instance method):<br /><br /><a name='more'></a><br /><br /><pre class="brush: java; highlight: 2">public void processOnEndOfDay(Contract c) {<br />    if (c.isOutdated()) {<br />        priorityHandling(c, OUTDATED_FEE);<br />        notifyOutdated(c);<br />        log.info("Outdated: {}", c);<br />    } else {<br />        if(sendNotifications) {<br />            notifyPending(c);<br />        }<br />        log.debug("Pending {}", c);<br />    }<br />}<br /></pre>Noticed the different? My IDE made <code>isOutdated()</code> an instance method of <code>Contract</code>, which sound right. But I'm still unhappy. There is too much happening in this method. One branch performs some business-related <code>priorityHandling()</code>, some system notification and logging. Other branch does conditional notification and logging. First let's move handling outdated contracts to a separate method:<br /><br /><pre class="brush: java; highlight: 3">public void processOnEndOfDay(Contract c) {<br />    if (c.isOutdated()) {<br />        handleOutdated(c);<br />    } else {<br />        if(sendNotifications) {<br />            notifyPending(c);<br />        }<br />        log.debug("Pending {}", c);<br />    }<br />}<br /><br />private void handleOutdated(Contract c) {<br />    priorityHandling(c, OUTDATED_FEE);<br />    notifyOutdated(c);<br />    log.info("Outdated: {}", c);<br />}<br /></pre>One might say it's enough, but I see striking asymmetry between branches. <code>handleOutdated()</code> is very high-level while sending <code>else</code> branch is technical. Software should be easy to read, so don't mix different levels of abstraction next to each other. Now I'm happy:<br /><br /><pre class="brush: java; highlight: 5">public void processOnEndOfDay(Contract c) {<br />    if (c.isOutdated()) {<br />        handleOutdated(c);<br />    } else {<br />        stillPending(c);<br />    }<br />}<br /><br />private void handleOutdated(Contract c) {<br />    priorityHandling(c, OUTDATED_FEE);<br />    notifyOutdated(c);<br />    log.info("Outdated: {}", c);<br />}<br /><br />private void stillPending(Contract c) {<br />    if(sendNotifications) {<br />        notifyPending(c);<br />    }<br />    log.debug("Pending {}", c);<br />}<br /></pre><hr />This example was a bit contrived but actually I wanted to prove something different. Not that often these days, but there are still developers afraid of extracting methods believing it's slower at runtime. They fail to understand that JVM is a wonderful piece of software (it will probably outlast Java the language by far) that has many truly amazing runtime optimizations built-in. First of all shorter methods are easier to reason. The flow is more obvious, scope is shorter, side effects are better visible. With long methods JVM might simply give up. Second reason is even more important:<br /><br /><h3>Method inlining</h3>If JVM discovers some small method being executed over and over, it will simply replace each invocation of that method with its body. Take this as an example:<br /><br /><pre class="brush: java">private int add4(int x1, int x2, int x3, int x4) {<br />    return add2(x1, x2) + add2(x3, x4);<br />}<br /><br />private int add2(int x1, int x2) {<br />    return x1 + x2;<br />}<br /></pre>You might be almost sure that after some time JVM will get rid of <code>add2()</code> and translate your code into:<br /><br /><pre class="brush: java">private int add4(int x1, int x2, int x3, int x4) {<br />    return x1 + x2 + x3 + x4;<br />}<br /></pre>Important remark is that it's the JVM, not the compiler. <code>javac</code> is quite conservative when producing bytecode and leaves all that work onto the JVM. This design decision turned out to be brilliant:<br /><br /><ul><li>JVM knows more about target environment, CPU, memory, architecture and can optimize more aggressively<br /><br /> </li><li>JVM can discover runtime characteristics of your code, e.g. which methods are executed most often, which virtual methods have only one implementation, etc.<br /><br /> </li><li><code>.class</code> compiled using old Java will run faster on newer JVM. It's much more likely that you'll update Java rather then recompile your source code.<br /><br /> </li></ul>Let's put all these assumptions into test. I wrote a small program with a working title "<i>Worst application of <a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">divide and conquer</a> principle ever</i>. The <code>add128()</code> takes 128 arguments (!) and calls <code>add64()</code> twice - with first and second half of arguments. <code>add64()</code> is similar, except that it calls <code>add32()</code> twice. I think you get the idea, in the end we land on <code>add2()</code> that does heavy lifting. Some numbers truncated to <a href="https://github.com/nurkiewicz/benchmarks/blob/master/src/main/java/com/blogspot/nurkiewicz/inlining/ConcreteAdder.java">spare your eyes</a>:<br /><br /><pre class="brush: java">public class ConcreteAdder {<br /><br />    public int add128(int x1, int x2, int x3, int x4, ... more ..., int x127, int x128) {<br />        return add64(x1, x2, x3, x4, ... more ..., x63, x64) +<br />                add64(x65, x66, x67, x68, ... more ..., x127, x128);<br />    }<br /><br />    private int add64(int x1, int x2, int x3, int x4, ... more ..., int x63, int x64) {<br />        return add32(x1, x2, x3, x4, ... more ..., x31, x32) +<br />                add32(x33, x34, x35, x36, ... more ..., x63, x64);<br />    }<br /><br />    private int add32(int x1, int x2, int x3, int x4, ... more ..., int x31, int x32) {<br />        return add16(x1, x2, x3, x4, ... more ..., x15, x16) +<br />                add16(x17, x18, x19, x20, ... more ..., x31, x32);<br />    }<br /><br />    private int add16(int x1, int x2, int x3, int x4, ... more ..., int x15, int x16) {<br />        return add8(x1, x2, x3, x4, x5, x6, x7, x8) + add8(x9, x10, x11, x12, x13, x14, x15, x16);<br />    }<br /><br />    private int add8(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8) {<br />        return add4(x1, x2, x3, x4) + add4(x5, x6, x7, x8);<br />    }<br /><br />    private int add4(int x1, int x2, int x3, int x4) {<br />        return add2(x1, x2) + add2(x3, x4);<br />    }<br /><br />    private int add2(int x1, int x2) {<br />        return x1 + x2;<br />    }<br /><br />}<br /></pre>It's not hard to observe that by calling <code>add128()</code> we make total of 127 method calls. A lot. For reference purposes here is a <a href="https://github.com/nurkiewicz/benchmarks/blob/master/src/main/java/com/blogspot/nurkiewicz/inlining/InlineAdder.java">straightforward implementation</a>:<br /><br /><pre class="brush: java">public class InlineAdder {<br /><br />    public int add128n(int x1, int x2, int x3, int x4, ... more ..., int x127, int x128) {<br />        return x1 + x2 + x3 + x4 + ... more ... + x127 + x128;<br />    }<br />}<br /></pre>Finally I also include an implementation that uses <code>abstract</code> methods and inheritance. 127 <a href="http://en.wikipedia.org/wiki/Virtual_function">virtual calls</a> are quite expensive. These methods require <a href="http://en.wikipedia.org/wiki/Dynamic_dispatch">dynamic dispatch</a> and thus are much more demanding as they cannot be inlined. Can't they?<br /><br /><pre class="brush: java">public abstract class Adder {<br /><br />    public abstract int add128(int x1, int x2, int x3, int x4, ... more ..., int x127, int x128);<br /><br />    public abstract int add64(int x1, int x2, int x3, int x4, ... more ..., int x63, int x64);<br /><br />    public abstract int add32(int x1, int x2, int x3, int x4, ... more ..., int x31, int x32);<br /><br />    public abstract int add16(int x1, int x2, int x3, int x4, ... more ..., int x15, int x16);<br /><br />    public abstract int add8(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8);<br /><br />    public abstract int add4(int x1, int x2, int x3, int x4);<br /><br />    public abstract int add2(int x1, int x2);<br />}<br /></pre>and an implementation:<br /><br /><pre class="brush: java">public class VirtualAdder extends Adder {<br /><br />    @Override<br />    public int add128(int x1, int x2, int x3, int x4, ... more ..., int x128) {<br />        return add64(x1, x2, x3, x4, ... more ..., x63, x64) +<br />                add64(x65, x66, x67, x68, ... more ..., x127, x128);<br />    }<br /><br />    @Override<br />    public int add64(int x1, int x2, int x3, int x4, ... more ..., int x63, int x64) {<br />        return add32(x1, x2, x3, x4, ... more ..., x31, x32) +<br />                add32(x33, x34, x35, x36, ... more ..., x63, x64);<br />    }<br /><br />    @Override<br />    public int add32(int x1, int x2, int x3, int x4, ... more ..., int x32) {<br />        return add16(x1, x2, x3, x4, ... more ..., x15, x16) +<br />                add16(x17, x18, x19, x20, ... more ..., x31, x32);<br />    }<br /><br />    @Override<br />    public int add16(int x1, int x2, int x3, int x4, ... more ..., int x16) {<br />        return add8(x1, x2, x3, x4, x5, x6, x7, x8) + add8(x9, x10, x11, x12, x13, x14, x15, x16);<br />    }<br /><br />    @Override<br />    public int add8(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8) {<br />        return add4(x1, x2, x3, x4) + add4(x5, x6, x7, x8);<br />    }<br /><br />    @Override<br />    public int add4(int x1, int x2, int x3, int x4) {<br />        return add2(x1, x2) + add2(x3, x4);<br />    }<br /><br />    @Override<br />    public int add2(int x1, int x2) {<br />        return x1 + x2;<br />    }<br /><br />}<br /></pre>Encouraged by some interesting readers input after <a href="http://nurkiewicz.blogspot.no/2013/01/cacheable-overhead-in-spring.html">my article about <code>@Cacheable</code> overhead</a> I wrote a <a href="https://github.com/nurkiewicz/benchmarks/blob/master/src/main/java/com/blogspot/nurkiewicz/inlining/InliningBenchmark.java">quick benchmark</a> to compare the overhead of over-extracted <code>ConcreteAdder</code> and <code>VirtualAdder</code> (to see virtual call overhead). Results are unexpected and a bit ambiguous. I run the same benchmark on two machines (blue and red), same software but the second one has more cores and is 64 bit:<br /><br /><span id="goog_181579822"></span><img alt="Diagram" src="https://raw.github.com/nurkiewicz/benchmarks/master/src/main/docs/img/inlining-diagram.png" /><span id="goog_181579823"></span><br /><br />Detailed environments:<br /><br /><img alt="Environments" src="https://raw.github.com/nurkiewicz/benchmarks/master/src/main/docs/img/inlining-environments.png" /><br /><br />It turns out that on a slower machine <i>A</i> JVM decided to inline everything. Not only simple <code>private</code> calls but also the virtual once. How's that possible? Well, JVM discovered that there is only one subclass of <code>Adder</code>, thus only one possible version of each <code>abstract</code> method. If, at runtime, you load another subclass (or even more subclasses), you can expect to see performance drop as inlining is no longer possible. But keeping details aside, in this benchmark <b>method calls aren't cheap, they are effectively free</b>! Method calls (with their great documentation value improving readability) exist only in your source code and bytecode. At runtime they are completely eliminated (inlined).<br /><br />I don't quite understand the second benchmark though. It looks like the faster machine <i>B</i> indeed runs the reference <code>SingleMethodCall</code> benchmark faster, but the others are slower, even compared to <i>A</i>. Perhaps it decided to postpone inlining? The difference is significant, but not really that huge. Again, just like with <a href="http://nurkiewicz.blogspot.no/2012/10/where-do-stack-traces-come-from.html">optimizing stack trace generation</a> - if you start optimizing your code by manually inlining methods and thus making them much longer and complicated, you are solving the wrong problem.<br /><br />The benchmark is available <a href="https://github.com/nurkiewicz/benchmarks">on GitHub</a>, together with <a href="https://github.com/nurkiewicz/benchmarks/blob/master/src/main/docs/inlining.md">article source</a>. I encourage you to run it on your setup. Moreover each pull request is automatically built on <a href="https://travis-ci.org/nurkiewicz/benchmarks">Travis</a>, so you can compare the results easily on the same environment.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>