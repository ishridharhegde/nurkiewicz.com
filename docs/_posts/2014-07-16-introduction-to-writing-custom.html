---
layout: post
title: Introduction to writing custom collectors in Java 8
date: '2014-07-16T00:06:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
- java 8
modified_time: '2016-10-29T14:43:03.095+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-547584015613262829
blogger_orig_url: https://www.nurkiewicz.com/2014/07/introduction-to-writing-custom.html
---

Java 8 introduced the concept of collectors. Most of the time we barely use factory methods from <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html"><code>Collectors</code></a> class, e.g. <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toList--"><code>collect(toList())</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toSet--"><code>toSet()</code></a> or maybe something more fancy like <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#counting--"><code>counting()</code></a> or <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-"><code>groupingBy()</code></a>. Not many of us actually bother to look how collectors are defined and implemented. Let's start from analysing what <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html"><code>Collector&lt;T, A, R&gt;</code></a> really is and how it works.<br /><br /><code>Collector&lt;T, A, R&gt;</code> works as a "<i>sink</i>" for streams - stream pushes items (one after another) into a collector, which should produce some "<i>collected</i>" value in the end. Most of the time it means building a collection (like <code>toList()</code>) by accumulating elements or reducing stream into something smaller (e.g. <code>counting()</code> collector that barely counts elements). Every collector accepts items of type <code>T</code> and produces aggregated (accumulated) value of type <code>R</code> (e.g. <code>R = List&lt;T&gt;</code>). Generic type <code>A</code> simply defines the type of intermediate mutable data structure that we are going to use to accumulate items of type <code>T</code> in the meantime. Type <code>A</code> can, but doesn't have to be the same as <code>R</code> - in simple words the mutable data structure that we use to collect items from input <code>Stream&lt;T&gt;</code> can be different than the actual output collection/value. That being said, every collector must implement the following methods:<br /><br /><pre class="brush: java">interface Collector&lt;T,A,R&gt; {<br />    Supplier&lt;A&gt;          supplier()<br />    BiConsumer&lt;A,T&gt;      acumulator() <br />    BinaryOperator&lt;A&gt;    combiner() <br />    Function&lt;A,R&gt;        finisher()<br />    Set&lt;Characteristics&gt; characteristics()<br />} <br /></pre><ul><li><code>supplier()</code> returns a function that creates an instance of accumulator - mutable data structure that we will use to accumulate input elements of type <code>T</code>.</li><li><code>accumulator()</code> returns a function that will take accumulator and one item of type <code>T</code>, mutating accumulator. </li><li><code>combiner()</code> is used to join two accumulators together into one. It is used when collector is executed in parallel, splitting input <code>Stream&lt;T&gt;</code> and collecting parts independently first. </li><li><code>finisher()</code> takes an accumulator <code>A</code> and turns it into a result value, e.g. collection, of type <code>R</code>. All of this sounds quite abstract, so let's do a simple example. </li></ul>Obviously Java 8 doesn't provide a built-in collector for <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableSet.html"><code>ImmutableSet&lt;T&gt;</code></a> from Guava. However creating one is very simple. Remember that in order to iteratively build <code>ImmutableSet</code> we use <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableSet.Builder.html"><code>ImmutableSet.Builder&lt;T&gt;</code></a> - this is going to be our accumulator.<br /><br /><pre class="brush: java">import com.google.common.collect.ImmutableSet;<br /><br />public class ImmutableSetCollector&lt;T&gt; <br />        implements Collector&lt;T, ImmutableSet.Builder&lt;T&gt;, ImmutableSet&lt;T&gt;&gt; {<br />    @Override<br />    public Supplier&lt;ImmutableSet.Builder&lt;T&gt;&gt; supplier() {<br />        return ImmutableSet::builder;<br />    }<br /><br />    @Override<br />    public BiConsumer&lt;ImmutableSet.Builder&lt;T&gt;, T&gt; accumulator() {<br />        return (builder, t) -&gt; builder.add(t);<br />    }<br /><br />    @Override<br />    public BinaryOperator&lt;ImmutableSet.Builder&lt;T&gt;&gt; combiner() {<br />        return (left, right) -&gt; {<br />            left.addAll(right.build());<br />            return left;<br />        };<br />    }<br /><br />    @Override<br />    public Function&lt;ImmutableSet.Builder&lt;T&gt;, ImmutableSet&lt;T&gt;&gt; finisher() {<br />        return ImmutableSet.Builder::build;<br />    }<br /><br />    @Override<br />    public Set&lt;Characteristics&gt; characteristics() {<br />        return EnumSet.of(Characteristics.UNORDERED);<br />    }<br />}<br /></pre>First of all look carefully at generic types. Our <code>ImmutableSetCollector</code> takes input elements of type <code>T</code>, so it works for any <code>Stream&lt;T&gt;</code>. In the end it will produce <code>ImmutableSet&lt;T&gt;</code> - as expected. <code>ImmutableSet.Builder&lt;T&gt;</code> is going to be our intermediate data structure. <br /><br /><ul><li><code>supplier()</code> returns a function that creates new <code>ImmutableSet.Builder&lt;T&gt;</code>. If you are not that familiar with lambdas in Java 8, <code>ImmutableSet::builder</code> is a shorthand for <code>() -&gt; ImmutableSet.builder()</code>. </li><li><code>accumulator()</code> returns a function that takes <code>builder</code> and one element of type <code>T</code>. It simply adds said element to the builder.</li><li><code>combiner()</code> returns a function that will accept two builders and turn them into one by adding all elements from one of them into the other - and returning the latter. Finally <code>finisher()</code> returns a function that will turn <code>ImmutableSet.Builder&lt;T&gt;</code> into <code>ImmutableSet&lt;T&gt;</code>. Again this is a shorthand syntax for: <code>builder -&gt; builder.build()</code>. </li><li>Last but not least, <code>characteristics()</code> informs JDK what capabilities our collector has. For example if <code>ImmutableSet.Builder&lt;T&gt;</code> was thread-safe (it isn't), we could say <code>Characteristics.CONCURRENT</code> as well.</li></ul>We can now use our custom collector everywhere using <code>collect()</code>: <br /><br /><pre class="brush: java">final ImmutableSet&lt;Integer&gt; set = Arrays<br />        .asList(1, 2, 3, 4)<br />        .stream()<br />        .collect(new ImmutableSetCollector&lt;&gt;());<br /></pre>However creating new instance is slightly verbose so I suggest creating static factory method, similar to what JDK does:<br /><br /><pre class="brush: java">public class ImmutableSetCollector&lt;T&gt; implements Collector&lt;T, ImmutableSet.Builder&lt;T&gt;, ImmutableSet&lt;T&gt;&gt; {<br /><br />    //...<br /><br />    public static &lt;T&gt; Collector&lt;T, ?, ImmutableSet&lt;T&gt;&gt; toImmutableSet() {<br />        return new ImmutableSetCollector&lt;&gt;();<br />    }<br />}<br /></pre>From now on we can take full advantage of our custom collector by simply typing: <code>collect(toImmutableSet())</code>. In the second part we will learn how to write more complex and useful collectors.<br /><br />Check out the second part of this article: <a href="http://www.nurkiewicz.com/2014/07/grouping-sampling-and-batching-custom.html">Grouping, sampling and batching - custom collectors in Java 8</a>. <br /><br /><h2>Update</h2><a href="https://twitter.com/akarazniewicz">@akarazniewicz</a> <a href="https://twitter.com/akarazniewicz/status/489288579882180608">pointed out</a> that collectors are just verbose implementation of folding. With my <a href="http://www.nurkiewicz.com/2012/04/secret-powers-of-foldleft-in-scala.html">love</a> and <a href="http://www.nurkiewicz.com/2014/06/optionfold-considered-unreadable.html">hate</a> relationship with folds, I have to comment on that. Collectors in Java 8 are basically object-oriented encapsulation of the most complex type of fold found in Scala, namely <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.GenTraversableOnce"><code>GenTraversableOnce.aggregate[B](z: ⇒ B)(seqop: (B, A) ⇒ B, combop: (B, B) ⇒ B): B</code></a>. <code>aggregate()</code> is like <code>fold()</code>, but requires extra <code>combop</code> to combine two accumulators (of type <code>B</code>) into one. Comparing this to collectors, parameter <code>z</code> comes from a <code>supplier()</code>, <code>seqop()</code> reduction operation is an <code>accumulator()</code> and <code>combop</code> is a <code>combiner()</code>. In pseudo-code we can write:<br /><br /><pre class="brush: java">finisher(<br />    seq.aggregate(collector.supplier())<br />        (collector.accumulator(), collector.combiner()))<br /></pre><code>GenTraversableOnce.aggregate()</code> is used when concurrent reduction is possible - just like with collectors.<br /><br /><script>SyntaxHighlighter.highlight();</script>