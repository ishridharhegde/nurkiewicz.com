---
layout: post
title: Activiti processes and executions explained
date: '2011-01-08T17:45:00.001+01:00'
author: Tomasz Nurkiewicz
tags:
- activiti
- bpmn
modified_time: '2011-11-17T19:09:04.896+01:00'
thumbnail: http://2.bp.blogspot.com/_P3ewsGQzHn0/TSiPQwaWLlI/AAAAAAAAAY8/yXtDC4XHXtc/s72-c/ForkJoin.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2472688727643024414
blogger_orig_url: https://www.nurkiewicz.com/2011/01/activiti-processes-and-executions.html
---

<div>I was interested in <a href="http://activiti.org/">Activiti</a> process engine long before it reached its first stable 5.0 version. Now, when 5.1 was released, I decided to play a bit with this framework, especially paying attention to Spring and JUnit support. But one of the first impediments encountered was the difference between process instance and execution, as well as between sub process and call activity. I am hoping after reading this article you won't encounter the same problems when starting with Activiti.</div><div><br /></div><div>As you know, even a monkey can learn a new Java framework after reading documentation, but the real fun comes when you meet the technology by studying its source code (often tracking bugs and looking for solutions). And I must admit that Activiti code-base was a pleasure to read, nicely structured and designed. For some reason it is not deployed to Alfresco's <a href="http://maven.alfresco.com/nexus/content/repositories/activiti">repository</a>, so to take full advantage of your BPMN journey, start by:</div><div><br /></div><div><pre class="brush: bash"><br />svn co http://svn.codehaus.org/activiti/activiti/tags/activiti-5.1<br />cd activiti-5.1<br />mvn install source:jar -DskipTests -Pdistro<br /></pre></div><div><br /></div><div><br /></div><div>OK, for starters take a look at this process:</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_P3ewsGQzHn0/TSiPQwaWLlI/AAAAAAAAAY8/yXtDC4XHXtc/s1600/ForkJoin.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="229" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/TSiPQwaWLlI/AAAAAAAAAY8/yXtDC4XHXtc/s640/ForkJoin.png" width="640" /></a></div><div><br /></div><div><br /></div><div><br /><a name='more'></a>As you can probably guess, <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">+</span> signs symbolize places where process splits up (<i>forks</i>) into two or more concurrent paths or <i>joins</i> concurrent paths back. All you need to know is that until every path created in <i>fork</i> activity reaches corresponding <i>join</i> activity, all the paths that reached the <i>join</i> earlier must wait for the last one to come. If you thought about <a href="http://en.wikipedia.org/wiki/Barrier_%28computer_science%29">barrier pattern</a> in thread synchronization, you got the idea. You might also wonder why forks and joins in this process are asymmetric (there is no <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Join B</span> corresponding to <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Fork B</span>). First of all, I wanted to show that the process will still work with such a flow. And actually, it won't work with obvious symmetric approach, see bug <a href="http://jira.codehaus.org/browse/ACT-482">ACT-482</a>.</div><div><br /></div><div>Never mind, let's do some coding! Activiti has excellent support for JUnit (but don't you dare calling this unit testing!) thanks to <a href="http://activiti.org/javadocs/org/activiti/engine/test/Deployment.html">@Deployment</a> annotation. But I can't imagine running processes without Spring support (also very good in Activiti), so I started directly from Spring integration test. First context file:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy"&gt;<br />    &lt;property name="targetDataSource"&gt;<br />        &lt;bean class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;<br />            &lt;property name="driverClassName" value="org.h2.Driver" /&gt;<br />            &lt;property name="url" value="jdbc:h2:~/workspace/h2/activiti;DB_CLOSE_ON_EXIT=FALSE;TRACE_LEVEL_FILE=4" /&gt;<br />            &lt;property name="username" value="sa" /&gt;<br />            &lt;property name="password" value="" /&gt;<br />        &lt;/bean&gt;<br />    &lt;/property&gt;<br />&lt;/bean&gt;<br /><br />&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;<br />    &lt;property name="dataSource" ref="dataSource" /&gt;<br />&lt;/bean&gt;<br /><br />&lt;!-- Workaround to http://jira.codehaus.org/browse/ACT-473 --&gt;<br />&lt;bean id="initProcessEngines" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;<br />    &lt;property name="staticMethod" value="org.activiti.engine.ProcessEngines.init"/&gt;<br />&lt;/bean&gt;<br />&lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean" depends-on="initProcessEngines"&gt;<br />    &lt;property name="processEngineConfiguration"&gt;<br />        &lt;bean class="org.activiti.spring.SpringProcessEngineConfiguration"&gt;<br />            &lt;property name="databaseType" value="h2" /&gt;<br />            &lt;property name="dataSource" ref="dataSource" /&gt;<br />            &lt;property name="transactionManager" ref="transactionManager" /&gt;<br />            &lt;property name="databaseSchemaUpdate" value="none" /&gt;<br />            &lt;property name="jobExecutorActivate" value="false" /&gt;<br />            &lt;property name="deploymentResources" value="classpath*:/com/blogspot/nurkiewicz/tryipad2/bpmn20/*.bpmn20.xml" /&gt;<br />        &lt;/bean&gt;<br />    &lt;/property&gt;<br />&lt;/bean&gt;<br /><br /></pre></div><div><br /></div><div>For unit testing you should rather use in-memory database and set <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">databaseSchemaUpdate</span> to <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">create</span>; fortunately H2 works perfectly as in-memory, standalone and TCP-enabled server. Also it's the default database for Activiti and Grails projects is moving <a href="http://www.grails.org/Roadmap">onto it</a>. So what are you waiting for?  </div><div><br /></div><div>The configuration is anything but complicated, just creating <a href="http://activiti.org/javadocs/org/activiti/engine/ProcessEngine.html">ProcessEngine</a> instance using factory bean. This is the central engine class, exposing several convenient services to the user. To make access to them easier, add the following beans as well:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" /&gt;<br />&lt;bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService" /&gt;<br />&lt;bean id="taskService" factory-bean="processEngine" factory-method="getTaskService" /&gt;<br />&lt;bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService" /&gt;<br />&lt;bean id="managementService" factory-bean="processEngine" factory-method="getManagementService" /&gt;<br /></pre></div><div><br /></div><div>Did you noticed <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">deploymentResources</span> attribute of factory bean? It instruct process engine to search given directory and automatically open, parse and deploy processes found there. Unfortunately Activiti can't handle PNG process diagrams, but it speaks <a href="http://www.bpmn.org/">BPMN 2.0</a> natively. Here is the same process in this language:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;process name="ForkJoin" id="ForkJoin" isExecutable="false"&gt;<br />    &lt;startEvent id="Start" name="Start"/&gt;<br />    &lt;userTask id="Task_0" name="Task 0"/&gt;<br />    &lt;parallelGateway gatewayDirection="Diverging" id="Fork_AB" name="Fork AB"/&gt;<br />    &lt;userTask id="Task_A" name="Task A"/&gt;<br />    &lt;userTask id="Task_B" name="Task B"/&gt;<br />    &lt;parallelGateway gatewayDirection="Diverging" id="Fork_B" name="Fork B"/&gt;<br />    &lt;userTask id="Task_B1" name="Task B1"/&gt;<br />    &lt;parallelGateway gatewayDirection="Converging" id="Join_B" name="Join B"/&gt;<br />    &lt;userTask id="Task_B2" name="Task B2"/&gt;<br />    &lt;parallelGateway gatewayDirection="Converging" id="Join_AB" name="Join AB"/&gt;<br />    &lt;userTask id="Task_C" name="Task C"/&gt;<br />    &lt;endEvent id="End" name="End"/&gt;<br /><br />    &lt;sequenceFlow id="Flow_2" name="" sourceRef="Fork_AB" targetRef="Task_A" /&gt;<br />    &lt;sequenceFlow id="Flow_5" name="" sourceRef="Fork_AB" targetRef="Task_B" /&gt;<br />    &lt;sequenceFlow id="Flow_7" name="" sourceRef="Task_B" targetRef="Fork_B" /&gt;<br />    &lt;sequenceFlow id="Flow_0" name="" sourceRef="Fork_B" targetRef="Task_B1" /&gt;<br />    &lt;sequenceFlow id="Flow_1" name="" sourceRef="Fork_B" targetRef="Task_B2" /&gt;<br />    &lt;sequenceFlow id="Flow_11" name="" sourceRef="Task_B1" targetRef="Join_AB" /&gt;<br />    &lt;sequenceFlow id="Flow_10" name="" sourceRef="Task_B2" targetRef="Join_AB" /&gt;<br />    &lt;sequenceFlow id="Flow_4" name="" sourceRef="Task_A" targetRef="Join_AB" /&gt;<br />    &lt;sequenceFlow id="Flow_8" name="" sourceRef="Join_AB" targetRef="Task_C" /&gt;<br />    &lt;sequenceFlow id="Flow_12" name="" sourceRef="Task_C" targetRef="End" /&gt;<br />    &lt;sequenceFlow id="Flow_9" name="" sourceRef="Start" targetRef="Task_0" /&gt;<br />    &lt;sequenceFlow id="Flow_6" name="" sourceRef="Task_0" targetRef="Fork_AB" /&gt;<br />&lt;/process&gt;<br /></pre></div><div><br /></div><div>Maybe it's not that kind of format you'd love, but on the other hand I won't insult your intelligence explaining it. It becomes even more obvious when compared with process diagram above. By the way keep this diagram and BPMN description open on your second display (I bet you have it!), it will be easier to follow the test case.</div><div><br /></div><div><pre class="brush: java"><br />import static org.fest.assertions.Assertions.assertThat;<br />import org.activiti.engine.RuntimeService;<br />import org.activiti.engine.runtime.ProcessInstance;<br /><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = "classpath:/com/blogspot/nurkiewicz/tryipad2/activiti/ActivitiTestCase-context.xml")<br />public class ForkJoinTest {<br /><br />    @Resource<br />    private RuntimeService runtimeService;<br /><br />    @Test<br />    public void shouldRunConcurrently() throws Exception {<br />        final ProcessInstance process = runtimeService.startProcessInstanceByKey("ForkJoin");<br />        final String pid = process.getId();<br />        //...<br />    }<br />}<br /></pre></div><div><br /></div><div>Using <a href="http://activiti.org/javadocs/org/activiti/engine/RuntimeService.html">RuntimeService</a>, one of the services provided by <a href="http://activiti.org/javadocs/org/activiti/engine/ProcessEngine.html">ProcessEngine</a>, we start new <i><b>process instance</b></i>. You can use either process key (name) or process id. The latter allows you to specify exact process definition version, while using process key will always result in starting the latest version. Yes, Activiti supports seamless process versioning. And yes, it's similarities to <a href="http://www.jboss.org/jbpm">jBPM</a> are almost to evident – but that's not a <a href="http://processdevelopments.blogspot.com/2010/05/alfresco-creates-activiti.html">secret</a>.</div><div><br /></div><div>Now when our process is started, we might manipulate it and perform some assertions. And remember: the process was not only created, but it <i>started</i><span style="font-style: normal;">. This means that calling <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">startProcessInstanceByKey()</span> is blocking and it will return only when process engine has nothing more to do (for instance, it reached user task which requires user interaction). This is the case in our project, the first activity after start is user <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task 0</span>:</span></div><div><br /></div><div><pre class="brush: java"><br />log.debug("Waiting in Task 0");<br />assertThat(runtimeService.getActiveActivityIds(pid)).containsOnly("Task_0");<br /><br /></pre></div><div><br /></div><div><span style="font-style: normal;">Now Activiti waits for user confirmation (this might be a particular user, group or anyone) to proceed further. But before doing so, let's go one step back. We have created one process instance, and every process instance </span><i>is</i><span style="font-style: normal;"> some type of </span><i><b>execution</b></i><span style="font-style: normal;">. This terminology will be extremely important when we </span><span style="font-style: normal;">go</span><span style="font-style: normal;"> into Activiti querying API:</span></div><div><br /></div><div><pre class="brush: java"><br />//only one execution<br />assertThat(<br />        runtimeService<br />                .createExecutionQuery()<br />                .processInstanceId(pid)<br />                .list()<br />).hasSize(1);<br /><br /></pre></div><div><br /></div><div>We were looking here for all <i><span style="font-weight: normal;">executions</span></i> belonging to <i><span style="font-weight: normal;">process</span></i> with given id. Now when we are sure that there is only one execution (it is the process itself), we should quickly move forward:</div><div><br /></div><div><pre class="brush: java"><br />log.debug("Signaling advances to Task A and B concurrently");<br />runtimeService.signal(pid);<br />assertThat(runtimeService.getActiveActivityIds(pid)).containsOnly("Task_A", "Task_B");<br /><br />//three execution<br />assertThat(<br />        runtimeService<br />                .createExecutionQuery()<br />                .processInstanceId(pid)<br />                .list()<br />).hasSize(3);<br /><br /></pre></div><div><br /></div><div><span style="font-style: normal;">Are you looking at the process graph on the second display like I </span><span style="font-style: normal;">told you to do</span><span style="font-style: normal;">? After signalling the process it moved forward to Task A </span><span style="font-style: normal;"><b>and</b></span><span style="font-style: normal;"> Task B. And, same as with <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task 0</span>, it waits for our interactions. </span><span style="font-style: normal;">But also notice, that we already have three executions! Two executions are representing two concurrent paths (nomen est omen!) of execution, while the remaining third execution is the process itself. And the process waits until <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Join AB</span> is reached to get the control back.</span></div><div><br /></div><div><span style="font-style: normal;">So let's push <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task A</span> further. By the way don't get the false impression that process engine is only about stopping and waiting for being pushed </span><span style="font-style: normal;">manually</span><span style="font-style: normal;"> – it's just silly </span><i>hello </i><i>forked </i><i>world</i><span style="font-style: normal;"> </span><span style="font-style: normal;">example</span><span style="font-style: normal;">, we'll dive deeper into more comprehensive example</span><span style="font-style: normal;">s</span><span style="font-style: normal;"> later. Now we must learn the basics. Wh</span><span style="font-style: normal;">ere</span><span style="font-style: normal;"> was I?</span></div><div><br /></div><div><pre class="brush: java"><br />final Execution forkA = runtimeService<br />        .createExecutionQuery()<br />        .activityId("Task_A")<br />        .processInstanceId(pid)<br />        .singleResult();<br />log.debug("Found forked execution {} in Task A activity for process {}", forkA, pid);<br /><br />runtimeService.signal(forkA.getId());<br />log.debug("Advanced fork A, waiting in Join AB");<br />assertThat(runtimeService.getActiveActivityIds(pid)).containsOnly("Task_B");<br /><br />//no active activities in fork A since waiting in join<br />assertThat(runtimeService.getActiveActivityIds(forkA.getId())).isEmpty();<br /><br /></pre></div><div><br /></div><div><span style="font-style: normal;">Lots of exciting things happen here (unless, which I can hardly believe, you don't find Java BPMN process engine in action exciting). First we found (via Activiti <a href="http://activiti.org/javadocs/org/activiti/engine/runtime/ExecutionQuery.html">ExecutionQuery</a>) exactly one execution that belongs to given process and waits in activity Task A. Then we pushed it further as previously. But what about active activities? Seems like execution representing <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task A</span> doesn't have any (?), while the whole process has only one (<span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task B</span>) active activity available. How come? The </span><span style="font-style: normal;">J</span><span style="font-style: normal;">avadocs state precisely, that executions becomes inactive (i.e. it has no active activity) when one of the following occurs:</span></div><div><br /></div><ul><ul><li><div>an   execution enters a nested scope</div></li></ul></ul><ul><ul><li><div>an   execution is split up into multiple concurrent executions, then the   <b>parent is made inactive</b>.</div></li></ul></ul><ul><ul><li><div>an   execution has <b>arrived in a parallel gateway</b> or join and that   join has not yet activated/fired.</div></li></ul></ul><ul><ul><li><div>an   execution is ended.</div></li></ul></ul><div><br /></div><div>Because the execution after leaving <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task A</span> activity reached <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Join AB</span> as first out of three parties, it waits for the remaining two, making its execution inactive. The main process execution is inactive as well, waiting for <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Join AB</span>. Understanding this behaviour is essential when it comes to testing parallel process executions. If you aren't convinced, look at Activiti logs:</div><div><br /></div><div><br /></div><div><pre class="brush: plain"><br />Leaving activity 'Task_A'<br />ConcurrentExecution[12256734] takes transition (Task_A)--Flow_4--&gt;(Join_AB)<br />ConcurrentExecution[12256734] executes Activity(Join_AB): org.activiti.engine.impl.bpmn.ParallelGatewayActivity<br />parallel gateway 'Join_AB' does not activate: 1 of 3 joined<br /><br /></pre></div><div><br /></div><div>Let us make branch A wait no more and advance branch B the same way we already exercised. Look at the process graph and think for a while, how many executions will exist then? How many of them are active? And which activities are active?</div><div><br /></div><div><pre class="brush: java"><br />final Execution forkB = runtimeService.createExecutionQuery()<br />        .activityId("Task_B")<br />        .processInstanceId(pid)<br />        .singleResult();<br />log.debug("Found forked execution {} in Task B activity for process {}", forkB, pid);<br /><br />runtimeService.signal(forkB.getId());<br />log.debug("Advanced fork B, waiting in concurrent activities B1 and B2");<br /><br />assertThat(runtimeService.getActiveActivityIds(pid)).containsOnly("Task_B1", "Task_B2");<br /><br /></pre></div><div><br /></div><div>Now we will push forward executions waiting in <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task B1</span> and <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">B2</span>:</div><div><br /></div><div><pre class="brush: java"><br />final Execution forkB1 = runtimeService<br />        .createExecutionQuery()<br />        .processInstanceId(pid)<br />        .activityId("Task_B1")<br />        .singleResult();<br />assertThat(forkB1).isNotNull();<br />assertThat(runtimeService.getActiveActivityIds(forkB1.getId())).containsOnly("Task_B1");<br /><br />final Execution forkB2 = runtimeService<br />        .createExecutionQuery()<br />        .processInstanceId(pid)<br />        .activityId("Task_B2")<br />        .singleResult();<br />assertThat(forkB2).isNotNull();<br />assertThat(runtimeService.getActiveActivityIds(forkB2.getId())).containsOnly("Task_B2");<br /><br />log.debug("Found forked executions {} and {} in B1/B2 activities accordingly ", forkB1, forkB2);<br /><br /></pre></div><div><br /></div><div>...signalling:</div><div><br /></div><div><pre class="brush: java"><br />runtimeService.signal(forkB1.getId());<br />assertThat(runtimeService.getActiveActivityIds(forkB1.getId())).isEmpty();<br />assertThat(runtimeService.getActiveActivityIds(forkB2.getId())).containsExactly("Task_B2");<br />assertThat(runtimeService.getActiveActivityIds(forkA.getId())).isEmpty();<br /><br />log.debug("Signalling fork B2 will activate Join AB");<br />runtimeService.signal(forkB2.getId());<br /><br />assertThat(<br />        runtimeService<br />                .createExecutionQuery()<br />                .executionId(forkA.getId())<br />                .singleResult()<br />).isNull();<br />assertThat(<br />        runtimeService<br />                .createExecutionQuery()<br />                .executionId(forkB1.getId())<br />                .singleResult()<br />).isNull();<br />assertThat(<br />        runtimeService<br />                .createExecutionQuery()<br />                .executionId(forkB2.getId())<br />                .singleResult()<br />).isNull();<br />assertThat(runtimeService.getActiveActivityIds(pid)).containsOnly("Task_C");<br /></pre></div><div><br /></div><div>...and logs:</div><div><br /></div><div><pre class="brush: java"><br />final Execution forkB = runtimeService.createExecutionQuery()<br />        .activityId("Task_B")<br />        .processInstanceId(pid)<br />        .singleResult();<br />log.debug("Found forked execution {} in Task B activity for process {}", forkB, pid);<br /><br />runtimeService.signal(forkB.getId());<br />log.debug("Advanced fork B, waiting in concurrent activities B1 and B2");<br /><br />assertThat(runtimeService.getActiveActivityIds(pid)).containsOnly("Task_B1", "Task_B2");<br /><br /></pre></div><div><br /></div><div>As you can see when execution containing <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task B1</span> reached join activity, nothing happened since the join waits for three executions to join. But when the remaining execution (the one containing <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task B2</span>) finally made it, <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Join AB</span> breaks and after so many tiring steps we are waiting at the last <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task C</span>.</div><div><br /></div><div>Now there is only one execution associated with the process back again. Finishing the process while waiting in <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">Task C</span> is trivial</div><div><br /></div><div><pre class="brush: java"><br />assertThat(<br />        runtimeService<br />                .createExecutionQuery()<br />                .processInstanceId(pid)<br />                .list()<br />).hasSize(1);<br />log.debug("Signalling Task C to finish the process");<br />runtimeService.signal(pid);<br /><br />assertThat(<br />        runtimeService<br />                .createProcessInstanceQuery()<br />                .processInstanceId(pid)<br />                .singleResult()<br />).isNull();<br /><br /></pre></div><div><br /></div><div>Fully understanding the difference between process and execution is essential to understand and take advantage of fork/join parallelism. Also it is important to use runtime querying API effectively. You must remember that <a href="http://activiti.org/javadocs/org/activiti/engine/runtime/ProcessInstanceQuery.html">ProcessInstanceQuery</a> is used to query process instances (<i>duh!</i>) (we've created only a single process instance throughout this test) by process id, while <a href="http://activiti.org/javadocs/org/activiti/engine/runtime/ExecutionQuery.html">ExecutionQuery</a> allows to find executions (we've created several executions during the test, including the process itself). Execution query is more powerful, as it enables you to find all executions associated with the given process (and also the process itself), executions in a given activity, etc. Both queries can be created using <a href="http://activiti.org/javadocs/org/activiti/engine/RuntimeService.html">RuntimeService</a>. </div><div><br /></div><div>I hope you have a general idea how Activiti manages process execution and how to test it. Full source code of the test case is <a href="https://github.com/nurkiewicz/try-ipad2/blob/process-execution/src/test/java/com/blogspot/nurkiewicz/tryipad2/activiti/ForkJoinTest.java">available</a>, as well as the whole working Maven <a href="https://github.com/nurkiewicz/try-ipad2/tree/process-execution">project</a>. In the next article I will explain <i>call activities</i> and <i>sub processes</i>, but prepare to dive into much more interesting case studies soon.<br /><br /></div>