---
layout: post
title: Detecting and testing stalled streams - RxJava FAQ
date: '2017-09-11T09:00:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- rxjava
modified_time: '2017-09-11T09:29:57.200+02:00'
thumbnail: https://1.bp.blogspot.com/-TG0ffm013z0/WavNqk_x8sI/AAAAAAAAEEc/nXMxZ_PyT-YlYNDWwxcQjdhc-rLrazKXQCLcBGAs/s72-c/2016-09-18%2B10.49.51.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-132278296001058002
blogger_orig_url: https://www.nurkiewicz.com/2017/09/detecting-and-testing-stalled-stream.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-TG0ffm013z0/WavNqk_x8sI/AAAAAAAAEEc/nXMxZ_PyT-YlYNDWwxcQjdhc-rLrazKXQCLcBGAs/s1600/2016-09-18%2B10.49.51.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="901" data-original-width="1600" height="112" src="https://1.bp.blogspot.com/-TG0ffm013z0/WavNqk_x8sI/AAAAAAAAEEc/nXMxZ_PyT-YlYNDWwxcQjdhc-rLrazKXQCLcBGAs/s200/2016-09-18%2B10.49.51.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Topiło Lake, Białowieża Forest</td></tr></tbody></table>Imagine you have a stream that publishes events with unpredictable frequency. Sometimes you can expect dozens of messages per second, but occasionally no events can be seen for several seconds. This can be an issue if your stream is transmitted over web socket, SSE or any other network protocol. Silent period taking too long (stall) can be interpreted as network issue. Therefore we often send artificial events (<em>pings</em>) once in a while just to make sure:<br /><br /><ul><li>clients are still alive</li><li>let clients know <em>we</em> are still alive</li></ul>A more concrete example, imagine we have a <code>Flowable&lt;String&gt;</code> stream that produces some events. When there is no event for more than one second, we should send a placeholder <code>"PING"</code> message. When the silence is even longer, there should be a <code>"PING"</code> message every second. How can we implement such a requirement in RxJava? The most obvious, but incorrect solution is to merge original stream with <em>pings</em>:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; events = //...<br />Flowable&lt;String&gt; pings = Flowable<br />            .interval(1, SECONDS)<br />            .map(x -&gt; "PING");<br /><br />Flowable&lt;String&gt; eventsWithPings = events.mergeWith(pings);</pre><code>mergeWith()</code> operator is crucial: it takes genuine <code>events</code> and combines them with a constant stream of pings. Surely, when no genuine events are presents, <code>"PING"</code> messages will appear. Unfortunately they are entirely unrelated to original stream. This means we keep sending pings even when there are plenty of normal events. Moreover when the silence begins we do not send <code>"PING"</code> precisely after one second. If you are OK with such mechanism, you may stop reading here.<br /><br /><h1 id="debounce-operator"><code>debounce()</code> operator</h1>A more sophisticated approach requires discovering silence that lasts for more than 1 second. We can use <code>timeout()</code> operator for that. Unfortunately it yields <code>TimeoutException</code> and unsubscribes from upstream - way too aggressive behaviour. We just want to get some sort of notification. Turns out <code>debounce()</code> operator can be used for that. Normally this operator postpones emission of new events just in case new events arrive, overriding the old ones. So if I say:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; events = //...<br />Flowable&lt;String&gt; delayed = events.debounce(1, SECONDS);</pre>This means <code>delayed</code> stream will only emit an event if it was <em>not</em> followed by another event within 1 second. Technically <code>delayed</code> may never emit anything if <code>events</code> stream keeps producing events fast enough. We will use the <code>delayed</code> stream to discover silence in the following way:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; events = //...<br />Flowable&lt;String&gt; delayed = events.debounce(1, SECONDS);<br />Flowable&lt;String&gt; pings = delayed.map(ev -&gt; "PING");<br />Flowable&lt;String&gt; eventsWithPings = Flowable.merge(events, pings);</pre>Keep in mind that there is no difference between <code>mergeWith()</code> and its <code>static</code> <code>merge()</code> counterpart. So we are getting somewhere. If the stream is busy, <code>delayed</code> stream never receives any events, therefore no <code>"PING"</code> messages are sent. However when original stream does not send any event for more than 1 second, <code>delayed</code> receives the last seen event, ignores it and transforms into <code>"PING"</code>. Clever, but broken. This implementation only sends one <code>"PING"</code> after discovering stall, as opposed to sending periodic pings every second. Fairly easy to fix! Rather than transforming the last seen event into single <code>"PING"</code> we can transform it into a sequence of periodic <em>pings</em>:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; events = //...<br />Flowable&lt;String&gt; delayed = events.debounce(1, SECONDS);<br />Flowable&lt;String&gt; pings = delayed<br />        .flatMap(x -&gt; Flowable<br />                .interval(0, 1, SECONDS)<br />                .map(e -&gt; "PING")<br />        );<br />Flowable&lt;String&gt; eventsWithPings = Flowable.merge(events, pings);</pre>Can you see where the flaw is? Every time a bit of silence appears in the original stream, we start emitting <em>pings</em> every second. However we should stop doing so once some genuine events appear. We don't. Every stall in the upstream causes new infinite stream of pings to appear on the final merged stream. We must somehow tell the the <code>pings</code> stream that it should stop emitting <em>pings</em> because the original stream emitted genuine event. Guess what, there is <code>takeUntil()</code> operator that does just that!<br /><br /><pre class="brush: java">    Flowable&lt;String&gt; events = //...<br />    Flowable&lt;String&gt; delayed = events.debounce(1, SECONDS);<br />    Flowable&lt;String&gt; pings = delayed<br />            .flatMap(x -&gt; Flowable<br />                    .interval(0, 1, SECONDS)<br />                    .map(e -&gt; "PING")<br />                    .takeUntil(events)<br />            );<br />    Flowable&lt;String&gt; eventsWithPings = Flowable.merge(events, pings);</pre>Take a moment to fully grasp the above code snippet. <code>delayed</code> stream emits an event every time nothing happens on the original stream for more than 1 second. <code>pings</code> stream emits a sequence of <code>"PING"</code> events every second for each event emitted from <code>delayed</code>. However <code>pings</code> stream is terminated the moment an event appears on the <code>events</code> stream. You can even define all of this as a single expression:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; events = //...<br />Flowable&lt;String&gt; eventsWithPings = events<br />        .mergeWith(<br />                events<br />                        .debounce(1, SECONDS)<br />                        .flatMap(x1 -&gt; Flowable<br />                                .interval(0, 1, SECONDS)<br />                                .map(e -&gt; "PING")<br />                                .takeUntil(events)<br />                        ));</pre><h1 id="testability">Testability</h1>All right, we wrote all of this, but how are we suppose to test this triple-nested blob of event-driven code? How do we make sure that <em>pings</em> appear at the right moment and stop when silence is over? How to simulate various time-related scenarios? RxJava has many killer features but testing how time passes through is probably the biggest one. First of all let's make our pinging code a little bit more testable and generic:<br /><br /><pre class="brush: java">&lt;T&gt; Flowable&lt;T&gt; withPings(Flowable&lt;T&gt; events, Scheduler clock, T ping) {<br />    return events<br />            .mergeWith(<br />                    events<br />                            .debounce(1, SECONDS, clock)<br />                            .flatMap(x1 -&gt; Flowable<br />                                    .interval(0, 1, SECONDS, clock)<br />                                    .map(e -&gt; ping)<br />                                    .takeUntil(events)<br />                            ));<br /><br />}</pre>This utility method takes arbitrary stream of <code>T</code> and adds <em>pings</em> in case the stream doesn't produce any events for a longer period of time. We use it like this in our test:<br /><br /><pre class="brush: java">PublishProcessor&lt;String&gt; events = PublishProcessor.create();<br />TestScheduler clock = new TestScheduler();<br />Flowable&lt;String&gt; eventsWithPings = withPings(events, clock, "PING");</pre>Oh boy, <code>PublishProcessor</code>, <code>TestScheduler</code>? <code>PublishProcessor</code> is an interesting class that is a subtype of <code>Flowable</code> (so we can use it as an ordinary stream). On the other hand we can imperatively emit events using its <code>onNext()</code> method:<br /><br /><pre class="brush: java">events.onNext("A");</pre>If someone listens to <code>events</code> stream, he will receive <code>"A"</code> event straight away. And what's with this <code>clock</code> thing? Every single operator in RxJava that deals with time in any way (e.g. <code>debounce()</code>, <code>interval()</code>, <code>timeout()</code>, <code>window()</code>) can take an optional <code>Scheduler</code> argument. It serves as an external source of time. Special <code>TestScheduler</code> is an artificial source of time which we have full control of. I.e. time stands still as long as we don't call <code>advanceTimeBy()</code> explicitly:<br /><br /><pre class="brush: java">clock.advanceTimeBy(999, MILLISECONDS);</pre>999 milliseconds is not a coincidence. <em>Pings</em> start to appear precisely after 1 second so they should not be visible after 999 milliseconds. Now it's about time to reveal full test case:<br /><br /><pre class="brush: java">@Test<br />public void shouldAddPings() throws Exception {<br />    PublishProcessor&lt;String&gt; events = PublishProcessor.create();<br />    final TestScheduler clock = new TestScheduler();<br />    final Flowable&lt;String&gt; eventsWithPings = withPings(events, clock, "PING");<br /><br />    final TestSubscriber&lt;String&gt; test = eventsWithPings.test();<br />    events.onNext("A");<br />    test.assertValues("A");<br /><br />    clock.advanceTimeBy(999, MILLISECONDS);<br />    events.onNext("B");<br />    test.assertValues("A", "B");<br />    clock.advanceTimeBy(999, MILLISECONDS);<br />    test.assertValues("A", "B");<br /><br />    clock.advanceTimeBy(1, MILLISECONDS);<br />    test.assertValues("A", "B", "PING");<br />    clock.advanceTimeBy(999, MILLISECONDS);<br />    test.assertValues("A", "B", "PING");<br /><br />    events.onNext("C");<br />    test.assertValues("A", "B", "PING", "C");<br /><br />    clock.advanceTimeBy(1000, MILLISECONDS);<br />    test.assertValues("A", "B", "PING", "C", "PING");<br />    clock.advanceTimeBy(999, MILLISECONDS);<br />    test.assertValues("A", "B", "PING", "C", "PING");<br /><br />    clock.advanceTimeBy(1, MILLISECONDS);<br />    test.assertValues("A", "B", "PING", "C", "PING", "PING");<br />    clock.advanceTimeBy(999, MILLISECONDS);<br />    test.assertValues("A", "B", "PING", "C", "PING", "PING");<br /><br />    events.onNext("D");<br />    test.assertValues("A", "B", "PING", "C", "PING", "PING", "D");<br /><br />    clock.advanceTimeBy(999, MILLISECONDS);<br />    events.onNext("E");<br />    test.assertValues("A", "B", "PING", "C", "PING", "PING", "D", "E");<br />    clock.advanceTimeBy(999, MILLISECONDS);<br />    test.assertValues("A", "B", "PING", "C", "PING", "PING", "D", "E");<br /><br />    clock.advanceTimeBy(1, MILLISECONDS);<br />    test.assertValues("A", "B", "PING", "C", "PING", "PING", "D", "E", "PING");<br /><br />    clock.advanceTimeBy(3_000, MILLISECONDS);<br />    test.assertValues("A", "B", "PING", "C", "PING", "PING", "D", "E", "PING", "PING", "PING", "PING");<br />}</pre>Looks like a wall of text but it's actually a complete testing scenario of our logic. It makes sure <em>pings</em> appear precisely after 1000 milliseconds, are repeated when silence is very long and quite down when genuine events appear. But the most important part: the test is 100% predictable and blazingly fast. No <a href="https://github.com/awaitility/awaitility">Awaitility</a>, busy waiting, polling, intermittent test failures and slowness. Artificial clock that we have full control of makes sure all these combined streams work exactly as expected.<br /><br /><script>SyntaxHighlighter.highlight();</script>