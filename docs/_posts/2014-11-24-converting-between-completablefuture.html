---
layout: post
title: Converting between Completablefuture and Observable
date: '2014-11-24T22:39:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- CompletableFuture
- java 8
- rxjava
modified_time: '2015-11-29T23:38:06.730+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5439683187518411638
blogger_orig_url: https://www.nurkiewicz.com/2014/11/converting-between-completablefuture.html
---

<a href="http://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html"><code>CompletableFuture&lt;T&gt;</code> from Java 8</a> is an advanced abstraction over a promise that value of type <code>T</code> will be available in the <em>future</em>. <a href="https://github.com/ReactiveX/RxJava/wiki/Observable"><code>Observable&lt;T&gt;</code></a> is quite similar, but it promises arbitrary number of items in the future, from 0 to infinity. These two representations of asynchronous results are quite similar to the point where <code>Observable</code> with just one item can be used instead of <code>CompletableFuture</code> and vice-versa. On the other hand <code>CompletableFuture</code> is more specialized and because it's now part of JDK, should become prevalent quite soon. Let's celebrate RxJava 1.0 release with a short article showing how to convert between the two, without loosing asynchronous and event-driven nature of them.<br /><br /><h1>From <code>CompletableFuture&lt;T&gt;</code> to <code>Observable&lt;T&gt;</code></h1><code>CompletableFuture</code> represents one value in the future, so turning it into <code>Observable</code> is rather simple. When <code>Future</code> completes with some value, <code>Observable</code> will emit that value as well immediately and close stream:<br /><br /><pre class="brush: groovy">class FuturesTest extends Specification {<br /><br />    public static final String MSG = "Don't panic"<br /><br />    def 'should convert completed Future to completed Observable'() {<br />        given:<br />            CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture("Abc")<br /><br />        when:<br />            Observable&lt;String&gt; observable = Futures.toObservable(future)<br /><br />        then:<br />            observable.toBlocking().toIterable().toList() == ["Abc"]<br />    }<br /><br />    def 'should convert failed Future into Observable with failure'() {<br />        given:<br />            CompletableFuture&lt;String&gt; future = failedFuture(new IllegalStateException(MSG))<br /><br />        when:<br />            Observable&lt;String&gt; observable = Futures.toObservable(future)<br /><br />        then:<br />            observable<br />                    .onErrorReturn({ th -&gt; th.message } as Func1)<br />                    .toBlocking()<br />                    .toIterable()<br />                    .toList() == [MSG]<br />    }  <br /><br />    CompletableFuture failedFuture(Exception error) {<br />        CompletableFuture future = new CompletableFuture()<br />        future.completeExceptionally(error)<br />        return future<br />    }<br /><br />}<br /></pre>First test of <em>not-yet-implemented</em> <code>Futures.toObservable()</code> converts <code>Future</code> into <code>Observable</code> and makes sure value is propagated correctly. Second test created failed <code>Future</code>, replaces failure with exception's message and makes sure exception was propagated. The implementation is much shorter:<br /><br /><pre class="brush: java">public static &lt;T&gt; Observable&lt;T&gt; toObservable(CompletableFuture&lt;T&gt; future) {<br />    return Observable.create(subscriber -&gt;<br />            future.whenComplete((result, error) -&gt; {<br />                if (error != null) {<br />                    subscriber.onError(error);<br />                } else {<br />                    subscriber.onNext(result);<br />                    subscriber.onCompleted();<br />                }<br />            }));<br />}<br /></pre>NB: <a href="https://github.com/ReactiveX/RxJava/wiki/Phantom-Operators#fromfuture"><code>Observable.fromFuture()</code></a> exists, however we want to take full advantage of <code>ComplatableFuture</code>'s asynchronous operators.<br /><br /><h1>From <code>Observable&lt;T&gt;</code> to <code>CompletableFuture&lt;List&lt;T&gt;&gt;</code></h1>There are actually two ways to convert <code>Observable</code> to <code>Future</code> - creating <code>CompletableFuture&lt;List&lt;T&gt;&gt;</code> or <code>CompletableFuture&lt;T&gt;</code> (if we assume <code>Observable</code> has just one item). Let's start from the former case, described with the following test cases:<br /><br /><pre class="brush: groovy">def 'should convert Observable with many items to Future of list'() {<br />    given:<br />        Observable&lt;Integer&gt; observable = Observable.just(1, 2, 3)<br /><br />    when:<br />        CompletableFuture&lt;List&lt;Integer&gt;&gt; future = Futures.fromObservable(observable)<br /><br />    then:<br />        future.get() == [1, 2, 3]<br />}<br /><br />def 'should return failed Future when after few items exception was emitted'() {<br />    given:<br />        Observable&lt;Integer&gt; observable = Observable.just(1, 2, 3)<br />                .concatWith(Observable.error(new IllegalStateException(MSG)))<br /><br />    when:<br />        Futures.fromObservable(observable)<br /><br />    then:<br />        def e = thrown(Exception)<br />        e.message == MSG<br />}<br /></pre>Obviously <code>Future</code> doesn't complete until source <code>Observable</code> signals end of stream. Thus <code>Observable.never()</code> would never complete wrapping <code>Future</code>, rather then completing it with empty list. The implementation is much shorter and sweeter:<br /><br /><pre class="brush: java">public static &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; fromObservable(Observable&lt;T&gt; observable) {<br />    final CompletableFuture&lt;List&lt;T&gt;&gt; future = new CompletableFuture&lt;&gt;();<br />    observable<br />            .doOnError(future::completeExceptionally)<br />            .toList()<br />            .forEach(future::complete);<br />    return future;<br />}<br /></pre>The key is <code>Observable.toList()</code> that conveniently converts from <code>Observable&lt;T&gt;</code> and <code>Observable&lt;List&lt;T&gt;&gt;</code>. The latter emits one item of <code>List&lt;T&gt;</code> type when source <code>Observable&lt;T&gt;</code> finishes.<br /><br /><h1>From <code>Observable&lt;T&gt;</code> to <code>CompletableFuture&lt;T&gt;</code></h1>Special case of the previous transformation happens when we know that <code>CompletableFuture&lt;T&gt;</code> will return exactly one item. In that case we can convert it directly to <code>CompletableFuture&lt;T&gt;</code>, rather than <code>CompletableFuture&lt;List&lt;T&gt;&gt;</code> with one item only. Tests first:<br /><br /><pre class="brush: groovy">def 'should convert Observable with single item to Future'() {<br />    given:<br />        Observable&lt;Integer&gt; observable = Observable.just(1)<br /><br />    when:<br />        CompletableFuture&lt;Integer&gt; future = Futures.fromSingleObservable(observable)<br /><br />    then:<br />        future.get() == 1<br />}<br /><br />def 'should create failed Future when Observable fails'() {<br />    given:<br />        Observable&lt;String&gt; observable = Observable.&lt;String&gt; error(new IllegalStateException(MSG))<br /><br />    when:<br />        Futures.fromSingleObservable(observable)<br /><br />    then:<br />        def e = thrown(Exception)<br />        e.message == MSG<br />}<br /><br />def 'should fail when single Observable produces too many items'() {<br />    given:<br />        Observable&lt;Integer&gt; observable = Observable.just(1, 2)<br /><br />    when:<br />        Futures.fromSingleObservable(observable)<br /><br />    then:<br />        def e = thrown(Exception)<br />        e.message.contains("too many elements")<br />}<br /></pre>Again the implementation is quite straightforward and almost identical:<br /><br /><pre class="brush: java">public static &lt;T&gt; CompletableFuture&lt;T&gt; fromSingleObservable(Observable&lt;T&gt; observable) {<br />    final CompletableFuture&lt;T&gt; future = new CompletableFuture&lt;&gt;();<br />    observable<br />        .doOnError(future::completeExceptionally)<br />        .single()<br />        .forEach(future::complete);<br />    return future;<br />}<br /></pre>Helpers methods above aren't fully robust yet, but if you ever need to convert between JDK 8 and RxJava style of asynchronous computing, this article should be enough to get you started.<br /><br /><script>SyntaxHighlighter.highlight();</script>