---
layout: post
title: Futures in Akka with Scala
date: '2013-03-07T18:39:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- akka
- scala
- multithreading
modified_time: '2013-03-07T18:39:31.570+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8062284487960397370
blogger_orig_url: https://www.nurkiewicz.com/2013/03/futures-in-akka-with-scala.html
---

Akka is actor based, event-driven framework for building highly concurrent, reliable applications. Shouldn't come a surprise that concept of a <i>future</i> is ubiquitous in a system like that. You typically never block waiting for a response, instead you send a message and expect response to arrive some time in the future. Sounds like great fit for... futures. Moreover futures in Akka are special for two reasons: Scala syntax together with type inference greatly improve readability and <i>monadic</i> nature. To fully appreciate the latter advantage check out <a href="http://blog.tmorris.net/posts/scalaoption-cheat-sheet/"><i>scala.Option Cheat Sheet</i></a> if you haven't yet grasped monads in practice in Scala.<br /><br />We will continue our <a href="http://nurkiewicz.blogspot.no/2013/02/executorcompletionservice-in-practice.html">web crawler example</a> taking <a href="http://nurkiewicz.blogspot.no/2013/02/listenablefuture-in-guava.html">yet another</a> approach, this time with Akka on top of Scala. First the basic syntax:<br /><br /><pre class="brush: scala">val future = Future {<br />    Source.fromURL(<br />        new URL("http://www.example.com"), StandardCharsets.UTF_8.name()<br />    ).mkString<br />}<br /></pre>That was quick! <code>future</code> is of <a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.Future"><code>scala.concurrent.Future[String]</code></a> inferred type. Provided code block will be executed asynchronously later and <code>future</code> (of <code>Future[String]</code> type) represents a handle to the value of that block. By now you should be wondering, how do you configure threads running this task? Good question, this code won't compile as it stands, it needs <a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.ExecutionContext"><code>ExecutionContext</code></a> to work on. <code>ExecutionContext</code> is just like <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html"><code>ExecutorService</code></a> but can be given implicitly. You have several choices:<br /><a name='more'></a><br /><br /><pre class="brush: scala">import ExecutionContext.Implicits.global<br /><br />//or<br /><br />implicit val ec = ExecutionContext.fromExecutorService(Executors.newFixedThreadPool(50))<br /><br />//or (inside actor)<br /><br />import context.dispatcher<br /><br />//or (explicitly)<br /><br />val future = Future {<br />    //...<br />} (ec)<br /></pre>First approach uses built in execution context composed of as many threads as many CPU/cores you have. Use this context only for small applications as it doesn't scale well and is quite inflexible. Second approach takes existing <code>ExecutorService</code> and wraps it. You have full control over the number of threads and their behaviour. Notice how <code>implicit val</code> is picked up automatically. If you are inside an actor you can reuse Akka <code>dispatcher</code> to run your task using the same thread pool as actors use. Finally you can of course pass <code>ExecutionContext</code> explicitly. In next examples I assume some implicit context is available.<br /><br />Having <code>Future</code> instance we would like to process the result. I am not even mentioning about blocking and waiting for them synchronously (but examine <a href="http://doc.akka.io/docs/akka/2.1.1/scala/futures.html">official documentation</a> if you <i>really</i> need it). More in a spirit of <a href="http://nurkiewicz.blogspot.no/2013/02/listenablefuture-in-guava.html"><code>ListenableFuture</code> from Guava</a> we will register some completion callbacks first:<br /><br /><pre class="brush: scala">Future {<br />    Source.fromURL(new URL("http://www.example.com"), StandardCharsets.UTF_8.name()).mkString<br />} onComplete {<br />    case Success(html) =&gt; logger.info("Result: " + html)<br />    case Failure(ex) =&gt; logger.error("Problem", ex)<br />}<br /></pre>This feels pretty much like <code>ListenableFuture</code> but with cleaner syntax. However there are even more powerful tools in our box. Remember, last time we had one synchronous method to parse downloaded HTML and a second, asynchronous method to compute <i>relevance</i> of the document (whatever that means):<br /><br /><pre class="brush: scala">def downloadPage(url: URL) = Future {<br />    Source.fromURL(url, StandardCharsets.UTF_8.name()).mkString<br />}<br /><br />def parse(html: String): Document = //...<br /><br />def calculateRelevance(doc: Document): Future[Double] = //...<br /></pre>Of course we can register <code>onComplete</code> callback but futures in Akka/Scala are monads, thus we can process the data as a sequence of chained, strongly typed transformations (explicit types preserved for clarity):<br /><br /><pre class="brush: scala"><br />val htmlFuture:         Future[String]   = downloadPage(new URL("http://www.example.com"))<br />val documentFuture:     Future[Document] = htmlFuture map parse<br />val relevanceFuture:    Future[Double]   = documentFuture flatMap calculateRelevance<br />val bigRelevanceFuture: Future[Double]   = relevanceFuture filter {_ &gt; 0.5}<br />bigRelevanceFuture foreach println<br /></pre>I want to be clear here. Calling <code>Future.map(someOperation)</code> does not wait for that future to complete. It simply wraps it and runs <code>someOperation</code> the moment it completes, some time in the, <i>ekhem</i>, future. The same applies to <code>Future.filter</code> and <code>Future.foreach</code>. You might be surprised to see them in this context as we typically associate such operators with collections. But just as with <code>Option[T]</code>, <code>Future[T]</code> is, greatly oversimplifying, a collection that may or may not contain exactly one element. With this comparison it should be obvious what the code above does. <code>Future.filter</code> invocation might not be clear but it basically specifies that we are not interested in the result of asynchronous operation that does not meet certain criteria. If the predicate yields <code>false</code>, <code>foreach</code> operation will never be executed.<br /><br />Of course you can take advantage of type inference and chaining to get more concise, but not necessarily easier to read code:<br /><br /><pre class="brush: scala">downloadPage(new URL("http://www.example.com")).<br />    map(parse).<br />    flatMap(calculateRelevance).<br />    filter(_ &gt; 0.5).<br />    foreach(println)<br /></pre>But the biggest win comes from for-comprehensions. You might not be aware of that, but because <code>Future</code> implements <code>map</code>, <code>foreach</code>, <code>filter</code> and such (simplifying), we can use it inside for comprehension (same applies to <code>Option[T]</code>). So yet another, arguably most readable approach would be:<br /><br /><pre class="brush: scala">for {<br />    html &lt;- downloadPage(new URL("http://www.example.com"))<br />    relevance &lt;- calculateRelevance(parse(html))<br />    if(relevance &gt; 0.5)<br />} println(relevance)<br /><br />println("Done")<br /></pre>It feels very imperative and sequential but in fact each step of this for comprehension is executed asynchronously and there is no blocking here. <code>"Done"</code> message will be displayed immediately, long before the computed relevance. This construct brings best of both worlds - looks sequential but in fact runs in background. Moreover it hides the obscure difference between functions returning value vs. <code>Future</code> of value (<code>map</code> vs. <code>flatMap</code>).<br /><br />Say we run code above for a list of web sites which gives us <code>List[Future[Double]]</code> and now we want to find the biggest relevance in that set. By now you should refuse all solutions involving blocking. There are two clever ways to do this in Scala - either by turning a <code>List[Future[Double]]</code> to <code>Future[List[Double]]</code> or by folding over a list of futures. The first solutions is identical to <a href="http://nurkiewicz.blogspot.no/2013/02/advanced-listenablefuture-capabilities.html"><code>Futures.allAsList</code> in Guava</a>:<br /><br /><pre class="brush: scala">val futures: Seq[Future[Double]] = //...<br />val future: Future[Seq[Double]] = Future sequence futures<br />future.onSuccess{<br />    case x =&gt; println(s"Max relevance: ${x.max}")<br />}<br /></pre>or even more concisely (remember that <code>x</code> is a <code>Seq[Double]</code> in both cases:<br /><br /><pre class="brush: scala">Future.sequence(futures).map {x =&gt;<br />    println(s"Max relevance: ${x.max}")<br />}<br /></pre>Remember that there is no blocking here. <code>Future[Seq[Double]]</code> completes when last underlying <code>Future[Double]</code> reports completion. If you like <code>foldLeft()</code> just like <a href="http://nurkiewicz.blogspot.no/2012/04/secret-powers-of-foldleft-in-scala.html">I do</a> (but not necessarily here) consider the following idiom:<br /><br /><pre class="brush: scala">Future.fold(futures)(0.0) {_ max _} map {maxRel =&gt;<br />    println(s"Max relevance: $maxRel")<br />}<br /></pre>This ones iterates over futures one-by-one and invokes our supplied <code>{_ max _}</code> fold function whenever given future succeeds.<br /><br /><h2>Summary</h2>Futures in Scala and Akka are very powerful: they allow non-blocking, CPU-effective asynchronous programming but they feel like imperative, single-threaded programming. You can apply sequence of transformations on top of a single future or a collection of them just as if that future was already resolved. Code looks totally imperative where you wait for one stage, run some transformation and run second stage. But in reality everything is asynchronous and event driven. Due to monadic nature of <code>Future[V]</code> and concise syntax, futures in Scala are a wonderful tool without introducing too much ceremony.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>