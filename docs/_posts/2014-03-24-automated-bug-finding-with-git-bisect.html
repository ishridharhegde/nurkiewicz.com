---
layout: post
title: Automated bug finding with git bisect and mvn test
date: '2014-03-24T22:34:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- testing
- git
modified_time: '2014-03-24T22:34:41.784+01:00'
thumbnail: http://1.bp.blogspot.com/-wYSOo8Z0-BA/UzCkCQ6gXaI/AAAAAAAABAg/Htds4_BrJps/s72-c/1.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1468733686413219161
blogger_orig_url: https://www.nurkiewicz.com/2014/03/automated-bug-finding-with-git-bisect.html
---

Do you know the feeling when you discover a bug in a functionality that was working couple of weeks (or versions) ago? Too bad we didn’t have any automated tests and what used to be fine, now is broken. Let’s take this simple repository as an example:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-wYSOo8Z0-BA/UzCkCQ6gXaI/AAAAAAAABAg/Htds4_BrJps/s1600/1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-wYSOo8Z0-BA/UzCkCQ6gXaI/AAAAAAAABAg/Htds4_BrJps/s1600/1.png" /></a></div><h2>Write test first</h2>We noticed that some particular functionality was OK in version 1.0 but is broken in 1.1. What is the first thing we do? Of course <a href="http://www.nurkiewicz.com/2009/12/adapter-pattern-revised.html">write a test case</a> to make sure this bug, once fixed, never comes back! Writing (failing) test for every bug you find has many advantages:<br /><br /><ol><li>It documents bugs and proves they were fixed</li><li>Non-obvious workarounds and solutions will not be removed ("why was <i>he</i> checking for <code>null</code> here?! It’s impossible, let's simplify it") by accident</li><li>You gradually improve overall code coverage, even in legacy codebase.</li></ol>So you have a failing test case. But even with isolated test you can't reliably figure out what is wrong. If only we could find a commit that broke that test - assuming commits are small and focused. But if we commit our test right now and check in one of the older versions to run it - it's not yet there. After all, test made its why to the codebase just now, if it was there from the first revision, we wouldn't have the problem altogether:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-aQQvN3vEEwU/UzCkCZSY84I/AAAAAAAABAo/fqvNfymiu_8/s1600/2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-aQQvN3vEEwU/UzCkCZSY84I/AAAAAAAABAo/fqvNfymiu_8/s1600/2.png" /></a></div><h2>Interactive rebasing</h2>Maybe instead of committing the test after version 1.1 (where we know it's broken) we should make a patch or stash this test? This way we could go through all revisions between 1.0 and 1.1, unstashing or applying patch with test and running it. Hope you agree this is far from perfect. The first trick is to use interactive rebase in order to shift commit with failing test case back in time. However we don't want to rebase <code>master</code> branch so we make a temporary copy and rebase it instead:<br /><br /><pre class="brush: plain">$ git checkout -b tmp<br />Switched to a new branch 'tmp'<br /><br />$ git rebase -i 1.0 tmp<br />Successfully rebased and updated refs/heads/tmp.<br /></pre>Interactive rebase will ask us to rearrange commits before proceeding, just move commit with test case from last to first position:<br /><br /><pre class="brush: plain">pick 10dbcc9 Feature 2<br />pick f4cf58a Feature 3<br />pick 8287434 Feature 4<br />pick e79d56f Feature 5<br />pick 50614b6 Feature 6<br />pick 21ae08f Feature 7<br />pick 1e5b5a5 Feature 8<br />pick f703abf Feature 9<br />pick 686d7a9 Feature 10<br />pick b5b5cf1 Feature 11<br />pick 8e58593 Feature 12<br />pick 3ab419a Feature 13<br />pick 0e769a0 Feature 14<br />pick 8bfdbea Feature 15<br />pick 0a95b7f Feature 16<br />pick 4622cbc Feature 17<br />pick 757c4eb Feature 18<br />pick 3d94d7e Feature 19<br />pick da69f6a Feature 20<br />pick 733bd17 Test for bug #123<br /></pre>Now our repository should look somewhat like this:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-RfosyTuHOOQ/UzCkCSIz0wI/AAAAAAAABAk/xTFZo9KgEyk/s1600/3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-RfosyTuHOOQ/UzCkCSIz0wI/AAAAAAAABAk/xTFZo9KgEyk/s1600/3.png" /></a></div><h2>git bisect</h2>Most importantly, our test case is now injected right after version 1.0 (known to be good). All we have to do is check in all revisions one after another and run this test. STOP! If you are smart (or lazy) you will start from commit right in the middle and if this one is broken you proceed with first half the same way - or take second half otherwise. It's sort of like binary search. However keeping track of which commit was last seen good and bad and also manually checking in revision in the middle is quite cumbersome. Luckily git can do this for us with <code>git bisect</code> command. In principal after starting bisecting we specify last known good and first known bad commit. Git will check in revision in between and ask us whether it's good or bad, continuing until we find exactly which commit broke code. In our case we simply run <code>mvn test</code> and proceed depending on its outcome:<br /><br /><pre class="brush: plain">$ git bisect start<br /><br />$ git bisect good 1.0<br /><br />$ git bisect bad tmp<br />Bisecting: 9 revisions left to test after this (roughly 3 steps)<br />[13ed8405beb387ec86874d951cf630de2c4fd927] Feature 10<br /><br />$ mvn test -Dcom.nurkiewicz.BugTest<br />...<br />[INFO] BUILD SUCCESS<br /><br />$ git bisect good<br />Bisecting: 4 revisions left to test after this (roughly 2 steps)<br />[b9e610428b61ba1436219edbaa1c5c435a1907ae] Feature 15<br /><br />$ mvn test -Dcom.nurkiewicz.BugTest<br />...<br />[INFO] BUILD SUCCESS<br /><br />$ git bisect good<br />Bisecting: 2 revisions left to test after this (roughly 1 step)<br />[e8a5ddd4dea219d826a15f7a085e412c29333b10] Feature 17<br /><br />$ mvn test -Dcom.nurkiewicz.BugTest<br />...<br />[INFO] BUILD FAILURE<br /><br />$ git bisect bad<br />Bisecting: 0 revisions left to test after this (roughly 0 steps)<br />[6d974faffa042781a098914a80d962953a492cb5] Feature 16<br /><br />$ mvn test -Dcom.nurkiewicz.BugTest<br />...<br />[INFO] BUILD SUCCESS<br /><br />$ git bisect good<br />e8a5ddd4dea219d826a15f7a085e412c29333b10 is the first bad commit<br />commit e8a5ddd4dea219d826a15f7a085e412c29333b10<br />Author: Tomasz Nurkiewicz<br />Date:   Wed Mar 19 19:43:40 2014 +0100<br /><br />    Feature 17<br /><br />:100644 100644 469c856b4ede8 90d6b2233832 M      SomeFile.java<br /></pre>See how we iteratively call <code>git good</code>/<code>bad</code> executing our test case in between? Also notice how quickly the number of commits to test shrinks. You might think this is neat and fast (logarithmic time!), but we can actually go much faster. <code>git bisect</code> has a hidden gem called <code>run</code> mode. Instead of relying on manual answer from the user after each iteration we can provide a script that tells whether given revision is good or bad. By convention if this script exits with code 0 it means success while any other exit code signals an error. Luckily <code>mvn</code> script follows this convention so we can simply execute <code>git bisect mvn test -Dcom.nurkiewicz.BugTest</code>, sit back and relax:<br /><br /><pre class="brush: plain">$ git bisect start<br /><br />$ git bisect good 1.0<br /><br />$ git bisect bad tmp<br />Bisecting: 9 revisions left to test after this (roughly 3 steps)<br />[13ed8405beb387ec86874d951cf630de2c4fd927] Feature 10<br /><br />$ git bisect run mvn test -Dcom.nurkiewicz.BugTest<br />running mvn test -Dcom.nurkiewicz.BugTest<br />...<br />[INFO] BUILD SUCCESS<br />...<br />Bisecting: 4 revisions left to test after this (roughly 2 steps)<br />[b9e610428b61ba1436219edbaa1c5c435a1907ae] Feature 15<br />running mvn test -Dcom.nurkiewicz.BugTest<br />...<br />[INFO] BUILD SUCCESS<br />...<br />Bisecting: 2 revisions left to test after this (roughly 1 step)<br />[e8a5ddd4dea219d826a15f7a085e412c29333b10] Feature 17<br />running mvn test -Dcom.nurkiewicz.BugTest<br />...<br />[INFO] BUILD FAILURE<br />...<br />Bisecting: 0 revisions left to test after this (roughly 0 steps)<br />[6d974faffa042781a098914a80d962953a492cb5] Feature 16<br />running mvn test -Dcom.nurkiewicz.BugTest<br />...<br />[INFO] BUILD SUCCESS<br />...<br />e8a5ddd4dea219d826a15f7a085e412c29333b10 is the first bad commit<br />commit e8a5ddd4dea219d826a15f7a085e412c29333b10<br />Author: Tomasz Nurkiewicz<br />Date:   Wed Mar 19 19:43:40 2014 +0100<br /><br />    Feature 17<br /><br />:100644 100644 469c856b4ede8 90d6b2233832 M      SomeFile.java<br />bisect run success<br /></pre>Program above is non-interactive and fully automated. git, after few iterations, points precisely which commit was the first one to break the test. We can run all tests, but there is no point since we know only this one fails. Of course you can use any other command rather than <code>mvn</code>. You can even write some simple script in any JVM language of your choice (use <code>System.exit ()</code>). <code>git</code> bisect, combined with interactive rebasing, are wonderful tools to look for regressions and bugs. Also they promote automated testing and automation in general. <br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>