---
layout: post
title: Option.fold() considered unreadable
date: '2014-06-23T22:17:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
- functional programming
- Haskell
modified_time: '2014-06-23T22:17:17.077+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-893869958175356978
blogger_orig_url: https://www.nurkiewicz.com/2014/06/optionfold-considered-unreadable.html
---

We had a lengthy discussion recently during code review whether <a href="http://www.scala-lang.org/api/2.11.1/index.html#scala.Option"><code>scala.Option.fold()</code></a> is idiomatic and clever or maybe unreadable and tricky? Let's first describe what the problem is. <code>Option.fold</code> does two things: maps a function <code>f</code> over <code>Option</code>'s value (if any) or returns an alternative <code>alt</code> if it's absent. Using simple pattern matching we can implement it as follows:<br /><br /><pre class="brush: scala">val option: Option[T] = //...<br />def alt: R = //...<br />def f(in: T): R = //...<br /><br />val x: R = option match {<br />    case Some(v) =&gt; f(v)<br />    case None =&gt; alt<br />}<br /></pre>If you prefer one-liner, <code>fold</code> is actually a combination of <code>map</code> and <code>getOrElse</code><br /><br /><pre class="brush: scala">val x: R = option map f getOrElse alt<br /></pre>Or, if you are a C programmer that still wants to write in C, but using Scala compiler:<br /><br /><pre class="brush: scala">val x: R = if (option.isDefined)<br />    f(option.get)<br />else<br />    alt<br /></pre>Interestingly this is similar to how <code>fold()</code> is actually implemented, but that's an implementation detail. OK, all of the above can be replaced with single <code>Option.fold()</code>:<br /><br /><pre class="brush: scala">val x: R = option.fold(alt)(f)<br /></pre>Technically you can even use <code>/:</code> and <code>\:</code> operators (<code>alt /: option</code>) - but that would be simply masochistic. I have three problems with <code>option.fold()</code> idiom. First of all - it's anything but readable. We are folding (reducing) over <code>Option</code> - which doesn't really make much sense. Secondly it reverses the ordinary <em>positive-then-negative-case</em> flow by starting with failure (absence, <code>alt</code>) condition followed by presence block (<code>f</code> function; see also: <a href="http://www.coolscala.com/wiki/Cool_Scala/Refactoring_map-getOrElse_to_fold"><em>Refactoring map-getOrElse to fold</em></a>). Interestingly this method would work great for me if it was named <code>mapOrElse</code>:<br /><br /><pre class="brush: scala">/**<br /> * Hypothetical in Option<br /> */<br />def mapOrElse[B](f: A =&gt; B, alt: =&gt; B): B =<br />    this map f getOrElse alt<br /></pre>Actually there is already such method in Scalaz, called <a href="http://scalaz.googlecode.com/svn/continuous/latest/doc/scalaz/OptionW.html"><code>OptionW.cata</code></a>. <strong>cata</strong>. Here is what <a href="http://stackoverflow.com/questions/5328007">Martin Odersky has to say about it</a>:<br /><br /><blockquote>"I personally find methods like <code>cata</code> that take two closures as arguments are often overdoing it. Do you really gain in readability over <code>map</code> + <code>getOrElse</code>? Think of a newcomer to your code[...]"<br /><br /></blockquote>While <code>cata</code> has some <a href="http://en.wikipedia.org/wiki/Catamorphism">theoretical background</a>, <code>Option.fold</code> just sounds like a random name collision that doesn't bring anything to the table, apart from confusion. I know what you'll say, that <code>TraversableOnce</code> has <code>fold</code> and we are sort-of doing the same thing. Why it's a random collision rather than extending the contract described in <code>TraversableOnce</code>? <code>fold()</code> method in Scala collections typically just delegates to one of <code>foldLeft()</code>/<code>foldRight()</code> (the one that works better for given data structure), thus it doesn't guarantee order and folding function has to be associative. But in <code>Option.fold()</code> the contract is different: folding function takes just one parameter rather than two. If you read <a href="http://www.nurkiewicz.com/2012/04/secret-powers-of-foldleft-in-scala.html">my previous article about folds</a> you know that reducing function always takes two parameters: current element and accumulated value (initial value during first iteration). But <code>Option.fold()</code> takes just one parameter: current <code>Option</code> value! This breaks the consistency, especially when realizing <code>Option.foldLeft()</code> and <code>Option.foldRight()</code> have <em>correct</em> contract (but it doesn't mean they are more readable).<br /><br />The only way to understand folding over option is to imagine <code>Option</code> as a sequence with <code>0</code> or <code>1</code> elements. Then it sort of makes sense, right? No.<br /><br /><pre class="brush: scala">def double(x: Int) = x * 2<br /><br />Some(21).fold(-1)(double)   //OK: 42<br />None.fold(-1)(double)       //OK: -1<br /></pre>but:<br /><br /><pre class="brush: scala">Some(21).toList.fold(-1)(double)<br />&lt;console&gt;: error: type mismatch;<br /> found   : Int =&gt; Int<br /> required: (Int, Int) =&gt; Int<br />              Some(21).toList.fold(-1)(double)<br />                                       ^<br /></pre>If we treat <code>Option[T]</code> as a <code>List[T]</code>, awkward <code>Option.fold()</code> breaks because it has different type than <code>TraversableOnce.fold()</code>. This is my biggest concern. I can't understand why <em>folding</em> wasn't defined in terms of the type system (trait?) and implemented strictly. As an example take a look at:<br /><br /><h2><code>Data.Foldable</code> in Haskell (advanced)</h2><a href="https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Foldable.html"><code>Data.Foldable</code> typeclass</a> describes various flavours of folding in Haskell. There are familiar <code>foldl</code>/<code>foldr</code>/<code>foldl1</code>/<code>foldr1</code>, in Scala named <code>foldLeft</code>/<code>foldRight</code>/<code>reduceLeft</code>/<code>reduceRight</code> accordingly. They have the same type as Scala and behave unsurprisingly with all types that you can fold over, including <code>Maybe</code>, lists, arrays, etc. There is also a function named <code>fold</code>, but it has a completely different meaning:<br /><br /><pre class="brush: plain">class Foldable t where<br />    fold :: Monoid m =&gt; t m -&gt; m<br /></pre>While other folds are quite complex, this one barely takes a foldable container of <code>m</code>s (which have to be <a href="https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Monoid.html"><code>Monoid</code></a>s) and returns the same <code>Monoid</code> type. A quick recap: a type can be a <code>Monoid</code> if there exists a neutral value of that type and an operation that takes two values and produces just one. Applying that function with one of the arguments being neutral value yields the other argument. <code>String</code> (<code>[Char]</code>) is a good example with empty string being neutral value (<code>mempty</code>) and string concatenation being such operation (<code>mappend</code>). Notice that there are two different ways you can construct monoids for numbers: under addition with neutral value being <code>0</code> (<code>x + 0 == 0 + x == x</code> for any <code>x</code>) and under multiplication with neutral <code>1</code> (<code>x * 1 == 1 * x == x</code> for any <code>x</code>). Let's stick to strings. If I fold empty list of strings, I'll get an empty string. But when a list contains many elements, they are being concatenated:<br /><br /><pre class="brush: plain">&gt; fold ([] :: [String])<br />""<br />&gt; fold [] :: String<br />""<br />&gt; fold ["foo", "bar"]<br />"foobar"<br /></pre>In the first example we have to explicitly say what is the type of empty list <code>[]</code>. Otherwise Haskell compiler can't figure out what is the type of elements in a list, thus which monoid instance to choose. In second example we declare that whatever is returned from <code>fold []</code>, it should be a <code>String</code>. From that the compiler infers that <code>[]</code> actually must have a type of <code>[String]</code>. Last <code>fold</code> is the simplest: the program folds over elements in list and concatenates them because concatenation is the operation defined in <code>Monoid String</code> typeclass instance.<br /><br />Back to options (or more precisely <code>Maybe</code>). Folding over <code>Maybe</code> monad having type parameter being <code>Monoid</code> (I can't believe I just said it) has an interesting interpretation: it either returns value inside <code>Maybe</code> or a default <code>Monoid</code> value:<br /><br /><pre class="brush: plain">&gt; fold (Just "abc")<br />"abc"<br />&gt; fold Nothing :: String<br />""<br /></pre><code>Just "abc"</code> is same as <code>Some("abc")</code> in Scala. You can see here that if <code>Maybe String</code> is <code>Nothing</code>, neutral <code>String</code> monoid value is returned, that is an empty string.<br /><br /><h2>Summary</h2>Haskell shows that folding (also over <code>Maybe</code>) can be at least consistent. In Scala <code>Option.fold</code> is unrelated to <code>List.fold</code>, confusing and unreadable. I advise avoiding it and staying with slightly more verbose <code>map</code>/<code>getOrElse</code> transformations or pattern matching.<br /><br />PS: Did I mention there is also <a href="http://www.scala-lang.org/api/current/index.html#scala.util.Either"><code>Either.fold()</code></a> (with even different contract) but no <a href="http://www.scala-lang.org/api/current/index.html#scala.util.Try"><code>Try.fold()</code></a>? <br /><br /> <script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>