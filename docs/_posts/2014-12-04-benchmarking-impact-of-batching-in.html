---
layout: post
title: Benchmarking impact of batching in Hystrix
date: '2014-12-04T22:55:00.002+01:00'
author: Tomasz Nurkiewicz
tags:
- Hystrix
- multithreading
modified_time: '2014-12-04T22:55:55.683+01:00'
thumbnail: http://3.bp.blogspot.com/-q23DcEWYdKs/VIDXiSmSWuI/AAAAAAAABMM/WQ1trLG87s0/s72-c/tps.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5437300109938028740
blogger_orig_url: https://www.nurkiewicz.com/2014/12/benchmarking-impact-of-batching-in.html
---

In previous article <a href="http://www.nurkiewicz.com/2014/11/batching-collapsing-requests-in-hystrix.html">"<em>Batching (collapsing) requests in Hystrix</em>"</a> we looked at collapsing API in Hystrix. Check it out before proceeding with this article. Example presented there was rather artificial, merely presenting API. Today let's look at semi-real-life example and do some benchmarking. We already used <a href="https://api.random.org/json-rpc/1/">random.org API</a> some time ago as an example (see: <a href="http://www.nurkiewicz.com/2012/10/your-first-message-discovering-akka.html"><em>Your first message - discovering Akka</em></a>), let's use it again. Imagine our application calls the following API facade in order to fetch exactly one random number per request (<code>generateIntegers(1)</code>):<br /><br /><pre class="brush: java">public interface RandomOrgClient {<br />    RandomIntegers generateIntegers(int howMany);<br />}<br /></pre>As you can see this method can easily fetch more than one number. You might wonder why it returns some fancy <code>RandomIntegers</code> class rather than, say <code>List&lt;Integer&gt;</code>? Well, a <em>list of integers</em> is just a data structure, it doesn't represent any business concept, while <code>*random integers*</code> leaves no room for speculation. Still unsurprisingly the implementation is just a wrapper/decorator over a list:<br /><br /><pre class="brush: java">public class RandomIntegers extends AbstractList&lt;Integer&gt; {<br /><br />    private final ImmutableList&lt;Integer&gt; values;<br /><br />    public RandomIntegers(Collection&lt;Integer&gt; values) {<br />        this.values = ImmutableList.copyOf(values);<br />    }<br /><br />    @Override<br />    public Integer get(int index) {<br />        return values.get(index);<br />    }<br /><br />    @Override<br />    public int size() {<br />        return values.size();<br />    }<br /><br />    public RandomIntegers take(int n) {<br />        return new RandomIntegers(values.subList(0, n));<br />    }<br /><br />    public RandomIntegers drop(int n) {<br />        return new RandomIntegers(values.subList(n, values.size()));<br />    }<br />}<br /></pre>This immutable value object has two extra methods <code>take(n)</code> and <code>drop(n)</code> to split it. We will use them in the future. To avoid unexpected latency and manage errors we wrap client inside <a href="https://github.com/Netflix/Hystrix">Hystrix</a> command:<br /><br /><pre class="brush: java">public class GenerateIntegersCmd extends HystrixCommand&lt;RandomIntegers&gt; {<br /><br />    private final RandomOrgClient randomOrgClient;<br />    private final int howMany;<br /><br />    public GenerateIntegersCmd(RandomOrgClient randomOrgClient, int howMany) {<br />        super(Setter<br />                        .withGroupKey(asKey("random.org"))<br />                        .andCommandKey(HystrixCommandKey.Factory.asKey("generateIntegers"))<br />                        .andThreadPoolPropertiesDefaults(<br />                                HystrixThreadPoolProperties.Setter()<br />                                        .withCoreSize(100)<br />                                        .withMaxQueueSize(100)<br />                                        .withQueueSizeRejectionThreshold(100))<br />                        .andCommandPropertiesDefaults(<br />                                HystrixCommandProperties.Setter()<br />                                        .withExecutionIsolationThreadTimeoutInMilliseconds(2000))<br />        );<br />        this.randomOrgClient = randomOrgClient;<br />        this.howMany = howMany;<br />    }<br /><br />    @Override<br />    protected RandomIntegers run() throws Exception {<br />        return randomOrgClient.generateIntegers(howMany);<br />    }<br /><br />}<br /></pre>We use an enormously big thread pool (100), Netflix <a href="https://github.com/Netflix/Hystrix/wiki/Configuration#ThreadPool">claims 10-20 is enough in their cases</a>, we'll see later how to fix it. Now imagine we have a simple endpoint that needs to call this API on each request:<br /><br /><pre class="brush: java">@RestController<br />public class RandomController {<br /><br />    private final RandomOrgClient randomOrgClient;<br /><br />    @Inject<br />    public RandomController(RandomOrgClient randomOrgClient) {<br />        this.randomOrgClient = randomOrgClient;<br />    }<br /><br />    @RequestMapping("/{howMany}")<br />    public String random(@PathVariable("howMany") int howMany) {<br />        final HystrixExecutable&lt;RandomIntegers&gt; generateIntsCmd = <br />            new GenerateIntegersCmd(randomOrgClient, howMany);<br />        final RandomIntegers response = generateIntsCmd.execute();<br />        return response.toString();<br />    }<br /><br />}<br /></pre>Now imagine <code>random.org</code> has an average of 500 ms latency (totally made up number, see <a href="http://stats.pingdom.com/1nxq7ngmup85/931078">here</a> for real data). When load testing our simple application with 100 clients we can expect about 200 transactions per second with half a second average response time:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-q23DcEWYdKs/VIDXiSmSWuI/AAAAAAAABMM/WQ1trLG87s0/s1600/tps.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-q23DcEWYdKs/VIDXiSmSWuI/AAAAAAAABMM/WQ1trLG87s0/s1600/tps.png" height="315" width="640" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-FK9GzXTqxOQ/VIDXh-We4jI/AAAAAAAABME/yfPfECOeYpc/s1600/rt.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-FK9GzXTqxOQ/VIDXh-We4jI/AAAAAAAABME/yfPfECOeYpc/s1600/rt.png" height="316" width="640" /></a></div><br />Collapsing (batching) is about collecting similar small requests into one bigger. This reduces downstream dependencies' load and network traffic. However this feature comes at a price of increased transaction time because before calling <code>random.org</code> directly we must now wait a bit, just in case some other client wants to call <code>random.org</code> at the same time. The first step to batch requests is to implement <code>HystrixCollapser</code>:<br /><br /><pre class="brush: java">public class GenerateIntegersCollapser extends HystrixCollapser&lt;RandomIntegers, RandomIntegers, Integer&gt; {<br /><br />    private final int howMany;<br />    private final RandomOrgClient randomOrgClient;<br /><br />    public GenerateIntegersCollapser(RandomOrgClient randomOrgClient, int howMany) {<br />        super(withCollapserKey(HystrixCollapserKey.Factory.asKey("generateIntegers"))<br />                .andCollapserPropertiesDefaults(Setter().withTimerDelayInMilliseconds(100))<br />                .andScope(Scope.GLOBAL));<br />        this.howMany = howMany;<br />        this.randomOrgClient = randomOrgClient;<br />    }<br /><br />    @Override<br />    public Integer getRequestArgument() {<br />        return howMany;<br />    }<br /><br />    @Override<br />    protected HystrixCommand&lt;RandomIntegers&gt; createCommand(Collection&lt;CollapsedRequest&lt;RandomIntegers, Integer&gt;&gt; collapsedRequests) {<br />        final int totalHowMany = collapsedRequests<br />                .stream()<br />                .mapToInt(CollapsedRequest::getArgument)<br />                .sum();<br />        return new GenerateIntegersCmd(randomOrgClient, totalHowMany);<br />    }<br /><br />    @Override<br />    protected void mapResponseToRequests(RandomIntegers batchResponse, Collection&lt;CollapsedRequest&lt;RandomIntegers, Integer&gt;&gt; collapsedRequests) {<br />        RandomIntegers ints = batchResponse;<br />        for (CollapsedRequest&lt;RandomIntegers, Integer&gt; curRequest : collapsedRequests) {<br />            final int count = curRequest.getArgument();<br />            curRequest.setResponse(ints.take(count));<br />            ints = ints.drop(count);<br />        }<br />    }<br />}<br /></pre><code>GenerateIntegersCollapser</code> is used twice in Hystrix - first when a bunch of requests come in at roughly the same time. After configured window (100 ms in our example) all requests are taken together and Hystrix asks us to create one batch command (see: <code>createCommand()</code>). All we do is calculate how many random integers we need in total and ask for all of them in one go. Second time <code>GenerateIntegersCollapser</code> is used when batch response arrives and we need to split it back into individual, small requests. That's the responsibility of <code>mapResponseToRequests()</code>. See how we chop <code>batchResponse</code> into smaller pieces? First I used mind-bending implementation with <code>reduce</code> just to avoid mutability:<br /><br /><pre class="brush: java">collapsedRequests.stream().reduce(batchResponse, (leftInBatch, curRequest) -&gt; {<br />    final int count = curRequest.getArgument();<br />    curRequest.setResponse(leftInBatch.take(count));<br />    return leftInBatch.drop(count);<br />}, (x, y) -&gt; {throw new UnsupportedOperationException("combiner not needed");});<br /></pre>This variant of <code>Stream.reduce()</code> is roughly equivalent to <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.TraversableOnce"><code>TraversableOnce</code>.<code>aggregate</code> <code>(z: ⇒ B)</code> <code>(seqop: (B, A) ⇒ B,</code> <code>combop: (B, B) ⇒ B):</code> <code>B)</code> in Scala</a>. But I have a problem with this <em>smarty pants</em> functional style - it's  harder to read, isn't shorter and requires <code>combiner</code> parameter, that isn't even used in single thread (but API requires it...) So let's stick to simplicity over cleverness.<br /><br />One last remark is <code>Scope.GLOBAL</code>. Without it collapsing would work only within one thread, e.g. HTTP request, rather than across the whole application. We definitely want global collapsing. Having collapser in place we can use it instead of normal command:<br /><br /><pre class="brush: java">final HystrixExecutable&lt;RandomIntegers&gt; generateIntsCollapser = <br />    new GenerateIntegersCollapser(randomOrgClient, howMany);<br />final RandomIntegers response = generateIntsCollapser.execute();<br /></pre>So not much changes from client code perspective. Now let's benchmark a bit:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-h_OgoA9GqLY/VIDXhYnx0ZI/AAAAAAAABL8/CHIssGNUcyI/s1600/rt-100.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-h_OgoA9GqLY/VIDXhYnx0ZI/AAAAAAAABL8/CHIssGNUcyI/s1600/rt-100.png" height="316" width="640" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-EzrQE0nUTAY/VIDXiCSmhJI/AAAAAAAABMI/ZEkGBOU0Sa4/s1600/tps-100.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-EzrQE0nUTAY/VIDXiCSmhJI/AAAAAAAABMI/ZEkGBOU0Sa4/s1600/tps-100.png" height="316" width="640" /></a></div><br />Ouch, this is quite disappointing. Average response time grew from 500 to 600 milliseconds. At the same time throughput measured in transactions per second (<em>TPS</em>, generated by 100 concurrent threads) dropped to about 160-170/s with significant variance. These numbers shouldn't really come as a surprise - enabling batching requires almost every request to wait a little bit, just in case another request comes by in the nearest future. Less stable measurements are also understandable - latency of each individual request depends on whether the collapsing window just opened or is about to close. OK, so what's the big deal, why do we bother with collapsing? Remember previous example - with 200 TPS we made 200 network calls and requests to external service. 100 concurrent clients meant 100 concurrent requests to backing service. The biggest win of batching/collapsing is reduction of downstream load, generated by our code. It means we put less load on our dependencies and flatten peaks. Just compare the number of queries we made to <code>random.org</code> API with and without batching:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-tGPgs2k4v44/VIDXhWdKxMI/AAAAAAAABMA/JtCVa7AVYRE/s1600/qps-100.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-tGPgs2k4v44/VIDXhWdKxMI/AAAAAAAABMA/JtCVa7AVYRE/s1600/qps-100.png" height="346" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-NeCZrVhrpDE/VIDXhbxD0JI/AAAAAAAABL4/bUvyvL_dBnI/s1600/qps.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-NeCZrVhrpDE/VIDXhbxD0JI/AAAAAAAABL4/bUvyvL_dBnI/s1600/qps.png" height="346" width="640" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><br /></div>200 requests (each asking for one random number) collapsed into 5-7 requests per second, however much larger in size - on average asking for about 30 random numbers rather than... one. It means within 100 millisecond window we captured about 30 requests and collapsed them together. And this, my dear friends, is a big improvement. We sacrificed our performance slightly to reduce generated traffic by an order of magnitude. Of course 100 millisecond batch window is quite extreme, but even 10 milliseconds (barely noticeable under normal circumstances) significantly reduces generated load to about 20 queries per second (rather than 200). This experiment shows that even 10 millisecond window captures (on average) 9 individual requests and collapses them, reducing downstream load. So collapsing is very powerful, just remember what type of optimization you really want to achieve.<br /><br /><script>SyntaxHighlighter.highlight();</script>