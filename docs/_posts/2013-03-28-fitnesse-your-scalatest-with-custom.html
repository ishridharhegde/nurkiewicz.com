---
layout: post
title: FitNesse your ScalaTest with custom Scala DSL
date: '2013-03-28T17:36:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- dsl
- testing
- scala
- scalatest
modified_time: '2015-11-12T13:24:43.623+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1022741925102059873
blogger_orig_url: https://www.nurkiewicz.com/2013/03/fitnesse-your-scalatest-with-custom.html
---

This article won't be about <a href="http://fitnesse.org/">FitNesse</a>. As matter of fact I don't like this tool very much and it seems to be loosing momentum, judging by the traffic on an <a href="http://tech.groups.yahoo.com/group/fitnesse/">official mailing list</a>. Instead we will implement trivial <a href="http://martinfowler.com/bliki/InternalDslStyle.html">internal DSL</a> on top of Scala to simplify testing code, inspired by <a href="http://fitnesse.org/FitNesse.UserGuide.FixtureGallery.FitLibraryFixtures.DoFixture"><code>DoFixture</code></a>. <code>DoFixture</code> in FitNesse allows one to write very readable acceptance tests almost in plain English using Wiki pages:<br /><br /><pre class="brush: plain">!|CarRegistrationFixtureTest|<br /><br />!1 Registering car<br />!2 Registering brand new car for the first time<br /><br />| register | brand new car | by | any owner | in | any country |<br /></pre>What might not be obvious is that the last line is actually executable and calls good old Java (or Scala for that matter) method:<br /><br /><pre class="brush: scala">class CarRegistrationFixtureTest extends DoFixture {<br /><br />    val carService = new CarService<br /><br />    def registerByIn(car: Car, owner: Owner, where: Country) = {<br />        //...<br />    }<br /><br />}<br /></pre>Notice how oddly named <code>registerByIn</code> method maps to "<i> <b>register</b> brand new car <b>by</b> any owner <b>in</b> any country</i>" wiki syntax.  What we will learn today is writing very simple, custom Scala DSL that is even more readable and does not require new tool and testing framework.<br /><br />The same test written in <a href="http://www.scalatest.org/">ScalaTest</a> would look something like this:<br /><br /><a name='more'></a><br /><br /><pre class="brush: scala">class CarRegistrationSpec extends FeatureSpec with GivenWhenThen {<br /><br />    val carService = new CarService()<br /><br />    feature("Registering car") {<br /><br />        scenario("Registering brand new car for the first time") {<br />            Given("Owner and brand new car")<br />            //...<br /><br />            When("Car registered")<br />            carService.registerCar(brandNewCar, anyOwner, anyCountry)<br /><br />            //...<br />        }<br />    }<br />}<br /></pre>Nothing fancy, ordinary <code>registerCar()</code> method call. The rest of the test (as well as the declaration of <code>brandNewCar</code>, <code>anyOwner</code> and <code>anyCountry</code>) is not relevant to our discussion. We can make it a little bit more readable by explicitly naming parameters:<br /><br /><pre class="brush: scala">carService.registerCar(car = brandNewCar, owner = anyOwner, where = anyCountry)<br /></pre>However it's not clear whether this is actually more readable for e.g. non-programmers. But since we already use descriptive <a href="http://www.scalatest.org/getting_started_with_feature_spec"><code>FeatureSpec</code></a>, can we make Scala code a little bit more human eye-friendly? Of course! Our biggest friends are <a href="http://docs.scala-lang.org/style/method-invocation.html">infix notation</a> and <a href="http://en.wikipedia.org/wiki/Fluent_interface">fluent API</a> pattern:<br /><br /><pre class="brush: scala">def register(car: Car) = new {<br />    def by(owner: Owner) = new {<br />        def in(country: Country) =<br />            carService.registerCar(car, owner, country)<br />    }<br />}<br /></pre>Looks weird, but put this code in your test and enjoy much more fluent call:<br /><br /><pre class="brush: scala">register(brandNewCar).by(anyOwner).in(anyCountry)<br /></pre>This is as far as Java can go, but Scala has infix method call syntax, which is equivalent and looks beautiful:<br /><br /><pre class="brush: scala">register(brandNewCar) by anyOwner in anyCountry<br /></pre>Why couldn't we skip first parentheses? It is a limitation on where infix notation can be used (only one-argument method calls on an object). Fortunately we can easily refactor our internal testing DSL by pushing noun (<i>owner</i>) onto first place and using implicit conversion:<br /><br /><pre class="brush: scala">implicit def fluentCarRegister(owner: Owner) = new {<br />    def registers(car: Car) = new {<br />        def in(country: Country) =<br />            carService.registerCar(car, owner, country)<br />    }<br />}<br /></pre>...which can be used as follows:<br /><br /><pre class="brush: scala">anyOwner registers brandNewCar in anyCountry<br /></pre>If you got lost, the line of code above is still Scala and is still executable. If you don't quite get what's happening, here is a <i>desugared</i> syntax:<br /><br /><pre class="brush: scala">fluentCarRegister(anyOwner).registers(brandNewCar).in(anyCountry)<br /></pre>Tests are all about readability and maintainability. Many people are scared of DSLs because often they are hard to implement and debug. As I showed in this short article, writing really simple yet impressive test DSL in Scala is both simple and rewarding. Moreover there is no reflection or magic meta-programming.  <script>SyntaxHighlighter.highlight();</script>