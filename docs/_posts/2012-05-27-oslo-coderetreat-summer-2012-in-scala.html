---
layout: post
title: Oslo coderetreat summer 2012 - in Scala
date: '2012-05-27T23:58:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- testing
- scala
- coderetreat
- tdd
modified_time: '2012-05-28T15:10:10.614+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7083859418549730440
blogger_orig_url: https://www.nurkiewicz.com/2012/05/oslo-coderetreat-summer-2012-in-scala.html
---

Few days ago I had a pleasure to attend <a href="http://www.meetup.com/OsloCodingDojo/events/63387912/">Coderetreat summer 2012</a> in Oslo, carried out by <a href="http://johannesbrodwall.com/">Johannes Brodwall</a>. It was a great experience, I had an opportunity to do some pair programming with six different people and learnt quite a lot about both programming and productivity. You can find some more thoughts about the event on <a href="http://andersnordby.wordpress.com/2012/05/21/coderetreat-summer-2012/">Anders Nordby's article</a> (+ C# implementation of the problem we were solving throughout the day).<br /><br />So what was the problem? Suspiciously simple: develop a function taking an arbitrary character and printing a diamond-shape like this:<br /><br /><pre class="brush: scala">test("should generate A diamond") {<br />  diamond('A') should equal (List(<br />    "A"<br />  ))<br />}<br /><br />test("should generate D diamond") {<br />  diamond('D') should equal (List(<br />    "   A   ",<br />    "  B B  ",<br />    " C   C ",<br />    "D     D",<br />    " C   C ",<br />    "  B B  ",<br />    "   A   "<br />  ))<br />}<br /></pre>The first approach all of us tried was a terrible mixture of <code>for</code> loops, counting spaces (nasty off-by-one "error generators" like <code>- 1</code>, <code>+ 1</code>, <code>* 2 - 1</code> all over the place and plenty of special cases. With every subsequent iteration we were discovering (often with a help from the coderetreat host) how this problem can be solved in various different ways. I would like to share my thoughts about how we managed to squeeze the code in 3 times less lines, while increasing the readability.<br /><br /><i>[I encourage you to stop right now and try implementing this simple program yourself in the language of choice. I programmed in Java, Groovy, C#, Scala - and passively paired with a person doing it in Clojure]</i><br /><br />...<br /><br /><a name='more'></a>The first advice given to us was to exploit the symmetry. If you look closely the desired diamond shape has two axes of symmetry - horizontal and vertical. What about simply drawing one quarter only and then mirroring it along two axes? We first need a helper function to perform mirroring. If we are lucky enough it should work on both sequences of strings (each string representing one line) and a single string, treated as a sequence of characters. Here are some test cases (we practiced TDD a lot):<br /><br /><pre class="brush: scala">test("should mirror array") {<br />  mirror("abcd") should equal ("abcdcba")<br />  mirror(List("abc", "def")) should equal (List("abc", "def", "abc"))<br />  mirror(List("abc", "def", "ghi")) should equal (List("abc", "def", "ghi", "def", "abc"))<br />}<br /><br />test("should do nothing when input has only one element") {<br />  mirror("a") should equal ("a")<br />  mirror(List("abc")) should equal (List("abc"))<br />}<br /></pre>My first na√Øve implementation was not sufficient:<br /><br /><pre class="brush: scala">def mirror[T](seq: Seq[T]): Seq[T] =<br />  seq ++ seq.reverse.tail<br /></pre>It was semantically correct and accepted both <code>Seq[String]</code> and <code>String</code> alone (treated as <code>Seq[Char]</code>). But that was the problem - the result of <code>mirror("abcd")</code> was a <code>Vector[Char]</code> rather than a <code>String</code>. The method was semantically correct but I wasn't capable of forcing it to return strongly typed string. So I asked about <a href="http://stackoverflow.com/questions/10689161">Method taking Seq[T] to return String rather than Seq[Char]</a> and minutes later got a terrifying answer:<br /><br /><pre class="brush: scala">def mirror[CC, A, That](seq: CC)(implicit asSeq: CC =&gt; Seq[A], cbf: CanBuildFrom[CC, A, That]): That = {<br />  val b = cbf(seq)<br />  b ++= seq ++ seq.reverse.tail<br />  b.result()<br />}<br /></pre>You know what? It works! If I call <code>mirror(List("abc", "def"))</code> I get <code>List[String]</code> in return. But if I call <code>mirror("abc")</code> the type of the method is <code>String</code>. Type safe, brilliant and frightening...<br /><br />Having the <code>mirror()</code> function in place we need a second one to actually draw the diamond quarter. This function can be described with the following test cases:<br /><br /><pre class="brush: scala">test("should print first quarter for 'A'") {<br />  quarter('A') should equal (List(<br />    "A"<br />  ))<br />}<br /><br />test("should print first quarter for 'D'") {<br />  quarter('D') should equal (List(<br />    "   A",<br />    "  B ",<br />    " C  ",<br />    "D   "<br />  ))<br />}<br /></pre>The <code>quarter</code> is not the cleanest implementation, but wait for the second approach!<br /><br /><pre class="brush: scala">def quarter(c: Char) = {<br />  val alphabetPos = c - 'A'<br />  (0 to alphabetPos) map { row =&gt;<br />    val curChar = ('A' + row).toChar<br />    (" " * (alphabetPos - row)) + curChar + (" " * row)<br />  }<br />}<br /></pre>This approach takes advantage of handy <code>"A" * 3 == "AAA"</code> construct in Scala. Having <code>quarter</code> and <code>mirror</code> methods do you know how to construct the <code>diamond()</code> method? It is beautifully simply:<br /><br /><pre class="brush: scala">def diamond(c: Char) =<br />  mirror(quarter(c)) map {mirror(_)}<br /></pre>We first generate one qurter (north-west) and mirror it to generate south-west piece. Then we mirror each and every line to generate eastern copies. That's it! BTW wondering why I didn't simply wrote <code>mirror(quarter(c)) map mirror</code>? See <a href="http://stackoverflow.com/questions/10774284">this</a>.<br /><br />The second approach suggested to us was even more intriguing. When looking at the diamond shape we can clearly see it can be defined in terms of geometry. By iterating over all possible points and examining whether they belong to the desired shape we end up with extremely compact implementation:<br /><br /><pre class="brush: scala; highlight: 6">def diamond2(c: Char) {<br />  val radius = c - 'A'<br /><br />  (-radius to radius) foreach {y =&gt;<br />    (-radius to radius) foreach {x =&gt;<br />      if (x.abs + y.abs == radius) {<br />        print(('A' + x.abs).toChar)<br />      } else {<br />        print(" ")<br />      }<br />    }<br />    println()<br />  }<br />}<br /></pre>The condition inside the loop is crucial - it defines whether a given point should be empty or contain a character. And since it is so simple, why not extract it and allow the client code to define any condition?<br /><br /><pre class="brush: scala; highlight: 6">def diamond(c: Char, predicate: (Int, Int, Int) =&gt; Boolean) {<br />  val radius = c - 'A'<br /><br />  (-radius to radius) foreach {y =&gt;<br />    (-radius to radius) foreach {x =&gt;<br />      if (predicate(x, y, radius)) {<br />        print(('A' + x.abs).toChar)<br />      } else {<br />        print(" ")<br />      }<br />    }<br />    println()<br />  }<br />}<br /></pre>We can now draw ellipses and other shapes in no time by simply passing different <code>predicate</code> functions:<br /><br /><pre class="brush: scala">diamond('P', (x, y, radius) =&gt; x.abs + y.abs == radius)<br />diamond('P', (x, y, radius) =&gt; math.sqrt(x * x + y * y - radius * radius) &lt; 6)<br />diamond('P', (x, y, radius) =&gt; x.abs == y.abs)<br /><br />               A               <br />              B B              <br />             C   C             <br />            D     D            <br />           E       E           <br />          F         F          <br />         G           G         <br />        H             H        <br />       I               I       <br />      J                 J      <br />     K                   K     <br />    L                     L    <br />   M                       M   <br />  N                         N  <br /> O                           O <br />P                             P<br /> O                           O <br />  N                         N  <br />   M                       M   <br />    L                     L    <br />     K                   K     <br />      J                 J      <br />       I               I       <br />        H             H        <br />         G           G         <br />          F         F          <br />           E       E           <br />            D     D            <br />             C   C             <br />              B B              <br />               A               <br /><br />          FEDCBABCDEF          <br />       IHG           GHI       <br />      JI               IJ      <br />     KJ                 JK     <br />    L                     L    <br />   M                       M   <br />  NM                       MN  <br /> ON                         NO <br /> O                           O <br /> O                           O <br />P                             P<br />P                             P<br />P                             P<br />P                             P<br />P                             P<br />P                             P<br />P                             P<br />P                             P<br />P                             P<br />P                             P<br />P                             P<br /> O                           O <br /> O                           O <br /> ON                         NO <br />  NM                       MN  <br />   M                       M   <br />    L                     L    <br />     KJ                 JK     <br />      JI               IJ      <br />       IHG           GHI       <br />          FEDCBABCDEF          <br /><br />P                             P<br /> O                           O <br />  N                         N  <br />   M                       M   <br />    L                     L    <br />     K                   K     <br />      J                 J      <br />       I               I       <br />        H             H        <br />         G           G         <br />          F         F          <br />           E       E           <br />            D     D            <br />             C   C             <br />              B B              <br />               A               <br />              B B              <br />             C   C             <br />            D     D            <br />           E       E           <br />          F         F          <br />         G           G         <br />        H             H        <br />       I               I       <br />      J                 J      <br />     K                   K     <br />    L                     L    <br />   M                       M   <br />  N                         N  <br /> O                           O <br />P                             P<br /></pre>I think the most important lesson for me was to fully understand the problem and explore as many different approaches as possible. As long as we were focused on console, spaces and lines, the implementations were very clumsy and complicated. Once we discovered what the problem really was, understood the problem domain, it became much easier to implement. And the full minified implementation (in Scala) <a href="https://twitter.com/tnurkiewicz/status/206862519309058048">fits one Twitter message!</a> (127 chars).<br /><br /><pre class="brush: scala"><br />def d(c:Char){val r=c-65;-r to r foreach{y=>(-r to r)foreach{x=>print((if(x.abs+y.abs==r)65+x.abs else 32).toChar)};println()}}<br /></pre>