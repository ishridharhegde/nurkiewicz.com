---
layout: post
title: Asynchronous timeouts with CompletableFuture
date: '2014-12-27T22:24:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- CompletableFuture
- java8
- multithreading
modified_time: '2015-11-29T23:37:40.369+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-141775687551418776
blogger_orig_url: https://www.nurkiewicz.com/2014/12/asynchronous-timeouts-with.html
---

One day I was rewriting poorly implemented multi-threaded code that was blocking at some point on <code>Future.get()</code>:<br/><br/><pre class="brush: java">public void serve() throws InterruptedException, ExecutionException, TimeoutException {<br />    final Future&lt;Response&gt; responseFuture = asyncCode();<br />    final Response response = responseFuture.get(1, SECONDS);<br />    send(response);<br />}<br /><br />private void send(Response response) {<br />    //...<br />}<br /></pre> This was actually an Akka application written in Java with a thread pool of 1000 threads (sic!) - all of them blocked on this <code>get()</code> call. Otherwise system couldn't keep up with the number of concurrent requests. After refactoring we got rid of all these threads and introduced just one, significantly reducing memory footprint. Let's simplify a bit and show examples in Java 8. The first step is to introduce <code>CompletableFuture</code> instead of plain <code>Future</code> (see: <a href="http://www.nurkiewicz.com/2014/11/executorservice-10-tips-and-tricks.html">tip 9</a>). It's simple if:<br/><br/><ul><li>you control how tasks are submitted to <code>ExecutorService</code>: just use <code>CompletableFuture.supplyAsync(..., executorService)</code> instead of <code>executorService.submit(...)</code></li><li>you deal with callback-based API: use promises</li></ul>Otherwise (if you have blocking API or <code>Future&lt;T&gt;</code> already) there will be some thread blocked. That's why there are so many asynchronous APIs being born right now. So let's say we somehow rewritten our code to receive <code>CompletableFuture</code>:<br/><br/><pre class="brush: java">public void serve() throws InterruptedException, ExecutionException, TimeoutException {<br />    final CompletableFuture&lt;Response&gt; responseFuture = asyncCode();<br />    final Response response = responseFuture.get(1, SECONDS);<br />    send(response);<br />}<br /></pre> Obviously that doesn't fix anything, we have to take advantage of new reactive style of programming:<br/><br/><pre class="brush: java">public void serve() {<br />    final CompletableFuture&lt;Response&gt; responseFuture = asyncCode();<br />    responseFuture.thenAccept(this::send);<br />}<br /></pre> This is functionally equivalent, but now <code>serve()</code> should run in no-time (no blocking or waiting). Just remember that <code>this::send</code> will be executed in the same thread that completed <code>responseFuture</code>. If you don't want to overload some arbitrary thread pool somewhere or <code>send()</code> is expensive, consider separate thread pool for that: <code>thenAcceptAsync(this::send, sendPool)</code>. Great, but we lost two important properties: error propagation and timeout. Error propagation is hard because we changed API. When <code>serve()</code> method exits, asynchronous operations is probably not yet finished. If you care about exceptions, consider either returning <code>responseFuture</code> or some alternative mechanism. At minimum, log exception because otherwise it will be swallowed:<br/><br/><pre class="brush: java">final CompletableFuture&lt;Response&gt; responseFuture = asyncCode();<br />responseFuture.exceptionally(throwable -&gt; {<br />    log.error(&quot;Unrecoverable error&quot;, throwable);<br />    return null;<br />});<br />responseFuture.thenAccept(this::send);<br /></pre> Be careful with the code above: <code>exceptionally()</code> tries to <em>recover</em> from failure, returning alternative result. It works here but if you chain <code>exceptionally()</code> with <code>thenAccept()</code> it will <code>send()</code> will be called even in case of failure, but with <code>null</code> argument (or whatever we return from <code>exceptionally()</code>:<br/><br/><pre class="brush: java">final CompletableFuture&lt;Response&gt; responseFuture = asyncCode();<br />responseFuture<br />    .exceptionally(throwable -&gt; {<br />        log.error(&quot;Unrecoverable error&quot;, throwable);<br />        return null;<br />    })<br />    .thenAccept(this::send);  //probably not what you think<br /></pre> Problem with lost 1 second timeout is subtle. Our original code was waiting (blocking) for at most 1 second until <code>Future</code> finishes. Otherwise <code>TimeoutException</code> was thrown. We lost this functionality, even worse unit tests for timeouts are inconvenient and often skipped. In order to port timeouts without sacrificing event-driven spirit we need one extra building block: a future that always fails after a given time:<br/><br/><pre class="brush: java">public static &lt;T&gt; CompletableFuture&lt;T&gt; failAfter(Duration duration) {<br />    final CompletableFuture&lt;T&gt; promise = new CompletableFuture&lt;&gt;();<br />    scheduler.schedule(() -&gt; {<br />        final TimeoutException ex = new TimeoutException(&quot;Timeout after &quot; + duration);<br />        return promise.completeExceptionally(ex);<br />    }, duration.toMillis(), MILLISECONDS);<br />    return promise;<br />}<br /><br />private static final ScheduledExecutorService scheduler =<br />        Executors.newScheduledThreadPool(<br />                1,<br />                new ThreadFactoryBuilder()<br />                        .setDaemon(true)<br />                        .setNameFormat(&quot;failAfter-%d&quot;)<br />                        .build());<br /></pre> That's simple: we create a <em>promise</em> (future without underlying task or thread pool) and complete it with <code>TimeoutException</code> after a given <code>java.time.Duration</code>. If you <code>get()</code> such future somewhere, <code>TimeoutException</code> will be thrown after blocking for at least that much time. Actually, it will be <code>ExecutionException</code> wrapping <code>TimeoutException</code>, no way around that. Notice that I use fixed <code>scheduler</code> thread pool with just one thread. It's not only for educational purposes: &quot;<em>1 thread ought to be enough for anybody</em>&quot; <sup><a href="http://en.wikiquote.org/wiki/Bill_Gates">[1]</a></sup> in this scenario. <code>failAfter()</code> on its own is rather useless, but combine it with our <code>responseFuture</code> and we have a solution!<br/><br/><pre class="brush: java">final CompletableFuture&lt;Response&gt; responseFuture = asyncCode();<br />final CompletableFuture&lt;Response&gt; oneSecondTimeout = failAfter(Duration.ofSeconds(1));<br />responseFuture<br />        .acceptEither(oneSecondTimeout, this::send)<br />        .exceptionally(throwable -&gt; {<br />            log.error(&quot;Problem&quot;, throwable);<br />            return null;<br />        });<br /></pre> A lot is going on here. After receiving <code>responseFuture</code> with our background task we also create &quot;synthetic&quot; <code>oneSecondTimeout</code> future that will never complete successfully but always fails after 1 second. Now we combine the two by calling <code>acceptEither</code>. This operator will execute block of code against first completed future, either <code>responseFuture</code> or <code>oneSecondTimeout</code> and simply ignore outcome of the slower one. If <code>asyncCode()</code> completes within 1 second <code>this::send</code> will be invoked and exception from <code>oneSecondTimeout</code> will get ignored. However! If <code>asyncCode()</code> is really slow, <code>oneSecondTimeout</code> kicks in first. But since it fails with an exception, <code>exceptionally</code> error handler is invoked instead of <code>this::send</code>. You can take for granted that either <code>send()</code> or <code>exceptionally</code> will be called, not both. Of course if we had two &quot;ordinary&quot; futures completing normally, <code>send()</code> would be called with a response from the first one, discarding the latter.<br/><br/>This wasn't the cleanest solution. Cleaner one would wrap original future and make sure it finishes within given time. Such operator is available in <a href="https://twitter.github.io/util/docs/#com.twitter.util.Future"><code>com.twitter.util.Future</code></a> (Scala; called <code>within()</code>), however is missing in <a href="http://www.scala-lang.org/files/archive/nightly/docs/library/index.html#scala.concurrent.Future"><code>scala.concurrent.Future</code></a> (supposedly inspired by the former). Let's leave Scala behind and implement similar operator for <code>CompletableFuture</code>. It takes one future as input and returns a future that completes when underlying one is completed. However if it takes too long to complete the underlying future, exception is thrown:<br/><br/><pre class="brush: java">public static &lt;T&gt; CompletableFuture&lt;T&gt; within(CompletableFuture&lt;T&gt; future, Duration duration) {<br />    final CompletableFuture&lt;T&gt; timeout = failAfter(duration);<br />    return future.applyToEither(timeout, Function.identity());<br />}<br /></pre> This leads to final, clean and flexible solution:<br/><br/><pre class="brush: java">final CompletableFuture&lt;Response&gt; responseFuture = within(<br />        asyncCode(), Duration.ofSeconds(1));<br />responseFuture<br />        .thenAccept(this::send)<br />        .exceptionally(throwable -&gt; {<br />            log.error(&quot;Unrecoverable error&quot;, throwable);<br />            return null;<br />        });<br /></pre> Hope you enjoyed this article, as you can see reactive programming in Java is no longer a thing of the <em>future</em> (no pun intended).<br/><br/> <script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script> <script>SyntaxHighlighter.highlight();</script>