---
layout: post
title: Non-blocking I/O - discovering Akka
date: '2012-11-06T18:42:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- akka
- scala
modified_time: '2012-11-06T22:45:47.946+01:00'
thumbnail: http://2.bp.blogspot.com/-b0Qdcbe3pKo/UJlJyGJN7VI/AAAAAAAAAqM/U5TAOIQhaVw/s72-c/100_8104.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-977466812599275646
blogger_orig_url: https://www.nurkiewicz.com/2012/11/non-blocking-io-discovering-akka.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-b0Qdcbe3pKo/UJlJyGJN7VI/AAAAAAAAAqM/U5TAOIQhaVw/s1600/100_8104.JPG" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://2.bp.blogspot.com/-b0Qdcbe3pKo/UJlJyGJN7VI/AAAAAAAAAqM/U5TAOIQhaVw/s320/100_8104.JPG" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Waterfall on Akerselva</td></tr></tbody></table>Here comes the time to follow some good practices when implementing actors. One of the most important rules we should follow is avoiding any blocking input/output operations, polling, busy waiting, sleeping, etc. Simply put, actor while handling a message should only depend on CPU and if it doesn't need CPU cycles it should immediately return from <code>receive</code> and let other actors to process. If we follow this rule strictly, Akka can easily handle hundreds of thousands of messages per second using just a handful of threads. It shouldn't come as a surprise that even though our application can comprise thousands of seemingly independent actors (e.g. one actor per each HTTP connection, one player in MMO game, etc.), each actor gets only a limited CPU time within a pool of threads. With default 10 threads handling all the actors in the system, one blocking or sleeping actor is enough to reduce the throughput by 10%. Therefore 10 actors sleeping at the same time completely halt the system.<br /><br />For that reason calling <code>sleep()</code> or actively waiting for a response from some other actor is highly discouraged within <code>receive</code>. Unfortunately there is no mature asynchronous library equivalent to JDBC (but watch <a href="https://github.com/mauricio/postgresql-netty">postgresql-netty</a>, <a href="http://code.google.com/p/adbcj/">adbcj</a>, <a href="http://code.google.com/p/async-mysql-connector/">async-mysql-connector</a> and also related: <a href="http://www.allanbank.com/mongodb-async-driver/">mongodb-async-driver</a>) and using NIO is rather problematic. But we should seek for alternatives and avoid blocking code whenever possible. In <a href="http://nurkiewicz.blogspot.no/2012/11/becomeunbecome-discovering-akka.html">our sample application</a> fetching random numbers from external web service was implemented in quite naive way:<br /><br /><pre class="brush: scala">val url = new URL("https://www.random.org/integers/?num=" + batchSize + "&amp;min=0&amp;max=65535&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new")<br />val connection = url.openConnection()<br />val stream = Source.fromInputStream(connection.getInputStream)<br />sender ! RandomOrgServerResponse(stream.getLines().map(_.toInt).toList)<br />stream.close()<br /></pre>This code blocks waiting for an HTTP reply for <a href="http://nurkiewicz.blogspot.no/2012/10/your-first-message-discovering-akka.html">up to one minute</a>. This means our actor can't handle any other message for several seconds. Moreover it holds one thread (by default out of ten) from Akka worker pool. This pool is suppose to be shared among thousands of actors, so that feels a bit selfish.<br /><br /><a name='more'></a><br /><br />Luckily mature asynchronous HTTP client libraries exist, namely <a href="https://github.com/AsyncHttpClient/async-http-client">async-http-client</a> (based on <a href="https://netty.io/">netty</a>, with <a href="http://dispatch.databinder.net/Dispatch.html">Scala wrapper called Dispatch</a>) and <a href="http://wiki.eclipse.org/Jetty/Tutorial/HttpClient">Jetty HttpClient</a>. For test purposes we'll use the first one (and leave Dispatch for later). API is quite obvious: it asks us for target URL and a callback object, which will be used when reply arrives. Thus sending HTTP request is asynchronous and non-blocking (actor can quickly consume more incoming messages) and the response arrives asynchronously from a different thread:<br /><br /><pre class="brush: scala">implicit def block2completionHandler[T](block: Response =&gt; T) = new AsyncCompletionHandler[T]() {<br />  def onCompleted(response: Response) = block(response)<br />}<br /><br />def receive = {<br />  case FetchFromRandomOrg(batchSize) =&gt;<br />    val curSender = sender<br />    val url = "https://www.random.org/integers/?num=" + batchSize + "&amp;min=0&amp;max=65535&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new"<br />    client.prepareGet(url).execute {<br />      response: Response =&gt;<br />        val numbers = response.getResponseBody.lines.map(_.toInt).toList<br />        curSender ! RandomOrgServerResponse(numbers)<br />    }<br />}<br /></pre>We are very close to really dangerous bug in the code above. Notice how I make a local copy of <code>sender</code> called <code>curSender</code>. If I wouldn't do this, the block of code executed when a response arrives would read <b>current</b> value of <code>sender</code>. <i>Current</i>, that is if our actor was handling some other message at a time, it would point to a sender of that other message. As a side note that's one of the reasons why variables accessed from anonymous inner classes in Java have to be <code>final</code>. It's also a good reason to avoid arbitrary code blocks called asynchronously inside actors. It's much better to extract them to a separate class outside of the actor to avoid accidental access to internal actor state.<br /><br />Let's leave our example for a while. Imagine how scalable our general architecture would be for a general RSS/Atom feed reader as a service. For each feed URL we can create one actor (and we monitor thousands of feeds, thus that many actors). Actor sends an asynchronous request to each site and waits for a response. Theoretically using just one worker thread we can handle thousands of feeds/servers, processing the results on the fly as they come (after all each server has a different response time). In a classic, blocking model we can only process as many feeds concurrently as many threads we can use (certainly not several thousands), not to mention each thread requires significant amount of memory.<br /><br />If you see some similarities to <a href="http://nodejs.org/">node.js</a> you are on the right track. This framework is based entirely on asynchronous I/O, thus being able to handle large amount of concurrent connections using only one (!) thread.<br /><br />Source code for this article is <a href="https://github.com/nurkiewicz/learning-akka">available on GitHub</a> in <a href="https://github.com/nurkiewicz/learning-akka/tree/non-blocking-io"><code>non-blocking-io</code> tag</a>.<br /><br /><blockquote>This was a translation of my article <a href="http://scala.net.pl/poznajemy-akka-nieblokujace-io/">"<i>Poznajemy Akka: nieblokujÄ…ce I/O</i>"</a> originally published on <a href="http://scala.net.pl/">scala.net.pl</a>.</blockquote><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>