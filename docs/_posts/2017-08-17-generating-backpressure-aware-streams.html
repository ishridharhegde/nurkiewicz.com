---
layout: post
title: Generating backpressure-aware streams with Flowable.generate() - RxJava FAQ
date: '2017-08-17T22:57:00.001+02:00'
author: Tomasz Nurkiewicz
tags:
- backpressure
- rxjava
modified_time: '2017-08-17T22:58:55.070+02:00'
thumbnail: https://2.bp.blogspot.com/-UymhpwHleUU/WZYC-Z4kf3I/AAAAAAAAECg/aOfv2Bb-_z8PIQKzoBu4s0FbXulKLFNBgCLcBGAs/s72-c/2016-06-12%2B14.37.11b.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1716158098842612685
blogger_orig_url: https://www.nurkiewicz.com/2017/08/generating-backpressure-aware-streams.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-UymhpwHleUU/WZYC-Z4kf3I/AAAAAAAAECg/aOfv2Bb-_z8PIQKzoBu4s0FbXulKLFNBgCLcBGAs/s1600/2016-06-12%2B14.37.11b.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="900" data-original-width="1600" height="112" src="https://2.bp.blogspot.com/-UymhpwHleUU/WZYC-Z4kf3I/AAAAAAAAECg/aOfv2Bb-_z8PIQKzoBu4s0FbXulKLFNBgCLcBGAs/s200/2016-06-12%2B14.37.11b.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Babia GÃ³ra, Poland</td></tr></tbody></table>RxJava is missing a factory to create an infinite stream of natural numbers. Such a stream is useful e.g. when you want to assign unique sequence numbers to possibly infinite stream of events by zipping both of them:<br /><br /><pre class="brush: java">Flowable&lt;Long&gt; naturalNumbers = //???<br /><br />Flowable&lt;Event&gt; someInfiniteEventStream = //...<br />Flowable&lt;Pair&lt;Long, Event&gt;&gt; sequenced = Flowable.zip(<br />        naturalNumbers,<br />        someInfiniteEventStream,<br />        Pair::of<br />);</pre>Implementing <code>naturalNumbers</code> is surprisingly complex. In RxJava 1.x you could briefly get away with <code>Observable</code> that does not respect backpressure:<br /><br /><pre class="brush: java">import rx.Observable;  //RxJava 1.x<br /><br />Observable&lt;Long&gt; naturalNumbers = Observable.create(subscriber -&gt; {<br />    long state = 0;<br />    //poor solution :-(<br />    while (!subscriber.isUnsubscribed()) {<br />        subscriber.onNext(state++);<br />    }<br />});</pre>What does it mean that such stream is not backpressure-aware? Well, basically the stream produces events (ever-incrementing <code>state</code> variable) as fast as the CPU core permits, millions per second, easily. However when consumers can't consume events so fast, growing backlog of unprocessed events starts to appear:<br /><br /><pre class="brush: java">naturalNumbers<br />//      .observeOn(Schedulers.io())<br />        .subscribe(<br />                x -&gt; {<br />                    //slooow, 1 millisecond<br />                }<br />        );</pre>The program above (with <code>observeOn()</code> operator commented out) runs just fine because it has <em>accidental</em> backpressure. By default everything is single threaded in RxJava, thus producer and consumer work within the same thread. Invoking <code>subscriber.onNext()</code> actually blocks, so the <code>while</code> loop throttles itself automatically. But try uncommenting <code>observeOn()</code> and disaster happens a few milliseconds later. The subscription callback is single-threaded by design. For every element it needs at least 1 millisecond, therefore this stream can process not more than 1000 events per second. We are somewhat lucky. RxJava quickly discovers this disastrous condition and fails fast with <code>MissingBackpressureException</code><br /><br />Our biggest mistake was producing events without taking into account how slow the consumer is. By the way this is the core idea behind <a href="http://www.reactive-streams.org/">reactive streams</a>: producer is not allowed to emit more events than requested by consumer. In RxJava 1.x implementing even the simplest stream that was respecting backpressure from scratch was a non-trivial task. RxJava 2.x brought several convenient operators that built on top of experience from previous versions. First of all RxJava 2.x does not allow you to implement <code>Flowable</code> (backpressure-aware) the same way as you can with <code>Observable</code>. It's not possible to create <code>Flowable</code> that overloads the consumer with messages:<br /><br /><pre class="brush: java">Flowable&lt;Long&gt; naturalNumbers = Flowable.create(subscriber -&gt; {<br />    long state = 0;<br />    while (!subscriber.isCancelled()) {<br />        subscriber.onNext(state++);<br />    }<br />}, BackpressureStrategy.DROP);</pre>Did you spot this extra <code>DROP</code> parameter? Before we explain it, let's see the output when we subscribe with slow consumer:<br /><br /><pre class="brush: java">0<br />1<br />2<br />3<br />//...continuous numbers...<br />126<br />127<br />101811682<br />//...where did my 100M events go?!?<br />101811683<br />101811684<br />101811685<br />//...continuous numbers...<br />101811776<br />//...17M events disappeared again...<br />101811777<br />//...</pre>Your mileage may vary. What happens? The <code>observeOn()</code> operator switches between schedulers (thread pools). A pool of threads that are hydrated from a queue of pending events. This queue is finite and has capacity of 128 elements. <code>observeOn()</code> operator, knowing about this limitation, only requests 128 elements from upstream (our custom <code>Flowable</code>). At this point it lets our subscriber process the events, 1 per millisecond. So after around 100 milliseconds <code>observeOn()</code> discovers its internal queue is almost empty and asks for more. Does it get 128, 129, 130...? No! Our <code>Flowable</code> was producing events like crazy during this 0.1 second period and it (astonishingly) managed to generate more than <strong>100 million</strong> numbers in that time frame. Where did they go? Well, <code>observeOn()</code> was not asking for them so the <code>DROP</code> strategy (a mandatory parameter) simply discarded unwanted events.<br /><br /><h2 id="backpressurestrategy"><code>BackpressureStrategy</code></h2>That doesn't sound right, are there any other strategies? Yes, many:<br /><br /><ul><li><code>BackpressureStrategy.BUFFER</code>: If upstream produces too many events, they are buffered in an unbounded queue. No events are lost, but your whole application most likely is. If you are lucky, <code>OutOfMemoryError</code> will save you. I got stuck on 5+ second long GC pauses.<br /><br /></li><li><code>BackpressureStrategy.ERROR</code>: If over-production of events is discovered, <code>MissingBackpressureException</code> will be thrown. It's a sane (and safe) strategy.<br /><br /></li><li><code>BackpressureStrategy.LATEST</code>: Similar to <code>DROP</code>, but remembers last dropped event. Just in case request for more data comes in but we just dropped everything - we at least have the last seen value.<br /><br /></li><li><code>BackpressureStrategy.MISSING</code>: No safety measures, deal with it. Most likely one of the downstream operators (like <code>observeOn()</code>) will throw <code>MissingBackpressureException</code>.<br /><br /></li><li><code>BackpressureStrategy.DROP</code>: drops events that were not requested.<br /><br /></li></ul>By the way when you are turning an <code>Observable</code> to <code>Flowable</code> you must also provide <code>BackpressureStrategy</code>. RxJava must know how to limit over-producing <code>Observable</code>. OK, so what is the correct implementation of such a simple stream of sequential natural numbers?<br /><br /><h2 id="meet-flowable.generate">Meet <code>Flowable.generate()</code></h2>The difference between <code>create()</code> and <code>generate()</code> lies in responsibility. <code>Flowable.create()</code> is suppose to generate the stream in its entirety with no respect to backpressure. It simply produces events whenever it wishes to do so. <code>Flowable.generate()</code> on the other hand is only allowed to generate one event at a time (or complete a stream). Backpressure mechanism transparently figures out how many events it needs at the moment. <code>generate()</code> is called appropriate number of times, for example 128 times in case of <code>observeOn()</code>.<br /><br />Because this operator produces events one at a time, typically it needs some sort of state to figure out where it was the last time<sup>1</sup>. This is what <code>generate()</code> is: a holder for (im)mutable state and a function that generates next event based on it:<br /><br /><pre class="brush: java">Flowable&lt;Long&gt; naturalNumbers =<br />    Flowable.generate(() -&gt; 0L, (state, emitter) -&gt; {<br />        emitter.onNext(state);<br />        return state + 1;<br />    });</pre>The first argument to <code>generate()</code> is an initial state (factory), <code>0L</code> in our case. Now every time a subscriber or any downstream operator asks for some number of events, the lambda expression is invoked. Its responsibility is to call <code>onNext()</code> at most once (emit at most one event) somehow based on supplied state. When lambda is invoked for the first time the <code>state</code> is equal to initial value <code>0L</code>. However we are allowed to modify the state and return its new value. In this example we increment <code>long</code> so that subsequent invocation of lambda expression receives <code>state = 1L</code>. Obviously this goes on and on, producing consecutive natural numbers.<br /><br />Such a programming model is obviously harder than a <code>while</code> loop. It also fundamentally changes the way you implement your sources of events. Rather than pushing events whenever you feel like it you are only passively waiting for requests. Downstream operators and subscribers are <em>pulling</em> data from your stream. This shift enables backpressure at all levels of your pipeline.<br /><br /><code>generate()</code> has a few flavors. First of all if your state is a mutable object you can use an overloaded version that does not require returning new state value. Despite being less <em>functional</em> mutable state tends to produce way less garbage. This assumes your state is constantly mutated and the same state object instance is passed every time. For example you can easily turn an <code>Iterator</code> (also pull-based!) into a stream with all wonders of backpressure:<br /><br /><pre class="brush: java">Iterator&lt;Integer&gt; iter = //...<br /><br />Flowable&lt;String&gt; strings = Flowable.generate(() -&gt; iter, (iterator, emitter) -&gt; {<br />    if (iterator.hasNext()) {<br />        emitter.onNext(iterator.next().toString());<br />    } else {<br />        emitter.onComplete();<br />    }<br />}); </pre>Notice that the type of stream (<code>&lt;String&gt;</code>) doesn't have to be the same as the type of state (<code>Iterator&lt;Integer&gt;</code>). Of course if you have a Java <code>Collection</code> and want to turn it into a stream, you don't have to create an iterator first. It's enough to use <code>Flowable.fromIterable()</code>. Even simpler version of <code>generate()</code> assumes you have no state at all. For example stream of random numbers:<br /><br /><pre class="brush: java">Flowable&lt;Double&gt; randoms = Flowable<br />        .generate(emitter -&gt; emitter.onNext(Math.random()));</pre>But honestly, you will probably need an instance of <code>Random</code> after all:<br /><br /><pre class="brush: java">Flowable.generate(Random::new, (random, emitter) -&gt; {<br />    emitter.onNext(random.nextBoolean());<br />});</pre><h2 id="summary">Summary</h2>As you can see <code>Observable.create()</code> in RxJava 1.x and <code>Flowable.create()</code> have some shortcomings. If you really care about scalability and health of your heavily concurrent system (and otherwise you wouldn't be reading this!) you must be aware of backpressure. If you really need to create streams from scratch, as opposed to using <code>from*()</code> family of methods or various libraries that do the heavy lifting - familiarize yourself with <code>generate()</code>. In essence you must learn how to model certain types of data sources as fancy iterators. Expect more articles explaining how to implement more real-life streams.<br /><br /><sup><em></em></sup> This is similar to stateless HTTP protocol that uses small pieces of state called session* on the server to keep track of past requests.<br /><br /><script>SyntaxHighlighter.highlight();</script>