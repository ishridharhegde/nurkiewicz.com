---
layout: post
title: Freemarker - pierwsze kroki
date: '2009-01-07T20:12:00.003+01:00'
author: Tomasz Nurkiewicz
tags:
- freemarker
modified_time: '2009-08-14T00:04:48.594+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5686563089048014206
blogger_orig_url: https://www.nurkiewicz.com/2009/01/freemarker-pierwsze-kroki.html
---

Postanowiłem sporządzić krótki tutorial z jednym prostym przykładem pokazującym podstawowe możliwości <a href="http://freemarker.sourceforge.net/">Freemarkera</a>. Wbrew pozorom nie stanąłem przed koniecznością migracji plików JSP na Freemarker, a użyłem tej biblioteki w klasycznej, konsolowej aplikacji Java SE. Jak się okazało, sprawdziła się znakomicie.<br /><br />Bez zbędnego lania wody - Freemarker jest procesorem, który na wejściu otrzymuje model (zestaw obiektów Java) + szablon, a na wyjściu produkuje dokument będący szablonem uzupełnionym o odpowiednio sformatowane dane z modelu. Problem polega na konwersji obiektu Java do reprezentacji tekstowej. By być precyzyjnym, chodziło o translację następującego JavaBeanu:<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;font-family:Andale Mono,Lucida Console,Monaco,fixed,monospace;font-size:12px;"><code>package com.blogspot.nurkiewicz;<br /><br />import java.util.List;<br /><br />public class Procedure {<br /><br /></code><code>    </code><code>private boolean returns;<br /><br /></code><code>    </code><code>private String name;<br /><br /></code><code>    </code><code>private List&lt;String&gt; args;<br /><br /></code><code>    </code><code>/* konstruktory, gettery i settery*/<br /><br />}<br /><br /></code></pre>do kodu w języku Java. Dla przykładowych wartości właściwości: name="count", args=[x, y, size], returns=true, powinniśmy otrzymać następujący tekst:<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;font-family:Andale Mono,Lucida Console,Monaco,fixed,monospace;font-size:12px;"><code>public double subCount(double x, double y, double size);<br /></code></pre>Zacznijmy zatem od przygotowania środowiska. Podstawowym obiektem Freemarkera jest klasa <a href="http://freemarker.sourceforge.net/docs/api/freemarker/template/Template.html"><span style="font-family:courier new;">Template</span></a>. Co prawda dokumentacja poleca tworzenie jej instancji za pomocą klasy <a href="http://freemarker.sourceforge.net/docs/api/freemarker/template/Configuration.html"><span style="font-family:courier new;">Configuration</span></a>, jednak ponieważ domyślnie ma ona dość ubogie API (można ładować szablony jedynie z plików, i to bez przeszukiwania CLASSPATH), utworzymy obiekt klasy Template bezpośrednio:<br /><pre   style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;font-family:Andale Mono,Lucida Console,Monaco,fixed,monospace;font-size:12px;"><code>Template template = new Template(null,<br /></code><code>    </code><code>new InputStreamReader(Main.class.getResourceAsStream("procedure.ftl")),<br /></code><code>    </code><code>new Configuration());<br /></code></pre>Kod ten został umieszczony w klasie <span style="font-family:courier new;">com.blogspot.nurkiewicz.Main</span>, zatem plik <span style="font-family:courier new;">procedure.ftl</span> będzie szukany w katalogu <span style="font-family:courier new;">src/main/resource/com/blogspot/nurkiewicz</span>.<br /><br />Posiadając obiekt template możemy przystąpić do zasilenia go modelem; wystarczy prosta mapa:<br /><pre face="Andale Mono,Lucida Console,Monaco,fixed,monospace" size="12px" style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;"><code>Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;();<br />final Procedure procedure = new Procedure(true, "count", Arrays.asList("x", "y", "size"));<br />model.put("proc", procedure);<br /></code></pre>Jak widać umieściliśmy w modelu, pod kluczem <span style="font-style: italic;">proc</span>, instancję naszej klasy <span style="font-family:courier new;">Procedure</span>. Oznacza to, że w naszym szablonie będziemy mogli otrzymać wartości z tego obiektu posługując się prefiksem <span style="font-style: italic;">proc</span>. Spróbujmy - przypominam, że plik procedure.ftl zawiera treść szablonu:<br /><pre face="Andale Mono,Lucida Console,Monaco,fixed,monospace" size="12px" style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;"><code>public double ${proc.name}(double ${proc.args[0]}, double ${proc.args[1]}, double ${proc.args[2]});<br /></code></pre><span style="font-family:courier new;">${proc.name}</span> jest jednym z odwołań do modelu - w tym wypadku do właściwości name obiektu pod kluczem proc (czyli Freemarker wywoła <span style="font-family:courier new;">Procedure.getName()</span> na instancji klasy Procedure). Z kolei <span style="font-family:courier new;">${proc.args[0]}</span> spowoduje javowe odwołanie <span style="font-family:courier new;">getArgs().get(0)</span>. Jasne.<br /><br />Do uruchomienia przykładu potrzebujemy jeszcze właściwego przetworzenia szablonu wraz z modelem oraz zdefiniowania dokąd ma trafić wynik (w naszym wypadku standardowe wyjście):<br /><pre face="Andale Mono,Lucida Console,Monaco,fixed,monospace" size="12px" style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;"><code>template.process(model, new OutputStreamWriter(System.out));<br /></code></pre>I wynik programu, nieco odbiegający od oczekiwań:<br /><pre face="Andale Mono,Lucida Console,Monaco,fixed,monospace" size="12px" style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;"><code>public double count(double x, double y, double size);<br /></code></pre>Nie dość, że brakuje prefiksu <span style="font-family:courier new;">sub</span> przed nazwą metody, to jeszcze zahardkodowaliśmy długość listy <span style="font-family:courier new;">args </span>oraz nie sprawdzamy właściwości <span style="font-family:courier new;">returns</span>, wartość której determinuje, czy metoda zwraca <span style="font-family:courier new;">double </span>czy <span style="font-family:courier new;">void</span>. Zacznijmy od tego. Freemarker udostępnia proste wyrażenia warunkowe, zwróćcie uwagę, że nie ma już potrzeby korzystania ze znaku dolara i nawiasów klamrowych:<br /><pre face="Andale Mono,Lucida Console,Monaco,fixed,monospace" size="12px" style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;"><code>public <span style="font-weight: bold;">&lt;#if proc.returns&gt;double&lt;#else&gt;void&lt;/#if&gt;</span><br /></code><code>    </code><code>${proc.name}(${proc.args[0]}, ${proc.args[1]}, ${proc.args[2]});<br /></code></pre>Dla lepszej czytelności rozbiję szablon na linijki. Wyrażenie chyba oczywiste, Freemarker domyśla się, że trzeba wywołać metodę <span style="font-family:courier new;">Procedure.isReturns()</span>. Jednak zamiast złożonego warunku możemy zwyczajnie napisać:<br /><pre face="Andale Mono,Lucida Console,Monaco,fixed,monospace" size="12px" style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;"><code>${proc.returns?string("double", "void")}<br /></code></pre>co przypomina znany z wielu języków, także Javy, trójargumentowy operator warunkowy <span style="font-family:courier new;">?:</span> .<br /><br />Większym problemem jest nazwa metody - samo dodanie prefiksu nie wystarczy, ponieważ dodatkowo, zgodnie z notacją <span style="font-style: italic;">camel case</span>, trzeba rozpocząć dostarczoną nazwę metody od wielkiej litery. Szczęśliwie, Freemarker potrafi sobie poradzić z tak prostym zabiegiem edycyjnym:<br /><pre   style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;  font-family:Andale Mono,Lucida Console,Monaco,fixed,monospace;font-size:12px;"><code>public ${proc.returns?string("double", "void")} sub<span style="font-weight: bold;">${proc.name?cap_first}</span>(<br /></code><code>    </code><code>${proc.args[0]}, ${proc.args[1]}, ${proc.args[2]}<br />);<br /></code></pre><span style="font-family:courier new;">cap_first</span> od <span style="font-family:courier new;">capitalize first letter</span>, Freemarker umożliwia nam jeszcze wiele innych transformacji, takich jak <span style="font-family:courier new;">substring</span>, dopełnianie czy obcinanie białych znaków. Tymczasem nasz wynik:<br /><pre face="Andale Mono,Lucida Console,Monaco,fixed,monospace" size="12px" style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;"><code>public double subCount(<br /></code><code>    </code><code>x, y, size<br />);<br /></code></pre>Została tylko nieszczęsna lista. Po pierwsze musimy umieć iterować po liście dowolnej długości, po drugie ostatni element nie może się kończyć przecinkiem. Użyjemy w tym celu dyrektywy <#list> (istnieje również uboższa wersja: <#foreach>):<br /><pre face="Andale Mono,Lucida Console,Monaco,fixed,monospace" size="12px" style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;"><code>&lt;#list proc.args as arg&gt;<br /></code><code>    </code><code>double ${arg},<br />&lt;/#list&gt;);<br /></code></pre>Znowu dość prosty kod: dla każdego elementu z kolekcji <span style="font-family:courier new;">proc.args</span> (w każdej iteracji dany element jest widoczny pod kluczem <span style="font-family:courier new;">arg</span>) zostanie wydrukowana zawartość dyrektywy <span style="font-family:courier new;"><#list></span>, czyli w naszym wypadku "<span style="font-family:courier new;">double ${arg},</span>". Efekt do przewidzenia, ale co zrobić z przecinkiem po ostatniej iteracji? Otóż dyrektywa <span style="font-family:courier new;"><#list></span> wprowadza kilka dodatkowych zmiennych, m.in. swojsko brzmiącą <span style="font-family:courier new;">arg_has_next</span>. Czy trzeba tłumaczyć, że w każdej iteracji z wyjątkiem ostatniej przybiera ona wartość true? I czy muszę pokazywać pełny kod szablonu?<br /><pre face="Andale Mono,Lucida Console,Monaco,fixed,monospace" size="12px" style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); line-height: 14px; width: 100%;"><code>public ${proc.returns?string("double", "void")} sub${proc.name?cap_first}(<br />&lt;#list proc.args as arg&gt;<br /></code><code>    </code><code>double ${arg}<span style="font-weight: bold;">&lt;#if arg_has_next&gt;, &lt;/#if&gt;</span><br />&lt;/#list&gt;);<br /></code></pre>I tak oto Freemarker pomógł mi skrócić kod w Javie do zaledwie jednej linijki wykonującej odpowiedni szablon, zamknąłem widok i odizolowałem od modelu. A co najważniejsze, usunąłem pachnącą amatorką, zamotaną pętlę ze StringBuilderem, warunkami i tekstem przeplecionym z kodem w Javie - i chyba o to chodzi?<br /><br />Mam nadzieję, że udało mi się przybliżyć składnię Freemarkera i zachęcić do stosowania tego narzędzia wszędzie tam, gdzie trzeba zamienić dane na tekst. Narzędzie to może również z powodzeniem zastępować XSLT: <a href="http://freemarker.org/fmVsXSLT.html">FreeMarker vs. XSLT</a>.<br /><br /><a href="http://sites.google.com/site/nurkiewicz/Home/zalaczniki/freemarker-test.zip">Pełen kod źródłowy programu</a>, maven friendly, 3,3 KiB.