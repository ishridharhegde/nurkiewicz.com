---
layout: post
title: Null safety in Kotlin
date: '2013-05-27T21:17:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
- kotlin
modified_time: '2013-05-27T21:17:29.755+02:00'
thumbnail: http://3.bp.blogspot.com/-R8JrHuEpuCA/UaOwtv8Dj-I/AAAAAAAAAwc/Sccm7L9TBG0/s72-c/243254_160570290675449_4878445_o.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8673906548385245398
blogger_orig_url: https://www.nurkiewicz.com/2013/05/null-safety-in-kotlin.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-R8JrHuEpuCA/UaOwtv8Dj-I/AAAAAAAAAwc/Sccm7L9TBG0/s1600/243254_160570290675449_4878445_o.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="149" src="http://3.bp.blogspot.com/-R8JrHuEpuCA/UaOwtv8Dj-I/AAAAAAAAAwc/Sccm7L9TBG0/s200/243254_160570290675449_4878445_o.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Gjersjøen lake</td></tr></tbody></table><a href="http://kotlin.jetbrains.org/">Kotlin</a> is a statically typed JVM language developed by <a href="http://www.jetbrains.com/">Jetbrains</a>. It has some <a href="http://confluence.jetbrains.com/display/Kotlin/Kotlin">good documentation</a> so today I will focus on a tiny part of it - <a href="http://confluence.jetbrains.com/display/Kotlin/Null-safety">null safety</a>.<br /><br />There are at least couple of approaches to <code>null</code> handling in JVM languages: <br /><br /><ul><li><b>Java</b> doesn’t go much further than C - every reference (“pointer”) can be <code>null</code>, whether you like it or not. If it’s not a primitive, every single field, parameter or return value can be <code>null</code>.<br /><br /></li><li><b>Groovy</b> has similar background but adds some <a href="http://groovy.codehaus.org/Operators">syntactic sugar</a>, namely <i>Elvis Operator</i> (<code>?:</code>) and Safe Navigation Operator (<code>?.</code>).<br /><br /></li><li><b>Clojure</b> renames <code>null</code> to <code>nil</code>, additionally treating it as <code>false</code> in boolean expressions. <code>NullPointerException</code> is still possible.<br /><br /></li><li><b>Scala</b> is first to adopt systematic, type safe <a href="http://www.scala-lang.org/api/current/scala/Option.html"><code>Option[T]</code> monad</a> (Java 8 will have <a href="http://download.java.net/lambda/b88/docs/api/java/util/Optional.html"><code>Optional&lt;T&gt;</code></a> as well!) Idiomatic Scala code should not contain <code>null</code>s but when interoperating with Java you must sometimes wrap nullable values. <br /><br /></li></ul>Kotlin takes yet another approach. References that can be <code>null</code> have different type, thus null-safety is encoded in the type system and enforced only during compilation. We get <code>NullPointerException</code>-free code and no runtime overhead due to extra <code>Option</code> wrapper.<br /><br />In the syntax layer each type <code>T</code> has a super type <code>T?</code> that allows <code>null</code>. Have a look at these trivial examples:<br /><a name='more'></a><br /><br /><pre class="brush: java">fun hello(name: String) {<br />    println("Hello, ${name}")<br />}<br /><br />fun main(args: Array&lt;String&gt;) {<br />    val str = "Kotlin"<br />    hello(str)<br /><br />    val maybeStr: String? = "Maybe?"<br />    hello(maybeStr)     //doesn't COMPILE<br /><br />    if(maybeStr != null) {<br />        hello(maybeStr)<br />    }<br /><br />}<br /></pre>Type of <code>str</code> is inferred to <code>String</code>. Function <code>hello()</code> accepts <code>String</code> so <code>hello(str)</code> is fine. However we explicitly declare <code>maybeStr</code> as <code>String?</code> type (nullable <code>String</code>). The compiler prevents us from calling <code>hello()</code> with <code>String?</code> due to incompatible type.<br /><br />However if the compiler can <i>prove</i> that a call is safe, e.g. because we just checked for <code>null</code>, compilation succeeds. To be precise, the compiler can prove that downcasting from <code>String?</code> to <code>String</code> is safe. Similarly I always found it annoying in Java that after using <code>instanceof</code> operator (being annoying on its own) I still have to down cast my object:<br /><br /><pre class="brush: java">Object obj = "Any object"<br /><br />if(obj instanceof String) {<br />    hello((String)obj)<br />}<br /></pre>Not in Kotlin:<br /><br /><pre class="brush: java">val obj: Any = "Any object"<br /><br />if(obj is String) {<br />    hello(obj)<br />}<br /></pre>See? <code>obj</code> is of type <code>Any</code> (<code>Object</code> in Java terms) so calling <code>hello(obj)</code> is doomed to fail, right? Not quite. The compiler can <i>prove</i> that <code>obj</code> is actually of type <code>String</code> so it performs automatic, safe downcasting for us. Neat! But back to <code>null</code> handling.<br /><br />I said a lot about downcasting, remembering that any non-null type <code>T</code> has a super type of nullable <code>T?</code>. Just like in any other polymorphic language upcasting is implicit. In other words we can pass type <code>T</code> when <code>T?</code> is required - which is quite obvious:<br /><br /><pre class="brush: java">val str: String = "Hello"     //String type can be inferred here<br />unsafeHello(str)<br /><br />fun unsafeHello(name: String?) {<br /><br />}<br /></pre>Interestingly primitives can also be nullable:<br /><br /><pre class="brush: java">fun safePositive(x: Int) = x &gt; 0<br />fun unsafePositive(x: Int?): Boolean = x != null &amp;&amp; x &gt; 0<br /></pre>In generated bytecode former method takes <code>int</code> while the latter <code>java.lang.Integer</code>. While we are at it, first two expressions compile, but not the last one:<br /><br /><pre class="brush: java">if(unsafePositive(maybeInt)) {<br />    //...<br />}<br /><br />if(maybeInt != null &amp;&amp; safePositive(maybeInt)) {<br />    //...<br />}<br /><br />if(safePositive(maybeInt)) {<br />    //...<br />}<br /></pre>First expression has a perfect type match (<code>Int?</code> vs. <code>Int?</code>). In the second case the compiler can <i>prove</i> that <code>maybeInt</code> can be downcasted to <code>Int</code>, required by <code>safePositive()</code>. This can’t be proven in the last case, resulting in type mismatch compilation error.<br /><br />So far it looks great - null safety with no extra runtime overhead. However Java interoperability is Achilles’ heel of Kotlin. In Scala <code>Option[T]</code> wrapper is implemented on top of the language and Scala itself allows <code>null</code> for Java interop. You won’t see <code>null</code> in idiomatic Scala code, but it pops up sometimes when interacting with Java collections and libraries. Typically extra <code>Option(javaMethod())</code> delegation is required.<br /><br />However Kotlin takes much more aggressive approach: every parameter of every Java method is considered nullable (that we don’t care), but also every return value is nullable - unless stated otherwise. It turns out that Kotlin compiler has some knowledge of JDK:<br /><br /><pre class="brush: java">val formatted: String = String.format("Kotlin-is-%s", "cool")<br />val joined:    String = String.join("-", "Kotlin", "is", "cool")<br /></pre>First line compiles just fine, Kotlin knows that <code>String.format()</code> never returns <code>null</code>. However it can’t say that about <code>String.join()</code>, new in Java 8. Thus, even though <code>String.join()</code> <i>never</i> returns <code>null</code> as well, you still get <code>String?</code> inferred type. The same applies to any library or your custom Java code. Unfortunately <code>@javax.validation.constraints.NotNull</code> annotation doesn’t help, not to mention you can’t add annotations to library/JDK code.<br /><br />Well.. you sort of can… IntelliJ IDEA has an obscure feature called <a href="http://blog.jetbrains.com/kotlin/using-external-annotations/">External Annotations</a> which lets you annotate arbitrary method, even in external JARs. You cannot change external code so such annotations are kept in special <code>annotations.xml</code> file:<br /><br /><pre class="brush: xml">&lt;root&gt;<br />    &lt;item name='java.lang.String java.lang.String join(java.lang.CharSequence, java.lang.CharSequence...)'&gt;<br />        &lt;annotation name='org.jetbrains.annotations.NotNull'/&gt;<br />    &lt;/item&gt;<br />&lt;/root&gt;<br /></pre>This declaration (of course IntelliJ manages it for you) tells Kotlin compiler that <code>String.join()</code> can’t return <code>null</code>. Because our code won’t compile without it, it must be checked into version control and becomes part of your code base.<br /><br />Doesn’t seem like this problem would go away soon. There will always be libraries without <code>@NotNull</code> annotations and the compiler can’t possibly detect whether Java method is nullable or not (especially taking dynamic nature of class loading and CLASSPATH). More portable solution is to simply force down casting to null-safe type:<br /><br /><pre class="brush: java">String.join("-", "Kotlin", "is", "cool") as String<br /></pre>…but it feels superfluous.<br /><br />To wrap things up: <code>null</code> handling in Kotlin is both radical (type-safety and compile-time checking) and conservative (<code>null</code> is still here, no functional, monadic style). I only hope that rough edges in Java interoperability will eventually go away.<br /><br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>