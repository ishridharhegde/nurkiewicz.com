---
layout: post
title: Clojure macros for beginners
date: '2013-06-09T23:27:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- clojure
- functional programming
modified_time: '2015-08-05T08:47:20.090+02:00'
thumbnail: http://1.bp.blogspot.com/-j1P9jtYKKbQ/UbTyoJNg5EI/AAAAAAAAAw8/wa46aI-LOhw/s72-c/oslo-0.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4187944289979788653
blogger_orig_url: https://www.nurkiewicz.com/2013/06/clojure-macros-for-beginners.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-j1P9jtYKKbQ/UbTyoJNg5EI/AAAAAAAAAw8/wa46aI-LOhw/s1600/oslo-0.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="149" src="http://1.bp.blogspot.com/-j1P9jtYKKbQ/UbTyoJNg5EI/AAAAAAAAAw8/wa46aI-LOhw/s200/oslo-0.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Bjørvika</td></tr></tbody></table>This article will guide you step-by-step (or even <i>character-by-character</i>) through the process of writing macros in Clojure. I will focus on fundamental macro characteristics while explaining what happens behind the scenes.<br /><br />Imagine you are about to write an assertions library for Clojure, similar to <a href="https://github.com/alexruiz/fest-assert-2.x/wiki">FEST Assertions</a>, <a href="http://www.scalatest.org/user_guide/using_assertions">ScalaTest assertions</a> or <a href="http://hamcrest.org/">Hamcrest</a>. Of course there are <a href="http://clojure.github.io/clojure/clojure.test-api.html">such existing</a> but this is just for educational purposes. What we essentially need first is a <code>assert-equals</code> function used like this:<br /><br /><pre class="brush: plain">(assert-equals <br />    (count (filter even? primes)) 1)<br /></pre>Of course this is more than trivial:<br /><br /><pre class="brush: plain">(defn assert-equals [actual expected] <br />    (when-not (= actual expected) <br />        (throw <br />            (AssertionError. <br />                (str "Expected " expected " but was " actual)))))<br /></pre>Quick test with incorrectly defined <code>primes</code> vector:<br /><br /><pre class="brush: plain">user=&gt; (def primes [0 2 3 5 7 11])<br />#'user/primes<br />user=&gt; (assert-equals (count (filter even? primes)) 1)<br /><br />AssertionError Expected 1 but was 2<br /></pre>Cool, but imagine this test failing on CI server or seeing this in your terminal. There is no context, maybe you’ll get test name if you’re lucky. “<code>Expected 1 but was 2</code>” tells us nothing about the nature or root cause of the problem. Wouldn’t it be great to see:<br /><a name='more'></a><br /><br /><pre class="brush: plain">AssertionError Expected '(count (filter even? primes))' to be 1 but was 2<br /></pre>You see this? Assertion error now gives us full expression that yielded incorrect result. We can see from the very first second what the issue can be. However, there is a problem. Big one. By the time we are throwing <code>AssertionError</code>, original expression is lost. We got <code>actual</code> <i>value</i> as an argument and we have no idea where did that value came from. It could have been a constant, result of expression like <code>(count (filter even? primes))</code> or even a random value. Function arguments are computed eagerly and there is no way to access <i>code</i> that produced these arguments.<br /><br /><h2>Entering macros</h2>Macros and functions in Clojure are not independent or orthogonal. In fact, they are almost the same:<br /><br /><ul><li><b>Functions</b> execute at <b>run time</b>, they take and produce <b>data</b> (values). Conceptually one can replace every (pure) function invocation with its value.<br /><br /></li><li><b>Macros</b> execute at <b>compile time</b>, they take and produce <b>code</b>. Conceptually one can replace (<i>expand</i>) every occurrence of macro with its value.<br /><br /></li></ul>Not that much different? Moreover since Clojure is <a href="http://en.wikipedia.org/wiki/Homoiconicity"><i>homoiconic</i></a>, Clojure code can be represented as Clojure data structures. In other words both functions and macros accept data, but in case of macros it’s more often to see Clojure source represented using data structures like lists.<br /><br />What does it all mean and how can it help us? Let’s jump straight into writing our first (incorrect) macro and improve it step-by-step to finally achieve desired result. To keep samples focused I skip throwing an <code>AssertionError</code> and leave only equality condition:<br /><br /><pre class="brush: plain">user=&gt; (defmacro assert-equals [actual expected] <br />            (= expected actual))<br />#'user/assert-equals<br />user=&gt; (assert-equals 2 2)<br />true<br /><br />user=&gt; (assert-equals 2 3)<br />false<br /></pre>Works? In fact we are very far from having a correct version:<br /><br /><pre class="brush: plain">user=&gt; (assert-equals (inc 5) 6)<br />false<br /><br />user=&gt; (def x 1)<br />#'user/x<br />user=&gt; (assert-equals (+ x 2) 3)<br />false<br /></pre><code>1 + 2</code> is definitely equal to <code>3</code>, yet it returns false. In order to appreciate this behaviour and call it “<i>feature</i>” rather than “<i>bug</i>” we must deeply understand what just happened. Remember, macros are executed at compile time, right? And they are almost ordinary functions. So, the compiler executes <code>assert-equals</code>. However during compilation it can’t possibly know the values of variables like <code>x</code>, therefore it can’t eagerly evaluate macro arguments. We don’t even want that, as you see later.<br /><br />Instead the compiler passes <b>Clojure code, literally</b>. The <code>actual</code> parameter is <code>(inc 5)</code> - literally, Clojure list holding two elements: <code>inc</code> symbol and <code>5</code> number. That’s all there is to it. <code>expected</code> is just a number. This means that inside macro we have full access to Clojure source code enclosed by that macro.<br /><br />So maybe you can now guess what happens. Clojure compiler executes macro definition, that is <code>(= expected actual)</code>. As far as the compiler is concerned, <code>actual</code> is a list <code>(inc 5)</code> while <code>expected</code> is a number <code>6</code>. List can never possibly be equal to a number. Thus macro returns <code>false</code>, just like any other function can return it. Later on Clojure compiler replaces <code>(assert-equals (inc 5) 6)</code> expression with the outcome of macro, which happens to be… <code>false</code>. We said before that macro should return valid Clojure code (represented using Clojure data structures). <code>false</code> <i>is</i> valid Clojure code!<br /><br />Now we know that instead of evaluating <code>(= expected actual)</code> by the compiler (after all, we don’t want the compiler to run our assertions, we only want to compile them!) we simply want to return <i>code</i> that represents this assertion. It’s not that hard!<br /><br /><pre class="brush: plain">(defmacro assert-equals [actual expected] (list '= expected actual))<br /></pre>Now our macro returns result of evaluating <code>(list '= expected actual)</code> expression. The result happens to be… <code>(= expected actual)</code>. That’s right, it looks like valid Clojure code, again. Extra quote (<code>'=</code>) was added so that <code>=</code> is interpreted as raw symbol rather than a function reference. Let’s take it for a test drive:<br /><br /><pre class="brush: plain">user=&gt; (assert-equals (inc 5) 6)<br />true<br />user=&gt; (macroexpand '(assert-equals (inc 5) 6))<br />(= 6 (inc 5))<br /></pre><code>macroexpand</code> and <code>macroexpand-1</code> are your weapons of choice when debugging macros. Here you see that <code>(assert-equals (inc 5) 6)</code> is actually being replaced by <code>(= 6 (inc 5))</code>. This process happens at compile time, <b>macros don’t exist at runtime</b>. In your compiled code you are left with <code>(= 6 (inc 5))</code>. OK, so let’s restore the full functionality of throwing <code>AssertionError</code>. As you know by now, our macro should return Clojure code that includes equality check and throwing an exception. This becomes a bit unwieldy:<br /><br /><pre class="brush: plain">(defmacro assert-equals [actual expected] <br />    (list 'when-not (list '= actual expected) <br />        (list 'throw <br />            (list 'AssertionError.<br />                (list 'str "Expected " expected " but was " actual)))))<br /></pre>Notice how every single symbol has to be escaped (<code>'when-not</code>, <code>'throw</code>, <code>'AssertionError.</code>, …), otherwise compiler will try to evaluate it at compile time. Moreover list in Clojure denotes function call so we must proceed every list literal with <code>(list ...)</code> function call. If you are not that familiar with Clojure: <code>(list 1 2)</code> returns list of <code>(1 2)</code> while <code>(1 2)</code> will throw an exception since <code>1</code> number is not a function.<br /><br />Ugly or not, it works:<br /><br /><pre class="brush: plain">user=&gt; (assert-equals (inc 5) 6)<br />nil<br />user=&gt; (assert-equals 5 6)<br />AssertionError Expected 6 but was 5<br /></pre>We barely reproduced what original <code>assert-equals</code> function was doing and the first commandment of writing macros is: don’t write macros if function is sufficient. But before we go further, let us clean up what we have so far. Typical macro definition consists of lots of Clojure code that has to be escaped and not that much <i>live</i> values like <code>actual</code> and <code>expected</code> in our case. So there is a smart default - instead of quoting everything except few items, quote everything upfront and selectively <i>unquote</i> things. This is called <b>syntax-quoting</b> (using ` character) and unquoting is done via <code>~</code> operator. Look carefully: we syntax quote whole result and selectively unquote what was previously not quoted:<br /><br /><pre class="brush: plain">(defmacro assert-equals [actual expected] <br />    `(when-not (= ~actual ~expected) <br />        (throw <br />            (AssertionError.<br />                (str "Expected " ~expected " but was " ~actual)))))<br /></pre>This is equivalent to previous definition but looks much better, almost entirely like valid Clojure code. Let’s employ <code>macroexpand-1</code> to see how our macro is expanded during compilation. <code>macroexpand</code> would work as well, but since <code>when-not</code> is also a macro (!) it would be recursively expanded, cluttering output:<br /><br /><pre class="brush: plain">user=&gt; (macroexpand-1 '(assert-equals (inc 5) 6))<br />(when-not <br />    (= (inc 5) 6) <br />        (throw <br />            (java.lang.AssertionError.<br />                (str "Expected " 6 " but was " (inc 5)))))<br /></pre>It’s like templating language embedded within that language! Notice how <code>(inc 5)</code> piece of code was inserted instead of <code>~actual</code> twice. Keep that in mind. Also experiment by removing unquote (<code>~</code>) symbol here or there. Use <code>macroexpand-1</code> to figure out what is going on.<br /><br />Remember, our ultimate goal was to show <code>actual</code> expression in its full glory, not only its value. <br /><br /><pre class="brush: plain">(AssertionError.<br />   (str "Expected '???' to be " ~expected " but was " actual-value#))))))<br /></pre>What should we put in place of <code>???</code> to print “<code>(inc 5)</code>” <i>string</i>. We know that value of <code>actual</code> is <i>not</i> <code>6</code> but a list with two items: <code>(inc 5)</code>. Can we somehow quote that list again so that it no longer evaluates at run-time but instead is treated as a data structure? Of course, we know how to quote things!<br /><br /><pre class="brush: plain">(defmacro assert-equals [actual expected] <br />    `(let [~'actual-value ~actual] <br />        (when-not (= ~'actual-value ~expected) <br />            (throw <br />                (AssertionError.<br />                   (str "Expected '" '~actual "' to be " ~expected " but was " ~'actual-value))))))<br /></pre><code>'~actual</code>, oh dear! <i>quote unquote actual</i>. This translates to <code>'(inc 5)</code>. And that’s it! Look how descriptive assertion error messages are:<br /><br /><pre class="brush: plain">user=&gt; (assert-equals (inc 5) 5)<br />AssertionError Expected '(inc 5)' to be 5 but was 6<br /><br />user=&gt; (assert-equals (count (filter even? primes)) 1)<br />AssertionError Expected '(count (filter even? primes))' to be 1 but was 2<br /></pre>Expanding this macro manually reveals how it is translated by the compiler (edited to improve readability):<br /><br /><pre class="brush: plain">user=&gt; (macroexpand-1 '(assert-equals (inc 5) 5))<br />(when-not <br />    (= (inc 5) 5) <br />        (throw <br />            (java.lang.AssertionError. <br />                (str "Expected '" (quote (inc 5)) "' to be " 5 " but was " (inc 5)))))<br /></pre>There is really no magic here, we could have written that ourselves. But macros avoid lots of repetitive work.<br /><br /><h2>Bindings in macros</h2>Our solution so far has one major issue. Imagine we are testing impure or slow function like this:<br /><br /><pre class="brush: plain">(def question "Answer to the Ultimate Question of Life, The Universe, and Everything")<br />(defn answer [q] <br />    (do <br />        (println "Computing for 7½ million years...")<br />        41))<br /></pre>As you can see it returns <a href="http://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life.2C_the_Universe.2C_and_Everything_.2842.29">wrong result</a>, which can be easily proved in a unit test:<br /><br /><pre class="brush: plain">user=&gt; (assert-equals (answer question) 42)<br />Computing for 7½ million years...<br />Computing for 7½ million years...<br /><br />AssertionError Expected '(answer question)' to be 42 but was 41<br /></pre>The error message is fine, but notice that “<code>Computing...</code>” statement was printed twice. Clearly because impure <code>answer</code> function was called twice as well. Macro expansion reveals why:<br /><br /><pre class="brush: plain">user=&gt; (macroexpand-1 '(assert-equals (answer question) 42))<br />(when-not <br />    (= (answer question) 42) <br />        (throw (java.lang.AssertionError. <br />            (str "Expected '" (quote (answer question)) "' to be " 42 " but was " <br />                (answer question)))))<br /></pre><code>(answer question)</code> appears twice (not counting <code>quote</code>d one), once during comparison and second time when we generate assertion message. This is rarely desired, especially when <i>function under test</i> has side effects. The solution is simple: precompute <code>(answer question)</code> once, store it somewhere and reference when needed. But there is a twist: declaring <code>let</code> bindings inside macros is tricky. Sometimes you might hit unexpected name shadowing and overriding when names of variables inside macro collide with the ones used in user code. Not going into much detail, using <code>(gensym)</code> or convenient <code>#</code> suffix is enough to keep our macros safe. In both cases Clojure compiler will produce unique names making sure they don’t collide. Our final solution looks like this:<br /><br /><pre class="brush: plain">(defmacro assert-equals [actual expected] <br />    `(let [actual-value# ~actual] <br />        (when-not (= actual-value# ~expected) <br />            (throw <br />                (AssertionError. <br />                   (str "Expected '" '~actual "' to be " ~expected<br />                       " but was " actual-value#))))))<br /></pre>This time <code>actual-value#</code> binding is used to compute <code>actual</code> only once:<br /><br /><pre class="brush: plain">user=&gt; (macroexpand-1 '(assert-equals (answer question) 42))<br />(let [actual-value__264__auto__ (answer question)] <br />    (when-not (= actual-value__264__auto__ 42) <br />        (throw <br />            (java.lang.AssertionError. <br />                (str "Expected '" (quote (answer question)) "' to be " 42 "<br />                   but was " actual-value__264__auto__)))))<br /></pre>Extra suffix replacing <code>#</code> symbol makes sure <code>actual-value</code> is not colliding with any other symbol.<br /><br /><h2>Summary</h2>Our <code>assert-equals</code> macro is not the most comprehensive one, just like this tutorial. But it gives you some impression of what macros can do and how they work. If you need further resources, check out this <a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">great macro tutorial</a> (part <a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">2</a> and <a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">3</a>). If you like the idea of enhanced assertions, <a href="http://hamletdarcy.blogspot.no/2009/05/new-power-assertions-in-groovy.html">Power Assertions in Groovy</a> are even more comprehensive. But I bet this behaviour can be reproduced in Clojure macros!<br /><br /><script>SyntaxHighlighter.highlight();</script>