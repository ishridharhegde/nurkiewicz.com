---
layout: post
title: Streaming large JSON file with Jackson - RxJava FAQ
date: '2017-09-04T08:48:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- backpressure
- Jackson
- JSON
- rxjava
modified_time: '2017-09-04T08:48:46.231+02:00'
thumbnail: https://2.bp.blogspot.com/-MBOsRX24c9c/WavE7sh_G_I/AAAAAAAAEEA/-BFmXH2LMrodCzEWX2GWZXIIZasfcXxyACLcBGAs/s72-c/2016-09-07%2B12.54.39.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8528775892007617321
blogger_orig_url: https://www.nurkiewicz.com/2017/09/streaming-large-json-file-with-jackson.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-MBOsRX24c9c/WavE7sh_G_I/AAAAAAAAEEA/-BFmXH2LMrodCzEWX2GWZXIIZasfcXxyACLcBGAs/s1600/2016-09-07%2B12.54.39.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="901" data-original-width="1600" height="112" src="https://2.bp.blogspot.com/-MBOsRX24c9c/WavE7sh_G_I/AAAAAAAAEEA/-BFmXH2LMrodCzEWX2GWZXIIZasfcXxyACLcBGAs/s200/2016-09-07%2B12.54.39.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Oslo coast</td></tr></tbody></table>In the previous article, we learned <a href="http://www.nurkiewicz.com/2017/08/loading-files-with-backpressure-rxjava.html">how to parse excessively large XML files</a> and turn them into RxJava streams. This time let's look at a large JSON file. We will base our examples on tiny <a href="https://github.com/corysimmons/colors.json/blob/master/colors.json">colors.json</a> containing almost 150 records of such format:<br /><br /><pre class="brush: java">{<br />  "aliceblue": [240, 248, 255, 1],<br />  "antiquewhite": [250, 235, 215, 1],<br />  "aqua": [0, 255, 255, 1],<br />  "aquamarine": [127, 255, 212, 1],<br />  "azure": [240, 255, 255, 1],<br />  //...</pre>Little known fact: <em>azure</em> is also a colour and <em>python</em> is a snake. But back to RxJava. This file is tiny but we'll use it to learn some principles. If you follow them you'll be capable of loading and continually processing arbitrarily large, even infinitely long JSON files. First of all the standard <a href="https://github.com/FasterXML/jackson">"<em>Jackson</em>" way</a> is similar to JAXB: loading the whole file into memory and mapping it to Java beans. However, if your file is in megabyte or gigabytes (because somehow you found JSON to be the best format for storing gigabytes of data...) this technique won't work. Luckily Jackson provides streaming mode similar to StAX.<br /><br /><h2 id="loading-json-files-token-by-token-using-jackson">Loading JSON files token-by-token using Jackson</h2>There is nothing wrong with a standard <code>ObjectMapper</code> that takes JSON and turns it into a collection of objects. But in order to avoid loading everything into memory, we must use lower-level API used by <code>ObjectMapper</code> underneath. Let's look again at the JSON example:<br /><br /><pre class="brush: java">{<br />  "aliceblue": [240, 248, 255, 1],<br />  "antiquewhite": [250, 235, 215, 1],<br />  //...</pre>From the disk and memory perspective this is a single-dimension stream of bytes that we can logically aggregate into JSON tokens:<br /><br /><pre class="brush: java">START_OBJECT        '{'<br />FIELD_NAME          'aliceblue'<br />START_ARRAY         '['<br />VALUE_NUMBER_INT    '240'<br />VALUE_NUMBER_INT    '248'<br />VALUE_NUMBER_INT    '255'<br />VALUE_NUMBER_INT    '1'<br />END_ARRAY           ']'<br />FIELD_NAME          'antiquewhite'<br />START_ARRAY         '['<br />VALUE_NUMBER_INT    '250'<br />VALUE_NUMBER_INT    '235'<br />VALUE_NUMBER_INT    '215'<br />VALUE_NUMBER_INT    '1'<br />END_ARRAY           ']'<br />...</pre>You get the idea. If you are familiar with compiler theory this is one of the first steps during compilation. The compiler transforms source code from characters to tokens.<br />But, if you know compiler theory you are probably not parsing JSON for a living. Anyway! Jackson library works this way and we can use it without transparent object mapping:<br /><br /><pre class="brush: java">import com.fasterxml.jackson.core.JsonFactory;<br />import com.fasterxml.jackson.core.JsonParser;<br />import com.fasterxml.jackson.core.JsonToken;<br /><br />JsonParser parser = new JsonFactory().createParser(new File("colors.json"));<br />parser.nextToken(); // JsonToken.START_OBJECT;<br />while (parser.nextToken() != JsonToken.END_OBJECT) {<br />    final String name = parser.getCurrentName();<br />    parser.nextToken(); // JsonToken.START_ARRAY;<br />    parser.nextValue();<br />    final int red = parser.getIntValue();<br />    parser.nextValue();<br />    final int green = parser.getIntValue();<br />    parser.nextValue();<br />    final int blue = parser.getIntValue();<br />    parser.nextValue();<br />    parser.getIntValue();<br />    System.out.println(name + ": " + red + ", " + green + ", " + blue);<br />    parser.nextToken(); // JsonToken.END_ARRAY;<br />}<br />parser.close();</pre>...or if you get rid of some duplication and make the code a little bit easier to read:<br /><br /><pre class="brush: java">import lombok.Value;<br /><br /><br />JsonParser parser = new JsonFactory().createParser(new File("colors.json"));<br />parser.nextToken(); // JsonToken.START_OBJECT;<br />while (parser.nextToken() != JsonToken.END_OBJECT) {<br />    System.out.println(readColour(parser));<br />}<br />parser.close();<br /><br />//...<br /><br />private Colour readColour(JsonParser parser) throws IOException {<br />    final String name = parser.getCurrentName();<br />    parser.nextToken(); // JsonToken.START_ARRAY;<br />    final Colour colour = new Colour(<br />            name,<br />            readInt(parser),<br />            readInt(parser),<br />            readInt(parser),<br />            readInt(parser)<br />    );<br />    parser.nextToken(); // JsonToken.END_ARRAY;<br />    return colour;<br />}<br /><br />private int readInt(JsonParser parser) throws IOException {<br />    parser.nextValue();<br />    return parser.getIntValue();<br />}<br /><br />@Value<br />class Colour {<br />    private final String name;<br />    private final int red;<br />    private final int green;<br />    private final int blue;<br />    private final int alpha;<br />}</pre>What does it have to do with RxJava? You can probably guess - we can read this JSON file on demand, chunk-by-chunk. This enables backpressure mechanism to work seamlessly:<br /><br /><pre class="brush: java">final Flowable&lt;Colour&gt; colours = Flowable.generate(<br />        () -&gt; parser(new File("colors.json")),<br />        this::pullOrComplete,<br />        JsonParser::close);</pre>Let me explain what these three lambda expressions are doing. The first one sets up <code>JsonParser</code> - our mutable state that will be used to produce (<em>pull</em>) more items:<br /><br /><pre class="brush: java">private JsonParser parser(File file) throws IOException {<br />    final JsonParser parser = new JsonFactory().createParser(file);<br />    parser.nextToken(); // JsonToken.START_OBJECT;<br />    return parser;<br />}</pre>Nothing fancy. The second lambda expression is crucial. It is invoked every time subscriber wishes to receive more items. If it asks for 100 items, this lambda expression will be invoked 100 times:<br /><br /><pre class="brush: java">private void pullOrComplete(JsonParser parser, Emitter&lt;Colour&gt; emitter) throws IOException {<br />    if (parser.nextToken() != JsonToken.END_OBJECT) {<br />        final Colour colour = readColour(parser);<br />        emitter.onNext(colour);<br />    } else {<br />        emitter.onComplete();<br />    }<br />}</pre>Of course, if we reach <code>END_OBJECT</code> (closing whole JSON file) we signal that the stream is over. The last lambda expression simply allows to clean up the state, for example by closing <code>JsonParser</code> and underlying <code>File</code>. Now imagine this JSON file is hundreds of gigabytes in size. Having <code>Flowable&lt;Colour&gt;</code> we can consume it safely in arbitrary speed without risking memory overload.<br /><br /><script>SyntaxHighlighter.highlight();</script>