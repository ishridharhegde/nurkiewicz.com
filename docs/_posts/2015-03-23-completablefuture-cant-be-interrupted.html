---
layout: post
title: CompletableFuture can't be interrupted
date: '2015-03-23T19:10:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- CompletableFuture
- java 8
- concurrency
modified_time: '2015-11-29T23:37:49.463+01:00'
thumbnail: http://4.bp.blogspot.com/-dgTN_PP6CSU/VRBW6owFlOI/AAAAAAAABPo/rrgfiw32jh8/s72-c/future-state-diagram.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1434818069057087430
blogger_orig_url: https://www.nurkiewicz.com/2015/03/completablefuture-cant-be-interrupted.html
---

I wrote a lot about <a href="http://www.nurkiewicz.com/2014/05/interruptedexception-and-interrupting.html"><em>InterruptedException and interrupting threads</em></a> already. In short if you call <code>Future.cancel()</code> not inly given <code>Future</code> will terminate pending <code>get()</code>, but also it will try to interrupt underlying thread. This is a pretty important feature that enables better thread pool utilization. I also wrote to always prefer <a href="http://www.nurkiewicz.com/2014/11/executorservice-10-tips-and-tricks.html"><em><code>CompletableFuture</code> over standard <code>Future</code></em></a>. It turns out the more powerful younger brother of <code>Future</code> doesn't handle <code>cancel()</code> so elegantly. Consider the following task, which we'll use later throughout the tests:<br /><br /><pre class="brush: java">class InterruptibleTask implements Runnable {<br /><br />    private final CountDownLatch started = new CountDownLatch(1)<br />    private final CountDownLatch interrupted = new CountDownLatch(1)<br /><br />    @Override<br />    void run() {<br />        started.countDown()<br />        try {<br />            Thread.sleep(10_000)<br />        } catch (InterruptedException ignored) {<br />            interrupted.countDown()<br />        }<br />    }<br /><br />    void blockUntilStarted() {<br />        started.await()<br />    }<br /><br />    void blockUntilInterrupted() {<br />        assert interrupted.await(1, TimeUnit.SECONDS)<br />    }<br /><br />}<br /></pre>Client threads can examine <code>InterruptibleTask</code> to see whether it has started or was interrupted. First let's see how <code>InterruptibleTask</code> reacts to <code>cancel()</code> from outside:<br /><br /><pre class="brush: java">def "Future is cancelled without exception"() {<br />    given:<br />        def task = new InterruptibleTask()<br />        def future = myThreadPool.submit(task)<br />        task.blockUntilStarted()<br />    and:<br />        future.cancel(true)<br />    when:<br />        future.get()<br />    then:<br />        thrown(CancellationException)<br />}<br /><br />def "CompletableFuture is cancelled via CancellationException"() {<br />    given:<br />        def task = new InterruptibleTask()<br />        def future = CompletableFuture.supplyAsync({task.run()} as Supplier, myThreadPool)<br />        task.blockUntilStarted()<br />    and:<br />        future.cancel(true)<br />    when:<br />        future.get()<br />    then:<br />        thrown(CancellationException)<br />}<br /></pre>So far so good. Clearly both <code>Future</code> and <code>CompletableFuture</code> work pretty much the same way - retrieving result after it was canceled throws <code>CancellationException</code>. But what about thread in <code>myThreadPool</code>? I thought it will be interrupted and thus recycled by the pool, how wrong was I!<br /><br /><pre class="brush: java">def "should cancel Future"() {<br />    given:<br />        def task = new InterruptibleTask()<br />        def future = myThreadPool.submit(task)<br />        task.blockUntilStarted()<br />    when:<br />        future.cancel(true)<br />    then:<br />        task.blockUntilInterrupted()<br />}<br /><br />@Ignore("Fails with CompletableFuture")<br />def "should cancel CompletableFuture"() {<br />    given:<br />        def task = new InterruptibleTask()<br />        def future = CompletableFuture.supplyAsync({task.run()} as Supplier, myThreadPool)<br />        task.blockUntilStarted()<br />    when:<br />        future.cancel(true)<br />    then:<br />        task.blockUntilInterrupted()<br />}<br /></pre>First test submits ordinary <code>Runnable</code> to <code>ExecutorService</code> and waits until it's started. Later we cancel <code>Future</code> and wait until <code>InterruptedException</code> is observed. <code>blockUntilInterrupted()</code> will return when underlying thread is interrupted. Second test, however, fails. <code>CompletableFuture.cancel()</code> will never interrupt underlying thread, so despite <code>Future</code> looking as if it was cancelled, backing thread is still running and no <code>InterruptedException</code> is thrown from <code>sleep()</code>. Bug or a feature? <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#cancel-boolean-">It's documented</a>, so unfortunately a feature:<br /><br /><blockquote><strong>Parameters:</strong><code>mayInterruptIfRunning</code> - this value has no effect in this implementation because interrupts are not used to control processing.<br /><br /></blockquote>RTFM, you say, but why <code>CompletableFuture</code> works this way? First let's examine how "old" <code>Future</code> implementations differ from <code>CompletableFuture</code>. <code>FutureTask</code>, returned from <code>ExecutorService.submit()</code> has the following <code>cancel()</code> implementation (I removed <code>Unsafe</code> with similar non-thread safe Java code, so treat it as pseudo code only):<br /><br /><pre class="brush: java">public boolean cancel(boolean mayInterruptIfRunning) {<br />    if (state != NEW)<br />        return false;<br />    state = mayInterruptIfRunning ? INTERRUPTING : CANCELLED;<br />    try {<br />        if (mayInterruptIfRunning) {<br />            try {<br />                Thread t = runner;<br />                if (t != null)<br />                    t.interrupt();<br />            } finally { // final state<br />                state = INTERRUPTED;<br />            }<br />        }<br />    } finally {<br />        finishCompletion();<br />    }<br />    return true;<br />}<br /></pre><code>FutureTask</code> has a <code>state</code> variable that follows this state diagram:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-dgTN_PP6CSU/VRBW6owFlOI/AAAAAAAABPo/rrgfiw32jh8/s1600/future-state-diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-dgTN_PP6CSU/VRBW6owFlOI/AAAAAAAABPo/rrgfiw32jh8/s1600/future-state-diagram.png" height="400" width="363" /></a></div><br /><br />In case of <code>cancel()</code> we can either enter <code>CANCELLED</code> state or go to <code>INTERRUPTED</code> through <code>INTERRUPTING</code>. The core part is where we take <code>runner</code> thread (if exists, i.e. if task is currently being executed) and we try to interrupt it. This branch takes care of eager and forced interruption of already running thread. In the end we must notify all threads blocked on <code>Future.get()</code> in <code>finishCompletion()</code> (irrelevant here). So it's pretty obvious how old <code>Future</code> cancels already running tasks. What about <code>CompletableFuture</code>? Pseudo-code of <code>cancel()</code>:<br /><br /><pre class="brush: java">public boolean cancel(boolean mayInterruptIfRunning) {<br />    boolean cancelled = false;<br />    if (result == null) {<br />        result = new AltResult(new CancellationException());<br />        cancelled = true;<br />    }<br />    postComplete();<br />    return cancelled || isCancelled();<br />}<br /></pre>Quite disappointing, we barely set <code>result</code> to <code>CancellationException</code>, ignoring <code>mayInterruptIfRunning</code> flag. <code>postComplete()</code> has a similar role to <code>finishCompletion()</code> - notifies all pending callbacks registered on that future. Its implementation is rather unpleasant (using non-blocking <a href="http://people.csail.mit.edu/shanir/publications/Lock_Free.pdf">Treiber stack</a>) but it definitely doesn't interrupt any underlying thread.<br /><br /><h1>Reasons and implications</h1>Limited <code>cancel()</code> in case of <code>CompletableFuture</code> is not a bug, but a design decision. <code>CompletableFuture</code> is not inherently bound to any thread, while <code>Future</code> almost always represents background task. It's perfectly fine to create <code>CompletableFuture</code> from scratch (<code>new CompletableFuture&lt;&gt;()</code>) where there is simply no underlying thread to cancel. Still I can't help the feeling that majority of <code>CompletableFuture</code>s <em>will</em> have an associated task and background thread. In that case malfunctioning <code>cancel()</code> is a potential problem. I no longer advice blindly replacing <code>Future</code> with <code>CompletableFuture</code> as it might change the behavior of applications relying on <code>cancel()</code>. This means <code>CompletableFuture</code> intentionally breaks <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a> - and this is a serious implication to consider.<br /><br /><script>SyntaxHighlighter.highlight();</script>