---
layout: post
title: Testing Quartz Cron expressions
date: '2012-10-20T19:40:00.002+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
- intellij idea
- quartz
modified_time: '2012-10-31T13:37:40.772+01:00'
thumbnail: http://3.bp.blogspot.com/-z0PW-z5i9c8/UILd3_FoAhI/AAAAAAAAAns/IqXSTHiN52o/s72-c/100_8514.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7081347593846515102
blogger_orig_url: https://www.nurkiewicz.com/2012/10/testing-quartz-cron-expressions.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-z0PW-z5i9c8/UILd3_FoAhI/AAAAAAAAAns/IqXSTHiN52o/s1600/100_8514.JPG" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://3.bp.blogspot.com/-z0PW-z5i9c8/UILd3_FoAhI/AAAAAAAAAns/IqXSTHiN52o/s320/100_8514.JPG" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Trollvann</td></tr></tbody></table>Declaring complex Cron expressions is still giving me some headaches, especially when some more advanced constructs are used. After all, can you tell when the following trigger will fire <code>"0 0 17 L-3W 6-9 ? *"</code>? Since triggers are often meant to run far in the future, it's desired to test them beforehand and make sure they will actually fire when we think they will.<br /><br /><a href="http://quartz-scheduler.org/">Quartz scheduler</a> (I'm testing version 2.1.6) doesn't provide direct support for that, but it's easy to craft some simple function based on existing APIs, namely <a href="http://quartz-scheduler.org/api/2.1.5/org/quartz/CronExpression.html#getNextValidTimeAfter(java.util.Date)"><code>CronExpression.getNextValidTimeAfter()</code></a> method. Our goal is to define a method that will return next <code>N</code> scheduled executions for a given Cron expression. We cannot request <i>all</i> since some triggers (including the one above) do not have end date, repeating infinitely. We can only depend on aforementioned <code>getNextValidTimeAfter()</code> which takes a date as an argument and returns nearest fire time <code>T<sub>1</sub></code> after that date. So if we want to find second scheduled execution, we must ask about next execution after the first one (<code>T<sub>1</sub></code>). And so on. Let's put that into code:<br /><pre class="brush: scala">def findTriggerTimesIterative(expr: CronExpression, from: Date = new Date, max: Int = 100): Seq[Date] = {<br />    val times = mutable.Buffer[Date]()<br />    var next = expr getNextValidTimeAfter from<br />    while (next != null &amp;&amp; times.size &lt; max) {<br />        times += next<br />        next = expr getNextValidTimeAfter next<br />    }<br />    times<br />}<br /></pre>If there is no next fire time (e.g. trigger is suppose to run only in 2012 and we ask about fire times after 1st of January 2013), <code>null</code> is returned. A little bit of crash testing:<br /><pre class="brush: scala">findTriggerTimesRecursive(new CronExpression("0 0 17 L-3W 6-9 ? *")) foreach println<br /></pre>yields:<br /><a name='more'></a><br /><pre class="brush: plain">Thu Jun 27 17:00:00 CEST 2013<br />Mon Jul 29 17:00:00 CEST 2013<br />Wed Aug 28 17:00:00 CEST 2013<br />Fri Sep 27 17:00:00 CEST 2013<br />Fri Jun 27 17:00:00 CEST 2014<br />Mon Jul 28 17:00:00 CEST 2014<br />Thu Aug 28 17:00:00 CEST 2014<br />Fri Sep 26 17:00:00 CEST 2014<br />Fri Jun 26 17:00:00 CEST 2015<br />Tue Jul 28 17:00:00 CEST 2015<br />Fri Aug 28 17:00:00 CEST 2015<br />Mon Sep 28 17:00:00 CEST 2015<br />Mon Jun 27 17:00:00 CEST 2016<br />...<br /></pre>Hope the meaning of our complex Cron expression is now clearer: <i>closest week day (<code>W</code>) three days before the end of month (<code>L-3</code>) between June and September (<code>6-9</code>) at 17:00:00 (<code>0 0 17</code>)</i>. Now I started experimenting a little bit with different implementations to find the most elegant and suitable for this quite simple problem. First I noticed that the problem is not iterative, but recursive: finding next 100 execution times is equivalent to finding first execution and finding 99 remaining executions after the first one:<br /><pre class="brush: scala">def findTriggerTimesRecursive(expr: CronExpression, from: Date = new Date, max: Int = 100): List[Date] = <br />    expr getNextValidTimeAfter from match {<br />        case null =&gt; Nil<br />        case next =&gt;<br />            if (max &gt; 0)<br />                next :: findTriggerTimesRecursive(expr, next, max - 1)<br />            else<br />                Nil<br />    }<br /></pre>Seems like the implementation is much simpler: no matches - return empty list (<code>Nil</code>). Match found - return it prepended to next matches, unless we already collected enough dates. There is one problem with this implementation though, it's not <a href="http://en.wikipedia.org/wiki/Tail_call">tail-recursive</a>. Very often this can be changed by introducing second function and accumulating the intermediate results in arguments:<br /><pre class="brush: scala">def findTriggerTimesTailRecursive(expr: CronExpression, from: Date = new Date, max: Int = 100) = {<br /><br />    @tailrec def accum(curFrom: Date, curMax: Int, acc: List[Date]): List[Date] = {<br />        expr getNextValidTimeAfter curFrom match {<br />            case null =&gt; acc<br />            case next =&gt;<br />                if (curMax &gt; 0)<br />                    accum(next, curMax - 1, next :: acc)<br />                else<br />                    acc<br />        }<br />    }<br /><br />    accum(from, max, Nil)<br />}<br /></pre>A little bit more complex, but at least <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StackOverflowError.html"><code>StackOverflowError</code></a> won't wake us up in the middle of night. BTW I just noticed IntelliJ IDEA not only shows icons identifying recursion (see next to line number), but also uses different icons when tail-call optimization is employed (!):<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-CmlVnX1XhPI/UILg11-HTII/AAAAAAAAAoI/amEHPGrKrag/s1600/icons.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-CmlVnX1XhPI/UILg11-HTII/AAAAAAAAAoI/amEHPGrKrag/s1600/icons.png" /></a></div><br /><br />So I thought that's best what I can get when another idea came to me. First of all, the artificial <code>max</code> limit (defaulting to 100) seemed awkward. Also why accumulate all the results if we can compute them on the fly, one after another? This is when I realized that I don't need <code>Seq</code> or <code>List</code>, I need an <code>Iterator[Date]</code>!<br /><pre class="brush: scala">class TimeIterator(expr: CronExpression, from: Date = new Date) extends Iterator[Date] {<br />    private var cur = expr getNextValidTimeAfter from<br /><br />    def hasNext = cur != null<br /><br />    def next() = if (hasNext) {<br />        val toReturn = cur<br />        cur = expr getNextValidTimeAfter cur<br />        toReturn<br />    } else {<br />        throw new NoSuchElementException<br />    }<br />}<br /></pre>I've spent some time trying to reduce the <code>if</code> true-branch into one-liner and avoid intermediate <code>toReturn</code> variable. It's possible, but for clarity (and to spare your eyes) I won't reveal it<sup>*</sup>. But why an iterator, known to be less flexible and pleasant to use? Well, first of all it allows us to lazily generate next trigger times, so we don't pay for what we don't use. Also intermediate results aren't stored anywhere, so we can save memory as well. And because everything that works for sequences works for iterators as well, we can easily work with iterators in Scala, e.g. printing (<i>taking</i>) first 10 dates:<br /><pre class="brush: scala">new TimeIterator(expr) take 10 foreach println<br /></pre>It's tempting to do a little benchmark comparing different implementations (here using <a href="http://code.google.com/p/caliper/">caliper</a>):<br /><pre class="brush: scala">object FindTriggerTimesBenchmark extends App {<br />    Runner.main(classOf[FindTriggerTimesBenchmark], Array("--trials", "1"))<br />}<br /><br />class FindTriggerTimesBenchmark extends SimpleBenchmark {<br /><br />    val expr = new CronExpression("0 0 17 L-3W 6-9 ? *")<br /><br />    def timeIterative(reps: Int) {<br />        for (i &lt;- 1 to reps) {<br />            findTriggerTimesIterative(expr)<br />        }<br />    }<br /><br />    def timeRecursive(reps: Int) {<br />        for (i &lt;- 1 to reps) {<br />            findTriggerTimesRecursive(expr)<br />        }<br />    }<br /><br />    def timeTailRecursive(reps: Int) {<br />        for (i &lt;- 1 to reps) {<br />            findTriggerTimesTailRecursive(expr)<br />        }<br />    }<br /><br />    def timeUsedIterator(reps: Int) {<br />        for (i &lt;- 1 to reps) {<br />            (new TimeIterator(expr) take 100).toList<br />        }<br />    }<br /><br />    def timeNotUsedIterator(reps: Int) {<br />        for (i &lt;- 1 to reps) {<br />            new TimeIterator(expr)<br />        }<br />    }<br />}<br /></pre>Seems like the implementation changes have negligible impact on time since most of the CPU is presumably burnt inside <code>getNextValidTimeAfter()</code>.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-GxxbPucU3P0/UILd5Q_rVxI/AAAAAAAAAnw/eyVVU3MHpEA/s1600/caliper.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-GxxbPucU3P0/UILd5Q_rVxI/AAAAAAAAAnw/eyVVU3MHpEA/s1600/caliper.png" /></a></div><br /><h4>What have we learnt today?</h4><ul><li>don't think too much about performance unless you really have a problem. Strive for best design and simplest implementation.<br /> </li><li>think a lot about data structures you want to use to represent your problem and solution. In this (trivial on first sight) problem <code>Iterator</code> (lazily evaluated, possibly infinite stream of items) turned out to be the best approach<br /> </li></ul><sup>*</sup> OK, here's how. Hint: assignment has <code>Unit</code> type and <code>(Date, Unit)</code> tuple is involved here:<br /><pre class="brush: scala">def next() = if (hasNext)<br />    (cur, cur = expr getNextValidTimeAfter cur)._1<br />else<br />    throw new NoSuchElementException<br /></pre>