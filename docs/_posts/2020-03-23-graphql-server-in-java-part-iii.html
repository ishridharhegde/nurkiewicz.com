---
layout: post
title: 'GraphQL server in Java: Part III: Improving concurrency'
date: '2020-03-23T22:56:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- CompletableFuture
- graphql
modified_time: '2020-03-24T01:28:16.972+01:00'
thumbnail: https://1.bp.blogspot.com/-m4w1NLEYUcE/Xna5Cp2SdUI/AAAAAAAA0EQ/I63UX403AfMJNDR0m7iGlLg1lb4wxuG3gCLcBGAsYHQ/s72-c/Screenshot%2B2019-12-21%2Bat%2B00.56.18.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2836052966215266716
blogger_orig_url: https://www.nurkiewicz.com/2020/03/graphql-server-in-java-part-iii.html
---

The idea behind GraphQL is to reduce the number of network round-trips by batching multiple, often unrelated requests, into a single network call. This greatly reduces latency by delivering many pieces of information at once. It’s especially useful when multiple sequential network round-trips can be replaced with a single one. Well, honestly, every web browser does that automatically for us. For example, when we open a website with several images, the browser will send HTTP requests for each image concurrently. Or, to be precise, it will start not more than a certain number of connections to the same host. It’s something between 2 and 8, depending on the browser. The same applies to multiple AJAX/RESTful calls (see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><code>fetch()</code> API</a>), which are concurrent by default with no extra work on a developer’s side. Actually, that’s what <em>A</em> stands for in AJAX<sup>1</sup>.<br /><h2 id="so-whats-the-advantage-of-graphql">So, what’s the advantage of GraphQL?</h2>If a web browser can make concurrent requests to multiple pieces of data at once already, why bother with GraphQL? There are some advantages:<br /><ul><li>if you need to make more than the allowed number of concurrent connections (max 2-8, see above), the browser will throttle you anyway, queuing some requests</li><li>GraphQL prevents over-fetching and N+1 problem by returning only properties and relationships you explicitly asked for, not more, not less</li><li>there is just one, batched request. Concurrency happens on the server side. Well, not really…</li></ul><h2 id="graphql-server-is-not-utilizing-concurrency-by-default">GraphQL server is not utilizing concurrency by default</h2>The last statement is <em>not true</em> by default, in Java’s implementation of GraphQL server. Remember, we provided a bunch of resolvers for each non-trivial property and relationship. Just as a reminder, this is how our resolver looks like:<br /><pre class="prettyprint linenums">@Component<br />class PlayerResolver implements GraphQLResolver&lt;Player&gt; {<br /><br />    Billing billing(Player player) //...<br />    String name(Player player) //...<br />    int points(Player player) //...<br />    ImmutableList&lt;Item&gt; inventory(Player player) //...<br /><br />}</pre>Each of these methods is invoked only on demand and each one is potentially heavyweight. Unfortunately, by default GraphQL engine on the server side invokes resolver methods sequentially. Therefore the overall latency is much worse compared to RESTful API (!) Restful API would take advantage of the browser’s built-in concurrency. To show how awful this behaves, I set up Zipkin and traced each resolver:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-m4w1NLEYUcE/Xna5Cp2SdUI/AAAAAAAA0EQ/I63UX403AfMJNDR0m7iGlLg1lb4wxuG3gCLcBGAsYHQ/s1600/Screenshot%2B2019-12-21%2Bat%2B00.56.18.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="500" data-original-width="1600" height="200" src="https://1.bp.blogspot.com/-m4w1NLEYUcE/Xna5Cp2SdUI/AAAAAAAA0EQ/I63UX403AfMJNDR0m7iGlLg1lb4wxuG3gCLcBGAsYHQ/s640/Screenshot%2B2019-12-21%2Bat%2B00.56.18.png" width="640" /></a></div><br /><br />Notice how entirely unrelated resolvers are waiting for each other. Luckily this performance bottleneck is easy to fix. Turns out GraphQL engine understands <code>CompletableFuture</code>!<br /><h2 id="asynchronous-resolvers">Asynchronous resolvers</h2>Have a look at a revamped resolver API:<br /><pre class="prettyprint linenums">@Component<br />class PlayerResolver implements GraphQLResolver&lt;Player&gt; {<br /><br />    CompletableFuture&lt;Billing&gt; billing(Player player) //...<br />    CompletableFuture&lt;String&gt; name(Player player) //...<br />    CompletableFuture&lt;Integer&gt; points(Player player) //...<br />    CompletableFuture&lt;List&lt;Item&gt;&gt; inventory(Player player) //...<br /><br />}</pre>The source of concurrency is not important here. It can be:<br /><ul><li>Java 9’s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpClient.html"><code>HttpClient</code></a>,</li><li>Dedicated thread pool,</li><li>Converting from Reactor’s reactive <code>Mono</code> using <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--"><code>Mono.toFuture()</code></a>,</li><li>Converting from Kotlin’s [<code>Deferred</code>] object using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-jdk8/kotlinx.coroutines.future/kotlinx.coroutines.-deferred/index.html"><code>asCompletableFuture()</code></a></li><li>…</li></ul>The point being, GraphQL takes that future into account and invokes multiple resolvers at the same time. Just look how wonderful it looks in Zipkin:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-O14--i-GKwY/Xna5JPj0bfI/AAAAAAAA0EU/ktC64keRufgBoRACQ6HySkwInundajHigCLcBGAsYHQ/s1600/Screenshot%2B2019-12-21%2Bat%2B00.53.10.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="500" data-original-width="1600" height="200" src="https://1.bp.blogspot.com/-O14--i-GKwY/Xna5JPj0bfI/AAAAAAAA0EU/ktC64keRufgBoRACQ6HySkwInundajHigCLcBGAsYHQ/s640/Screenshot%2B2019-12-21%2Bat%2B00.53.10.png" width="640" /></a></div><br /><br />This image teaches us two things:<br /><ul><li>the overall latency dropped from 1.1 seconds to 0.6 s - the sum of all latencies to the max of latencies</li><li>even more importantly - did you notice how total latency is mostly affected by slow <code>inventory</code> resolver? Maybe, as a client, you can skip that property and cut latency by half?</li></ul>GraphQL gives clients this fantastic opportunity to customize their queries in a fine-grained fashion. It’s your decision how much data you want. The API producer is no longer in charge. Also, the API doesn’t have to be the lowest common denominator. Each and every client makes an independent decision, rather than <em>one size fits all</em>. Last but not least, being able to profile each and every resolver easily is a great win.<br />The <a href="https://github.com/nurkiewicz/graphql-server-demo">full source</a> code for all articles in this series is available on GitHub, including Zipkin setup on Docker.<br /><br /><ul><li><a href="{{ site.baseurl }}{% post_url 2019-10-01-graphql-server-in-java-part-i-basics %}">Part I: Basics</a></li><li><a href="{{ site.baseurl }}{% post_url 2019-10-24-graphql-server-in-java-part-ii %}">Part II: Understanding Resolvers</a></li><li>Part III: Improving concurrency</li><li><a href="https://github.com/nurkiewicz/graphql-server-demo">github.com/nurkiewicz/graphql-server-demo</a></li></ul><br /><sup>1</sup> - Coincidentally <em>X</em> in <em>AJAX</em> stands for… XML. Well, a technology invented by Microsoft.