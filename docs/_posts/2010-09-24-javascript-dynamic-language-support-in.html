---
layout: post
title: JavaScript dynamic language support in Spring framework
date: '2010-09-24T20:12:00.002+02:00'
author: Tomasz Nurkiewicz
tags:
- spring-js
- groovy
- javascript
- spring
- tdd
- jruby
modified_time: '2011-11-17T18:40:34.139+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7845273221647314404
blogger_orig_url: https://www.nurkiewicz.com/2010/09/javascript-dynamic-language-support-in.html
---

Miško Hevery’s blog <a href="http://misko.hevery.com/2010/04/07/move-over-java-i-have-fallen-in-love-with-javascript">post</a> about JavaScript opened my eyes and changed the way I thought about this language completely. Miško practices TDD and advices this technique at every occasion. JavaScript, being dynamic language, needs tests even more than statically and strongly typed languages. This immediately invalidates main objections against JavaScript and dynamic languages at all – that lack of compile time checks inevitably lead to poor quality and runtime bugs instead of compile time. But what is more convincing to you: that your code passes very strict compile time rules or that it passes unit tests covering all the use cases?<br /><br />After going through the first few chapters of <a href="http://www.amazon.com/gp/product/1847194141?ie=UTF8&amp;tag=javaandneighb-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1847194141">Object-Oriented JavaScript...</a> I couldn’t help myself to try this new, very productive language with functional aspirations. But then I realized that, unlike Java, JavaScript misses:<br /><br /><ul><li>good runtime environment: it’s hard to name handful of web browsers, each implementing different dialect of the language, decent runtime</li><li>good development environment: debugger, editor with code completion, profiler – I mean, <a href="http://getfirebug.com/">Firebug</a> is wonderful, but...</li><li>testing capabilities – aforementioned vast number of web browser in countless versions, actually, how to run such tests on your continuous integration server?</li><li>server-side attitude. C’mon, I’m a <a href="http://geekandpoke.typepad.com/geekandpoke/2010/07/how-to-make-enterprise-software.html">back-end guy</a>, running my code inside a web browser to manipulate page DOM and debug using browser plugin? This just doesn’t feel right. Let me run this script clustered on a farm of 16-core servers to make me excited!</li></ul><br />And when I say server-side, I mean Spring Framework. The idea to run JavaScript on server-side <a href="http://en.wikipedia.org/wiki/Comparison_of_Server-side_JavaScript_solutions">isn’t new</a>, so it would be nice to introduce JavaScript in Spring. Since version 2.0 Spring supports developing beans using few dynamic languages, namely Groovy, JRuby and BeanShell. The support includes:<br /><a name='more'></a><br /><ol><li>Implementing given Java interface using one of the dynamic languages above</li><li>Injecting beans implemented in dynamic language to standard Java beans (other beans simply use Java interface as their client view)</li><li>...and vice-versa – injecting standard Spring beans into dynamic language scripts</li><li>Automatic refresh of script source with configured frequency – sources can be located somewhere on the file system or over the network , allowing hot-deployment and reevaluation without Spring context restart</li><li>Scripted beans can participate in Spring aspects, transactions, etc.</li></ol>The list of features (and possible use cases) for scripted beans is impressive and the whole concept is very powerful. But the list of languages supported is somewhat limited, and – you’ve guessed, but no prize this time – I will add JavaScript to this list in the next few pages. This isn’t going to be very hard since <a href="http://www.mozilla.org/rhino">Rhino</a>, JavaScript engine for Java, is now embedded in JRE.<br /><br />Please at least take a look at Spring dynamic languages support <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/dynamic-language.html">documentation</a> before proceeding, as I will start from the example how I wish the JavaScript support would look like in TDD spirit. Let’s start from simple Java interface:<br /><br /><pre class="brush: java"><br />package org.springframework.scripting.js;<br /><br />public interface HelloService {<br /><br /> String hello(String name);<br /><br /> String helloParameterized(String name, Date effectiveDate, int age, Locale locale);<br /><br />}<br /><br /></pre><br /><br />This is the client view of our bean, the implementation is completely transparent to the users of this interface. What we would like to achieve is to be able to implement this interface using JavaScript similar to Groovy or JRuby support in Spring:<br /><br /><pre class="brush: xml"><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:lang="http://www.springframework.org/schema/lang"<br />       xsi:schemaLocation="<br />http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-3.0.xsd"&gt;<br /><br /> &lt;lang:js id="javaScriptHelloService" script-interfaces="org.springframework.scripting.js.HelloService"&gt;<br />  &lt;lang:inline-script&gt;<br />   function hello(name) {<br />    return "Hello, " + name + "!"<br />   }<br /><br />   function helloParameterized(name, effectiveDate, age, locale) {<br />    return "" + effectiveDate + ": " + name + " (" + (age + 1) + ", " +<br />     locale.getDisplayCountry(java.util.Locale.US) + ")" <br />   }<br /><br />  &lt;/lang:inline-script&gt;<br /> &lt;/lang:js&gt;<br /><br />&lt;/beans&gt;<br /></pre><br /><br />And finally the test case stub:<br /><br /><pre class="brush: java"><br />package org.springframework.scripting.js;<br /><br /><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration<br />public class JavaScriptScriptFactoryHelloTest {<br /><br /> @Resource<br /> private HelloService helloService;<br /><br /> @Test<br /> public void shouldReturnHelloStringFromJs() throws Exception {<br />  //given<br />  final String name = "Tomek";<br /><br />  //when<br />  final String result = helloService.hello(name);<br /><br />  //then<br />  assertThat(result).isEqualTo("Hello, Tomek!");<br /> }<br /><br /> //other tests<br /><br />}<br /><br /></pre><br /><br />Typical Spring integration test looks for file named after the test case name with “<span style="font-family: &quot;;">-context.xml</span>” suffix (see above). As you can see, no JavaScript is visible, test case (being <span style="font-family: &quot;;">HelloService</span> client) uses injected interface and calls its operations. The fact that this works and runs JavaScript using Rhino behind the scenes is completely hidden by Spring Framework. Maybe hidden – but not yet implemented. Test fails, we must provide the implementation.<br /><br />First, one line must be added to <span style="font-family: &quot;;">LangNamespaceHandler</span>, simply mapping <span style="font-family: &quot;;">&lt;lang:js&gt;</span> tag to so-called <i>script factory</i>.<br /><br /><pre class="brush: java"><br />package org.springframework.scripting.config;<br /><br />public class LangNamespaceHandler extends NamespaceHandlerSupport {<br /><br /> public void init() {<br />  registerScriptBeanDefinitionParser("groovy", "org.springframework.scripting.groovy.GroovyScriptFactory");<br />  registerScriptBeanDefinitionParser("jruby", "org.springframework.scripting.jruby.JRubyScriptFactory");<br />  registerScriptBeanDefinitionParser("bsh", "org.springframework.scripting.bsh.BshScriptFactory");<br />  registerScriptBeanDefinitionParser("js", "org.springframework.scripting.js.JavaScriptScriptFactory");<br />  registerBeanDefinitionParser("defaults", new ScriptingDefaultsParser());<br /> }<br /><br />}<br /><br /></pre><br /><br />The purpose of <span style="font-family: &quot;;">JavaScriptScriptFactory</span> is pretty straightforward: it gets set of Java interfaces (have you mentioned the <i style="font-family: &quot;Courier New&quot;,Courier,monospace;">script-interfaces</i> attribute?) and script source and is suppose to return some implementation of all these interfaces, of course utilizing script source provided:<br /><br /><pre class="brush: java"><br />package org.springframework.scripting.js;<br /><br />public class JavaScriptScriptFactory implements ScriptFactory {<br /><br /> public boolean requiresConfigInterface() {<br />  return true;<br /> }<br /><br /> public Object getScriptedObject(ScriptSource scriptSource, Class[] actualInterfaces) throws IOException, ScriptCompilationException {<br />  return //It's a kind of magic<br /> }<br /><br />}<br /></pre><br /><br />Actually, there is no magic out there, just plain <a href="http://jcp.org/en/jsr/detail?id=223">JSR-223</a> API abstracting Rhino engine. But still dynamic proxies, reflection and creating Java interfaces from scratch using CGLIB is taking place out there (luckily Spring manages most of this), so if you are really curious, take a look at my GitHub <a href="http://github.com/nurkiewicz/spring-js/tree/master/src/main/java/org/springframework/scripting/js">account</a>.<br /><br />What have we achieved? Take for instance this JavaScript Spring bean declaration:<br /><br /><pre class="brush: xml"><br />&lt;lang:js id="javaScriptUserService"<br /> script-interfaces="org.springframework.scripting.js.UserService"<br /> script-source="http://somehost:8080/scripts/UserService.js"<br /> refresh-check-delay="15000"/&gt;<br /></pre><br /><br />Enough to make Spring download <span style="font-family: &quot;;">UserService.js</span> file from external HTTP server and reload its contents every 15 seconds. Now in order to change <span style="font-family: &quot;;">UserService</span> behavior simply put new version of <span style="font-family: &quot;;">.js</span> file on your web server (or FTP folder, or file system directory, or...) – no restarts, no class-loaders juggling, no OSGi – unbelievably flexible, deadly simple and terribly dangerous toy – but that’s a different story.<br /><br />We, programmers, love Hello World <a href="http://en.wikibooks.org/wiki/List_of_hello_world_programs">examples</a>. Some of us even judge technologies based on their “<i>hello</i>” incarnation. But how could you use scripted bean in a real world application? The last feature we haven’t covered yet is dependency injection into JavaScript bean (not injecting the bean somewhere else). Spring already provides syntax for that:<br /><br /><pre class="brush: xml"><br />&lt;bean id="resourceBundleMessageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt;<br /> &lt;property name="basename" value="org.springframework.scripting.js.i18n.hello"/&gt;<br />&lt;/bean&gt;<br /><br />&lt;bean id="greatBritainLocale" class="java.util.Locale"&gt;<br /> &lt;constructor-arg value="en_GB"/&gt;<br />&lt;/bean&gt;<br /><br />&lt;lang:js id="javaScriptHelloService"<br />  script-interfaces="org.springframework.scripting.js.HelloService"<br />  script-source="/org/springframework/scripting/js/HelloService.js"&gt;<br /> &lt;lang:property name="city" value="Warsaw"/&gt;<br /> &lt;lang:property name="locale" ref="greatBritainLocale"/&gt;<br /> &lt;lang:property name="messages" ref="resourceBundleMessageSource"/&gt;<br />&lt;/lang:js&gt;<br /><br /></pre><br /><br />As you can see we ask Spring to inject three properties (Spring bean, Java built-in object and primitive) into the script. How can the script use this dependencies? I have decided to enable them directly as implicit variables:<br /><br /><pre class="brush: js"><br />function hello(name) {<br /> return messages.getMessage("hello", [name, city], locale);<br />}<br /><br /></pre><br /><br /><span style="font-family: &quot;;">name</span> is <span style="font-family: &quot;;">hello</span>’s argument, but where does the <span style="font-family: &quot;;">messages</span>, <span style="font-family: &quot;;">city</span> and <span style="font-family: &quot;;">locale</span> come from? Scripted bean can easily interact with other Spring beans (not necessarily written in Java nor JavaScript!), for example asking <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html"> ResourceBundleMessageSource</a> to return internationalized message. I have a <a href="http://github.com/nurkiewicz/spring-js/blob/master/src/test/java/org/springframework/scripting/js/JavaScriptScriptFactoryPropertiesTest.java">test case</a> for that (actually, I started from it), believe me, it works!<br /><br />Finally I can get my hands dirty wit JavaScript. Writing unit tests using JUnit feels much more natural than observing web browser output. Also Spring-enabled scripted beans give me much richer environment to work with. From my complete novice point of view JavaScript isn’t as good as Groovy, but still it’s worth trying, especially when embedding few MiB groovy.jar is out of the question in your Java 6 app. If you want to experiment with JavaScript support in Spring Framework, just clone my GitHub’s <a href="http://github.com/nurkiewicz/spring-js">spring-js</a> repository. And you really like concept of JavaScript running from within Spring, vote for <a href="https://jira.springframework.org/browse/SPR-7592">SPR-7592</a>.