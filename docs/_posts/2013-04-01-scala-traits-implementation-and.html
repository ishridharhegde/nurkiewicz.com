---
layout: post
title: 'Scala traits implementation and interoperability. Part I: Basics'
date: '2013-04-01T23:16:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
- traits
modified_time: '2013-04-07T13:13:16.341+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8914537097194389121
blogger_orig_url: https://www.nurkiewicz.com/2013/04/scala-traits-implementation-and.html
---

Traits in Scala are similar to interfaces, but much more powerful. They allow implementations of some of the methods, fields, stacking, etc. But have you ever wondered how are they implemented on top of JVM? How is it possible to extend multiple traits and where the implementations go to? In this article, based on <a href="http://stackoverflow.com/a/7637888">my StackOverflow answer</a>, I will give several trait examples and explain how <code>scalac</code> implements them, what are the drawbacks and what you get for free. Often we will look at compiled classes and decompile them to Java. It's not essential knowledge, but I hope you'll enjoy it. All examples are compiled against Scala 2.10.1.<br /><br /><h2>Simple trait with no method implementations</h2>The following trait:<br /><br /><pre class="brush: scala">trait Solver {<br />    def answer(question: String): Int<br />}<br /></pre>compiles down to the most boring Java interface:<br /><a name='more'></a><br /><br /><pre class="brush: java">public interface Solver {<br />    int answer(String);<br />}<br /></pre>There is really nothing special in Scala traits. That also means that if you ship <code>Solver.class</code> as part of your library, users can safely implement such interface from Java code. As far as <code>java</code>/<code>javac</code> is concerned, this is an ordinary Java compiled interface.<br /><br /><h2>Traits having some methods implemented</h2>OK, but what if trait actually has some method bodies?<br /><br /><pre class="brush: scala">trait Solver {<br /><br />    def answer(s: String): Int<br /><br />    def ultimateAnswer = answer("Answer to the Ultimate Question of Life, the Universe, and Everything")<br /><br />}<br /></pre>Here, <code>ultimateAnswer</code> method actually has some implementation (the fact that it calls abstract <code>answer()</code> method is irrelevant) while <code>answer()</code> remains unimplemented. What will <code>scalac</code> produce?<br /><br /><pre class="brush: java">public interface Solver {<br />    int answer(java.lang.String);<br />    int ultimateAnswer();<br />}<br /></pre>Well, it's still an interface and the implementation is gone. If the implementation is gone, what happens when we extend such a trait?<br /><br /><pre class="brush: scala">class DummySolver extends Solver {<br /><br />    override def answer(s: String) = 42<br /><br />}<br /></pre>We need to implement <code>answer()</code> but <code>ultimateAnswer</code> is already available via <code>Solver</code>. Anxious to see how it looks under the hood? <code>DummySolver.class</code>:<br /><br /><pre class="brush: java">public class DummySolver implements Solver {<br /><br />    public DummySolver() {<br />        Solver$class.$init$(this);<br />    }<br /><br />    public int ultimateAnswer() {<br />        return Solver$class.ultimateAnswer(this);<br />    }<br /><br />    public int answer(String s) {<br />        return 42;<br />    }<br /><br />}<br /></pre>That... is... weird... Apparently we missed one new class file, <code>Solver$class.class</code>. Yes, the class is named <code>Solver$class</code>, this is valid even in Java. This is <i>not</i> <code>Solver.class</code> expression which returns <code>Class[Solver]</code>, it's apparently an ordinary Java class named <code>Solver$class</code> with a bunch of static methods. Here is how it looks like:<br /><br /><pre class="brush: java">public abstract class Solver$class {<br /><br />    public static int ultimateAnswer(Solver $this) {<br />        return $this.answer("Answer to the Ultimate Question of Life, the Universe, and Everything");<br />    }<br /><br />    public static void $init$(Solver solver) {}<br />}<br /></pre>Do you see the trick? Scala created a helper <code>Solver$class</code> and methods that are implemented inside trait are actually placed in that hidden class. BTW this is not a companion object, it's just a helper class invisible to you. But the real trick is <code>$this</code> parameter, invoked as <code>Solver$class.ultimateAnswer(this)</code>. Since we are technically in another object, we must somehow get a handle of a <i>real</i> <code>Solver</code> instance. It is like OOP but done manually.<br /><br />So we learned that method implementations from traits are extracted to a special helper class. This class is referenced every time we call such a method. This way we don't copy method body over and over into every single class extending given trait.<br /><br /><h2>Extending multiple traits with implementations</h2>Imagine extending multiple traits, each implementing distinct set of methods:<br /><br /><pre class="brush: scala">trait Foo {<br />    def foo = "Foo"<br />}<br /><br />trait Bar {<br />    def bar = "Bar"<br />}<br /><br />class Buzz extends Foo with Bar<br /></pre>By analogy you probably know already how <code>Foo.class</code> and <code>Bar.class</code> look like:<br /><br /><pre class="brush: java">public interface Foo {<br />    String foo();<br />}<br /><br />public interface Bar {<br />    String bar();<br />}<br /></pre>Implementations are hidden in mysterious <code>...$class.class</code> files just as before:<br /><br /><pre class="brush: java">public abstract class Foo$class {<br />    public static String foo(Foo) {<br />        return "Foo";<br />    }<br /><br />    public static void $init$(Foo) {}<br />}<br /><br />public abstract class Bar$class {<br />    public static String bar(Bar) {<br />        return "Bar";<br />    }<br /><br />    public static void $init$(Bar) {}<br />}<br /></pre>Notice that static methods in <code>Foo$class</code> accept instances of <code>Foo</code> while <code>Bar$class</code> require reference to <code>Bar</code>. This works because <code>Buzz</code> implements both <code>Foo</code> and <code>Bar</code>:<br /><br /><pre class="brush: java">public class Buzz implements Foo, Bar {<br /><br />    public Buzz() {<br />        Foo.class.$init$(this);<br />        Bar.class.$init$(this);<br />    }<br /><br />    public String bar() {<br />        return Bar$class.bar(this);<br />    }<br /><br />    public String foo() {<br />        return Foo$class.foo(this);<br />    }<br /><br />}<br /></pre>Both <code>foo()</code> and <code>bar()</code> pass <code>this</code> reference, but this is fine.<br /><br /><h2>Traits with fields</h2>Fields are another interesting feature of traits. This time let's use a real-world example from <a href="http://www.springsource.org/spring-data">Spring Data</a> project. As you know interfaces can require certain methods to be implemented. However they can't force you to provide certain fields (or provide fields on their own). This limitation becomes painful when working with <a href="http://static.springsource.org/spring-data/data-commons/docs/current/api/org/springframework/data/domain/Auditable.html"><code>Auditable&lt;U, ID&gt;</code></a> interface extending <a href="http://static.springsource.org/spring-data/data-commons/docs/current/api/org/springframework/data/domain/Persistable.html"><code>Persistable&lt;ID&gt;</code></a>. While these interfaces merely exist to make sure certain fields are present on your <code>@Entity</code> class, namely <code>createdBy</code>, <code>createdDate</code>, <code>lastModifiedBy</code>, <code>lastModifiedDate</code> and <code>id</code>, this cannot be expressed cleanly. Instead you have to implement the following methods in every single entity extending <code>Auditable</code>:<br /><br /><pre class="brush: java"><br />       U getCreatedBy();<br />    void setCreatedBy(final U createdBy);<br />DateTime getCreatedDate();<br />    void setCreatedDate(final DateTime creationDate);<br />       U getLastModifiedBy();<br />    void setLastModifiedBy(final U lastModifiedBy);<br />DateTime getLastModifiedDate();<br />    void setLastModifiedDate(final DateTime lastModifiedDate);<br /><br />      ID getId();<br /> boolean isNew();<br /></pre>Moreover, every single class must of course define fields highlighted above. Doesn't feel <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a> at all. Luckily traits can help us <i>a lot</i>. In trait we can define what fields should be created in every class extending this trait:<br /><br /><pre class="brush: scala">trait IAmAuditable[ID &lt;: java.io.Serializable] extends Auditable[User, ID] {<br /><br />    var createdBy: User = _<br /><br />    def getCreatedBy = createdBy<br /><br />    def setCreatedBy(createdBy: User) {<br />        this.createdBy = createdBy<br />    }<br /><br />    var createdDate: DateTime = _<br /><br />    def getCreatedDate = createdDate<br /><br />    def setCreatedDate(creationDate: DateTime) {<br />        this.createdDate = creationDate<br />    }<br /><br />    var lastModifiedBy: User = _<br /><br />    def getLastModifiedBy = lastModifiedBy<br /><br />    def setLastModifiedBy(lastModifiedBy: User) {<br />        this.lastModifiedBy = lastModifiedBy<br />    }<br /><br />    var lastModifiedDate: DateTime = _<br /><br />    def getLastModifiedDate = lastModifiedDate<br /><br />    def setLastModifiedDate(lastModifiedDate: DateTime) {<br />        this.lastModifiedDate = lastModifiedDate<br />    }<br /><br />    var id: ID = _<br /><br />    def getId = id<br /><br />    def isNew = id == null<br />}<br /></pre>But wait, Scala has built-in support for POJO-style getters/setters! So we can shorten this to:<br /><br /><pre class="brush: scala">class IAmAuditable[ID &lt;: java.io.Serializable] extends Auditable[User, ID] {<br /><br />    @BeanProperty var createdBy: User = _<br /><br />    @BeanProperty var createdDate: DateTime = _<br /><br />    @BeanProperty var lastModifiedBy: User = _<br /><br />    @BeanProperty var lastModifiedDate: DateTime = _<br /><br />    @BeanProperty var id: ID = _<br /><br />    def isNew = id == null<br />}<br /></pre>Compiler-generated getters and setters implement interface automatically. From now on, every class willing to provide auditing capabilities can extend this trait:<br /><br /><pre class="brush: scala">@Entity<br />class Person extends IAmAuditable[String] {<br /><br />    //...<br /><br />}<br /></pre>All the fields, getters and setters are there. But how is it implemented? Let's look at the generated <code>Person.class</code>:<br /><br /><pre class="brush: java">public class Person implements IAmAuditable&lt;java.lang.String&gt; {<br />    private User createdBy;<br />    private DateTime createdDate;<br />    private User lastModifiedBy;<br />    private DateTime lastModifiedDate;<br />    private java.io.Serializable id;<br /><br />    public User createdBy() //...<br />    public void createdBy_$eq(User) //...<br />    public User getCreatedBy() //...<br />    public void setCreatedBy(User) //...<br /><br />    public DateTime createdDate() //...<br />    public void createdDate_$eq(DateTime) //...<br />    public DateTime getCreatedDate() //...<br />    public void setCreatedDate(DateTime) //...<br /><br />    public boolean isNew();<br /><br />    //...<br />}<br /></pre>There is actually much more, but you get the idea. So fields aren't refactored into a separate class, but that was to be expected. Instead fields are copied into every single class extending this particular trait. In Java we could have used abstract base class for that, but it's nice to reserve inheritance for real <i>is-a</i> relationships and do not use it for dummy field holders. In Scala trait is such a holder, grouping common fields that we can reuse across several classes.<br /><br />What about Java interoperability? Well, <code>IAmAuditable</code> is compiled down to Java interface, thus it doesn't have fields at all. If you implement it from Java, you gain nothing special.<br /><br />We covered basic use cases for traits in Scala and their implementation. In the next article <a href="http://nurkiewicz.blogspot.no/2013/04/scala-traits-implementation-and_3.html">we will explore how mixins and stackable modifications work</a>.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>