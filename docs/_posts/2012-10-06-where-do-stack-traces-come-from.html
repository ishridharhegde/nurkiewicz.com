---
layout: post
title: Where do the stack traces come from?
date: '2012-10-06T12:11:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- stack traces
- caliper
- performance
modified_time: '2012-11-03T20:30:56.510+01:00'
thumbnail: http://1.bp.blogspot.com/-aEPHeUl-BcQ/UHACiS_aAlI/AAAAAAAAAnE/y8W1XKfL2mk/s72-c/100_8140.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-641166685790141415
blogger_orig_url: https://www.nurkiewicz.com/2012/10/where-do-stack-traces-come-from.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-aEPHeUl-BcQ/UHACiS_aAlI/AAAAAAAAAnE/y8W1XKfL2mk/s1600/100_8140.JPG" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://1.bp.blogspot.com/-aEPHeUl-BcQ/UHACiS_aAlI/AAAAAAAAAnE/y8W1XKfL2mk/s320/100_8140.JPG" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Aker Brygge seen from a boat</td></tr></tbody></table>I believe that reading and understanding stack traces is an essential skill every programmer should posses in order to effectively troubleshoot problems with every JVM language (see also: <a href="http://nurkiewicz.blogspot.no/2012/03/filtering-irrelevant-stack-trace-lines.html"><i>Filtering irrelevant stack trace lines in logs</i></a> and <a href="http://nurkiewicz.blogspot.no/2011/09/logging-exceptions-root-cause-first.html"><i>Logging exceptions root cause first</i></a>). So may we start with a little quiz? Given the following piece of code, which methods will be present in the stack trace? <code>foo()</code>, <code>bar()</code> or maybe both?<br /><pre class="brush: java">public class Main {<br /><br />    public static void main(String[] args) throws IOException {<br />        try {<br />            foo();<br />        } catch (RuntimeException e) {<br />            bar(e);<br />        }<br />    }<br /><br />    private static void foo() {<br />        throw new RuntimeException("Foo!");<br />    }<br /><br />    private static void bar(RuntimeException e) {<br />        throw e;<br />    }<br />}<br /></pre>In C# both answers would be possible depending on <a href="http://stackoverflow.com/questions/730250">how the original exception is re-thrown</a> in <code>bar()</code> - <code>throw e</code> overwrites the original stack trace (originating in <code>foo()</code>) with the place where it was thrown again (in <code>bar()</code>). On the other hand bare "<code>throw</code>" keyword re-throws the exception keeping the original stack trace. Java follows the second approach (using the syntax of the first one) and doesn't even allow the former approach directly. But what about this slightly modified version:<br /><pre class="brush: java">public static void main(String[] args) throws IOException {<br />    final RuntimeException e = foo();<br />    bar(e);<br />}<br /><br />private static RuntimeException foo() {<br />    return new RuntimeException();<br />}<br /><br />private static void bar(RuntimeException e) {<br />    throw e;<br />}<br /></pre><code>foo()</code> only creates the exception, but instead of throwing, <i>returns</i> that exception object. This exception is then thrown from a completely different method. How will the stack trace look now? Surprise, it still points to <code>foo()</code>, just like if the exception was thrown from there, exactly the same as in first example:<br /><a name='more'></a><br /><pre class="brush: plain">Exception in thread "main" java.lang.RuntimeException<br />    at Main.foo(Main.java:7)<br />    at Main.main(Main.java:15)<br /></pre>What's going on, you might ask? Looks like <b>the stack trace is not generated when the exception is thrown, but when the exception object is created</b>. In a vast majority of situations these actions occur in the same place, so no one bothers. Many beginning Java programmers aren't even aware that one can create an exception object and assign it to a variable or field or even pass it around.<br /><hr />But where does the exception stack trace come from, really? The answer is quite simple, from <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html#fillInStackTrace()"><code>Throwable.fillInStackTrace()</code> method!</a><br /><pre class="brush: java">public class Throwable implements Serializable {<br /><br />    public synchronized native Throwable fillInStackTrace();<br /><br />//...<br />}<br /></pre>Notice that this method is not <code>final</code>, which allows us to hack a little bit. Not only we can bypass stack trace creation and throw an exception without any context, but even overwrite the stack completely!<br /><pre class="brush: java">public class SponsoredException extends RuntimeException {<br /><br />    @Override<br />    public synchronized Throwable fillInStackTrace() {<br />        setStackTrace(new StackTraceElement[]{<br />                new StackTraceElement("ADVERTISEMENT", "   If you don't   ", null, 0),<br />                new StackTraceElement("ADVERTISEMENT", " want to see this ", null, 0),<br />                new StackTraceElement("ADVERTISEMENT", "     exception    ", null, 0),<br />                new StackTraceElement("ADVERTISEMENT", "    please  buy   ", null, 0),<br />                new StackTraceElement("ADVERTISEMENT", "   full  version  ", null, 0),<br />                new StackTraceElement("ADVERTISEMENT", "  of  the program ", null, 0)<br />        });<br />        return this;<br />    }<br />}<br /><br />public class ExceptionFromHell extends RuntimeException {<br /><br />    public ExceptionFromHell() {<br />        super("Catch me if you can");<br />    }<br /><br />    @Override<br />    public synchronized Throwable fillInStackTrace() {<br />        return this;<br />    }<br />}<br /></pre>Throwing the exceptions above will result in the following errors printed by the JVM (seriously, try it!)<br /><pre class="brush: plain">Exception in thread "main" SponsoredException<br />    at ADVERTISEMENT.   If you don't   (Unknown Source)<br />    at ADVERTISEMENT. want to see this (Unknown Source)<br />    at ADVERTISEMENT.     exception    (Unknown Source)<br />    at ADVERTISEMENT.    please  buy   (Unknown Source)<br />    at ADVERTISEMENT.   full  version  (Unknown Source)<br />    at ADVERTISEMENT.  of  the program (Unknown Source)<br /><br />Exception in thread "main" ExceptionFromHell: Catch me if you can<br /></pre>That's right. <code>ExceptionFromHell</code> is even more interesting. As it does not include the stack trace as part of the exception object, only class name and message are available. Stack trace was lost and neither JVM nor any logging framework can do anything about it. Why on earth would you ever do that (and I am not talking about <code>SponsoredException</code>)?<br />Unexpectedly generating stack trace is considered expensive by some (?) It's a <code>native</code> method and it has to walk down the whole stack to build the <code>StackTraceElement</code>s. Once in my life I saw a library using this technique to make throwing exceptions faster. So I wrote a quick <a href="http://code.google.com/p/caliper/">caliper benchmark</a> to see the performance difference between throwing normal <code>RuntimeException</code> and exception without stack trace filled vs. ordinary method returning value. I run tests with different stack trace depths using recursion:<br /><pre class="brush: java">public class StackTraceBenchmark extends SimpleBenchmark {<br /><br />    @Param({"1", "10", "100", "1000"})<br />    public int threadDepth;<br /><br />    public void timeWithoutException(int reps) throws InterruptedException {<br />        while(--reps &gt;= 0) {<br />            notThrowing(threadDepth);<br />        }<br />    }<br /><br />    private int notThrowing(int depth) {<br />        if(depth &lt;= 0)<br />            return depth;<br />        return notThrowing(depth - 1);<br />    }<br /><br />    //--------------------------------------<br /><br />    public void timeWithStackTrace(int reps) throws InterruptedException {<br />        while(--reps &gt;= 0) {<br />            try {<br />                throwingWithStackTrace(threadDepth);<br />            } catch (RuntimeException e) {<br />            }<br />        }<br />    }<br /><br />    private void throwingWithStackTrace(int depth) {<br />        if(depth &lt;= 0)<br />            throw new RuntimeException();<br />        throwingWithStackTrace(depth - 1);<br />    }<br /><br />    //--------------------------------------<br /><br />    public void timeWithoutStackTrace(int reps) throws InterruptedException {<br />        while(--reps &gt;= 0) {<br />            try {<br />                throwingWithoutStackTrace(threadDepth);<br />            } catch (RuntimeException e) {<br />            }<br />        }<br />    }<br /><br />    private void throwingWithoutStackTrace(int depth) {<br />        if(depth &lt;= 0)<br />            throw new ExceptionFromHell();<br />        throwingWithoutStackTrace(depth - 1);<br />    }<br /><br />    //--------------------------------------<br /><br />    public static void main(String[] args) {<br />        Runner.main(StackTraceBenchmark.class, new String[]{"--trials", "1"});<br />    }<br /><br />}<br /></pre>Here are the results:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-OsjfnPcMX5Y/UHACJP2iu4I/AAAAAAAAAm8/K_RlBwc0qiM/s1600/caliper.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-OsjfnPcMX5Y/UHACJP2iu4I/AAAAAAAAAm8/K_RlBwc0qiM/s1600/caliper.png" /></a></div><br /><br />We can clearly see that the longer the stack trace is, the longer it takes to throw an exception. We also see that for reasonable stack trace lengths throwing an exception should not take more than 100 μs (faster than <a href="https://gist.github.com/2841832">reading 1 MiB of main memory</a>). Finally throwing an exception without stack trace is 2-5 times faster. But honestly, if this is an issue for you, the problem is somewhere else. If your application throws exceptions so often that you actually have to optimize it, there is probably something wrong with your design. Do not fix Java then, it's not broken.<br /><h4>Summary:</h4><ul><li>stack trace always shows the place where the exception (object) was created, not where it was thrown - although in 99% of the cases that's the same place.<br /> </li><li>you have full control over the stack trace returned by your exceptions<br /> </li><li>generating stack trace has some cost, but if it becomes a bottleneck in your application, you are probably doing something wrong.</li></ul><br /><h4>See also:</h4><ul><li>&nbsp;Russian translation: <a href="http://singletonpost.com/otkuda-berutsya-stektreysyi/">Откуда берутся стектрейсы?</a> </li></ul><br /><ul></ul>