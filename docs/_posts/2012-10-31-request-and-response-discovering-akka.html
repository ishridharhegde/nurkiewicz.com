---
layout: post
title: 'Request and response - discovering Akka '
date: '2012-10-31T19:52:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- akka
- scala
modified_time: '2012-11-05T19:35:52.440+01:00'
thumbnail: http://1.bp.blogspot.com/-fkmMc1gICwo/UJFyf1S8qgI/AAAAAAAAApE/1zudHic2uqU/s72-c/100_8093.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-226342276927572987
blogger_orig_url: https://www.nurkiewicz.com/2012/10/request-and-response-discovering-akka.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-fkmMc1gICwo/UJFyf1S8qgI/AAAAAAAAApE/1zudHic2uqU/s1600/100_8093.JPG" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://1.bp.blogspot.com/-fkmMc1gICwo/UJFyf1S8qgI/AAAAAAAAApE/1zudHic2uqU/s320/100_8093.JPG" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Holmenkollen seen from a roof in Nydalen</td></tr></tbody></table>In the previous part we <a href="http://nurkiewicz.blogspot.no/2012/10/your-first-message-discovering-akka.html">implemented our first actor</a> and sent message to it. Unfortunately actor was incapable of returning any result of processing this message, which rendered him rather useless. In this episode we will learn how to send reply message to the sender and how to integrate synchronous, blocking API with (by definition) asynchronous system based on message passing.<br /><br />Before we begin I must draw very strong distinction between an actor (extending <a href="http://doc.akka.io/api/akka/2.0/akka/actor/Actor.html"><code>Actor</code></a> trait) and an actor reference of <a href="http://doc.akka.io/api/akka/2.0/akka/actor/ActorRef.html"><code>ActorRef</code></a> type. When implementing an actor we extend <code>Actor</code> trait which forces us to implement <code>receive</code> method. However we do not create instances of actors directly, instead we ask <code>ActorSystem</code>:<br /><br /><pre class="brush: scala">val randomOrgBuffer: ActorRef = system.actorOf(Props[RandomOrgBuffer], "buffer")<br /></pre>To our great surprise returned object is not of <code>RandomOrgBuffer</code> type like our actor, it's not even an <code>Actor</code>. Thanks to <code>ActorRef</code>, which is a <i>wrapper</i> (<i>proxy</i>) around an actor:<br /><br /><ul><li>internal state, i.e. fields, of an actor is inaccessible from outside (encapsulation)<br /><br /> </li><li>the Akka system makes sure that <code>receive</code> method of each actor processes at most one message at a time (single-threaded) and queues awaiting messages<br /><br /> </li><li>the actual actor can be deployed on a different machine in the cluster, <code>ActorRef</code> transparently and invisibly to the client sends messages over the wire to the correct node in the cluster (more on that later in the series).<br /><br /> </li></ul>That being said let's somehow "return" random numbers fetched inside our actor. In turns out that inside every actor there is a method with very promising name <code>sender</code>. It won't be a surprise if I say that it's an <code>ActorRef</code> pointing to an actor that sent the message which we are processing right now:<br /><a name='more'></a><br /><br /><pre class="brush: scala">object Bootstrap extends App {<br />    //...<br />    randomOrgBuffer ! RandomRequest<br />    //...<br />}<br /><br />//...<br /><br />class RandomOrgBuffer extends Actor with ActorLogging {<br /><br />    def receive = {<br />        case RandomRequest =&gt;<br />            if(buffer.isEmpty) {<br />                buffer ++= fetchRandomNumbers(50)<br />            }<br />            sender ! buffer.dequeue()<br />    }<br />}<br /></pre>I hope you are already accustomed to <code>!</code> notation used to send a message to an actor. If not, there are more conservative alternatives:<br /><br /><pre class="brush: scala">sender tell buffer.dequeue()<br />sender.tell(buffer.dequeue())<br /></pre>Nevertheless instead of printing new random numbers on screen we send them back to the sender. Quick test of our program reveals that... nothing happens. Looking closely at the <code>sender</code> reference we discover that it points to <code>Actor[akka://Akka/deadLetters]</code>. <code>deadLetters</code> doesn't sound very well, but it's logical. <code>sender</code> represents a reference to an actor that sent given message. We have sent the message inside a normal Scala class, not from an actor. If we were using two actors and the first one would have sent a message to the second one, then the second actor can use <code>sender</code> reference pointing to the first actor to send the reply back. Obviously then we would still not be capable of receiving the reply, despite increasing the abstraction.<br /><br />We will look at multi-actor scenarios soon, for the time being we have to learn how to integrate normal, non-Akka code with actors. In other words how to receive a reply so that Akka is not only a black hole that receives messages and never sends any results back. The solution is surprisingly simple - we can <i>wait</i> for a reply!<br /><br /><pre class="brush: scala">implicit val timeout = Timeout(1 minutes)<br /><br />val future = randomOrgBuffer ? RandomRequest<br />val veryRandom: Int = Await.result(future.mapTo[Int], 1 minute)<br /></pre>The name <code>future</code> is not a coincidence. Although it's not an instance of <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html"><code>java.util.concurrent.Future</code></a>, semantically it represents the exact same concept. But first note that instead of exclamation mark we use question mark (<code>?</code>) to send a message. This communication model is known as "<i>ask</i>" as opposed to already introduced "<i>tell</i>". In essence Akka created a temporary actor named <code>Actor[akka://Akka/temp/$d]</code>, sent a message on behalf of that actor and now waits up to one minute for a reply sent back to aforementioned temporary actor. Sending a message is still not-blocking and <code>future</code> object represents result of an operation that might not have been finished yet (it will be available in the <i>future</i>). Next (now in blocking manner) we wait for a reply. In addition <code>mapTo[Int]</code> is necessary since Akka does not know what type of response we expect.<br /><br />You must remember that using the "<i>ask</i>" pattern and waiting/blocking for a reply is very rare. Typically we rely on asynchronous messages and event driven architecture. One actor should never block waiting for a reply from another actor. But in this particular case we need a direct access to return value as we are building bridge between imperative request/response method and message-driven Akka system. Having a reply, what interesting use-cases can we support? For example we can design our own <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Random.html"><code>java.util.Random</code></a> implementation based entirely on ideal, true random numbers!<br /><br /><pre class="brush: scala">class RandomOrgRandom(randomOrgBuffer: ActorRef) extends java.util.Random {<br />    implicit val timeout = Timeout(1 minutes)<br /><br />    override def next(bits: Int) = {<br />        if(bits &lt;= 16) {<br />            random16Bits() &amp; ((1 &lt;&lt; bits) - 1)<br />        } else {<br />            (next(bits - 16) &lt;&lt; 16) + random16Bits()<br />        }<br />    }<br /><br />    private def random16Bits(): Int = {<br />        val future = randomOrgBuffer ? RandomRequest<br />        Await.result(future.mapTo[Int], 1 minute)<br />    }<br />}<br /></pre>The implementation details are irrelevant, enough to say that we must implement the <code>next()</code> method returning requested number of random bits, whereas our actor always returns 16 bits. The only thing we need now is a lightweight <a href="http://www.scala-lang.org/api/current/scala/util/Random.html"><code>scala.util.Random</code></a> wrapping <code>java.util.Random</code> and enjoy ideally shuffled sequence of numbers:<br /><br /><pre class="brush: scala">val javaRandom = new RandomOrgRandom(randomOrgBuffer)<br />val scalaRandom = new scala.util.Random(javaRandom)<br />println(scalaRandom.shuffle((1 to 20).toList))<br />//List(17, 15, 14, 6, 10, 2, 1, 9, 8, 3, 4, 16, 7, 18, 13, 11, 19, 5, 12, 20)<br /></pre>Let's wrap up. First we developed a simple system based on one actor that (if necessary) connects to external web service and buffers a batch of random numbers. When requested, it sends back one number from the buffer. Next we integrated asynchronous world of actors with synchronous API. By wrapping our actor we implemented our own <code>java.util.Random</code> implementation (see also <a href="http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html"><code>java.security.SecureRandom</code></a>). This class can now be used in any place where we need random numbers of very high quality. However the implementation is far from perfect, which we will address in next parts.<br /><br /><a href="https://github.com/nurkiewicz/learning-akka">Source code</a> is available on GitHub (<a href="https://github.com/nurkiewicz/learning-akka/commit/24b2f2ced653fadc391fbe50769b2b69e1b9a597">request-response tag</a>).<br /><br /><blockquote>This was a translation of my article <a href="http://scala.net.pl/poznajemy-akka-zadanie-i-odpowiedz/">"<i>Poznajemy Akka: żądanie i odpowiedź</i>"</a> originally published on <a href="http://scala.net.pl/">scala.net.pl</a>.</blockquote><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>