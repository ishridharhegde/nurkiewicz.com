---
layout: post
title: 'Idiomatic concurrency: flatMap() vs. parallel() - RxJava FAQ'
date: '2017-09-14T10:10:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- concurrency
- rxjava
modified_time: '2017-09-14T12:56:14.751+02:00'
thumbnail: https://2.bp.blogspot.com/-YaKlJORLr5A/Wax02ALpFsI/AAAAAAAAEEs/s4FS0UnAT-82IqfCmsXRwo5DZl-psVtCgCLcBGAs/s72-c/2016-10-23%2B11.01.20.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8066220601726729227
blogger_orig_url: https://www.nurkiewicz.com/2017/09/idiomatic-concurrency-flatmap-vs.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-YaKlJORLr5A/Wax02ALpFsI/AAAAAAAAEEs/s4FS0UnAT-82IqfCmsXRwo5DZl-psVtCgCLcBGAs/s1600/2016-10-23%2B11.01.20.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="901" data-original-width="1600" height="112" src="https://2.bp.blogspot.com/-YaKlJORLr5A/Wax02ALpFsI/AAAAAAAAEEs/s4FS0UnAT-82IqfCmsXRwo5DZl-psVtCgCLcBGAs/s200/2016-10-23%2B11.01.20.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Bieszczady mountains</td></tr></tbody></table>Simple, effective and safe concurrency was one of the design principles of RxJava. Yet, ironically, it's probably one of the most misunderstood aspects of this library. Let's take a simple example: imagine we have a bunch of <code>UUID</code>s and for each one of them we must perform a set of tasks. The first problem is to perform I/O intensive operation per each <code>UUID</code>, for example loading an object from a database:<br /><br /><pre class="brush: java">Flowable&lt;UUID&gt; ids = Flowable<br />        .fromCallable(UUID::randomUUID)<br />        .repeat()<br />        .take(100);<br /><br />ids.subscribe(id -&gt; slowLoadBy(id));</pre>First I'm generating 100 random <code>UUID</code>s just for the sake of testing. Then for each <code>UUID</code> I'd like to load a record using the following method:<br /><br /><pre class="brush: java">Person slowLoadBy(UUID id) {<br />    //...<br />}</pre>The implementation of <code>slowLoadBy()</code> is irrelevant, just keep in mind it's slow and blocking. Using <code>subscribe()</code> to invoke <code>slowLoadBy()</code> has many disadvantages:<br /><br /><ul><li><code>subscribe()</code> is single-threaded by design and there is no way around it. Each <code>UUID</code> is loaded sequentially</li><li>when you call <code>subscribe()</code> you can not transform <code>Person</code> object further. It's a terminal operation</li></ul>A more robust, and even more broken, approach is to <code>map()</code> each <code>UUID</code>:<br /><br /><pre class="brush: java">Flowable&lt;Person&gt; people = ids<br />        .map(id -&gt; slowLoadBy(id));  //BROKEN</pre>This is very readable but unfortunately broken. Operators, just like subscribers, are single-threaded. This means at any given time only one <code>UUID</code> can be mapped, no concurrency is allowed here as well. To make matters worse, we are inheriting thread/worker from upstream. This has several drawbacks. If the upstream produces events using some dedicated scheduler, we will hijack threads from that scheduler. For example many operators, like <code>interval()</code>, use <code>Schedulers.computation()</code> thread pool transparently. We suddenly start to perform I/O intensive operations on a pool that is totally not suitable for that. Moreover, we slow down the whole pipeline with this one blocking, sequential step. Very, very bad.<br /><br />You might have heard about this <code>subscribeOn()</code> operator and how it enables concurrency. Indeed, but you have to be very careful when applying it. The following sample is (again) <em>wrong</em>:<br /><br /><pre class="brush: java">import io.reactivex.schedulers.Schedulers;<br /><br /><br />Flowable&lt;Person&gt; people = ids<br />        .subscribeOn(Schedulers.io())<br />        .map(id -&gt; slowLoadBy(id)); //BROKEN</pre>The code snippet above is still broken. <code>subscribeOn()</code> (and <code>observeOn()</code> for that matter) barely switch execution to a different worker (thread) without introducing any concurrency. The stream still sequentially processes all events, but on a different thread. In other words - rather than consuming events sequentially on a thread inherited from upstream, we now consume them sequentially on <code>io()</code> thread. So what about this mythical <code>flatMap()</code> operator?<br /><br /><h1 id="flatmap-operator-to-the-rescue"><code>flatMap()</code> operator to the rescue</h1><code>flatMap()</code> operator enables concurrency by splitting a stream of events into a stream of substreams. But first, one more broken example:<br /><br /><pre class="brush: java">Flowable&lt;Person&gt; asyncLoadBy(UUID id) {<br />    return Flowable.fromCallable(() -&gt; slowLoadBy(id));<br />}<br /><br />Flowable&lt;Person&gt; people = ids<br />        .subscribeOn(Schedulers.io())<br />        .flatMap(id -&gt; asyncLoadBy(id)); //BROKEN</pre>Oh gosh, this is still <em>broken</em>! <code>flatMap()</code> operator logically does two things:<br /><br /><ul><li>applying the transformation (<code>id -&gt; asyncLoadBy(id)</code>) on each upstream event - this produces <code>Flowable&lt;Flowable&lt;Person&gt;&gt;</code>. This makes sense, for each upstream <code>UUID</code> we get a <code>Flowable&lt;Person&gt;</code> so we end up with a stream of streams of <code>Person</code> objects<br /><br /></li><li>then <code>flatMap()</code> tries to subscribe to <em>all</em> of these inner sub-streams at once. Whenever any of the substreams emit a <code>Person</code> event, it is transparently passed as an outcome of outer <code>Flowable</code>.<br /><br /></li></ul>Technically, <code>flatMap()</code> only creates and subscribes to the first 128 (by default, optional <code>maxConcurrency</code> parameter) substreams. Also when the last substream completes, outer stream of <code>Person</code> completes as well. Now, why on earth is this broken? RxJava doesn't introduce any thread pool unless explicitly asked for. For example this piece of code is still blocking:<br /><br /><pre class="brush: java">log.info("Setup");<br />Flowable&lt;String&gt; blocking = Flowable<br />        .fromCallable(() -&gt; {<br />            log.info("Starting");<br />            TimeUnit.SECONDS.sleep(1);<br />            log.info("Done");<br />            return "Hello, world!";<br />        });<br />log.info("Created");<br />blocking.subscribe(s -&gt; log.info("Received {}", s));<br />log.info("Done");</pre>Look at the output carefully, especially on the order of events and threads involved:<br /><br /><pre class="brush: java">19:57:28.847 | INFO  | main | Setup<br />19:57:28.943 | INFO  | main | Created<br />19:57:28.949 | INFO  | main | Starting<br />19:57:29.954 | INFO  | main | Done<br />19:57:29.955 | INFO  | main | Received Hello, world!<br />19:57:29.957 | INFO  | main | Done</pre>No concurrency whatsoever, no extra threads. Merely wrapping blocking code in a <code>Flowable</code> doesn't magically add concurrency. You have to explicitly use... <code>subscribeOn()</code>:<br /><br /><pre class="brush: java">log.info("Setup");<br />Flowable&lt;String&gt; blocking = Flowable<br />        .fromCallable(() -&gt; {<br />            log.info("Starting");<br />            TimeUnit.SECONDS.sleep(1);<br />            log.info("Done");<br />            return "Hello, world!";<br />        })<br />        .subscribeOn(Schedulers.io());<br />log.info("Created");<br />blocking.subscribe(s -&gt; log.info("Received {}", s));<br />log.info("Done");</pre>The output this time is more promising:<br /><br /><pre class="brush: java">19:59:10.547 | INFO  | main | Setup<br />19:59:10.653 | INFO  | main | Created<br />19:59:10.662 | INFO  | main | Done<br />19:59:10.664 | INFO  | RxCachedThreadScheduler-1 | Starting<br />19:59:11.668 | INFO  | RxCachedThreadScheduler-1 | Done<br />19:59:11.669 | INFO  | RxCachedThreadScheduler-1 | Received Hello, world!</pre>But we <em>did</em> use <code>subscribeOn()</code> last time, what's going on? Well, <code>subscribeOn()</code> on the outer stream level basically said that all events should be processed sequentially, within this stream, on a different thread. We didn't say that there should many sub-streams running concurrently. And because all sub-streams are blocking, when RxJava tries to subscribe to all of them, it effectively subscribes sequentially to one after another. <code>asyncLoadBy()</code> is not really <em>async</em>, thus it blocks when <code>flatMap()</code> operator tries to subscribe to it. The fix is easy. Normally you would put <code>subscribeOn()</code> inside <code>asyncLoadBy()</code> but for educational purposes I'll place it directly in the main pipeline:<br /><br /><pre class="brush: java">Flowable&lt;Person&gt; people = ids<br />    .flatMap(id -&gt; asyncLoadBy(id).subscribeOn(Schedulers.io()));</pre>Now it works like a charm! By default RxJava will take first 128 upstream events (<code>UUID</code>s), turn them into sub-streams and subscribe to all of them. If sub-streams are asynchronous and highly parallelizable (e.g. network calls), we get 128 concurrent invocations of <code>asyncLoadBy()</code>. The concurrency level (128) is configurable via <code>maxConcurrency</code> parameter:<br /><br /><pre class="brush: java">Flowable&lt;Person&gt; people = ids<br />    .flatMap(id -&gt;<br />                asyncLoadBy(id).subscribeOn(Schedulers.io()),<br />                10  //maxConcurrency<br />    );</pre>That was a lot of work, don't you think? Shouldn't concurrency be even more declarative? We no longer deal with <code>Executor</code>s and futures, but still, it seems this approach is too error prone. Can't it be as simple as <code>parallel()</code> in Java 8 streams?<br /><br /><h1 id="enter-paralleleflowable">Enter <code>ParallelFlowable</code></h1>Let's first look again at our example and make it even more complex by adding <code>filter()</code>:<br /><br /><pre class="brush: java">Flowable&lt;Person&gt; people = ids<br />        .map(this::slowLoadBy)     //BROKEN<br />        .filter(this::hasLowRisk); //BROKEN</pre>where <code>hasLowRisk()</code> is a <em>slow</em> predicate:<br /><br /><pre class="brush: java">boolean hasLowRisk(Person p) {<br />    //slow...<br />}</pre>We already know that idiomatic approach to this problem is by using <code>flatMap()</code>, twice:<br /><br /><pre class="brush: java">Flowable&lt;Person&gt; people = ids<br />        .flatMap(id -&gt; asyncLoadBy(id).subscribeOn(io()))<br />        .flatMap(p -&gt; asyncHasLowRisk(p).subscribeOn(io()));</pre><code>asyncHasLowRisk()</code> is rather obscure - it either returns a single-element stream when predicate passes or an empty stream when it fails. This is how you emulate <code>filter()</code> using <code>flatMap()</code>. Can we do better? Since RxJava 2.0.5 there is a new operator called... <code>parallel()</code>! It's quite surprising because operator with the same name <a href="https://github.com/ReactiveX/RxJava/issues/1673">was removed</a> before RxJava became 1.0 due to many misconceptions and being misused. <code>parallel()</code> in 2.x seems to finally address the problem of idiomatic concurrency in a safe and declarative way. First, let's see some beautiful code!<br /><br /><pre class="brush: java">Flowable&lt;Person&gt; people = ids<br />        .parallel(10)<br />        .runOn(Schedulers.io())<br />        .map(this::slowLoadBy)<br />        .filter(this::hasLowRisk)<br />        .sequential();</pre>Just like that! A block of code between <code>parallel()</code> and <code>sequential()</code> runs... in parallel. What do we have here? First of all the new <code>parallel()</code> operator turns <code>Flowable&lt;UUID&gt;</code> into <code>ParallelFlowable&lt;UUID&gt;</code> which has a much smaller API than Flowable. You'll see in a second why. The optional <code>int</code> parameter (<code>10</code> in our case) defines concurrency, or (as the documentation puts it) how many concurrent "rails" are created. So for us we split single <code>Flowable&lt;Person&gt;</code> into 10 concurrent, independent rails (think: <em>threads</em>). Events from original stream of <code>UUID</code>s are split (<code>modulo 10</code>) into different rails, sub-streams that are independent from each other. Think of them as sending upstream events into 10 separate threads. But first we have to define where these threads come from - using handy <code>runOn()</code> operator. This is so much better than <code>parallel()</code> on Java 8 streams where you have no control over concurrency level.<br /><br />At this point we have a <code>ParallelFlowable</code>. When an event appears in upstream (<code>UUID</code>) it is delegated to one of 10 "rails", concurrent, independent pipelines. Pipeline provides a limited subset of operators that are safe to run concurrently, e.g. <code>map()</code> and <code>filter()</code>, but also <code>reduce()</code>. There is no <code>buffer()</code>, <code>take()</code> etc. as their semantics are unclear when invoked on many sub-streams at once. Our blocking <code>slowLoadBy()</code> as well as <code>hasLowRisk()</code> are still invoked sequentially, but only within single "rail". Because we now have 10 concurrent "rails", we effectively parallelized them without much effort.<br /><br />When events reach the end of sub-stream ("rail") they encounter <code>sequential()</code> operator. This operator turns <code>ParallelFlowable</code> back into <code>Flowable</code>. As long as our mappers and filters are thread-safe, <code>parallel()</code>/<code>sequential()</code> pair provides very easy way of parallelizing streams. One small caveat - you will inevitably get messages reordered. Sequential <code>map()</code> and <code>filter()</code> always preserve order (like most operators). But once you run them within <code>parallel()</code> block, the order is lost. This allows for greater concurrency, but you have to keep that in mind.<br /><br />Should you use <code>parallel()</code> rather than nested <code>flatMap()</code> to parallelize your code? It's up to you, but <code>parallel()</code> seems to be much easier to read and grasp.<br /><br /><script>SyntaxHighlighter.highlight();</script>