---
layout: post
title: Lazy sequences in Scala and Clojure
date: '2013-05-04T11:53:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- clojure
- scala
modified_time: '2013-05-04T11:53:04.458+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2890020890886760312
blogger_orig_url: https://www.nurkiewicz.com/2013/05/lazy-sequences-in-scala-and-clojure.html
---

<i>Lazy sequences</i> (also known as <i>streams</i>) are an interesting functional data structure which you might have never heard of. Basically lazy sequence is a list that is not fully known/computed until you actually use it. Imagine a list that is very expensive to create and you don't want to compute too much - but still allow clients to consume as much as they want or need. Similar to iterator, however iterators are destructive - once you read them, they're gone. Lazy sequences on the other hand remember already computed elements.<br /><br />Notice that this abstraction even allows us to construct and work with <i>infinite</i> streams! It's perfectly possible to create a lazy sequence of prime numbers or <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci series</a>. It's up to the client to decide how many elements they want to consume - and only that many are going to be generated. Compare it to eager list - that has to be precomputed prior to first usage and iterator - that forgets about already computed values. <br /><br />Remember however that lazy sequences are always traversed from the beginning so in order to find Nth element lazy sequence will have to compute preceding N-1 elements.<br /><br />I try to avoid purely academic examples thus there will be no Fibonacci series example. You will find it in every article on the subject. Instead we will implement something useful - <a href="http://en.wikipedia.org/wiki/Cron">Cron expression</a> testing utility, returning a sequence of next fire times. We already <a href="http://nurkiewicz.blogspot.no/2012/10/testing-quartz-cron-expressions.html">implemented testing Cron expressions</a> before, using recursion and iterator. To quickly recap, we would like to make sure that our Cron expression is correct and fires when we really expect it. <a href="http://www.quartz-scheduler.org/">Quartz scheduler</a> provides convenient <a href="http://quartz-scheduler.org/api/2.1.7/org/quartz/CronExpression.html#getNextValidTimeAfter(java.util.Date)"><code>CronExpression.getNextValidTimeAfter(Date)</code></a> method that returns next fire time after given date. If we want to compute e.g. next ten fire times, we need to call this method ten times, but! The result of first invocation should be passed as an argument to the second invocation - after all once we know when the job will fire the first time, we want to know what is the fire time of the next invocation (after the first one). And continuing, in order to find third invocation time we must pass second invocation time as an argument. This description led us to simple recursive algorithm:<br /><br /><pre class="brush: scala">def findTriggerTimesRecursive(expr: CronExpression, after: Date): List[Date] =<br />    expr getNextValidTimeAfter after match {<br />        case null =&gt; Nil<br />        case next =&gt; next :: findTriggerTimesRecursive(expr, next)<br />    }<br /></pre><code>getNextValidTimeAfter()</code> may return <code>null</code> to indicate that Cron expression will never fire again (e.g. it only runs during 2013 and we already reached the end of year). However this solution has multiple issues:<br /><a name='more'></a><br /><br /><ul><li>we don't really know how many future dates client needs so we most likely generate too much, unnecessarily consuming CPU cycles<sup>1</sup><br /><br /></li><li>even worse, some Cron expressions never end. <code>"0 0 17 * * ? *"</code> will run at 5 PM every day, every year, to infinity. We definitely don't have that much time and memory<br /><br /></li><li>our implementation is not tail-recursive. Easy to fix though<br /><br /></li></ul>What if we had a "list-like" data structure that we could pass around and work with it just like with any other sequence, but without eagerly evaluating it? Here is an implementation in Scala of <code>Stream[Date]</code> that computes next fire times only when needed:<br /><br /><pre class="brush: scala">def findTriggerTimes(expr: CronExpression, after: Date): Stream[Date] =<br />    expr getNextValidTimeAfter after match {<br />        case null =&gt; Stream.Empty<br />        case next =&gt; next #:: findTriggerTimes(expr, next)<br />    }<br /></pre>Look carefully as it's almost identical! We replaced <code>List[Date]</code> with <code>Stream[Date]</code> (both implement <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.LinearSeq"><code>LinearSeq</code></a>), <code>Nil</code> with <code>Stream.Empty</code> and <code>::</code> with <code>#::</code>. Last change is crucial. <code>#::</code> method (yes, it's a method...) accepts <code>tl: =&gt; Stream[A]</code> - <i>by name</i>. It means the <code>findTriggerTimes(expr, next)</code> is not really called here! It is actually a closure that we pass to <code>#::</code> higher order function. This closure is evaluated only if needed. Let's play a bit with this code:<br /><br /><pre class="brush: scala">val triggerTimesStream = findTriggerTimes("0 0 17 L-3W 6-9 ? *")<br /><br />println(triggerTimesStream)<br />//Stream(Thu Jun 27 17:00:00 CEST 2013, ?)<br /><br />val firstThree = triggerTimesStream take 3<br />println(firstThree.toList)<br />//List(Thu Jun 27 17:00:00 CEST 2013, Mon Jul 29 17:00:00 CEST 2013, Wed Aug 28 17:00:00 CEST 2013)<br /><br />println(triggerTimesStream)<br />//Stream(Thu Jun 27 17:00:00 CEST 2013, Mon Jul 29 17:00:00 CEST 2013, Wed Aug 28 17:00:00 CEST 2013, ?)<br /></pre>Look carefully. Initially printing the stream barely shows the first element. Question mark in <code>Stream.toString</code> represents unknown remaining part of the stream. Then we take first three elements. Interestingly we have to transform the result to <code>List</code>. Invoking <code>take(3)</code> alone barely returns another stream, further postponing evaluation as long as possible. But printing the original stream again shows all three elements as well, but the forth one is not known yet.<br /><br />Let's do something more advanced. Say we would like to find out when will the Cron expression fire for the 100th time? And how many times will it fire within one year from today?<br /><br /><pre class="brush: scala">val hundredth = triggerTimesStream.drop(99).head<br /><br />val calendar = new GregorianCalendar()<br />calendar.add(Calendar.YEAR, 1)<br />val yearFromNow = calendar.getTime<br /><br />val countWithinYear = triggerTimesStream.takeWhile(_ before yearFromNow).size<br /></pre>Computing 100th fire time is pretty straightforward - simply discard first 99 dates and take the first one of what's left. However the word <i>discard</i> is a bit unfortunate - these items are computed and cached in <code>triggerTimesStream</code> so the next time we try to access any of the first 100 elements, they are available immediately. Interesting fact: <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream"><code>Stream[T]</code></a> in Scala is immutable and thread-safe but it keeps changing internally while you iterate over it. But this is an implementation detail.<br /><br />You may be wondering why I use <code>takeWhile(...).size</code> instead of simple <code>filter(...).size</code> or even <code>count(...)</code>? Well, from the definition fire times in our stream are growing so if we only want to count dates within one year, the moment we find first non-matching date we can stop. But it's not only a micro-optimization. Remember that streams can be infinite? Think about it. In the meantime we will port our small utility to Clojure.<br /><br /><h1>Clojure</h1>the stream (<code>lazy-seq</code>) in Clojure:<br /><br /><pre class="brush: plain">(defn find-trigger-times [expr after]<br />    (let [next (. expr getNextValidTimeAfter after)] <br />        (case next<br />            nil []<br />            (cons next (lazy-seq (find-trigger-times expr next))))))<br /></pre>This is almost exact translation of Scala code, except it uses one <code>let</code> binding to capture <code>getNextValidTimeAfter()</code> result. Less literate but more compact translation can be crafted with <code>if-let</code> form:<br /><br /><pre class="brush: plain">(defn find-trigger-times [expr after]<br />    (if-let [next (. expr getNextValidTimeAfter after)] <br />        (cons next (lazy-seq (find-trigger-times expr next)))<br />        []))<br /></pre><code>if-let</code> combines condition and binding. If expression bound to <code>next</code> is false (or <code>nil</code> in our case), 3rd line is not evaluated at all. Instead the result of fourth line (empty sequence) is returned. These two implementations are equivalent. For completeness let us see how to grab 100th element and count number of dates matching Cron expression within one year:<br /><br /><pre class="brush: plain">(def expr (new CronExpression "0 0 17 L-3W 6-9 ? *"))<br />(def trigger-times (find-trigger-times expr (new Date)))<br /><br />(def hundredth (first (drop 99 trigger-times)))<br /><br />(def year-from-now (let [calendar (new GregorianCalendar)] <br />    (. calendar add Calendar/YEAR 1)<br />    (. calendar getTime)))<br /><br />(take-while #(.before % year-from-now) trigger-times)<br /></pre>Notice that, again, we use <code>take-while</code> instead of simple <code>filter</code><br /><br /><h1>Space and time complexity</h1>Imagine using <code>filter()</code> instead of <code>takeWhile()</code> to calculate how many times Cron trigger will fire within next year. Remember that streams in general (and our Cron stream in particular) can be infinite. Simple <code>filter()</code> on a <code>Stream</code> will run until it reaches end - which may never happen with infinite stream. The same applies to even such simple methods like <code>size</code> - <code>Stream</code> will keep evaluating more and more until it reaches the end. But sooner your program will fill in whole heap space. Why? Because once element is evaluated, <code>Stream[T]</code> will cache it for later.<br /><br />Accidentally holding head of a large <code>Stream</code> is another danger:<br /><br /><pre class="brush: scala">val largeStream: Stream[Int] = //,..<br />//...<br />val smallerStream = largeStream drop 1000000<br /></pre><code>smallerStream</code> is a reference to a stream without first million elements. But these elements are still cached in original <code>largeStream</code>. As long as you keep a reference to it, they are kept in memory. The moment <code>largeStream</code> reference goes out of scope, first million elements are eligible for garbage collection, while the remaining part of the stream is still referenced.<br /><br />The discussion above applies equally well to Scala and Clojure. As you can see you have to be really careful when working with lazy sequences. They are very powerful and ubiquitous in functional languages - but <a href="http://en.wikiquote.org/wiki/Stan_Lee">"<i>With great power, comes great responsibility</i>"</a>. The moment you start playing with possibly infinite entities, you have to be careful.<br /><br /><h1><code>iterate</code></h1>If you are more experienced with Clojure or Scala you might be wondering why I haven't used <a href="http://clojuredocs.org/clojure_core/clojure.core/iterate"><code>(iterate f x)</code></a> or <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream$"><code>Stream.iterate()</code></a>. These helper methods are great when you have an infinite stream and when each element can be computed as a function of the previous one. Clearly Cron stream cannot take advantage of this handy tool as it <i>can</i> be finite as shown earlier. But for the sake of being complete, here is a much shorter, <b>but incorrect</b> implementation using <code>iterate</code>:<br /><br /><pre class="brush: scala">def infiniteFindTriggerTimes(expr: CronExpression, after: Date) =<br />    Stream.iterate(expr getNextValidTimeAfter after){last =&gt;<br />        expr getNextValidTimeAfter last<br />    }<br /></pre>...and Clojure:<br /><br /><pre class="brush: plain">(defn find-trigger-times [expr after]<br />    (iterate <br />        #(. expr getNextValidTimeAfter %)<br />        (. expr getNextValidTimeAfter after)))<br /></pre>The idea in both cases is simple: we provide initial element <code>x</code> (first argument in Scala, second in Clojure) and a function <code>f</code> that transforms previous element to current one. In other words we produce the following stream: <code>[x, f(x), f(f(x)), f(f(f(x))), ...]</code>.<br /><br />Implementations above work until they reach end of stream (if any). So to end with something positive we shall use <code>iterate</code> to produce infinite stream of prime numbers (apologize for such a theoretical problem) using naïve <code>prime?</code> predicate:<br /><br /><pre class="brush: plain">(defn- divisors [x] <br />    (filter #(zero? (rem x %))<br />        (range 2 (inc (Math/sqrt x)))))<br />(defn- prime? [x] (empty? (divisors x)))<br />(defn- next-prime [after] <br />    (loop [x (inc after)] <br />        (if (prime? x) <br />            x<br />            (recur (inc x)))))<br />(def primes (iterate next-prime 2))<br /></pre>I hope both the idea and the implementation are clear. If a number doesn't have any divisors, it's considered prime. <code>next-prime</code> returns subsequent prime number greater than a given value. So <code>(next-prime 2)</code> yields <code>3</code>, <code>(next-prime 3)</code> gives <code>5</code> and so on. Using this function we can build <code>primes</code> lazy sequence by simply providing first prime number and <code>next-prime</code> function.<br /><br /><h1>Conclusion</h1>Lazy sequences (or streams) are great abstractions, impossible or tedious to represent in imperative languages. They feel like normal lists but they are evaluated only when needed. Both Scala and Clojure have great support for them and they behave similarly. You can map, filter, cut etc. on streams and they never really compute their elements as long as it's not really needed. Moreover they cache already computed values while still being thread-safe. However when dealing with infinity, care must be taken. If you try to innocently count elements of infinite stream or find non-existing item (e.g. <code>primes.find(_ == 10)</code>) no one will save you.<br /><br /><sup>1</sup> - <code>getNextValidTimeAfter()</code> full implementation is <a href="http://grepcode.com/file/repo1.maven.org/maven2/org.quartz-scheduler/quartz/2.1.6/org/quartz/CronExpression.java#CronExpression.getTimeAfter(java.util.Date)">400 lines long</a>.<br /><br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>