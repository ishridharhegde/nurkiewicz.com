---
layout: post
title: Mapping enums done right with @Convert in JPA 2.1
date: '2013-06-02T23:00:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- eclipselink
- jpa
- spring
modified_time: '2013-06-02T23:00:42.617+02:00'
thumbnail: http://4.bp.blogspot.com/-j7xDCrz-9F0/UauxY9iDvAI/AAAAAAAAAws/voW0njwC_Ag/s72-c/oslo-0.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-6873036090398150824
blogger_orig_url: https://www.nurkiewicz.com/2013/06/mapping-enums-done-right-with-convert.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-j7xDCrz-9F0/UauxY9iDvAI/AAAAAAAAAws/voW0njwC_Ag/s1600/oslo-0.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="130" src="http://4.bp.blogspot.com/-j7xDCrz-9F0/UauxY9iDvAI/AAAAAAAAAws/voW0njwC_Ag/s200/oslo-0.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Torshovdalen</td></tr></tbody></table>If you ever worked with Java enums in JPA you are definitely aware of their limitations and traps. Using <code>enum</code> as a property of your <code>@Entity</code> is often very good choice, however JPA prior to 2.1 didn’t handle them very well. It gave you 2+1 choices:<br /><br /><ol><li><code>@Enumerated(EnumType.ORDINAL)</code> (default) will map <code>enum</code> values using <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#ordinal()"><code>Enum.ordinal()</code></a>. Basically first enumerated value will be mapped to <code>0</code> in database column, second to <code>1</code>, etc. This is very compact and works great to the point when you want to modify your enum. Removing or adding value in the middle or rearranging them will totally break existing records. Ouch! To make matters worse, unit and integration tests often work on clean database, so they won’t catch discrepancy in old data.<br /><br /></li><li><code>@Enumerated(EnumType.STRING)</code> is much safer because it stores string representation of <code>enum</code>. You can now safely add new values and move them around. However renaming <code>enum</code> in Java code will still break existing records in DB. Even more important, such representation is very verbose, unnecessarily consuming database resources.<br /><br /></li><li>You can also use raw representation (e.g. single <code>char</code> or <code>int</code>) and map it manually back and forth in <code>@PostLoad</code>/<code>@PrePersist</code>/<code>@PreUpdate</code> events. Most flexible and safe from database perspective, but quite ugly.<br /><br /></li></ol>Luckily <a href="https://java.net/projects/jpa-spec/">Java Persistence API 2.1</a> (<a href="http://jcp.org/en/jsr/detail?id=338">JSR-388</a>) released few days ago provides standardized mechanism of <a href="http://en.wikibooks.org/wiki/Java_Persistence/Basic_Attributes#Converters_.28JPA_2.1.29">pluggable data converters</a>. Such API was present for ages in proprietary forms and it’s not really rocket science, but having it as part of JPA is a big improvement. To my knowledge <a href="http://www.eclipse.org/eclipselink/">Eclipselink</a> is the only JPA 2.1 implementation available to date, so we will use it to experiment a bit.<br /><br />We will start from <a href="https://github.com/nurkiewicz/books">sample Spring application</a> developed as part of <a href="http://nurkiewicz.blogspot.no/2011/07/poor-mans-crud-jqgrid-rest-ajax-and.html">“<i>Poor man’s CRUD: jqGrid, REST, AJAX, and Spring MVC in one house</i>”</a> article. That version had no persistence, so we will add thin DAO layer on top of Spring Data JPA backed by Eclipselink. Only entity so far is <code>Book</code>:<br /><br /><pre class="brush: java">@Entity<br />public class Book {<br /><br />    @Id<br />    @GeneratedValue(strategy = IDENTITY)<br />    private Integer id;<br /><br />    //...<br /><br />    private Cover cover;<br /><br />    //...<br />}<br /></pre>Where <code>Cover</code> is an <code>enum</code>:<br /><a name='more'></a><br /><br /><pre class="brush: java">public enum Cover {<br /><br />    PAPERBACK, HARDCOVER, DUST_JACKET<br /><br />}<br /></pre>Neither <code>ORDINAL</code> nor <code>STRING</code> is a good choice here. The former because rearranging first three values in any way will break loading of existing records. The latter is too verbose. Here is where custom converters in JPA come into play:<br /><br /><pre class="brush: java">import javax.persistence.AttributeConverter;<br />import javax.persistence.Converter;<br /><br />@Converter<br />public class CoverConverter implements AttributeConverter&lt;Cover, String&gt; {<br /><br />    @Override<br />    public String convertToDatabaseColumn(Cover attribute) {<br />        switch (attribute) {<br />            case DUST_JACKET:<br />                return "D";<br />            case HARDCOVER:<br />                return "H";<br />            case PAPERBACK:<br />                return "P";<br />            default:<br />                throw new IllegalArgumentException("Unknown" + attribute);<br />        }<br />    }<br /><br />    @Override<br />    public Cover convertToEntityAttribute(String dbData) {<br />        switch (dbData) {<br />            case "D":<br />                return DUST_JACKET;<br />            case "H":<br />                return HARDCOVER;<br />            case "P":<br />                return PAPERBACK;<br />            default:<br />                throw new IllegalArgumentException("Unknown" + dbData);<br />        }<br />    }<br />}<br /></pre>OK, I won’t insult you, my dear reader, explaining this. Converting enum to whatever will be stored in relational database and vice-versa. Theoretically JPA provider should apply converters automatically if they are declared with:<br /><br /><pre class="brush: java">@Converter(autoApply = true)<br /></pre>It didn’t work for me. Moreover declaring them explicitly instead of <code>@Enumerated</code> in <code>@Entity</code> class didn’t work as well:<br /><br /><pre class="brush: java">import javax.persistence.Convert;<br /><br />//...<br /><br />@Convert(converter = CoverConverter.class)<br />private Cover cover;<br /></pre>Resulting in exception:<br /><br /><pre class="brush: java">Exception Description: The converter class [com.blogspot.nurkiewicz.CoverConverter] <br />specified on the mapping attribute [cover] from the class [com.blogspot.nurkiewicz.Book] was not found. <br />Please ensure the converter class name is correct and exists with the persistence unit definition.<br /></pre>Bug or feature, I had to mention converter in <code>orm.xml</code>:<br /><br /><pre class="brush: xml">&lt;?xml version="1.0"?&gt;<br />&lt;entity-mappings xmlns="http://www.eclipse.org/eclipselink/xsds/persistence/orm" version="2.1"&gt;<br />    &lt;converter class="com.blogspot.nurkiewicz.CoverConverter"/&gt;<br />&lt;/entity-mappings&gt;<br /></pre>And it flies! I have a freedom of modifying my <code>Cover</code> enum (adding, rearranging, renaming) without affecting existing records.<br /><br />One tip I would like to share with you is related to maintainability. Every time you have a piece of code mapping from or to <code>enum</code>, make sure it’s tested properly. And I don’t mean testing every possible existing value manually. I am more after a test making sure that new <code>enum</code> values are reflected in mapping code. Hint: code below will fail (by throwing <code>IllegalArgumentException</code>) if you add new <code>enum</code> value but forget to add mapping code <i>from</i> it:<br /><br /><pre class="brush: java">for (Cover cover : Cover.values()) {<br />    new CoverConverter().convertToDatabaseColumn(cover);<br />}<br /></pre><hr />Custom converters in JPA 2.1 are much more useful than what we saw. If you combine JPA with Scala, you can use <code>@Converter</code> to map database columns directly to <a href="http://www.scala-lang.org/api/current/index.html#scala.math.BigDecimal"><code>scala.math.BigDecimal</code></a>, <a href="http://www.scala-lang.org/api/current/index.html#scala.Option"><code>scala.Option</code></a> or small case class. In Java there will finally be a portable way of mapping <a href="http://joda-time.sourceforge.net/">Joda time</a>. Last but not least, if you like (very) strongly typed domain, you may wish to have <code>PhoneNumber</code> class (with <code>isInternational()</code>, <code>getCountryCode()</code> and custom validation logic) instead of <code>String</code> or <code>long</code>. This small addition in JPA 2.1 will surely improve domain objects quality significantly.<br /><br />If you wish to play a bit with this feature, sample Spring web application is <a href="https://github.com/nurkiewicz/books">available on GitHub</a>.<br /><br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>