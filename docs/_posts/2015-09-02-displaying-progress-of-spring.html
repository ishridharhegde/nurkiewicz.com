---
layout: post
title: Displaying progress of Spring application startup in web browser
date: '2015-09-02T00:05:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- sse
- spring boot
- javascript
- spring
- rxjava
- tomcat
modified_time: '2015-09-02T00:05:37.400+02:00'
thumbnail: https://i.ytimg.com/vi/ct9lCULe4o0/0.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4042660644758193621
blogger_orig_url: https://www.nurkiewicz.com/2015/09/displaying-progress-of-spring.html
---

When you restart your <em>enterprise</em> application, what do your clients see when they open the web browser?<br /><br /><ol style="list-style-type: decimal;"><li>They see nothing, server doesn't respond yet so web browser displays <code>ERR_CONNECTION_REFUSED</code><br /><br /></li><li>Web proxy (if any) in front of your application notices that it's down and display "friendly" error message<br /><br /></li><li>The website takes forever to load - it accepted socket connection and HTTP request but waits with response until application actually boots up<br /><br /></li><li>Your application is scaled out so that other nodes quickly pick up requests and no one notices (and session is replicated anyway)<br /><br /></li><li>...or the application is so fast to start that no one notices any disruption (hey, plain Spring Boot <em>Hello world</em> app takes less than 3 seconds from hitting <code>java -jar ... [Enter]</code> to start serving requests). BTW check out <a href="https://jira.spring.io/browse/SPR-8767"><em>SPR-8767: Parallel bean initialization during startup</em></a>.<br /><br /></li></ol>It's definitely better to be in situation 4. and 5., but in this article we'll cover more robust handling of situations 1. and 3.<br /><br />Typical Spring Boot application starts web container (e.g. Tomcat) at the very end, when all beans are loaded (situation 1.) This is a very reasonable default as it prevents clients from reaching our endpoints until they are fully configured. However this means we cannot differentiate between application that starts up for several seconds and application that is down. So the idea is to have an application that shows some meaningful startup page while it loads, similar to web proxy showing "<em>Service unavailable</em>". However since such startup page is part of our application, it can potentially have greater insight into startup progress. We want to start Tomcat earlier in the initialization lifecycle, but serve special purpose startup page until Spring fully bootstraps. This special page should intercept every possible request - thus it sounds like a servlet filter.<br /><br /><h1 id="starting-tomcat-eagerly-and-early.">Starting Tomcat eagerly and early.</h1>In Spring Boot servlet container is initialized via <a href="http://docs.spring.io/autorepo/docs/spring-boot/1.2.x/api/org/springframework/boot/context/embedded/EmbeddedServletContainerFactory.html"><code>EmbeddedServletContainerFactory</code></a> that creates an instance of <a href="http://docs.spring.io/autorepo/docs/spring-boot/1.2.x/api/org/springframework/boot/context/embedded/EmbeddedServletContainer.html"><code>EmbeddedServletContainer</code></a>. We have an opportunity to intercept this process using <a href="http://docs.spring.io/autorepo/docs/spring-boot/1.2.x/api/org/springframework/boot/context/embedded/EmbeddedServletContainerCustomizer.html"><code>EmbeddedServletContainerCustomizer</code></a>. The container is created early in the application lifecycle, but it's <em>started</em> much later, when whole context is done. So I thought I will simply call <code>start()</code> in my own customizer and that's it. Unfortunately <a href="http://docs.spring.io/autorepo/docs/spring-boot/1.2.x/api/org/springframework/boot/context/embedded/ConfigurableEmbeddedServletContainer.html"><code>ConfigurableEmbeddedServletContainer</code></a> doesn't expose such API, so I had to decorate <code>EmbeddedServletContainerFactory</code> like this:<br /><br /><pre class="brush: java">class ProgressBeanPostProcessor implements BeanPostProcessor {<br /><br />    //...<br /><br />    @Override<br />    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {<br />        if (bean instanceof EmbeddedServletContainerFactory) {<br />            return wrap((EmbeddedServletContainerFactory) bean);<br />        } else {<br />            return bean;<br />        }<br />    }<br /><br />    private EmbeddedServletContainerFactory wrap(EmbeddedServletContainerFactory factory) {<br />        return new EmbeddedServletContainerFactory() {<br />            @Override<br />            public EmbeddedServletContainer getEmbeddedServletContainer(ServletContextInitializer... initializers) {<br />                final EmbeddedServletContainer container = factory.getEmbeddedServletContainer(initializers);<br />                log.debug("Eagerly starting {}", container);<br />                container.start();<br />                return container;<br />            }<br />        };<br />    }<br />}</pre>You might think that <code>BeanPostProcessor</code> is an overkill, but it will become very useful later on. What we do here is that if we encounter <code>EmbeddedServletContainerFactory</code> being requested from application context, we return a decorator that eagerly starts Tomcat. This leaves us with rather unstable setup, where Tomcat accepts connections to not yet initialized context. So let's put a servlet filter intercepting all requests until context is done.<br /><br /><h1 id="intercepting-request-during-startup">Intercepting request during startup</h1>I started simply by adding <a href="http://docs.spring.io/autorepo/docs/spring-boot/1.2.x/api/org/springframework/boot/context/embedded/FilterRegistrationBean.html"><code>FilterRegistrationBean</code></a> to Spring context, hoping it would intercept incoming request until context is started. This was fruitless: I had to wait long second until filter was registered and ready, therefor from the user perspective the application was hanging. Later on I even tried registering filter directly in Tomcat using servlet API (<a href="https://docs.oracle.com/javaee/6/api/javax/servlet/ServletContext.html#addFilter(java.lang.String,%20javax.servlet.Filter)"><code>javax.servlet.ServletContext.addFilter()</code></a>) but apparently whole <code>DispatcherServlet</code> had to be bootstrapped beforehand. Remember all I wanted was an extremely fast feedback from the application that it's about to initialize.<br /><br />So I ended up with Tomcat's proprietary API: <a href="http://tomcat.apache.org/tomcat-8.0-doc/api/org/apache/catalina/Valve.html"><code>org.apache.catalina.Valve</code></a>. <code>Valve</code> is similar to servlet filter, but it's part of Tomcat's architecture. Tomcat bundles multiple valves on its own to handle various container features like SSL, session clustering and <code>X-Forwarded-For</code> handling. Also <a href="http://logback.qos.ch/access.html">Logback Access</a> uses this API so I'm not feeling that guilty. The Valve looks like this:<br /><br /><pre class="brush: java">package com.nurkiewicz.progress;<br /><br />import org.apache.catalina.connector.Request;<br />import org.apache.catalina.connector.Response;<br />import org.apache.catalina.valves.ValveBase;<br />import org.apache.tomcat.util.http.fileupload.IOUtils;<br /><br />import javax.servlet.ServletException;<br />import java.io.IOException;<br />import java.io.InputStream;<br /><br />public class ProgressValve extends ValveBase {<br /><br />    @Override<br />    public void invoke(Request request, Response response) throws IOException, ServletException {<br />        try (InputStream loadingHtml = getClass().getResourceAsStream("loading.html")) {<br />            IOUtils.copy(loadingHtml, response.getOutputStream());<br />        }<br />    }<br />}</pre>Valves typically delegate to next valve in chain, but this time we simply return static <code>loading.html</code> page for every single request. Registering such valve is surprisingly simple, Spring Boot has an API for that!<br /><br /><pre class="brush: java">if (factory instanceof TomcatEmbeddedServletContainerFactory) {<br />    ((TomcatEmbeddedServletContainerFactory) factory).addContextValves(new ProgressValve());<br />}</pre>Custom valve turned out to be a great idea, it starts immediately with Tomcat and is fairly easy to use. However you might have noticed that we never give up serving <code>loading.html</code>, even after our application started. That's bad. There are multiple ways Spring context can signal initialization, e.g. with <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>:<br /><br /><pre class="brush: java">@Component<br />class Listener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {<br /><br />    private static final CompletableFuture&lt;ContextRefreshedEvent&gt; promise = new CompletableFuture&lt;&gt;();<br /><br />    public static CompletableFuture&lt;ContextRefreshedEvent&gt; initialization() {<br />        return promise;<br />    }<br /><br />    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {<br />        return bean;<br />    }<br /><br />    @Override<br />    public void onApplicationEvent(ContextRefreshedEvent event) {<br />        promise.complete(event);<br />    }<br /><br />}</pre>I know what you think, "<code>static</code>"? But inside <code>Valve</code> I don't want to touch Spring context at all, as it might introduce blocking or even deadlock if I ask for some bean at wrong point in time from random thread. When we complete <code>promise</code>, <code>Valve</code> deregisters itself:<br /><br /><pre class="brush: java">public class ProgressValve extends ValveBase {<br /><br />    public ProgressValve() {<br />        Listener<br />                .initialization()<br />                .thenRun(this::removeMyself);<br />    }<br /><br />    private void removeMyself() {<br />        getContainer().getPipeline().removeValve(this);<br />    }<br /><br />    //...<br /><br />}</pre>This is surprisingly clean solution: when <code>Valve</code> is no longer needed, rather than paying the cost on every single request, we simply remove it from the processing pipeline. I'm not going to demonstrate how and why it works, let's move directly to target solution.<br /><br /><h1 id="monitoring-progress">Monitoring progress</h1>Monitoring progress of Spring application context startup is surprisingly simple. Also I'm amazed how "hackable" Spring framework is, as opposed to API- and spec-driven frameworks like EJB or JSF. In Spring I can simply implement <a href="http://docs.spring.io/spring-framework/docs/4.2.x/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html"><code>BeanPostProcessor</code></a> to be notified about each and every bean being created and initialized (<a href="https://github.com/nurkiewicz/spring-startup-progress/blob/master/src/main/java/com/nurkiewicz/progress/ProgressBeanPostProcessor.java">full source code</a>):<br /><br /><pre class="brush: java">package com.nurkiewicz.progress;<br /><br />import org.springframework.beans.BeansException;<br />import org.springframework.beans.factory.config.BeanPostProcessor;<br />import org.springframework.context.ApplicationListener;<br />import org.springframework.context.event.ContextRefreshedEvent;<br />import rx.Observable;<br />import rx.subjects.ReplaySubject;<br />import rx.subjects.Subject;<br /><br />class ProgressBeanPostProcessor implements BeanPostProcessor, ApplicationListener&lt;ContextRefreshedEvent&gt; {<br /><br />    private static final Subject&lt;String, String&gt; beans = ReplaySubject.create();<br /><br />    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {<br />        return bean;<br />    }<br /><br />    @Override<br />    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {<br />        beans.onNext(beanName);<br />        return bean;<br />    }<br /><br />    @Override<br />    public void onApplicationEvent(ContextRefreshedEvent event) {<br />        beans.onCompleted();<br />    }<br /><br />    static Observable&lt;String&gt; observe() {<br />        return beans;<br />    }<br />}</pre>Every time new bean is initialized, I publish its name into RxJava's observable. When whole application is initialized, I complete <code>Observable</code>. This <code>Observable</code> can later be consumed by anyone, e.g. our custom <code>ProgressValve</code> (<a href="https://github.com/nurkiewicz/spring-startup-progress/blob/master/src/main/java/com/nurkiewicz/progress/ProgressValve.java">full source code</a>):<br /><br /><pre class="brush: java">public class ProgressValve extends ValveBase {<br /><br />    public ProgressValve() {<br />        super(true);<br />        ProgressBeanPostProcessor.observe().subscribe(<br />                beanName -&gt; log.trace("Bean found: {}", beanName),<br />                t -&gt; log.error("Failed", t),<br />                this::removeMyself);<br />    }<br /><br />    @Override<br />    public void invoke(Request request, Response response) throws IOException, ServletException {<br />        switch (request.getRequestURI()) {<br />            case "/init.stream":<br />                final AsyncContext asyncContext = request.startAsync();<br />                streamProgress(asyncContext);<br />                break;<br />            case "/health":<br />            case "/info":<br />                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);<br />                break;<br />            default:<br />                sendHtml(response, "loading.html");<br />        }<br />    }<br /><br />    //...<br /><br />}</pre><code>ProgressValve</code> is now way more complex, and we're not done yet. It can handle multiple different requests, for example I intentionally return 503 on <code>/health</code> and <code>/info</code> Actuator endpoints so that the application appears as if it was down during startup. All other requests except <code>init.stream</code> show familiar <a href="https://github.com/nurkiewicz/spring-startup-progress/blob/master/src/main/resources/com/nurkiewicz/progress/loading.html"><code>loading.html</code></a>. <code>/init.stream</code> is special. It's a <a href="https://en.wikipedia.org/wiki/Server-sent_events">server-sent events</a> endpoint that will push message every time new bean is initialized (sorry for a wall of code):<br /><br /><pre class="brush: java">private void streamProgress(AsyncContext asyncContext) throws IOException {<br />    final ServletResponse resp = asyncContext.getResponse();<br />    resp.setContentType("text/event-stream");<br />    resp.setCharacterEncoding("UTF-8");<br />    resp.flushBuffer();<br />    final Subscription subscription = ProgressBeanPostProcessor.observe()<br />            .map(beanName -&gt; "data: " + beanName)<br />            .subscribeOn(Schedulers.io())<br />            .subscribe(<br />                    event -&gt; stream(event, asyncContext.getResponse()),<br />                    e -&gt; log.error("Error in observe()", e),<br />                    () -&gt; complete(asyncContext)<br />            );<br />    unsubscribeOnDisconnect(asyncContext, subscription);<br />}<br /><br />private void complete(AsyncContext asyncContext) {<br />    stream("event: complete\ndata:", asyncContext.getResponse());<br />    asyncContext.complete();<br />}<br /><br />private void unsubscribeOnDisconnect(AsyncContext asyncContext, final Subscription subscription) {<br />    asyncContext.addListener(new AsyncListener() {<br />        @Override<br />        public void onComplete(AsyncEvent event) throws IOException {<br />            subscription.unsubscribe();<br />        }<br /><br />        @Override<br />        public void onTimeout(AsyncEvent event) throws IOException {<br />            subscription.unsubscribe();<br />        }<br /><br />        @Override<br />        public void onError(AsyncEvent event) throws IOException {<br />            subscription.unsubscribe();<br />        }<br /><br />        @Override<br />        public void onStartAsync(AsyncEvent event) throws IOException {}<br />    });<br />}<br /><br />private void stream(String event, ServletResponse response) {<br />    try {<br />        final PrintWriter writer = response.getWriter();<br />        writer.println(event);<br />        writer.println();<br />        writer.flush();<br />    } catch (IOException e) {<br />        log.warn("Failed to stream", e);<br />    }<br />}</pre>This means we can track progress of Spring's application context startup using simple HTTP interface (!):<br /><br /><pre class="brush: plain">$ curl -v localhost:8090/init.stream<br />&gt; GET /init.stream HTTP/1.1<br />&gt; User-Agent: curl/7.35.0<br />&gt; Host: localhost:8090<br />&gt; Accept: */*<br /><br />&lt; HTTP/1.1 200 OK<br />&lt; Content-Type: text/event-stream;charset=UTF-8<br />&lt; Transfer-Encoding: chunked<br /><br />data: org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration$EmbeddedTomcat<br /><br />data: org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration$TomcatWebSocketConfiguration<br /><br />data: websocketContainerCustomizer<br /><br />data: org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration<br /><br />data: toStringFriendlyJsonNodeToStringConverter<br /><br />data: org.hibernate.validator.internal.constraintvalidators.bv.NotNullValidator<br /><br />data: serverProperties<br /><br />data: org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration<br /><br />...<br /><br />data: beanNameViewResolver<br /><br />data: basicErrorController<br /><br />data: org.springframework.boot.autoconfigure.orm.jpa.JpaBaseConfiguration$JpaWebConfiguration$JpaWebMvcConfiguration</pre>This endpoint will stream in real-time (see also: <a href="http://www.nurkiewicz.com/2015/07/server-sent-events-with-rxjava-and.html"><em>Server-sent events with RxJava and SseEmitter</em></a>) every single bean name being initialized. Having such an amazing tool we'll build more robust (<em>reactive</em> - there, I said it) <code>loading.html</code> page.<br /><br /><h1 id="fancy-progress-front-end">Fancy progress front-end</h1>First we need to identify which Spring beans represent which <em>subsystems</em>, high-level components (or maybe even <em>bounded contexts</em>) in our system. I encoded this <a href="https://github.com/nurkiewicz/spring-startup-progress/blob/master/src/main/resources/com/nurkiewicz/progress/loading.html#L21-L75">inside HTML</a> using <code>data-bean</code> custom attribute:<br /><br /><pre class="brush: java">&lt;h2 data-bean="websocketContainerCustomizer" class="waiting"&gt;<br />    Web socket support<br />&lt;/h2&gt;<br /><br />&lt;h2 data-bean="messageConverters" class="waiting"&gt;<br />    Spring MVC<br />&lt;/h2&gt;<br /><br />&lt;h2 data-bean="metricFilter" class="waiting"&gt;<br />    Metrics<br />&lt;/h2&gt;<br /><br />&lt;h2 data-bean="endpointMBeanExporter" class="waiting"&gt;<br />    Actuator<br />&lt;/h2&gt;<br /><br />&lt;h2 data-bean="mongoTemplate" class="waiting"&gt;<br />    MongoDB<br />&lt;/h2&gt;<br /><br />&lt;h2 data-bean="dataSource" class="waiting"&gt;<br />    Database<br />&lt;/h2&gt;<br /><br />&lt;h2 data-bean="entityManagerFactory" class="waiting"&gt;<br />    Hibernate<br />&lt;/h2&gt;</pre>CSS <code>class="waiting"</code> means that a given module is not yet initialized, i.e. given bean didn't yet appear in SSE stream. Initially all components are in <code>"waiting"</code> state. I then subscribe to <code>init.stream</code> and change CSS class to reflect module state changes:<br /><br /><pre class="brush: java">var source = new EventSource('init.stream');<br />source.addEventListener('message', function (e) {<br />    var h2 = document.querySelector('h2[data-bean="' + e.data + '"]');<br />    if(h2) {<br />        h2.className = 'done';<br />    }<br />});</pre>Simple, huh? Apparently one can write front-end without jQuery in pure JavaScript. When all beans are loaded, <code>Observable</code> is completed on the server side and SSE emits <code>event: complete</code>, let's handle that:<br /><br /><pre class="brush: java">source.addEventListener('complete', function (e) {<br />    window.location.reload();<br />});</pre>Because front-end is notified on application context startup, we can simply reload current page. At that point in time, our <code>ProgressValve</code> already deregistered itself, so reloading will open <em>true</em> application, not <code>loading.html</code> placeholder. Our job is done. Additionally I count how many beans started and knowing how many beans are in total (I hardcoded it in JavaScript, forgive me), I can calculate startup progress in percent. Picture is worth a thousand words, let this screencast&nbsp;show you the result we achieved:<br /><br /><div class="separator" style="clear: both; text-align: center;"><iframe width="320" height="266" class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/ct9lCULe4o0/0.jpg" src="https://www.youtube.com/embed/ct9lCULe4o0?feature=player_embedded" frameborder="0" allowfullscreen></iframe></div><br /><br />Subsequent modules are starting up nicely and we no longer look at browser error. Progress measured in percents makes the whole startup progress feel very smooth. Last but not least when application started, we are automatically redirected. Hope you enjoyed this proof-of-concept, whole <a href="https://github.com/nurkiewicz/spring-startup-progress">working sample application</a> is available on GitHub.<br /><br /><script>SyntaxHighlighter.highlight();</script>