---
layout: post
title: 'Adapter pattern: accesing Ehcache via Map interface'
date: '2009-09-16T22:09:00.004+02:00'
author: Tomasz Nurkiewicz
tags:
- design patterns
- ehcache
modified_time: '2009-09-16T22:25:41.896+02:00'
thumbnail: http://2.bp.blogspot.com/_P3ewsGQzHn0/SrFJLRDdJTI/AAAAAAAAANg/jmlhNYUZE8E/s72-c/adapter.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4871924137026556397
blogger_orig_url: https://www.nurkiewicz.com/2009/09/adapter-pattern-accesing-ehcache-via.html
---

Suppose you have some client code (developed by you, legacy code or third-party library) which requires object of some specific type. On the other hand  you already have almost exactly the same object, which does almost the same (in other words, fulfils similar contract). But the problem is, although both, required and yours, objects are pretty much the same, they have slightly or completely different interfaces. And in strongly typed Java world, even slightly means incompatible.<br /><br />If you travel a lot, you probably came across the same problem in your real life. European and American AC power plugs and sockets are different. Although they both have same purpose – provide you with electrical power – and have similar contract (voltage, frequency, etc.), they simply don’t fit each other. Even though they are semantically equivalent, they are syntactically incompatible (have different shapes). The solution is the same for both developer and traveler: provide an adapter, which will have two interfaces: one fitting client (either Java code or your laptop power supplier) and one wrapping and translating target (your Java object or power socket found in local hotel).<br /><br />OK, let’s go back to programming. As an example I have chosen <a href="http://ehcache.org/">Ehcache </a>library, which is amazingly useful caching facility, mostly known as being Hibernate’s second level cache <a href="http://ehcache.org/apidocs/net/sf/ehcache/hibernate/EhCacheProvider.html">provider</a>. But actually, Ehcache can be used in a variety of places, from a simple <a style="font-family: courier new;" href="http://java.sun.com/javase/6/docs/api/java/util/HashMap.html">HashMap</a> replacement to distributed, shared memory store with automatic peer discovery and disk persistence. If you have written some home-made caching solution and integrated it with your application, Ehcache should have been your first choice.<br /><br />And here our problem arises.  Look carefully at <a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html">Map</a> and <a href="http://ehcache.org/apidocs/net/sf/ehcache/Ehcache.html">Ehcache</a> interfaces. They look similar, aren’t they? Both <span style="font-family:courier new;">Map</span> and <span style="font-family:courier new;">Ehcache </span>are data structures used to store data in key-value (dictionary) manner. It is tempting to use full-featured Ehcache instead of simple map and take advantage of automatic expiration, eviction and size/memory constraints. But since Ehcache interface does not extend <span style="font-family:courier new;">Map</span>, there is no direct way to achieve this. Of course, you may rewrite the code to use <span style="font-family:courier new;">Ehcache </span>instead of simple map, but in many cases it is impossible or too expensive (like your boss says, nothing’s impossible, only unprofitable). So you ask yourself, since the code requires me to supply any implementation of <span style="font-family:courier new;">Map </span>interface, maybe I can fool it and write special implementation, that only delegates to hidden <span style="font-family:courier new;">Ehcache </span>instance? In other words, this implementation won’t do almost anything by itself, instead only proxying and translating every call to <span style="font-family:courier new;">Map </span>methods to corresponding similar <span style="font-family:courier new;">Ehcache </span>operations. Yes, we are going to write implementation of Adapter pattern.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_P3ewsGQzHn0/SrFJLRDdJTI/AAAAAAAAANg/jmlhNYUZE8E/s1600-h/adapter.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 131px;" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/SrFJLRDdJTI/AAAAAAAAANg/jmlhNYUZE8E/s200/adapter.png" alt="" id="BLOGGER_PHOTO_ID_5382163487589737778" border="0" /></a><br /><br /><br />Figure above illustrates the design of our Ehcache adapter: it implements interface required by client code (<span style="font-family:courier new;">Map</span>), wrapping and hiding the target interface (<span style="font-family:courier new;">Ehcache</span>; sometimes called <span style="font-style: italic;">Adaptee</span>). In Java we start by something like this:<br /><br /><pre name="code" class="java">public class EhcacheMapAdapter&lt;K, V&gt; implements Map&lt;K, V&gt; {<br /> private final Ehcache targetCache;<br /> //...<br />}</pre><br /><br />The most important part is to implement <span style="font-family:courier new;">Map </span>interface in the way that does not violate the map contract. More generally speaking, Adapter must delegate to target in such way, that it behaves exactly the same as the client interface specifies – and same as any other implementation. In other words – if you have good unit tests for particular <span style="font-family:courier new;">Map </span>implementation, they should pass as well for the adapter. Here is the full source code:<br /><br /><pre name="code" class="java">public class EhcacheMapAdapter&lt;K, V&gt; implements Map&lt;K, V&gt; {<br /><br /> private final Ehcache targetCache;<br /><br /> public EhcacheMapAdapter(Ehcache targetCache) {<br />    this.targetCache = targetCache;<br /> }<br /><br /> @Override<br /> public int size() {<br />    return targetCache.getSize();<br /> }<br /><br /> @Override<br /> public boolean isEmpty() {<br />    return size() == 0;<br /> }<br /><br /> @Override<br /> public boolean containsKey(Object key) {<br />    return targetCache.get(key) != null;<br /> }<br /><br /> @Override<br /> public boolean containsValue(Object value) {<br />    for (Object key : targetCache.getKeys()) {<br />     Element element = targetCache.get(key);<br />     if (element != null &amp;&amp; element.getValue() != null &amp;&amp; element.getValue().equals(value))<br />      return true;<br />    }<br />    return false;<br /> }<br /><br /> @Override<br /> public V get(Object key) {<br />    Element element = targetCache.get(key);<br />    if (element != null)<br />     return (V) element.getValue();<br />    else<br />     return null;<br /> }<br /><br /> @Override<br /> public V put(K key, V value) {<br />    V previousValue = get(key);<br />    targetCache.put(new Element(key, value));<br />    return previousValue;<br /> }<br /><br /> @Override<br /> public V remove(Object key) {<br />    V previousValue = get(key);<br />    targetCache.remove(key);<br />    return previousValue;<br /> }<br /><br /> @Override<br /> public void putAll(Map&lt;? extends K, ? extends V&gt; m) {<br />    for (Map.Entry&lt;? extends K, ? extends V&gt; entry : m.entrySet())<br />     put(entry.getKey(), entry.getValue());<br /> }<br /><br /> @Override<br /> public void clear() {<br />    targetCache.removeAll();<br /> }<br /><br /> @Override<br /> public Set&lt;K&gt; keySet() {<br />    return new HashSet&lt;K&gt;(targetCache.getKeys());<br /> }<br /><br /> @Override<br /> public Collection&lt;V&gt; values() {<br />    final ArrayList&lt;V&gt; values = new ArrayList&lt;V&gt;();<br />    for (Object key : targetCache.getKeys()) {<br />     Element element = targetCache.get(key);<br />     if (element != null)<br />      values.add((V) element.getValue());<br />    }<br />    return values;<br /> }<br /><br /> @Override<br /> public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {<br />    final Set&lt;Entry&lt;K, V&gt;&gt; values = new HashSet&lt;Entry&lt;K, V&gt;&gt;();<br />    for (Object key : targetCache.getKeys()) {<br />     Element element = targetCache.get(key);<br />     if (element != null)<br />      values.add(new EhcacheEntry&lt;K, V&gt;((K)key));<br />    }<br />    return values;<br /> }<br /><br /> private class EhcacheEntry&lt;K, V&gt; implements Entry&lt;K, V&gt; {<br /><br />    private final K key;<br /><br />    public EhcacheEntry(K key) {<br />     this.key = key;<br />    }<br /><br />    @Override<br />    public K getKey() {<br />     return key;<br />    }<br /><br />    @Override<br />    public V getValue() {<br />     Element element = targetCache.get(key);<br />     return element != null? (V) element.getValue() : null;<br />    }<br /><br />    @Override<br />    public V setValue(V value) {<br />     Element element = targetCache.get(key);<br />     V previousValue = element != null? (V) element.getValue() : null;<br />     targetCache.put(new Element(key, value));<br />     return previousValue;<br />    }<br /> }<br />}</pre><br /><br />Look carefully at any method – they mostly delegate to adaptee, but sometimes you must code a little bit to achieve equivalent functionality. I wrote a very small unit test to check that adapter implementation follows the map contract, though in order to be 100% sure, we should write at least couple test for every method independently. Please note that the test is written in Groovy and uses Groovy syntax – this shows that adapter can be safely used in any code which expects <span style="font-family:courier new;">Map</span>.<br /><br /><pre name="code" class="java">public class EhcacheMapAdapterTest extends GroovyTestCase {<br /><br /> public void testEhcacheMapAdapter() {<br />    //given<br />    Ehcache cache = CacheManager.getInstance().getCache("test");<br />    def map = new EhcacheMapAdapter&lt;String, Integer&gt;(cache);<br /><br />    //when<br />    map.one = 1<br />    map['two'] = 2<br />    map.put('thirty four', 34)<br /><br />    //then<br />    assertEquals  3, map.size()<br />    assertTrue  map.containsKey('one')<br />    assertTrue  map.containsKey('two')<br />    assertFalse  map.containsKey('three')<br />    assertTrue  map.containsKey('thirty four')<br /><br />    assertEquals  2, map.get('two')<br />    assertTrue  map.containsValue(1)<br /> }<br /><br />}</pre><br /><br />Final notes: our implementation has some additional benefit over using <span style="font-family:courier new;">Ehcache </span>directly: it is not only simpler, but also introduces strong-typing (Ehcache keys and values are of <span style="font-family:courier new;">Object </span>type). But to be precise, our adapter does not exactly conform to <span style="font-family:courier new;">Map </span>contract. It might happen, that value once put in map will not be present later even if it was not manipulated in the meantime. This is because the element might have expired and been removed from cache.<br /><br />I hope you all get the idea of Adapter pattern. Maybe some of you have been using this pattern not knowing about that. For example I have been working with <a href="http://en.wikipedia.org/wiki/IBM_WebSphere_MQ">IBM WebSphere MQ</a> message broker, which is available for Java developer via JMS adapter. I could use message driven beans, Spring’s <a style="font-family: courier new;" href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/jms/core/JmsTemplate.html">JmsTemplate</a> etc. just because MQ did provide their implementation of <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/jms/ConnectionFactory"><span style="font-family:courier new;">ConnectionFactory</span></a> and queues. It was much easier to integrate it in existing app, rather than using vendor specific API. Think of Adapters before you rewrite legacy code or look for existing ones (like JDBC from MS Excel bridges).