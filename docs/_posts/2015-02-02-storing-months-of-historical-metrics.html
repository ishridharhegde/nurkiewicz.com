---
layout: post
title: Storing months of historical metrics from Hystrix in Graphite
date: '2015-02-02T20:38:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- Hystrix
- monitoring
- Graphite
modified_time: '2015-02-02T20:38:02.088+01:00'
thumbnail: http://2.bp.blogspot.com/-ZNBCoWHmVYw/VMzVWnqkiyI/AAAAAAAABN8/CHBXa7hn1uo/s72-c/hystrix-dashboard.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7400736909518450402
blogger_orig_url: https://www.nurkiewicz.com/2015/02/storing-months-of-historical-metrics.html
---

One of the killer-features of <a href="https://github.com/Netflix/Hystrix">Hystrix</a> is a low-latency, data-intensive and beautiful <a href="https://github.com/Netflix/Hystrix/wiki/Dashboard">dashboard</a>:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-ZNBCoWHmVYw/VMzVWnqkiyI/AAAAAAAABN8/CHBXa7hn1uo/s1600/hystrix-dashboard.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-ZNBCoWHmVYw/VMzVWnqkiyI/AAAAAAAABN8/CHBXa7hn1uo/s1600/hystrix-dashboard.png" height="226" width="640" /></a></div><br /><br />Even though it's just a side-effect of what Hystrix is really doing (circuit breakers, thread pools, timeouts, etc.), it tends to be the most impressive feature. In order to make it work you have to include <code>hystrix-metrics-event-stream</code> dependency:<br /><br /><pre class="brush: xml">&lt;dependency&gt;<br />    &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;<br />    &lt;artifactId&gt;hystrix-metrics-event-stream&lt;/artifactId&gt;<br />    &lt;version&gt;1.4.0-RC6&lt;/version&gt;<br />&lt;/dependency&gt;<br /></pre><br />and register built-in servlet, e.g. in embedded Jetty:<br /><br /><pre class="brush: java">import org.eclipse.jetty.server.Server;<br />import org.eclipse.jetty.servlet.ServletContextHandler;<br />import org.eclipse.jetty.servlet.ServletHolder;<br /><br />//...<br /><br />Server server = new Server(8090);<br />ServletContextHandler context = new ServletContextHandler(ServletContextHandler.NO_SESSIONS);<br />server.setHandler(context);<br />final HystrixMetricsStreamServlet servlet = new HystrixMetricsStreamServlet();<br />final ServletHolder holder = new ServletHolder(servlet);<br />context.addServlet(holder, "/hystrix.stream");<br />server.start();<br /></pre>Of course if you already have a web application, it's much simpler. Here is an example in Spring Boot:<br /><br /><pre class="brush: java">@Bean<br />public ServletRegistrationBean servletRegistrationBean() {<br />    return new ServletRegistrationBean(new HystrixMetricsStreamServlet(), "/hystrix.stream");<br />}<br /></pre>From now on your application will stream real-time metrics in JSON format, which can easily be consumed using open-source dashboard, almost entirely written in JavaScript:<br /><br /><pre class="brush: bash">$ git clone git@github.com:Netflix/Hystrix.git<br />$ cd Hystrix<br />$ ./gradlew :hystrix-dashboard:jettyRun<br /></pre>After few seconds you can browse to <code>localhost:7979</code> and point to your <code>/hystrix.stream</code> servlet. Assuming your application is clustered, most likely you will add <a href="https://github.com/Netflix/Turbine">Turbine</a> to the party.   <br /><br />If you are using Hystrix, you know about all of this already. But one of the questions I am asked most often is: <em>why these metrics are so short-term</em>? Indeed, if you look at the dashboard above, metrics are aggregated with sliding window ranging from 10 seconds to 1 minute. If you received and automatic e-mail notification about some occurrence on production, experienced brief slowness or heard about performance problems from a customer, relevant statistics about this incident might already be lost - or they might be obscured by general instability that happened afterwards. <br /><br />This is actually by design - you can't have both low-latency, near real time statistics, that are as well durable and can be browsed days if not months back. But you don't need two monitoring systems for short-term metrics and long-term trends. Instead you can feed <a href="http://graphite.wikidot.com/">Graphite</a> directly with Hystrix metrics. With almost no code at all, just a little bit of glue here and there.<br /><br /><h2>Publishing metrics to Dropwizard metrics</h2>It turns out all building blocks are available and ready, you just have to connect them. Hystrix metrics are not limited to publishing servlet, you can as well plug in other consumers, e.g. <a href="https://dropwizard.github.io/metrics/3.1.0/">Dropwizard metrics</a>:<br /><br /><pre class="brush: xml">&lt;dependency&gt;<br />    &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;<br />    &lt;artifactId&gt;hystrix-codahale-metrics-publisher&lt;/artifactId&gt;<br />    &lt;version&gt;1.4.0-RC6&lt;/version&gt;<br />    &lt;exclusions&gt;<br />        &lt;exclusion&gt;<br />            &lt;groupId&gt;com.codahale.metrics&lt;/groupId&gt;<br />            &lt;artifactId&gt;metrics-core&lt;/artifactId&gt;<br />        &lt;/exclusion&gt;<br />    &lt;/exclusions&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt;<br />    &lt;artifactId&gt;metrics-core&lt;/artifactId&gt;<br />    &lt;version&gt;3.1.0&lt;/version&gt;<br />&lt;/dependency&gt;<br /></pre>You have to connect these two libraries explicitly, I'm using Spring Boot for orchestration, notice that <code>MetricRegistry</code> is <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html">automatically created by Boot</a>:<br /><br /><pre class="brush: java">@Bean<br />HystrixMetricsPublisher hystrixMetricsPublisher(MetricRegistry metricRegistry) {<br />    HystrixCodaHaleMetricsPublisher publisher = new HystrixCodaHaleMetricsPublisher(metricRegistry);<br />    HystrixPlugins.getInstance().registerMetricsPublisher(publisher);<br />    return publisher;<br />}<br /></pre>The moment Hystrix publishes to Dropwizard metrics, we can redirect these metrics to SLF4J, JMX or... Graphite!<br /><br /><h2>Graphite and Grafana</h2>We need one more dependency:<br /><br /><pre class="brush: xml">&lt;dependency&gt;<br />    &lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt;<br />    &lt;artifactId&gt;metrics-graphite&lt;/artifactId&gt;<br />    &lt;version&gt;3.1.0&lt;/version&gt;<br />&lt;/dependency&gt;<br /></pre>This allows <code>metrics</code> library to publish data straight to Graphite, just a little bit of glue again:<br /><br /><pre class="brush: java">@Bean<br />public GraphiteReporter graphiteReporter(MetricRegistry metricRegistry) {<br />    final GraphiteReporter reporter = GraphiteReporter<br />            .forRegistry(metricRegistry)<br />            .build(graphite());<br />    reporter.start(1, TimeUnit.SECONDS);<br />    return reporter;<br />}<br /><br />@Bean<br />GraphiteSender graphite() {<br />    return new Graphite(new InetSocketAddress("localhost", 2003));<br />}<br /></pre>Obviously you would like to tweak Graphite address. Setting up Graphite and Grafana is quite cumbersome, luckily there is a <a href="https://registry.hub.docker.com/u/choopooly/grafana-graphite">Docker image for that</a>:<br /><br /><pre class="brush: bash">$ docker run -d \<br />    -p 8070:80 -p 2003:2003 -p 8125:8125/udp -p 8126:8126 \<br />    --name grafana-dashboard \<br />    choopooly/grafana_graphite<br /></pre>If everything is set up correctly, head straight to <code>localhost:8070</code> and play around with some dashboards. Here is mine:<br /><br /><a href="http://1.bp.blogspot.com/-JaBO-Dk9oNI/VMzVWnxeP_I/AAAAAAAABOA/bYBwau60AVw/s1600/hystrix-grafana.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em; text-align: center;"><img border="0" src="http://1.bp.blogspot.com/-JaBO-Dk9oNI/VMzVWnxeP_I/AAAAAAAABOA/bYBwau60AVw/s1600/hystrix-grafana.png" height="360" width="640" /></a><br /><h2>New possibilities</h2>Built-in <a href="https://github.com/Netflix/Hystrix/wiki/Dashboard">Hystrix dashboard</a> is very responsive and useful. However having days, weeks or even months worth of statistics opens a lot of possibilities. Selection of features unattainable with built-in dashboard, that you can easily setup with Graphite/Grafana:<br /><br /><ul><li>Months of statistics (obviously), compared to seconds</li><li>Metrics ignored in standard dashboard, like lower percentiles, total counters, etc.</li><li>Full history of some metrics, rather than instant value (e.g. thread pool utilization)</li><li>Ability to compare seemingly unrelated metrics on single chart, e.g. several different commands latency vs. thread pool queue size - all with full history</li><li>Drill down - look at weeks or zoom in to minutes</li></ul>Examples can be found on previous screenshot. It totally depends on your use case, but unless your system is on fire, long-term statistics that you can examine hours or weeks after incident are probably more useful than built-in dashboard.<br /><br /><sup>*</sup> There is a <a href="https://github.com/Netflix/Hystrix/commit/ed964b87d8f0965171b4e5e6ad121bec289c70e8">tiny bug</a> in Hystrix metrics publisher, will be fixed in 1.4.0-RC7<br /><sup>**</sup> Features described above are available out-of-the-box in our <a href="https://github.com/4finance/micro-infra-spring">micro-infra-spring</a> open source project<br /><br /><script>SyntaxHighlighter.highlight();</script>