---
layout: post
title: Consuming java.util.concurrent.BlockingQueue as rx.Observable
date: '2015-07-15T20:25:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- multithreading
- design patterns
- rxjava
modified_time: '2015-10-28T23:46:48.511+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-287070384608043135
blogger_orig_url: https://www.nurkiewicz.com/2015/07/consuming-javautilconcurrentblockingque.html
---

Classical producer-consumer pattern is relatively simple in Java since we have <code>java.util.concurrent.BlockingQueue</code>. To avoid busy waiting and error-prone manual locking we simply take advantage of <code>put()</code> and <code>take()</code>. They both block if queue is full or empty respectively. All we need is a bunch of threads sharing reference to the same queue: some producing and others consuming. And of course the queue has to have a limited capacity, otherwise we will soon run out of memory in case of producers outperforming consumers. Greg Young couldn't emphasize enough this rule during Devoxx Poland:<br/><br/><blockquote>Never, ever create an unbounded queue<br/><br/></blockquote><h1>Producer-consumer using <code>BlockingQueue</code></h1>Here is a simplest example. First we need a producer that puts objects in a shared queue:<br/><br/><pre class="brush: java">import lombok.Value;<br />import lombok.extern.slf4j.Slf4j;<br /><br />@Slf4j<br />@Value<br />class Producer implements Runnable {<br /><br />  private final BlockingQueue&lt;User&gt; queue;<br /><br />  @Override<br />  public void run() {<br />    try {<br />      while (!Thread.currentThread().isInterrupted()) {<br />        final User user = new User("User " + System.currentTimeMillis());<br />        log.info("Producing {}", user);<br />        queue.put(user);<br />        TimeUnit.SECONDS.sleep(1);<br />      }<br />    } catch (Exception e) {<br />      log.error("Interrupted", e);<br />    }<br />  }<br />}<br /></pre>Producer simply publishes an instance of <code>User</code> class (whatever it is) to a given queue every second. Obviously in real life placing <code>User</code> in a queue would be a result of some action within a system, like user login. Similarly consumer takes new items from a queue and processes them:<br/><br/><pre class="brush: java">@Slf4j<br />@Value<br />class Consumer implements Runnable {<br /><br />  private final BlockingQueue&lt;User&gt; queue;<br /><br />  @Override<br />  public void run() {<br />    try {<br />      while (!Thread.currentThread().isInterrupted()) {<br />        final User user = queue.take();<br />        log.info("Consuming: {}", user);<br />      }<br />    } catch (Exception e) {<br />      log.error("Interrupted", e);<br />    }<br />  }<br />}<br /></pre>Again in real life processing would mean storing in database or running some fraud detection on a user. We use queue to decouple processing thread from consuming thread, e.g. to reduce latency. To run a simple test let's spin up few producer and consumer threads:<br/><br/><pre class="brush: java">BlockingQueue&lt;User&gt; queue = new ArrayBlockingQueue&lt;&gt;(1_000);<br />final List&lt;Runnable&gt; runnables = Arrays.asList(<br />    new Producer(queue),<br />    new Producer(queue),<br />    new Consumer(queue),<br />    new Consumer(queue),<br />    new Consumer(queue)<br />);<br /><br />final List&lt;Thread&gt; threads = runnables<br />    .stream()<br />    .map(runnable -&gt; new Thread(runnable, threadName(runnable)))<br />    .peek(Thread::start)<br />    .collect(toList());<br /><br />TimeUnit.SECONDS.sleep(5);<br />threads.forEach(Thread::interrupt);<br /><br />//...<br /><br />private static String threadName(Runnable runnable) {<br />  return runnable.getClass().getSimpleName() + "-" + System.identityHashCode(runnable);<br />}<br /></pre>We have 2 producers and 3 consumers, everything seems to be working. In real life you would probably have some implicit producer threads, like HTTP request handling threads. On the consumer side you would most likely use a thread pool. This pattern works well, but especially the consuming side is quite low-level.<br/><br/><h1>Introducing <code>ObservableQueue&lt;T&gt;</code></h1>The purpose of this article is to introduce an abstraction that behaves like a queue from producer side but as an <code>Observable</code> from RxJava on consumer side. In other words we can treats objects added to a queue as a stream that we can map, filter, compose, etc. on the client side. Interestingly, this is no longer a queue under the hood. <code>ObservableQueue&lt;T&gt;</code> simply forwards all new objects straight to subscribed consumers and doesn't buffer events in case of no-one listening ("<em>hot</em>" observable). <code>ObservableQueue&lt;T&gt;</code> is not a queue per-se, it's just a bridge between one API and the other. It's similar to <code>java.util.concurrent.SynchronousQueue</code>, but if no-one is interested in consuming, object is simply discarded.<br/><br/>Here is a first experimental implementation. It's just a toy code, do not consider it production ready. Also we'll greatly simplify it later:<br/><br/><pre class="brush: java">public class ObservableQueue&lt;T&gt; implements BlockingQueue&lt;T&gt;, Closeable {<br /><br />  private final Set&lt;Subscriber&lt;? super T&gt;&gt; subscribers = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());<br />  private final Observable&lt;T&gt; observable = Observable.create(subscriber -&gt; {<br />    subscribers.add(subscriber);<br />    subscriber.add(Subscriptions.create(() -&gt; subscribers.remove(subscriber)));<br />  });<br /><br />  public Observable&lt;T&gt; observe() {<br />    return observable;<br />  }<br /><br />  @Override<br />  public boolean add(T t) {<br />    return offer(t);<br />  }<br /><br />  @Override<br />  public boolean offer(T t) {<br />    subscribers.forEach(subscriber -&gt; subscriber.onNext(t));<br />    return true;<br />  }<br /><br />  @Override<br />  public T remove() {<br />    return noSuchElement();<br />  }<br /><br />  @Override<br />  public T poll() {<br />    return null;<br />  }<br /><br />  @Override<br />  public T element() {<br />    return noSuchElement();<br />  }<br /><br />  private T noSuchElement() {<br />    throw new NoSuchElementException();<br />  }<br /><br />  @Override<br />  public T peek() {<br />    return null;<br />  }<br /><br />  @Override<br />  public void put(T t) throws InterruptedException {<br />    offer(t);<br />  }<br /><br />  @Override<br />  public boolean offer(T t, long timeout, TimeUnit unit) throws InterruptedException {<br />    return offer(t);<br />  }<br /><br />  @Override<br />  public T take() throws InterruptedException {<br />    throw new UnsupportedOperationException("Use observe() instead");<br />  }<br /><br />  @Override<br />  public T poll(long timeout, TimeUnit unit) throws InterruptedException {<br />    return null;<br />  }<br /><br />  @Override<br />  public int remainingCapacity() {<br />    return 0;<br />  }<br /><br />  @Override<br />  public boolean remove(Object o) {<br />    return false;<br />  }<br /><br />  @Override<br />  public boolean containsAll(Collection&lt;?&gt; c) {<br />    return false;<br />  }<br /><br />  @Override<br />  public boolean addAll(Collection&lt;? extends T&gt; c) {<br />    c.forEach(this::offer);<br />    return true;<br />  }<br /><br />  @Override<br />  public boolean removeAll(Collection&lt;?&gt; c) {<br />    return false;<br />  }<br /><br />  @Override<br />  public boolean retainAll(Collection&lt;?&gt; c) {<br />    return false;<br />  }<br /><br />  @Override<br />  public void clear() {<br />  }<br /><br />  @Override<br />  public int size() {<br />    return 0;<br />  }<br /><br />  @Override<br />  public boolean isEmpty() {<br />    return true;<br />  }<br /><br />  @Override<br />  public boolean contains(Object o) {<br />    return false;<br />  }<br /><br />  @Override<br />  public Iterator&lt;T&gt; iterator() {<br />    return Collections.emptyIterator();<br />  }<br /><br />  @Override<br />  public Object[] toArray() {<br />    return new Object[0];<br />  }<br /><br />  @Override<br />  public &lt;T&gt; T[] toArray(T[] a) {<br />    return a;<br />  }<br /><br />  @Override<br />  public int drainTo(Collection&lt;? super T&gt; c) {<br />    return 0;<br />  }<br /><br />  @Override<br />  public int drainTo(Collection&lt;? super T&gt; c, int maxElements) {<br />    return 0;<br />  }<br /><br />  @Override<br />  public void close() throws IOException {<br />    subscribers.forEach(rx.Observer::onCompleted);<br />  }<br />}<br /></pre>There are couple of interesting facts about it:<br/><br/><ol><li>We must keep track of all subscribers, i.e. consumers that are willing to receive new items. If one of the subscribers is no longer interested, we must remove such subscriber, otherwise memory leak will occur (keep reading!)</li><li>This queue behaves as if it was always empty. It never holds any items - when you put something into this queue, it is automatically passed to subscribers and forgotten</li><li>Technically this queue is unbounded (!), meaning you can put as many items as you want. However since items are passed to all subscribers (if any) and immediately discarded, this queue is actually always empty (see above)</li><li>Still it's possible that producer is generating too many events and consumers can't keep up with that - RxJava now has back pressure support, not covered in this article.</li></ol>Producer can use <code>ObservableQueue&lt;T&gt;</code> just like any other <code>BlockingQueue&lt;T&gt;</code>, assuming I implemented queue contract correctly. However the consumer looks much lighter and smarter:<br/><br/><pre class="brush: java">  final ObservableQueue&lt;User&gt; users = new ObservableQueue&lt;&gt;();<br />  final Observable&lt;User&gt; observable = users.observe();<br /><br />  users.offer(new User("A"));<br />  observable.subscribe(user -&gt; log.info("User logged in: {}", user));<br />  users.offer(new User("B"));<br />  users.offer(new User("C"));<br /></pre>Code above prints <code>"B"</code> and <code>"C"</code> only. <code>"A"</code> is lost <em>by design</em> since <code>ObservableQueue</code> drops items in case no one is listening. Obviously <code>Producer</code> class now uses <code>users</code> queue. Everything works fine, you can call <code>users.observe()</code> at any point and apply one of dozens of <code>Observable</code> operators. However there is one caveat: by default RxJava doesn't enforce any threading, so consuming happens in the same thread as producing! We lost the most important feature of producer-consumer pattern, i.e. thread decoupling. Luckily everything is declarative in RxJava, thread scheduling as well:<br/><br/><pre class="brush: java">users<br />    .observe()<br />    .observeOn(Schedulers.computation())<br />    .forEach(user -&gt;<br />            log.info("User logged in: {}", user)<br />    );<br /></pre>Now let's see some real RxJava power. Imagine you want to count how many users log in per second, where each login is placed as an event into a queue:<br/><br/><pre class="brush: java">users<br />  .observe()<br />  .map(User::getName)<br />  .filter(name -&gt; !name.isEmpty())<br />  .window(1, TimeUnit.SECONDS)<br />  .flatMap(Observable::count)<br />  .doOnCompleted(() -&gt; log.info("System shuts down"))<br />  .forEach(c -&gt; log.info("Logins in last second: {}", c));<br /></pre>The performance is also acceptable, such queue can accept around 3 million objects per second on my laptop with one subscriber. Treat this class as an adapter from legacy systems using queues to modern reactive world. But wait! Using <code>ObservableQueue&lt;T&gt;</code> is easy, but the implementation with <code>subscribers</code> synchronized set seems too low-level. Luckily there is <code>Subject&lt;T, T&gt;</code>. <code>Subject</code> is "the other side" of <code>Observable</code> - you can push events to <code>Subject</code> but it still implements <code>Observable</code>, so you can easily create arbitrary <code>Observable</code>. Look how beautifully <code>ObservableQueue</code> looks like with one of the <code>Subject</code> implementations:<br/><br/><pre class="brush: java">public class ObservableQueue&lt;T&gt; implements BlockingQueue&lt;T&gt;, Closeable {<br /><br />  private final Subject&lt;T, T&gt; subject = PublishSubject.&lt;T&gt;create().toSerialized();<br /><br />  public Observable&lt;T&gt; observe() {<br />    return subject;<br />  }<br /><br />  @Override<br />  public boolean add(T t) {<br />    return offer(t);<br />  }<br /><br />  @Override<br />  public boolean offer(T t) {<br />    subject.onNext(t);<br />    return true;<br />  }<br /><br />  @Override<br />  public void close() throws IOException {<br />    subject.onCompleted();<br />  }<br />  @Override<br />  public T remove() {<br />    return noSuchElement();<br />  }<br /><br />  @Override<br />  public T poll() {<br />    return null;<br />  }<br /><br />  @Override<br />  public T element() {<br />    return noSuchElement();<br />  }<br /><br />  private T noSuchElement() {<br />    throw new NoSuchElementException();<br />  }<br /><br />  @Override<br />  public T peek() {<br />    return null;<br />  }<br /><br />  @Override<br />  public void put(T t) throws InterruptedException {<br />    offer(t);<br />  }<br /><br />  @Override<br />  public boolean offer(T t, long timeout, TimeUnit unit) throws InterruptedException {<br />    return offer(t);<br />  }<br /><br />  @Override<br />  public T take() throws InterruptedException {<br />    throw new UnsupportedOperationException("Use observe() instead");<br />  }<br /><br />  @Override<br />  public T poll(long timeout, TimeUnit unit) throws InterruptedException {<br />    return null;<br />  }<br /><br />  @Override<br />  public int remainingCapacity() {<br />    return 0;<br />  }<br /><br />  @Override<br />  public boolean remove(Object o) {<br />    return false;<br />  }<br /><br />  @Override<br />  public boolean containsAll(Collection&lt;?&gt; c) {<br />    return false;<br />  }<br /><br />  @Override<br />  public boolean addAll(Collection&lt;? extends T&gt; c) {<br />    c.forEach(this::offer);<br />    return true;<br />  }<br /><br />  @Override<br />  public boolean removeAll(Collection&lt;?&gt; c) {<br />    return false;<br />  }<br /><br />  @Override<br />  public boolean retainAll(Collection&lt;?&gt; c) {<br />    return false;<br />  }<br /><br />  @Override<br />  public void clear() {<br />  }<br /><br />  @Override<br />  public int size() {<br />    return 0;<br />  }<br /><br />  @Override<br />  public boolean isEmpty() {<br />    return true;<br />  }<br /><br />  @Override<br />  public boolean contains(Object o) {<br />    return false;<br />  }<br /><br />  @Override<br />  public Iterator&lt;T&gt; iterator() {<br />    return Collections.emptyIterator();<br />  }<br /><br />  @Override<br />  public Object[] toArray() {<br />    return new Object[0];<br />  }<br /><br />  @Override<br />  public &lt;T&gt; T[] toArray(T[] a) {<br />    return a;<br />  }<br /><br />  @Override<br />  public int drainTo(Collection&lt;? super T&gt; c) {<br />    return 0;<br />  }<br /><br />  @Override<br />  public int drainTo(Collection&lt;? super T&gt; c, int maxElements) {<br />    return 0;<br />  }<br /><br />}<br /></pre>The implementation above is much cleaner and we don't have to worry about thread synchronization at all.<br/><br/> <script>SyntaxHighlighter.highlight();</script>