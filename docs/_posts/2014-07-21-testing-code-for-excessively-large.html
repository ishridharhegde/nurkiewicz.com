---
layout: post
title: Testing code for excessively large inputs
date: '2014-07-21T20:44:00.001+02:00'
author: Tomasz Nurkiewicz
tags:
- guava
- jaxb
- testing
- StAX
- GPX
- Jackson
- java 8
- tdd
modified_time: '2015-10-06T17:04:32.468+02:00'
thumbnail: http://2.bp.blogspot.com/-181py3Bk7nE/U81eh3ferUI/AAAAAAAABGs/AbjMzCyiIuo/s72-c/1b.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3292904947736003788
blogger_orig_url: https://www.nurkiewicz.com/2014/07/testing-code-for-excessively-large.html
---

When writing unit tests we mostly focus on business correctness. We do our best to exercise happy path and all edge cases. We sometimes microbenchmark and measure throughput. But one aspect that is often missed is how our code behaves when the input is excessively large? We test how we handle normal input files, malformed files, empty files, missing files... but what about insanely large input files?<br /><br />Let's start from a real-life use case. You were given a task to implement <a href="http://en.wikipedia.org/wiki/GPS_Exchange_Format">GPX</a> (<i>GPS Exchange Format</i>, basically XML) to JSON transformation. I chose GPX for no particular reason, it's just another XML format that you might have come across e.g. when recording your hike or bicycle ride with GPS receiver. Also I thought it will be nice to use some standard rather than yet another "people database" in XML. Inside GPX file there are hundreds of flat <code>&lt;wpt/&gt;</code> entries, each one representing one point in space-time:<br /><br /><pre class="brush: xml">&lt;gpx&gt;<br />    &lt;wpt lat="42.438878" lon="-71.119277"&gt;<br />        &lt;ele&gt;44.586548&lt;/ele&gt;<br />        &lt;time&gt;2001-11-28T21:05:28Z&lt;/time&gt;<br />        &lt;name&gt;5066&lt;/name&gt;<br />        &lt;desc&gt;&lt;![CDATA[5066]]&gt;&lt;/desc&gt;<br />        &lt;sym&gt;Crossing&lt;/sym&gt;<br />        &lt;type&gt;&lt;![CDATA[Crossing]]&gt;&lt;/type&gt;<br />    &lt;/wpt&gt;<br />    &lt;wpt lat="42.439227" lon="-71.119689"&gt;<br />        &lt;ele&gt;57.607200&lt;/ele&gt;<br />        &lt;time&gt;2001-06-02T03:26:55Z&lt;/time&gt;<br />        &lt;name&gt;5067&lt;/name&gt;<br />        &lt;desc&gt;&lt;![CDATA[5067]]&gt;&lt;/desc&gt;<br />        &lt;sym&gt;Dot&lt;/sym&gt;<br />        &lt;type&gt;&lt;![CDATA[Intersection]]&gt;&lt;/type&gt;<br />    &lt;/wpt&gt;<br />    &lt;!-- ...more... --&gt;<br />&lt;/gpx&gt;<br /></pre>Full example: <a href="http://www.topografix.com/fells_loop.gpx"><code>www.topografix.com/fells_loop.gpx</code></a>. Our task is to extract each individual <code>&lt;wpt/&gt;</code> element, discard those without <code>lat</code> or <code>lon</code> attributes and store back JSON in the following format:<br /><br /><pre class="brush: javascript">[<br />    {"lat": 42.438878,"lon": -71.119277},<br />    {"lat": 42.439227,"lon": -71.119689}<br />    ...more...<br />]<br /></pre>That's easy! First of all I started with generating JAXB classes using <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/xjc.html"><code>xjc</code> utility from JDK</a> and <a href="https://github.com/AndyA/Geo--Gpx/blob/master/doc/gpx-1.0.xsd">GPX 1.0 XSD schema</a>. Please note that GPX 1.1 is the most recent version as of this writing, but examples I got use 1.0. For JSON marshalling I used <a href="http://jackson.codehaus.org/">Jackson</a>. The complete, working and tested program looks like this:<br /><br /><pre class="brush: java">import org.apache.commons.io.FileUtils;<br />import org.codehaus.jackson.map.ObjectMapper;<br />import javax.xml.bind.JAXBException;<br /><br />public class GpxTransformation {<br /><br />    private final ObjectMapper jsonMapper = new ObjectMapper();<br />    private final JAXBContext jaxbContext;<br /><br />    public GpxTransformation() throws JAXBException {<br />        jaxbContext = JAXBContext.newInstance("com.topografix.gpx._1._0");<br />    }<br /><br />    public void transform(File inputFile, File outputFile) throws JAXBException, IOException {<br />        final List&lt;Gpx.Wpt&gt; waypoints = loadWaypoints(inputFile);<br />        final List&lt;LatLong&gt; coordinates = toCoordinates(waypoints);<br />        dumpJson(coordinates, outputFile);<br />    }<br /><br />    private List&lt;Gpx.Wpt&gt; loadWaypoints(File inputFile) throws JAXBException, IOException {<br />        String xmlContents = FileUtils.readFileToString(inputFile, UTF_8);<br />        final Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();<br />        final Gpx gpx = (Gpx) unmarshaller.unmarshal(new StringReader(xmlContents));<br />        return gpx.getWpt();<br />    }<br /><br />    private static List&lt;LatLong&gt; toCoordinates(List&lt;Gpx.Wpt&gt; waypoints) {<br />        return waypoints<br />                    .stream()<br />                    .filter(wpt -&gt; wpt.getLat() != null)<br />                    .filter(wpt -&gt; wpt.getLon() != null)<br />                    .map(LatLong::new)<br />                    .collect(toList());<br />    }<br /><br />    private void dumpJson(List&lt;LatLong&gt; coordinates, File outputFile) throws IOException {<br />        final String resultJson = jsonMapper.writeValueAsString(coordinates);<br />        FileUtils.writeStringToFile(outputFile, resultJson);<br />    }<br /><br />}<br /><br />class LatLong {<br />    private final double lat;<br />    private final double lon;<br /><br />    LatLong(Gpx.Wpt waypoint) {<br />        this.lat = waypoint.getLat().doubleValue();<br />        this.lon = waypoint.getLon().doubleValue();<br />    }<br /><br />    public double getLat() { return lat; }<br /><br />    public double getLon() { return lon; }<br />}<br /></pre>Looks fairly good, despite few traps I left intentionally. We load GPX XML file, extract waypoints to a <code>List</code>, transform that list into lightweight <code>LatLong</code> objects, first filtering out broken waypoints. Finally we dump <code>List&lt;LatLong&gt;</code> back to disk. However one day extremely long bicycle ride crashed our system with <code>OutOfMemoryError</code>. Do you know what happened? The GPX file uploaded to our application was huge, much bigger then we ever expected to receive. Now look again at the implementation above and count in how many places we allocate more memory then necessary?<br /><br />But if you want to refactor immediately, stop right there! We want to practice TDD, right? And we want to limit <a href="http://www.osnews.com/story/19266/WTFs_m">WTF/minute factor</a> in our code? I have a theory that many "WTFs" are not caused by careless and inexperienced programmers. Often it's because of these late Friday production issues, totally unexpected inputs and unpredicted side effects. Code gets more and more workarounds, hard to understand refactorings, logic more complex then one might anticipate. Sometimes bad code was not intended, but required given circumstances we had long forgotten. So if one day you see <code>null</code> check that can't possible happen or hand-written code that could've been replaced by a library - think about the context. That being said let's start from writing tests proving our future refactorings are needed. If one day someone "fixes" our code, assuming "this stupid programmer" complicated things without good reason, automated tests will tell precisely <b>why</b>.<br /><br />Our test will simply try to transform insanely big input files. But before we begin we must refactor the original implementation a bit, so that it accapets <code>InputStream</code> and <code>OutputStream</code> rather than input and output <code>File</code>s - there is no reason to limit our implementation to file system only:<br /><br /><h1>Step 0a: Make it testable</h1><pre class="brush: java">import org.apache.commons.io.IOUtils;<br /><br />public class GpxTransformation {<br /><br />    //...<br /><br />    public void transform(File inputFile, File outputFile) throws JAXBException, IOException {<br />        try (<br />                InputStream input =<br />                        new BufferedInputStream(new FileInputStream(inputFile));<br />                OutputStream output =<br />                        new BufferedOutputStream(new FileOutputStream(outputFile))) {<br />            transform(input, output);<br />        }<br />    }<br /><br />    public void transform(InputStream input, OutputStream output) throws JAXBException, IOException {<br />        final List&lt;Gpx.Wpt&gt; waypoints = loadWaypoints(input);<br />        final List&lt;LatLong&gt; coordinates = toCoordinates(waypoints);<br />        dumpJson(coordinates, output);<br />    }<br /><br />    private List&lt;Gpx.Wpt&gt; loadWaypoints(InputStream input) throws JAXBException, IOException {<br />        String xmlContents = IOUtils.toString(input, UTF_8);<br />        final Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();<br />        final Gpx gpx = (Gpx) unmarshaller.unmarshal(new StringReader(xmlContents));<br />        return gpx.getWpt();<br />    }<br /><br />    //...<br /><br />    private void dumpJson(List&lt;LatLong&gt; coordinates, OutputStream output) throws IOException {<br />        final String resultJson = jsonMapper.writeValueAsString(coordinates);<br />        output.write(resultJson.getBytes(UTF_8));<br />    }<br /><br />}<br /></pre><h1>Step 0b: Writing input (stress) test</h1>Input will be generated from scratch using <code>repeat(byte[] sample, int times)</code> utility <a href="http://www.nurkiewicz.com/2014/07/building-extremely-large-in-memory.html">developed earlier</a>. We will basically repeat the same <code>&lt;wpt/&gt;</code> item millions of times, wrapping it with GPX header and footer so that it is well-formed. Normally I would consider placing samples in <code>src/test/resources</code>, but I wanted this code to be self-containing. Notice that we neither care about the actual input, nor output. This is already tested. If transformation succeeds (we can add some timeout if we want), it's OK. If it fails with any exception, most likely <code>OutOfMemoryError</code>, it's a test failure (error):<br /><br /><pre class="brush: java">import org.apache.commons.io.FileUtils<br />import org.apache.commons.io.output.NullOutputStream<br />import spock.lang.Specification<br />import spock.lang.Unroll<br /><br />import static org.apache.commons.io.FileUtils.ONE_GB<br />import static org.apache.commons.io.FileUtils.ONE_KB<br />import static org.apache.commons.io.FileUtils.ONE_MB<br /><br />@Unroll<br />class LargeInputSpec extends Specification {<br /><br />    final GpxTransformation transformation = new GpxTransformation()<br /><br />    final byte[] header = """&lt;?xml version="1.0"?&gt;<br />        &lt;gpx<br />            version="1.0"<br />            creator="ExpertGPS 1.1 - http://www.topografix.com"<br />            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />            xmlns="http://www.topografix.com/GPX/1/0"<br />            xsi:schemaLocation="http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd"&gt;<br />        &lt;time&gt;2002-02-27T17:18:33Z&lt;/time&gt;<br />        """.getBytes(UTF_8)<br /><br />    final byte[] gpxSample = """<br />        &lt;wpt lat="42.438878" lon="-71.119277"&gt;<br />            &lt;ele&gt;44.586548&lt;/ele&gt;<br />            &lt;time&gt;2001-11-28T21:05:28Z&lt;/time&gt;<br />            &lt;name&gt;5066&lt;/name&gt;<br />            &lt;desc&gt;&lt;![CDATA[5066]]&gt;&lt;/desc&gt;<br />            &lt;sym&gt;Crossing&lt;/sym&gt;<br />        &lt;type&gt;&lt;![CDATA[Crossing]]&gt;&lt;/type&gt;<br />        &lt;/wpt&gt;<br />        """.getBytes(UTF_8)<br /><br />    final byte[] footer = """&lt;/gpx&gt;""".getBytes(UTF_8)<br /><br />    def "Should not fail with OOM for input of size #readableBytes"() {<br />        given:<br />        int repeats = size / gpxSample.length<br />        InputStream xml = withHeaderAndFooter(<br />                RepeatedInputStream.repeat(gpxSample, repeats))<br /><br />        expect:<br />        transformation.transform(xml, new NullOutputStream())<br /><br />        where:<br />        size &lt;&lt; [ONE_KB, ONE_MB, 10 * ONE_MB, 100 * ONE_MB, ONE_GB, 8 * ONE_GB, 32 * ONE_GB]<br />        readableBytes = FileUtils.byteCountToDisplaySize(size)<br />    }<br /><br />    private InputStream withHeaderAndFooter(InputStream samples) {<br />        InputStream withHeader = new SequenceInputStream(<br />                new ByteArrayInputStream(header), samples)<br />        return new SequenceInputStream(<br />                withHeader, new ByteArrayInputStream(footer))<br />    }<br />}<br /></pre>There are actually 7 tests here, running GPX to JSON transformation for inputs of size: 1 KiB, 1 MiB, 10 MiB, 100 MiB, 1 GiB, 8 GiB and 32 GiB. I run these tests on JDK 8u11x64 with the following options: <code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xmx1g</code>. 1 GiB of memory is a lot, but clearly can't fit the whole input file in memory:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-181py3Bk7nE/U81eh3ferUI/AAAAAAAABGs/AbjMzCyiIuo/s1600/1b.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-181py3Bk7nE/U81eh3ferUI/AAAAAAAABGs/AbjMzCyiIuo/s1600/1b.png" height="153" width="640" /></a></div><h1><br /></h1>While small tests are passing, inputs above 1 GiB are failing fast.<br /><br /><h1>Step 1: Avoid keeping whole files in <code>String</code>s</h1>The stack trace reveals where the problem lies:<br /><br /><pre class="brush: plain">java.lang.OutOfMemoryError: Java heap space<br />    at java.util.Arrays.copyOf(Arrays.java:3326)<br />    at java.lang.AbstractStringBuilder.expandCapacity(AbstractStringBuilder.java:137)<br />    at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:121)<br />    at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:569)<br />    at java.lang.StringBuilder.append(StringBuilder.java:190)<br />    at org.apache.commons.io.output.StringBuilderWriter.write(StringBuilderWriter.java:138)<br />    at org.apache.commons.io.IOUtils.copyLarge(IOUtils.java:2002)<br />    at org.apache.commons.io.IOUtils.copyLarge(IOUtils.java:1980)<br />    at org.apache.commons.io.IOUtils.copy(IOUtils.java:1957)<br />    at org.apache.commons.io.IOUtils.copy(IOUtils.java:1907)<br />    at org.apache.commons.io.IOUtils.toString(IOUtils.java:778)<br />    at com.nurkiewicz.gpx.GpxTransformation.loadWaypoints(GpxTransformation.java:56)<br />    at com.nurkiewicz.gpx.GpxTransformation.transform(GpxTransformation.java:50)<br /></pre><code>loadWaypoints</code> eagerly loads <code>input</code> GPX file into a <code>String</code> (see: <code>IOUtils.toString(input, UTF_8)</code>) to later parse it. That's kind of dumb, especially since JAXB <code>Unmarshaller</code> can easily read <code>InputStream</code> directly. Let's fix it:<br /><br /><pre class="brush: java">private List&lt;Gpx.Wpt&gt; loadWaypoints(InputStream input) throws JAXBException, IOException {<br />    final Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();<br />    final Gpx gpx = (Gpx) unmarshaller.unmarshal(input);<br />    return gpx.getWpt();<br />}<br /><br />private void dumpJson(List&lt;LatLong&gt; coordinates, OutputStream output) throws IOException {<br />    jsonMapper.writeValue(output, coordinates);<br />}<br /></pre>Similarly we fixed <code>dumpJson</code> as it was first dumping JSON into <code>String</code> and later copying that <code>String</code> into <code>OutputStream</code>. Results are slightly better, but again 1 GiB fails, this time by going into infinite death loop of Full GC and finally throwing:<br /><br /><pre class="brush: plain">java.lang.OutOfMemoryError: Java heap space<br />    at com.sun.xml.internal.bind.v2.runtime.unmarshaller.LeafPropertyLoader.text(LeafPropertyLoader.java:50)<br />    at com.sun.xml.internal.bind.v2.runtime.unmarshaller.UnmarshallingContext.text(UnmarshallingContext.java:527)<br />    at com.sun.xml.internal.bind.v2.runtime.unmarshaller.SAXConnector.processText(SAXConnector.java:208)<br />    at com.sun.xml.internal.bind.v2.runtime.unmarshaller.SAXConnector.endElement(SAXConnector.java:171)<br />    at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:609)<br />    [...snap...]<br />    at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:649)<br />    at com.sun.xml.internal.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal0(UnmarshallerImpl.java:243)<br />    at com.sun.xml.internal.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal(UnmarshallerImpl.java:214)<br />    at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:157)<br />    at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:204)<br />    at com.nurkiewicz.gpx.GpxTransformation.loadWaypoints(GpxTransformation.java:54)<br />    at com.nurkiewicz.gpx.GpxTransformation.transform(GpxTransformation.java:47)<br /></pre><h1>Step 2: (Poorly) replacing JAXB with StAX</h1>We can suspect that main issue now is XML parsing using JAXB, which always eagerly maps the whole XML file into Java objects. It's easy to imagine why turning a 1 GiB file into object graph fails. We would like to somehow take more control over reading XML and consuming it in chunks. SAX was traditionally used in such circumstances, however the push programming model in SAX API is very inconvenient. SAX uses callback mechanism, which is very invasive and not very readable. <a href="http://docs.oracle.com/javase/tutorial/jaxp/stax/why.html">StAX (Streaming API for XML)</a>, working on a slightly higher level, exposes pull model. It means client code decides when, and how much input to consume. This gives us better control over input and allows more flexibility. To familiarize you with the API, here is almost equivalent code to <code>loadWaypoints()</code>, but I skip attributes of <code>&lt;wpt/&gt;</code> which aren't needed later:<br /><br /><pre class="brush: java">private List&lt;Gpx.Wpt&gt; loadWaypoints(InputStream input) throws JAXBException, IOException, XMLStreamException {<br />    final XMLInputFactory factory = XMLInputFactory.newInstance();<br />    final XMLStreamReader reader = factory.createXMLStreamReader(input);<br />    final List&lt;Gpx.Wpt&gt; waypoints = new ArrayList&lt;&gt;();<br />    while (reader.hasNext()) {<br />        switch (reader.next()) {<br />            case XMLStreamConstants.START_ELEMENT:<br />                if (reader.getLocalName().equals("wpt")) {<br />                    waypoints.add(parseWaypoint(reader));<br />                }<br />                break;<br />        }<br />    }<br />    return waypoints;<br />}<br /><br />private Gpx.Wpt parseWaypoint(XMLStreamReader reader) {<br />    final Gpx.Wpt wpt = new Gpx.Wpt();<br />    final String lat = reader.getAttributeValue("", "lat");<br />    if (lat != null) {<br />        wpt.setLat(new BigDecimal(lat));<br />    }<br />    final String lon = reader.getAttributeValue("", "lon");<br />    if (lon != null) {<br />        wpt.setLon(new BigDecimal(lon));<br />    }<br />    return wpt;<br />}<br /></pre>See how we explicitly ask <code>XMLStreamReader</code> for more data? However the fact that we are using more low-level API (and <i>a lot</i> more code) doesn't mean it has to be better if used incorrectly. We keep building huge <code>waypoints</code> list, so it's not a surprise we again see <code>OutOfMemoryError</code>:<br /><br /><pre class="brush: plain">java.lang.OutOfMemoryError: Java heap space<br />    at java.util.Arrays.copyOf(Arrays.java:3204)<br />    at java.util.Arrays.copyOf(Arrays.java:3175)<br />    at java.util.ArrayList.grow(ArrayList.java:246)<br />    at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:220)<br />    at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:212)<br />    at java.util.ArrayList.add(ArrayList.java:443)<br />    at com.nurkiewicz.gpx.GpxTransformation.loadWaypoints(GpxTransformation.java:65)<br />    at com.nurkiewicz.gpx.GpxTransformation.transform(GpxTransformation.java:52)<br /></pre>Exactly where we anticipated. The good news is that 1 GiB test passed (with 1 GiB heap), so we are <i>sort of</i> going in the right direction. But it took 1 minute to complete due to excessive GC.<br /><br /><h1>Step 3: StAX implemented properly</h1>Notice that implementation using StAX in previous example would be just as good with SAX. However the reason I chose StAX was that we can now turn an XML file into an <code>Iterator&lt;Gpx.Wpt&gt;</code>. This iterator will consume XML file in chunks, lazily and only when asked. We can later consume that iterator lazily as well, which means we no longer keep whole file in memory. Iterators, while clumsy to work with, are still much better than working with XML directly or with SAX callbacks:<br /><br /><pre class="brush: java">import com.google.common.collect.AbstractIterator;<br /><br />private Iterator&lt;Gpx.Wpt&gt; loadWaypoints(InputStream input) throws JAXBException, IOException, XMLStreamException {<br />    final XMLInputFactory factory = XMLInputFactory.newInstance();<br />    final XMLStreamReader reader = factory.createXMLStreamReader(input);<br />    return new AbstractIterator&lt;Gpx.Wpt&gt;() {<br /><br />        @Override<br />        protected Gpx.Wpt computeNext() {<br />            try {<br />                return tryPullNextWaypoint();<br />            } catch (XMLStreamException e) {<br />                throw Throwables.propagate(e);<br />            }<br />        }<br /><br />        private Gpx.Wpt tryPullNextWaypoint() throws XMLStreamException {<br />            while (reader.hasNext()) {<br />                int event = reader.next();<br />                switch (event) {<br />                    case XMLStreamConstants.START_ELEMENT:<br />                        if (reader.getLocalName().equals("wpt")) {<br />                            return parseWaypoint(reader);<br />                        }<br />                        break;<br />                    case XMLStreamConstants.END_ELEMENT:<br />                        if (reader.getLocalName().equals("gpx")) {<br />                            return endOfData();<br />                        }<br />                        break;<br />                }<br />            }<br />            throw new IllegalStateException("XML file didn't finish with &lt;/gpx&gt; element, malformed?");<br />        }<br />    };<br />}<br /></pre>This is getting complex! I'm using <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/AbstractIterator.html"><code>AbstractIterator</code></a> from Guava to handle tedious <code>hasNext()</code> state. Every time someone tries to pull next <code>Gpx.Wpt</code> item from an iterator (or call <code>hasNext()</code>) we consume a little bit of XML, just enough to return one entry. If <code>XMLStreamReader</code> encounters end of XML (<code>&lt;/gpx&gt;</code> tag), we signal iterator end by returning <code>endOfData()</code>. This is a very handy pattern where XML is read lazily and served via convenient iterator. This implementation alone consumes very little, constant amount of memory. However we changed the API from <code>List&lt;Gpx.Wpt&gt;</code> to <code>Iterator&lt;Gpx.Wpt&gt;</code>, which forces changes to the rest of our implementation:<br /><br /><pre class="brush: java">private static List&lt;LatLong&gt; toCoordinates(Iterator&lt;Gpx.Wpt&gt; waypoints) {<br />    final Spliterator&lt;Gpx.Wpt&gt; spliterator =<br />            Spliterators.spliteratorUnknownSize(waypoints, Spliterator.ORDERED);<br />    return StreamSupport<br />            .stream(spliterator, false)<br />            .filter(wpt -&gt; wpt.getLat() != null)<br />            .filter(wpt -&gt; wpt.getLon() != null)<br />            .map(LatLong::new)<br />            .collect(toList());<br />}<br /></pre><code>toCoordinates()</code> was previously accepting <code>List&lt;Gpx.Wpt&gt;</code>. Iterators can't be turned into <code>Stream</code> directly, so we need this clunky transformation through <code>Spliterator</code>. Do you think it's over? ! GiB test passes a little bit faster, but more demanding ones are failing just like before:<br /><br /><pre class="brush: plain">java.lang.OutOfMemoryError: Java heap space<br />    at java.util.Arrays.copyOf(Arrays.java:3175)<br />    at java.util.ArrayList.grow(ArrayList.java:246)<br />    at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:220)<br />    at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:212)<br />    at java.util.ArrayList.add(ArrayList.java:443)<br />    at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)<br />    at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)<br />    at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)<br />    at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)<br />    at java.util.Iterator.forEachRemaining(Iterator.java:116)<br />    at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)<br />    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)<br />    at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)<br />    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)<br />    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)<br />    at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)<br />    at com.nurkiewicz.gpx.GpxTransformation.toCoordinates(GpxTransformation.java:118)<br />    at com.nurkiewicz.gpx.GpxTransformation.transform(GpxTransformation.java:58)<br />    at com.nurkiewicz.LargeInputSpec.Should not fail with OOM for input of size #readableBytes(LargeInputSpec.groovy:49)<br /></pre>Remember that <code>OutOfMemoryError</code> is not always thrown from a place that actually consumes most memory. Luckily it's not the case this time. Look carefully to the bottom: <code>collect(toList())</code>.<br /><br /><h1>Step 4: Avoiding streams and collectors</h1>This is disappointing. Streams and collectors were designed from the ground up to support laziness. However it's virtually impossible to implement a collector (see also: <a href="http://www.nurkiewicz.com/2014/07/introduction-to-writing-custom.html"><i>Introduction to writing custom collectors in Java 8</i></a> and <a href="http://www.nurkiewicz.com/2014/07/grouping-sampling-and-batching-custom.html"><i>Grouping, sampling and batching - custom collectors</i></a>) from stream to iterator effectively, which is a big design flaw. Therefore we must forget about streams altogether and use plain iterators all the way down. Iterators aren't very elegant, but allow consuming input item-by-item, having full control over memory consumption. We need a way to <code>filter()</code> input iterator, discarding broken items and <code>map()</code> entries to another representation. Guava, again, provides few handy utilities for that, replacing <code>stream()</code> completely:<br /><br /><pre class="brush: java">private static Iterator&lt;LatLong&gt; toCoordinates(Iterator&lt;Gpx.Wpt&gt; waypoints) {<br />    final Iterator&lt;Gpx.Wpt&gt; filtered = Iterators<br />            .filter(waypoints, wpt -&gt; <br />                    wpt.getLat() != null &amp;&amp; <br />                    wpt.getLon() != null);<br />    return Iterators.transform(filtered, LatLong::new);<br />}<br /></pre><code>Iterator&lt;Gpx.Wpt&gt;</code> in, <code>Iterator&lt;LatLong&gt;</code> out. No processing was done, XML file was barely touched, marginal memory consumption. We are lucky, Jackson accepts iterators and transparently reads them, producing JSON iteratively. Thus, memory consumption is kept low as well. Guess what, we made it!<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-Pak1a13a90k/U81eh5mY4gI/AAAAAAAABGw/sOs5jEUOeJM/s1600/6b.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-Pak1a13a90k/U81eh5mY4gI/AAAAAAAABGw/sOs5jEUOeJM/s1600/6b.png" height="170" width="640" /></a></div><h1><br /></h1>Memory consumption is low and stable, I think we can safely assume it's constant. Our code processes about 40 MiB/s, so don't be surprised by almost 14 minutes it took to process 32 GiB. Oh, and did I mention that I run the last test with <code>-Xmx32M</code>? That's right, processing 32 GiB was successful without any performance loss using thousand times less memory. And 3000 times less, compared to initial implementation. As a matter of fact the last solution using iterators is capable of handling even infinite streams of XML. It's not really just theoretical case, imagine some sort of streaming API that produces never-ending flow of messages...<br /><br /><h1>Final implementation</h1>This is our code in it's entirety:<br /><br /><hr /><pre class="brush: java">package com.nurkiewicz.gpx;<br /><br />import com.google.common.base.Throwables;<br />import com.google.common.collect.AbstractIterator;<br />import com.google.common.collect.Iterators;<br />import com.topografix.gpx._1._0.Gpx;<br />import org.codehaus.jackson.map.ObjectMapper;<br /><br />import javax.xml.bind.JAXBException;<br />import javax.xml.stream.XMLInputFactory;<br />import javax.xml.stream.XMLStreamConstants;<br />import javax.xml.stream.XMLStreamException;<br />import javax.xml.stream.XMLStreamReader;<br />import java.io.BufferedInputStream;<br />import java.io.BufferedOutputStream;<br />import java.io.File;<br />import java.io.FileInputStream;<br />import java.io.FileOutputStream;<br />import java.io.IOException;<br />import java.io.InputStream;<br />import java.io.OutputStream;<br />import java.math.BigDecimal;<br />import java.util.Iterator;<br /><br />public class GpxTransformation {<br /><br />    private static final ObjectMapper jsonMapper = new ObjectMapper();<br /><br />    public void transform(File inputFile, File outputFile) throws JAXBException, IOException, XMLStreamException {<br />        try (<br />                InputStream input =<br />                        new BufferedInputStream(new FileInputStream(inputFile));<br />                OutputStream output =<br />                        new BufferedOutputStream(new FileOutputStream(outputFile))) {<br />            transform(input, output);<br />        }<br />    }<br /><br />    public void transform(InputStream input, OutputStream output) throws JAXBException, IOException, XMLStreamException {<br />        final Iterator&lt;Gpx.Wpt&gt; waypoints = loadWaypoints(input);<br />        final Iterator&lt;LatLong&gt; coordinates = toCoordinates(waypoints);<br />        dumpJson(coordinates, output);<br />    }<br /><br />    private Iterator&lt;Gpx.Wpt&gt; loadWaypoints(InputStream input) throws JAXBException, IOException, XMLStreamException {<br />        final XMLInputFactory factory = XMLInputFactory.newInstance();<br />        final XMLStreamReader reader = factory.createXMLStreamReader(input);<br />        return new AbstractIterator&lt;Gpx.Wpt&gt;() {<br /><br />            @Override<br />            protected Gpx.Wpt computeNext() {<br />                try {<br />                    return tryPullNextWaypoint();<br />                } catch (XMLStreamException e) {<br />                    throw Throwables.propagate(e);<br />                }<br />            }<br /><br />            private Gpx.Wpt tryPullNextWaypoint() throws XMLStreamException {<br />                while (reader.hasNext()) {<br />                    int event = reader.next();<br />                    switch (event) {<br />                        case XMLStreamConstants.START_ELEMENT:<br />                            if (reader.getLocalName().equals("wpt")) {<br />                                return parseWaypoint(reader);<br />                            }<br />                            break;<br />                        case XMLStreamConstants.END_ELEMENT:<br />                            if (reader.getLocalName().equals("gpx")) {<br />                                return endOfData();<br />                            }<br />                            break;<br />                    }<br />                }<br />                throw new IllegalStateException("XML file didn't finish with &lt;/gpx&gt; element, malformed?");<br />            }<br />        };<br />    }<br /><br />    private Gpx.Wpt parseWaypoint(XMLStreamReader reader) {<br />        final Gpx.Wpt wpt = new Gpx.Wpt();<br />        final String lat = reader.getAttributeValue("", "lat");<br />        if (lat != null) {<br />            wpt.setLat(new BigDecimal(lat));<br />        }<br />        final String lon = reader.getAttributeValue("", "lon");<br />        if (lon != null) {<br />            wpt.setLon(new BigDecimal(lon));<br />        }<br />        return wpt;<br />    }<br /><br />    private static Iterator&lt;LatLong&gt; toCoordinates(Iterator&lt;Gpx.Wpt&gt; waypoints) {<br />        final Iterator&lt;Gpx.Wpt&gt; filtered = Iterators<br />                .filter(waypoints, wpt -&gt;<br />                        wpt.getLat() != null &amp;&amp;<br />                        wpt.getLon() != null);<br />        return Iterators.transform(filtered, LatLong::new);<br />    }<br /><br />    private void dumpJson(Iterator&lt;LatLong&gt; coordinates, OutputStream output) throws IOException {<br />        jsonMapper.writeValue(output, coordinates);<br />    }<br /><br />}<br /></pre><hr /><h1>Summary (TL;DR)</h1>If you were not patient enough to follow all steps, here are three main takeaways:<br /><br /><ol><li><b>Your first goal is simplicity</b>. Initial JAXB implementation was perfectly fine (with minor modifications), keep it like that if your code doesn't have to handle large inputs.<br /><br /></li><li><b>Test your code against insanely large inputs</b>, e.g. using generated <code>InputStream</code>, producing gigabytes of input. Huge data set is another example of edge case. Don't test manually, once. One careless change or "improvement" might ruin your performance down the road.<br /><br /></li><li><b>Optimization is not an excuse for writing poor code</b>. Notice that our implementation is still composable and easy to follow. If we went through SAX and simply inlined all logic in SAX callbacks, maintainability would greatly suffer.<br /><br /></li></ol> <script>SyntaxHighlighter.highlight();</script>