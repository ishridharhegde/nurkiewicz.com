---
layout: post
title: Guide to time and date in Java
date: '2016-08-05T10:58:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- java.time
modified_time: '2016-08-05T10:59:36.832+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1680525005904435933
blogger_orig_url: https://www.nurkiewicz.com/2016/08/guide-to-time-and-date-in-java.html
---

Properly handling dates, time, time zones, daylight saving time, leap years and such has been my pet peeve for a long time. This article is not a comprehensive guide to time domain, see <a href="http://www.odi.ch/prog/design/datetime.php">Date and time in Java</a> - much more detailed but slightly, <em>ekhem</em>, dated. It's still relevant, but doesn't cover <code>java.time</code> from Java 8. I want to cover the absolute minimum that every junior Java developer should be aware of.<br /><br /><h1 id="when-did-an-event-happen">When did an event happen?</h1>Philosophy and quantum physics aside, we may treat time as a one-dimensional metric, a real number value. This value keeps growing when time passes by. If one event appeared after another, we assign greater time to that event. Two events happening simultaneously have the same time value. For practical reasons in computer systems we store time in discrete integer, mainly because computer clocks tick discretely. Therefore we can store time as an integer value. By convention we assign time = 0 to January 1st, 1970 but in Java we increment this value every millisecond, not second like in <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX time</a>. Historically using 32-bit signed integer in UNIX time will cause <a href="https://en.wikipedia.org/wiki/Year_2038_problem">year 2038 problem</a>. Thus Java stores time in 64-bit integer, which is sufficient even if you increment it thousand times more often. That being said the simplest, yet valid way of storing time in Java is... <code>long</code> primitive:<br /><br /><pre class="brush: java">long timestamp = System.currentTimeMillis();</pre>The problem with <code>long</code> is that it's so prevalent that using it for storing time undermines the type system. It may be an ID, may be hash value, can be anything. Also <code>long</code> doesn't have any meaningful methods related to time domain. The very first approach to wrap <code>long</code> in more meaningful object was <code>java.util.Date</code> known since Java 1.0:<br /><br /><pre class="brush: java">Date now = new Date();</pre><code>Date</code> class however has numerous flaws:<br /><br /><ol style="list-style-type: decimal;"><li>It does not represent... date. Seriously, officially date is "[...] the day of the month or year as specified by a number [...]" <a href="http://www.oxforddictionaries.com/definition/english/date">[1]</a> whereas in Java it represents point in time without any specific calendar (day/month/year).</li><li>Its <code>toString()</code> is misleading, displaying calendar date and time in system timezone. Not only it misled thousands of developers to think that <code>Date</code> has a timezone attached. Moreover it shows time, but <em>date</em> should only represent day, not hour.</li><li>It has 20+ deprecated methods, including <code>getYear()</code>, <code>parse(String)</code> and many constructors. These methods are deprecated for a reason, because they lead you to believe <code>Date</code> represents, you know, <em>date</em>.</li><li><code>java.sql.Date</code> extends <code>java.util.Date</code> and is actually much more accurate because it indeed represents calendar <em>date</em> (<code>DATE</code> in SQL). However this narrows the functionality of base class <code>Date</code>, thus violating <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a>. Don't believe me? <code>java.util.Date.toInstant()</code> works as expected but <code>java.sql.Date.toInstant()</code> fails unconditionally with <code>UnsupportedOperationException</code>...</li><li>Worst of them all, <code>Date</code> is <strong>mutable</strong>.</li></ol>Ever wondered why old and grumpy developers in your team are so excited about immutability? Imagine a piece of code that adds one minute to any <code>Date</code>. Simple, huh?<br /><br /><pre class="brush: java">Date addOneMinute(Date in) {<br />    in.setTime(in.getTime() + 1_000 * 60);<br />    return in;<br />}</pre>Looks fine, right? All test cases pass because who on earth would ever validate that input parameters are intact after testing code?<br /><br /><pre class="brush: java">    Date now = new Date();<br />    System.out.println(now);<br />    System.out.println(addOneMinute(now));<br />    System.out.println(now);</pre>The output may look as follows:<br /><br /><pre class="brush: plain">Tue Jul 26 22:59:22 CEST 2016<br />Tue Jul 26 23:00:22 CEST 2016<br />Tue Jul 26 23:00:22 CEST 2016</pre>Did you notice that <code>now</code> value was actually changed after adding one minute? When you have a function that takes <code>Date</code> and returns <code>Date</code> you would never expect it to modify its parameters! It's like having a function taking <code>x</code> and <code>y</code> numbers and retuning sum of them. If you discover that <code>x</code> was somehow modified during the course of addition, all your assumptions are ruined. By the way that is the reason why <code>java.lang.Integer</code> is immutable. Or <code>String</code>. Or <code>BigDecimal</code>.<br /><br />This is not a contrived example. Imagine a <code>ScheduledTask</code> class with a single method:<br /><br /><pre class="brush: java">class ScheduledTask {<br />    Date getNextRunTime();<br />}</pre>What happens if I say:<br /><br /><pre class="brush: java">ScheduledTask task = //...<br />task.getNextRunTime().setTime(new Date());</pre>Does changing the returned <code>Date</code> have effect on next run time? Or maybe <code>ScheduledTask</code> returns a copy of its internal state that you are free to modify? Maybe we will leave <code>ScheduledTask</code> in some inconsistent state? If <code>Date</code> was immutable no such problem would ever arise.<br /><br />Interestingly, every Java developer will become furious if you confuse Java with JavaScript. But guess what, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code> in JavaScript</a> has the exact same flaws as <code>java.util.Date</code> and seems like a bad example of copy-paste. <code>Date</code> in JavaScript is mutable, has misleading <code>toString()</code> and no support for time zones whatsoever.<br /><br />A great alternative to <code>Date</code> is <code>java.time.Instant</code>. It does precisely what it claims: stores an instant in time. <code>Instant</code> does not have date or calendar related methods, its <code>toString()</code> uses familiar ISO format in UTC time zone (more on that later) and most importantly: it's immutable. If you want to remember when a particular event happened, <code>Instant</code> is the best you can get in plain Java:<br /><br /><pre class="brush: java">Instant now = Instant.now();<br />Instant later = now.plusSeconds(60);</pre>Notice that <code>Instant</code> does not have <code>plusMinutes()</code>, <code>plusHours()</code> and so on. Minutes, hours and days are concepts related to calendar systems, whereas <code>Instant</code> is geographically and culturally agnostic.<br /><br /><h1 id="human-readable-calendars-with-zoneddatetime">Human readable calendars with <code>ZonedDateTime</code></h1>Sometimes you do need a human representation of an instant in time. This includes month, day of week, current hour and so on. But here is a major complication: date and time varies across countries and regions. <code>Instant</code> is simple and universal, but not very useful for human beings, it's just a number. If you have business logic related to calendar, like:<br /><br /><ul><li>...must happen during office hours...</li><li>...up to one day...</li><li>...two business days...</li><li>...valid for up to one year...</li><li>...</li></ul>then you must use some calendar system. <code>java.time.ZonedDateTime</code> is the best alternative to absolutely awful <code>java.util.Calendar</code>. As a matter of fact <code>java.util.Date</code> and <code>Calendar</code> are so broken by design that they are considered to be <a href="https://bugs.openjdk.java.net/browse/JDK-8065614">deprecated entirely</a> in JDK 9. You can create <code>ZonedDateTime</code> from <code>Instant</code> <strong>only</strong> by providing a time zone. Otherwise default system time zone is used which you have no control over. Converting <code>Instant</code> to <code>ZonedDateTime</code> in any way without providing explicit <code>ZoneId</code> is probably a bug:<br /><br /><pre class="brush: java">Instant now = Instant.now();<br />System.out.println(now);<br /><br />ZonedDateTime dateTime = ZonedDateTime.ofInstant(<br />        now,<br />        ZoneId.of("Europe/Warsaw")<br />    );<br /><br />System.out.println(dateTime);</pre>The output is as follows:<br /><br /><pre class="brush: plain">2016-08-05T07:00:44.057Z<br />2016-08-05T09:00:44.057+02:00[Europe/Warsaw]</pre>Notice that <code>Instant</code> (for convenience) displays date formatted in UTC whereas <code>ZonedDateTime</code> uses supplied <code>ZoneId</code> (+2 hours during summer, more on that later).<br /><br /><h1 id="calendar-misconceptions">Calendar misconceptions</h1>There are many misconceptions and myths related to time and calendars. For example some people believe that the time difference between two locations is always constant. There are at least two reasons for that not being true. First the daylight saving time, aka summer time:<br /><br /><pre class="brush: java">LocalDate localDate = LocalDate.of(2016, Month.AUGUST, 5);<br />LocalTime localTime = LocalTime.of(10, 21);<br />LocalDateTime local = LocalDateTime.of(localDate, localTime);<br />ZonedDateTime warsaw = ZonedDateTime.of(local, ZoneId.of("Europe/Warsaw"));<br /><br />ZonedDateTime sydney = warsaw.withZoneSameInstant(ZoneId.of("Australia/Sydney"));<br /><br />System.out.println(warsaw);<br />System.out.println(sydney);</pre>The output reveals that the difference between Warsaw and Sydney is exactly 8 hours:<br /><br /><pre class="brush: plain">2016-08-05T10:21+02:00[Europe/Warsaw]<br />2016-08-05T18:21+10:00[Australia/Sydney]</pre>Or is it? Change August to February and the difference becomes 10 hours:<br /><br /><pre class="brush: plain">2016-02-05T10:21+01:00[Europe/Warsaw]<br />2016-02-05T20:21+11:00[Australia/Sydney]</pre>That's because Warsaw does not observe DST in February (it's winter) whereas in Sydney it's summer so they use DST (+1 hour). In August it's vice-versa. To make things even more complex, the time to switch to DST varies and it's always during night of local time so there must be a moment where one country already switched but not the other, for example in October:<br /><br /><pre class="brush: plain">2016-10-05T10:21+02:00[Europe/Warsaw]<br />2016-10-05T19:21+11:00[Australia/Sydney]</pre>9 hours of difference. Another reason why time offset differs is political:<br /><br /><pre class="brush: java">LocalDate localDate = LocalDate.of(2014, Month.FEBRUARY, 5);<br />LocalTime localTime = LocalTime.of(10, 21);<br />LocalDateTime local = LocalDateTime.of(localDate, localTime);<br />ZonedDateTime warsaw = ZonedDateTime.of(local, ZoneId.of("Europe/Warsaw"));<br /><br />ZonedDateTime moscow = warsaw.withZoneSameInstant(ZoneId.of("Europe/Moscow"));<br /><br />System.out.println(warsaw);<br />System.out.println(moscow);</pre>The time difference between Warsaw and Moscow on February 5th, 2014 was 3 hours:<br /><br /><pre class="brush: plain">2014-02-05T10:21+01:00[Europe/Warsaw]<br />2014-02-05T13:21+04:00[Europe/Moscow]</pre>But the difference on the exact same day year later is 2 hours:<br /><br /><pre class="brush: plain">2015-02-05T10:21+01:00[Europe/Warsaw]<br />2015-02-05T12:21+03:00[Europe/Moscow]</pre>That's because Russia is changing their DST policy and time zone <a href="http://www.timeanddate.com/time/zone/russia/moscow">like crazy</a>.<br /><br />Another common misconception about dates is that a day is 24 hours. This is again related to daylight saving time:<br /><br /><pre class="brush: java">LocalDate localDate = LocalDate.of(2017, Month.MARCH, 26);<br />LocalTime localTime = LocalTime.of(1, 0);<br />ZonedDateTime warsaw = ZonedDateTime.of(localDate, localTime, ZoneId.of("Europe/Warsaw"));<br /><br />ZonedDateTime oneDayLater = warsaw.plusDays(1);<br /><br />Duration duration = Duration.between(warsaw, oneDayLater);<br />System.out.println(duration);</pre>What do you know, the difference between 1 AM on March 26th and 27th, 2017 is... 23 hours (<code>PT23H</code>). But if you change the time zone to <code>Australia/Sydney</code> you'll get familiar 24 hours because nothing special happens that day in Sydney. That special day in Sydney happens to be 2nd of April, 2017:<br /><br /><pre class="brush: java">LocalDate localDate = LocalDate.of(2017, Month.APRIL, 2);<br />LocalTime localTime = LocalTime.of(1, 0);<br />ZonedDateTime warsaw = ZonedDateTime.of(localDate, localTime, ZoneId.of("Australia/Sydney"));</pre>Which results in one day being equal to... 25 hours. But not in Brisbane (<code>"Australia/Brisbane"</code>), thousand km north to Sydney, which does not observe DST. Why is all of this important? When you make an agreement with your client that something is suppose to take one day vs. 24 hours this may actually make a huge difference at certain day. You must be precise, otherwise your system will become inconsistent twice a year. And don't get me started on <a href="https://en.wikipedia.org/wiki/Leap_second">leap second</a>.<br /><br />The lesson to learn here is that every time you enter calendar domain you <strong>must</strong> think about time zones. There are convenience methods that use default system time zone but in cloud environments you may not have control over that. The same applies to default character encoding, but that's a different story.<br /><br /><h1 id="storing-and-transmitting-time">Storing and transmitting time</h1>By default you should store and send time either as timestamp (<code>long</code> value) or as <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> which is basically what <code>Instant.toString()</code> does as per the documentation. Prefer <code>long</code> value as it is more compact, unless you need more readable format in some text encoding like JSON. Also <code>long</code> is timezone-agnostic so you are not pretending that the timezone you send/store has any meaning. This applies both to transmitting time and storing it in database.<br /><br />There are cases where you may want to send full calendar information, including timezone. For example when you build a chatting application you might want to tell the client what was the local time when the message was sent if your friend lives in a different timezone. Otherwise you know it was sent at 10 AM your time, but what was the time in your friend's location? Another example is flight ticket booking website. You want to tell your clients when flight departs and arrives in local time and it's only the server that knows the exact timezone at departure and destination.<br /><br /><h1 id="local-time-and-date">Local time and date</h1>Sometimes you want express date or time without any specific time zone. For example my birthday is:<br /><br /><pre class="brush: java">//1985-12-25<br />LocalDate.of(1985, Month.DECEMBER, 25)</pre>I will celebrate my birthday that day no matter where I am. This means party will start at approximately:<br /><br /><pre class="brush: java">//20:00<br />LocalTime.of(20, 0, 0)      </pre>Irrespective to time zone. I can even say that my birthday party this year will be precisely at:<br /><br /><pre class="brush: java">//2016-12-25T20:00<br />LocalDateTime party = LocalDateTime.of(<br />        LocalDate.of(2016, Month.DECEMBER, 25),<br />        LocalTime.of(20, 0, 0)<br />);</pre>But as long as I don't provide you a location, you don't know what is the time zone I live in, thus what is the actual start time. It's impossible (or very foolish) to convert from <code>LocalDateTime</code> to <code>Instant</code> or <code>ZonedDateTime</code> (which both point to a precise moment in time) without giving a time zone. So local times are useful, but they don't really represent any moment in time.<br /><br /><h1 id="testing">Testing</h1>I just scratched the surface of pitfalls and issues one might have with time an date. For example we didn't cover leap years which can become a serious source of bugs. I find <a href="http://www.nurkiewicz.com/2014/09/property-based-testing-with-scalacheck.html">property-based testing</a> extremely useful when testing dates:<br /><br /><pre class="brush: java">import spock.lang.Specification<br />import spock.lang.Unroll<br /><br />import java.time.*<br /><br />class PlusMinusMonthSpec extends Specification {<br /><br />    static final LocalDate START_DATE =<br />            LocalDate.of(2016, Month.JANUARY, 1)<br /><br />    @Unroll<br />    def '#date +/- 1 month gives back the same date'() {<br />        expect:<br />            date == date.plusMonths(1).minusMonths(1)<br />        where:<br />            date &lt;&lt; (0..365).collect {<br />                day -&gt; START_DATE.plusDays(day)<br />            }<br />    }<br /><br />}</pre>This test makes sure adding and subtracting one month to any date in 2016 gives back the same date. Pretty straightforward, right? This test fails for a number of days:<br /><br /><pre class="brush: plain">date == date.plusMonths(1).minusMonths(1)<br />|    |  |    |             |<br />|    |  |    2016-02-29    2016-01-29<br />|    |  2016-01-30<br />|    false<br />2016-01-30<br /><br /><br />date == date.plusMonths(1).minusMonths(1)<br />|    |  |    |             |<br />|    |  |    2016-02-29    2016-01-29<br />|    |  2016-01-31<br />|    false<br />2016-01-31<br /><br /><br />date == date.plusMonths(1).minusMonths(1)<br />|    |  |    |             |<br />|    |  |    2016-04-30    2016-03-30<br />|    |  2016-03-31<br />|    false<br />2016-03-31<br /><br />...</pre>Leap years cause all sorts of issues and break the laws of math. Another similar example is adding two months to a date that is not always equal to adding one month two times.<br /><br /><h1 id="summary">Summary</h1>Once again we barely scratched the surface. If there is just one thing I want you to learn from this article: mind the time zone!<br /><br /><script>SyntaxHighlighter.highlight();</script>