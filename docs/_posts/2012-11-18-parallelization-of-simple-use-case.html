---
layout: post
title: Parallelization of a simple use case explained
date: '2012-11-18T19:59:00.002+01:00'
author: Tomasz Nurkiewicz
tags:
- spring
- concurrency
modified_time: '2012-11-18T19:59:46.853+01:00'
thumbnail: http://1.bp.blogspot.com/-TKbrjLw9yI8/UKkva0Lfz8I/AAAAAAAAAq0/7iqqzJ4DQLw/s72-c/parallelization2.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2585022734493247699
blogger_orig_url: https://www.nurkiewicz.com/2012/11/parallelization-of-simple-use-case.html
---

Some time ago a friend of mine asked me about the possibilities of speeding up the following process: they are generating some data in two stages, reading from a database and processing the results. Reading takes approximately 70% of time and processing takes the remaining 30%. Unfortunately they cannot simply load the whole data into memory, thus they split reading into much smaller chunks (pages) and process these pages once they are retrieved, interleaving the these two stages in a loop. Here is a pseudo-code of what they have so far:<br /><br /><pre class="brush: java">public Data loadData(int page) {<br />    //70% of time...<br />}<br /><br />public void process(Data data) {<br />    //30% of time...<br />}<br /><br />for (int i = 0; i &lt; MAX; ++i) {<br />    Data data = loadData(i);<br />    process(data);<br />}<br /></pre>His idea of improving the algorithm was to somehow start fetching next page of data when current page is still being processed, thus reducing the overall run time of the algorithm. He was correct, but didn't know how to put this into Java code, not being very experienced with magnificent <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html"><code>java.util.concurrent</code></a> package. This article is targeted for such people, introducing briefly the very basic concepts of concurrent programming in Java such as thread pools and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html"><code>Future&lt;T&gt;</code></a> type. First let's visualize the initial and desired implementation using <a href="http://en.wikipedia.org/wiki/Gantt_chart">Gantt chart</a>:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-TKbrjLw9yI8/UKkva0Lfz8I/AAAAAAAAAq0/7iqqzJ4DQLw/s1600/parallelization2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="140" src="http://1.bp.blogspot.com/-TKbrjLw9yI8/UKkva0Lfz8I/AAAAAAAAAq0/7iqqzJ4DQLw/s640/parallelization2.png" width="640" /></a></div><br /><br />The second chart represents the solution we are aiming to achieve. The first observation you should make is that the second process finishes earlier, which is good. The second one is: when we are processing first page (yellow <code>1</code>), the second page is already being downloaded (green <code>2</code>). When we begin processing page <code>2</code>, page <code>3</code> began downloading. And so on. We will go back to this chart later, once we have a working implementation. Let's put this into code.<br /><br />Threads are the way to achieve background loading of data (green blocks). However simply starting a thread for each green block is both slow and inconvenient. Thread pool with just a single thread is much more flexible and easier to use. First let's wrap our call to <code>loadData()</code> into <code>Callable&lt;Data&gt;</code>:<br /><br /><a name='more'></a><br /><br /><pre class="brush: java">private class LoadDataTask implements Callable&lt;Data&gt; {<br /><br />    private final int page;<br /><br />    private LoadDataTask(int page) {<br />        this.page = page;<br />    }<br /><br />    @Override<br />    public Data call() throws Exception {<br />        return loadData(page);<br />    }<br />}<br /></pre>Once we have such class it's easy to feed thread pool (represented by <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html"><code>ExecutorService</code></a>) and wait for a reply. Here is a full implementation:<br /><br /><pre class="brush: java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br />Future&lt;Data&gt; next = executorService.submit(new LoadDataTask(0));<br />for (int i = 0; i &lt; MAX; ++i) {<br />    Future&lt;Data&gt; current = next;<br />    if (i + 1 &lt; MAX) {<br />        next = executorService.submit(new LoadDataTask(i + 1));<br />    }<br />    Data data = current.get();  //this can block<br />    process(data);<br />}<br />executorService.shutdownNow();<br /></pre><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newSingleThreadExecutor()"><code>Executors.newSingleThreadExecutor()</code></a> basically creates a background thread waiting for tasks to run. We cannot use a bigger pool (with more threads) because then we would risk keeping too much data in memory, before it gets processed.<br /><br />For the purpose of example assume loading a page (green blocks) takes 700ms while processing it (yellow blocks) - 300ms. At the beginning we submit an initial task to load page <code>0</code> (first blue arrow pointing down). Thus we have to wait full 700ms for the first block. However once the data is available, before we start processing it, we immediately ask for the next page. When we run the second iteration, we don't have to wait full 700 ms again, because loading data already progressed by 300 ms, thus <code>Future.get()</code> only blocks for 400 ms. We repeat this process until we are processing the last page. Of course we don't have load next page of data because we already processed all of them, thus this ugly condition inside loop. It's easy to avoid it by returning null object from <code>loadData()</code> when page is out of bounds, but let's leave it for the clarity of example.<br /><br /><hr />This approach is so common in the enterprise that dedicated support was added to both <a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/scheduling.html#scheduling-annotation-support-async">Spring</a> and <a href="http://docs.oracle.com/javaee/6/tutorial/doc/gkkqg.html">EJB</a>. Let's use Spring as an example. The only thing we have to change is to adjust return value of <code>loadData()</code> from <code>Data</code> to <code>Future&lt;Data&gt;</code>. Wrapping result value with <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/scheduling/annotation/AsyncResult.html"><code>AsyncResult</code></a> is required to compile:<br /><br /><pre class="brush: java">@Async<br />public Future&lt;Data&gt; loadData(int page) {<br />    //...<br />    return new AsyncResult&lt;Data&gt;(new Data(...));<br />}<br /></pre>Of course this class is a part of some Spring bean (say <code>dao</code>). API is now much cleaner:<br /><br /><pre class="brush: java">Future&lt;Data&gt; next = dao.loadData(0);<br />for (int i = 0; i &lt; MAX; ++i) {<br />    Future&lt;Data&gt; current = next;<br />    if (i + 1 &lt; MAX) {<br />        next = dao.loadData(i + 1);<br />    }<br />    Data data = current.get();<br />    processor.process(data);<br />}<br /></pre>we no longer have to use <code>Callable</code> and interact with some thread pools. Also bootstraping Spring was never that simple (so don't tell me that Spring is heavyweight!):<br /><br /><pre class="brush: java">@Configuration<br />@ComponentScan("com.blogspot.nurkiewicz.async")<br />@EnableAsync<br />public class Config implements AsyncConfigurer {<br /><br />    @Override<br />    public Executor getAsyncExecutor() {<br />        return Executors.newSingleThreadExecutor();<br />    }<br /><br />}<br /></pre>Technically <code>getAsyncExecutor()</code> is not required, but by default Spring will create a thread pool with 10 threads for <code>@Async</code> methods (and we want only one). Now simply run this somewhere in your code.<br /><br /><pre class="brush: java">ApplicationContext context = <br />  new AnnotationConfigApplicationContext(Config.class);<br /></pre>Lesson learnt from this article: don't be afraid of concurrency, it's much simpler than you think, providing that you are using built-in abstractions and understand them. <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>