---
layout: post
title: Thread pool self-induced deadlocks
date: '2018-09-10T08:10:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- deadlock
- reactor
- concurrency
modified_time: '2018-09-10T08:11:11.975+02:00'
thumbnail: https://2.bp.blogspot.com/-f3N_rBImaO4/W5V5f84YV_I/AAAAAAAAiEo/geT_sfOFr9AtULv1KFRdGBRxmwY_4kAjwCLcBGAs/s72-c/upload.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-6291934536059331561
blogger_orig_url: https://www.nurkiewicz.com/2018/09/thread-pool-self-induced-deadlocks.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-f3N_rBImaO4/W5V5f84YV_I/AAAAAAAAiEo/geT_sfOFr9AtULv1KFRdGBRxmwY_4kAjwCLcBGAs/s1600/upload.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" data-original-height="1600" data-original-width="1200" height="200" src="https://2.bp.blogspot.com/-f3N_rBImaO4/W5V5f84YV_I/AAAAAAAAiEo/geT_sfOFr9AtULv1KFRdGBRxmwY_4kAjwCLcBGAs/s200/upload.jpg" width="150" /></a></div><h3 id="summary-reading-time-10-minutes">Summary</h3><ul><li>Deadlocks are caused by many threads locking the same resources</li><li>Deadlocks can also occur if thread pool is used inside a task running in that pool</li><li>Modern libraries like RxJava/Reactor are also susceptible</li></ul>A deadlock is a situation where two or more threads are waiting for resources acquired by each other. For example thread A waits for <code>lock1</code> locked by thread B, whereas thread B waits for <code>lock2</code>, locked by thread A. In worst case scenario, the application freezes for an indefinite amount of time. Let me show you a concrete example. Imagine there is a <code>Lumberjack</code> class that holds references to two accessory locks:<br /><br /><pre class="prettyprint linenums">import com.google.common.collect.ImmutableList;<br />import lombok.RequiredArgsConstructor;<br /><br />import java.util.concurrent.locks.Lock;<br /><br />@RequiredArgsConstructor<br />class Lumberjack {<br /><br />    private final String name;<br />    private final Lock accessoryOne;<br />    private final Lock accessoryTwo;<br /><br />    void cut(Runnable work) {<br />        try {<br />            accessoryOne.lock();<br />            try {<br />                accessoryTwo.lock();<br />                work.run();<br />            } finally {<br />                accessoryTwo.unlock();<br />            }<br />        } finally {<br />            accessoryOne.unlock();<br />        }<br />    }<br />}</pre>Every lumberjack needs two accessories: a <em>helmet</em> and a <em>chainsaw</em>. Before he approaches any <code>work</code>, he must hold exclusive lock to both of these. We create lumberjacks as follows:<br /><br /><pre class="prettyprint linenums">import lombok.RequiredArgsConstructor;<br /><br />import java.util.concurrent.locks.Lock;<br />import java.util.concurrent.locks.ReentrantLock;<br /><br />@RequiredArgsConstructor<br />class Logging {<br /><br />    private final Names names;<br /><br />    private final Lock helmet = new ReentrantLock();<br />    private final Lock chainsaw = new ReentrantLock();<br /><br />    Lumberjack careful() {<br />        return new Lumberjack(names.getRandomName(), helmet, chainsaw);<br />    }<br /><br />    Lumberjack yolo() {<br />        return new Lumberjack(names.getRandomName(), chainsaw, helmet);<br />    }<br /><br />}</pre>As you can see there are two kinds of lumberjacks: those who first take a helmet and then a chainsaw and vice versa. Careful lumberjacks try to obtain a helmet first and then wait for a chainsaw. YOLO-type of lumberjacks first take a chainsaw and then look for a helmet. Let’s generate some lumberjacks and run them concurrently:<br /><br /><pre class="prettyprint linenums">private List&lt;Lumberjack&gt; generate(int count, Supplier&lt;Lumberjack&gt; factory) {<br />    return IntStream<br />            .range(0, count)<br />            .mapToObj(x -&gt; factory.get())<br />            .collect(toList());<br />}</pre><code>generate()</code> is a simple method that creates a collection of lumberjacks of a given type. Then we generate a bunch of careful and yolo lumberjacks:<br /><br /><pre class="prettyprint linenums">private final Logging logging;<br /><br />//...<br /><br />List&lt;Lumberjack&gt; lumberjacks = new CopyOnWriteArrayList&lt;&gt;();<br />lumberjacks.addAll(generate(carefulLumberjacks, logging::careful));<br />lumberjacks.addAll(generate(yoloLumberjacks, logging::yolo));</pre>Finally let’s put these lumberjacks to work:<br /><br /><pre class="prettyprint linenums">IntStream<br />        .range(0, howManyTrees)<br />        .forEach(x -&gt; {<br />            Lumberjack roundRobinJack = lumberjacks.get(x % lumberjacks.size());<br />            pool.submit(() -&gt; {<br />                log.debug("{} cuts down tree, {} left", roundRobinJack, latch.getCount());<br />                roundRobinJack.cut(/* ... */);<br />            });<br />        });</pre>This loop takes lumberjacks one after another in a round-robin fashion and asks them to cut a tree. Essentially we are submitting <code>howManyTrees</code> number of tasks to a thread <code>pool</code> (<code>ExecutorService</code>). In order to figure out when the job was done we use a <code>CountDownLatch</code>:<br /><br /><pre class="prettyprint linenums">CountDownLatch latch = new CountDownLatch(howManyTrees);<br />IntStream<br />        .range(0, howManyTrees)<br />        .forEach(x -&gt; {<br />            pool.submit(() -&gt; {<br />                //...<br />                roundRobinJack.cut(latch::countDown);<br />            });<br />        });<br />if (!latch.await(10, TimeUnit.SECONDS)) {<br />    throw new TimeoutException("Cutting forest for too long");<br />}</pre>The idea is simple - let a bunch of lumberjacks compete over a helmet and a chainsaw across multiple threads. The complete source code follows:<br /><br /><pre class="prettyprint linenums">import lombok.RequiredArgsConstructor;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br /><br />import java.util.ArrayList;<br />import java.util.List;<br />import java.util.concurrent.CountDownLatch;<br />import java.util.concurrent.ExecutorService;<br />import java.util.concurrent.TimeUnit;<br />import java.util.concurrent.TimeoutException;<br />import java.util.function.Supplier;<br />import java.util.stream.Collectors;<br />import java.util.stream.IntStream;<br /><br />@RequiredArgsConstructor<br />class Forest implements AutoCloseable {<br />    private static final Logger log = LoggerFactory.getLogger(Forest.class);<br /><br />    private final ExecutorService pool;<br />    private final Logging logging;<br /><br />    void cutTrees(int howManyTrees, int carefulLumberjacks, int yoloLumberjacks) throws InterruptedException, TimeoutException {<br />        CountDownLatch latch = new CountDownLatch(howManyTrees);<br />        List&lt;Lumberjack&gt; lumberjacks = new ArrayList&lt;&gt;();<br />        lumberjacks.addAll(generate(carefulLumberjacks, logging::careful));<br />        lumberjacks.addAll(generate(yoloLumberjacks, logging::yolo));<br />        IntStream<br />                .range(0, howManyTrees)<br />                .forEach(x -&gt; {<br />                    Lumberjack roundRobinJack = lumberjacks.get(x % lumberjacks.size());<br />                    pool.submit(() -&gt; {<br />                        log.debug("{} cuts down tree, {} left", roundRobinJack, latch.getCount());<br />                        roundRobinJack.cut(latch::countDown);<br />                    });<br />                });<br />        if (!latch.await(10, TimeUnit.SECONDS)) {<br />            throw new TimeoutException("Cutting forest for too long");<br />        }<br />        log.debug("Cut all trees");<br />    }<br /><br />    private List&lt;Lumberjack&gt; generate(int count, Supplier&lt;Lumberjack&gt; factory) {<br />        return IntStream<br />                .range(0, count)<br />                .mapToObj(x -&gt; factory.get())<br />                .collect(Collectors.toList());<br />    }<br /><br />    @Override<br />    public void close() {<br />        pool.shutdownNow();<br />    }<br />}</pre>Now the interesting part. If you only create <code>careful</code> lumberjacks, the application completes almost immediately, e.g.:<br /><br /><pre class="prettyprint linenums">ExecutorService pool = Executors.newFixedThreadPool(10);<br />Logging logging = new Logging(new Names());<br />try (Forest forest = new Forest(pool, logging)) {<br />    forest.cutTrees(10_000, 10, 0);<br />} catch (TimeoutException e) {<br />    log.warn("Working for too long", e);<br />}</pre>However, if you play a bit with the number of lumberjacks, e.g.&nbsp;10 careful and one yolo, the system quite often fails. What happened? Everyone in the careful team tries to pick up a helmet first. If one of the lumberjacks picked up a helmet, everyone else just waits. Then the lucky guy picks up a chainsaw, which must be available. Why? Everyone else is waiting for the helmet&nbsp;before they pick up a chainsaw. So far so good. But what if there is one yolo lumberjack in the team? While everyone competes for a helmet, he sneakily grabs a chainsaw. But there’s a problem. One of the careful lumberjacks gets his safety helmet. However, he can’t pick up a chainsaw, because it’s already taken by someone else. To make matters worse, the current owner of the chainsaw (the yolo guy) will not release his chainsaw until he gets a helmet. There are no timeouts here. Careful guy waits infinitely with his helmet, unable to get a chainsaw. The yolo guy sits idle forever&nbsp;because he can not obtain a helmet. A deadlock.<br /><br />Now, what would happen if all lumberjacks were yolo, i.e.&nbsp;they all tried to pick the chainsaw first? Turns out the easiest way to avoid deadlocks is to obtain and release locks always in the same order. For example, you can sort your resources based on some arbitrary criteria. If one thread obtains lock A followed B, whereas the second thread obtains B first, it’s a recipe for a deadlock.<br /><br /><h1 id="thread-pool-self-induced-deadlocks-1">Thread pool self-induced deadlocks</h1>This was an example of a deadlock, rather simple one. But it turns out a single thread pool can cause a deadlock when used incorrectly. Imagine you have an <code>ExecutorService</code> (just like in the previous example) that you use like so:<br /><br /><pre class="prettyprint linenums">ExecutorService pool = Executors.newFixedThreadPool(10);<br />pool.submit(() -&gt; {<br />    try {<br />        log.info("First");<br />        pool.submit(() -&gt; log.info("Second")).get();<br />        log.info("Third");<br />    } catch (InterruptedException | ExecutionException e) {<br />        log.error("Error", e);<br />    }<br />});</pre>This looks fine, all messages appear on the screen as expected:<br /><br /><pre class="prettyprint linenums">INFO [pool-1-thread-1]: First<br />INFO [pool-1-thread-2]: Second<br />INFO [pool-1-thread-1]: Third</pre>Notice that we block (see <code>get()</code>) waiting for the inner <code>Runnable</code> to complete before we display <code>"Third"</code>. It’s a trap! Waiting for the inner task to complete means it must acquire a thread from a thread <code>pool</code> in order to proceed. However we already acquired one thread, therefore inner will block until it can get the second. Our thread pool is large enough at the moment, so it works fine. Let’s change our code a little bit, shrinking the thread pool to just one thread. Also, we’ll remove <code>get()</code>, which is crucial:<br /><br /><pre class="prettyprint linenums">ExecutorService pool = Executors.newSingleThreadExecutor();<br />pool.submit(() -&gt; {<br />    log.info("First");<br />    pool.submit(() -&gt; log.info("Second"));<br />    log.info("Third");<br />});</pre>Code works fine, but with a twist:<br /><br /><pre class="prettyprint linenums">INFO [pool-1-thread-1]: First<br />INFO [pool-1-thread-1]: Third<br />INFO [pool-1-thread-1]: Second</pre>Two things to notice:<br /><br /><ul><li>everything runs in a single thread (unsurprisingly)</li><li>the <code>"Third"</code> message appears before <code>"Second"</code></li></ul>Change of order is entirely predictable and does not come from some race condition between threads (in fact, we have just one). Watch closely what happens: we submit a new task to a thread pool (the one printing <code>"Second"</code>). However, this time we don’t wait for the completion of that task. Great, because the very single thread in a thread pool is already occupied by the task printing <code>"First"</code> and <code>"Third"</code>. Therefore the outer task continues, printing <code>"Second"</code>. When this task finishes, it releases the single thread back to a thread pool. Inner task can finally begin execution, printing <code>"Second"</code>. Now where’s the deadlock? Try adding blocking <code>get()</code> to inner task:<br /><br /><pre class="prettyprint linenums">ExecutorService pool = Executors.newSingleThreadExecutor();<br />pool.submit(() -&gt; {<br />    try {<br />        log.info("First");<br />        pool.submit(() -&gt; log.info("Second")).get();<br />        log.info("Third");<br />    } catch (InterruptedException | ExecutionException e) {<br />        log.error("Error", e);<br />    }<br />});</pre>Deadlock! Step by step:<br /><br /><ul><li>Task printing <code>"First"</code> is submitted to an idle single-threaded pool</li><li>This task begins execution and prints <code>"First"</code></li><li>We submit an inner task printing <code>"Second"</code> to a thread pool</li><li>The inner task lands in a pending task queue - no threads are available since the only one is currently being occupied</li><li>We block waiting for the result of the inner task. Unfortunately while waiting for the inner task we hold the only available thread</li><li><code>get()</code> will wait forever, unable to acquire thread</li><li>deadlock</li></ul>Does it mean having a single-thread pool is bad? Not really. The same problem could occur with a thread pool of any size. But in that case a deadlock may occur only under high load, which is much worse from a maintenance perspective. You could technically have an unbounded thread pool, but that’s even worse.<br /><br /><h1 id="reactorrxjava">Reactor/RxJava</h1>Notice that this problem can occur with higher-level libraries like Reactor:<br /><br /><pre class="prettyprint linenums">Scheduler pool = Schedulers.fromExecutor(Executors.newFixedThreadPool(10));<br />Mono<br />    .fromRunnable(() -&gt; {<br />        log.info("First");<br />        Mono<br />                .fromRunnable(() -&gt; log.info("Second"))<br />                .subscribeOn(pool)<br />                .block();  //VERY, VERY BAD!<br />        log.info("Third");<br />    })<br />    .subscribeOn(pool);</pre>Once you subscribe, this seems to work, but is terribly non-idiomatic. The basic problem is the same. Outer <code>Runnable</code> acquires one thread from a <code>pool</code> (<code>subscribeOn()</code> in the last line) and at the same time inner <code>Runnable</code> tries to obtain thread as well. Replace underlying thread pool with single-thread pool and this produces a deadlock. At least with RxJava/Reactor the cure is simple - just compose asynchronous operations rather than blocking inside each other:<br /><br /><pre class="prettyprint linenums">Mono<br />    .fromRunnable(() -&gt; {<br />        log.info("First");<br />        log.info("Third");<br />    })<br />    .then(Mono<br />            .fromRunnable(() -&gt; log.info("Second"))<br />            .subscribeOn(pool))<br />    .subscribeOn(pool)</pre><h1 id="prevention">Prevention</h1>There is no 100% way of preventing deadlocks. One technique is to avoid situations that may lead to deadlocks like sharing resources or locking exclusively. If that’s not possible (or deadlocks are not obvious, like with thread pools), consider proper code hygiene. Monitor thread pools and avoid blocking indefinitely. I can hardly imagine a situation when you are willing to wait an indefinite amount of time for a completion. And that’s how <code>get()</code> or <code>block()</code> without timeout are working.<br /><br />
