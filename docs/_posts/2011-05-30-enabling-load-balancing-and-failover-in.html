---
layout: post
title: Enabling load balancing and failover in Apache CXF
date: '2011-05-30T23:47:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- esb
- apache cxf
- web services
- spring
- jmx
modified_time: '2011-11-17T19:20:32.160+01:00'
thumbnail: http://3.bp.blogspot.com/-0ZMAvLi6dOY/TeQPhgWf7RI/AAAAAAAAAbo/RolMGEq_NhU/s72-c/zrzut_ekranu-8.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7180071547096823487
blogger_orig_url: https://www.nurkiewicz.com/2011/05/enabling-load-balancing-and-failover-in.html
---

<div>A while ago we've faced the requirement of load-balancing web services clients based on <a href="http://cxf.apache.org/">Apache CXF</a>. Also the clients should automatically fail-over when some of the servers are down. To make it even worse, the list of servers target addresses was to be obtained from external service and updated at runtime. Eventually we ended up with home-grown load-balancing micro-library (ESB/UDDI/WS-Addressing seemed like an interesting alternatives, but they were an overkill in our situation). If we only knew Apache CXF already supports all these features (almost) out of the box?</div><div><br /></div><div>Don't blame us though, only <a href="http://cxf.apache.org/docs/featureslist.html">reference</a> to this feature points to a very poor <a href="http://cxf.apache.org/clustering">documentation</a> page (if you call 404 “poor”). If it's not in official documentation, I would expect to find it in <a href="http://www.amazon.com/gp/product/1847195407/ref=as_li_ss_tl?ie=UTF8&amp;tag=javaandneighb-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399349&amp;creativeASIN=1847195407">Apache CXF Web Service Development</a> book – unfortunately, bad luck there as well. But hey, isn't exploring such features yourself even greater fun? This is the client configuration we are starting with:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:jaxws="http://cxf.apache.org/jaxws"<br />       xmlns:clustering="http://cxf.apache.org/clustering"<br />       xmlns:util="http://www.springframework.org/schema/util"&gt;<br /><br />    &lt;jaxws:client id="testServiceClient"<br />                  serviceClass="com.blogspot.nurkiewicz.cxfcluster.SimpleService"<br />                  address="http://serverA/simple"&gt;<br />    &lt;/jaxws:client&gt;<br /><br />&lt;/beans&gt;<br /></pre></div><div><br /></div><div><br /><a name='more'></a>Endpoint interface is not important here, enough to know the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">testServiceClient</span> is being injected to some other services and load balancing and failover features shouldn't affect existing code. Note the service address is fixed and hard-coded (of course it can be externalized and read upon startup).</div><div><br /></div><div>Surprisingly enabling failover alone is pretty simple, straightforward and self-explanatory (despite being XML):</div><div><br /></div><div><pre class="brush: xml"><br />&lt;jaxws:client id="testServiceClient"<br />              serviceClass="com.blogspot.nurkiewicz.cxfcluster.SimpleService"<br />              address="http://serverA/simple"&gt;<br /><br />    &lt;jaxws:features&gt;<br />        &lt;clustering:failover&gt;<br />            &lt;clustering:strategy&gt;<br />                &lt;bean class="org.apache.cxf.clustering.RandomStrategy"&gt;<br />                    &lt;property name="alternateAddresses"&gt;<br />                        &lt;util:list&gt;<br />                            &lt;value&gt;http://serverB/simple&lt;/value&gt;<br />                            &lt;value&gt;http://serverC/simple&lt;/value&gt;<br />                            &lt;value&gt;http://serverD/simple&lt;/value&gt;<br />                        &lt;/util:list&gt;<br />                    &lt;/property&gt;<br />                &lt;/bean&gt;<br />            &lt;/clustering:strategy&gt;<br />        &lt;/clustering:failover&gt;<br />    &lt;/jaxws:features&gt;<br /><br />&lt;/jaxws:client&gt;<br /></pre></div><div><br /></div><div>The <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">serverA</span> address is used as a primary endpoint, but when it fails all failover endpoints (<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">serverB</span>, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">serverC</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">serverD</span>) are examined in random order. To play a bit with this configuration I advice you to turn on Apache CXF <a href="http://cxf.apache.org/docs/configuration.html">logging</a> of requests and responses:</div><div><br /></div><div><pre class="brush: xml"><br /> &lt;cxf:bus&gt;<br />    &lt;cxf:features&gt;<br />        &lt;cxf:logging/&gt;<br />    &lt;/cxf:features&gt;<br />&lt;/cxf:bus&gt; <br /></pre></div><div><br /></div><div>Once again (!) official documentation does not mention about very convenient configuration parameter <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">prettyLogging</span> that can be applied to logging feature in order to make XML requests and responses being properly formatted (new lines and indentation) before being logged. I wouldn't recommend it for production setup, but during development and testing having SOAP messages formatted is invaluable:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;bean id="abstractLoggingInterceptor" abstract="true"&gt;<br />    &lt;property name="prettyLogging" value="true"/&gt;<br />&lt;/bean&gt;<br />&lt;bean id="loggingInInterceptor" class="org.apache.cxf.interceptor.LoggingInInterceptor" parent="abstractLoggingInterceptor"/&gt;<br />&lt;bean id="loggingOutInterceptor" class="org.apache.cxf.interceptor.LoggingOutInterceptor" parent="abstractLoggingInterceptor"/&gt;<br /><br />&lt;cxf:bus&gt;<br />    &lt;cxf:inInterceptors&gt;<br />        &lt;ref bean="loggingInInterceptor"/&gt;<br />    &lt;/cxf:inInterceptors&gt;<br />    &lt;cxf:outInterceptors&gt;<br />        &lt;ref bean="loggingOutInterceptor"/&gt;<br />    &lt;/cxf:outInterceptors&gt;<br />    &lt;cxf:outFaultInterceptors&gt;<br />        &lt;ref bean="loggingOutInterceptor"/&gt;<br />    &lt;/cxf:outFaultInterceptors&gt;<br />    &lt;cxf:inFaultInterceptors&gt;<br />        &lt;ref bean="loggingInInterceptor"/&gt;<br />    &lt;/cxf:inFaultInterceptors&gt;<br />&lt;/cxf:bus&gt; <br /></pre></div><div><br /></div><div>So our service nicely fails over to backup endpoints if primary one is not available. But we have four equivalent servers and we want our client to treat them equally hitting each one with similar probability (round robin? random?). Here is when load-balancing is entering the stage:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;jaxws:client id="testServiceClient" serviceClass="com.blogspot.nurkiewicz.cxfcluster.SimpleService"&gt;<br /><br />    &lt;jaxws:features&gt;<br />        &lt;clustering:loadDistributor&gt;<br />            &lt;clustering:strategy&gt;<br />                &lt;bean class="org.apache.cxf.clustering.SequentialStrategy"&gt;<br />                    &lt;property name="alternateAddresses"&gt;<br />                        &lt;util:list&gt;<br />                            &lt;value&gt;http://serverA/simple&lt;/value&gt;<br />                            &lt;value&gt;http://serverB/simple&lt;/value&gt;<br />                            &lt;value&gt;http://serverC/simple&lt;/value&gt;<br />                            &lt;value&gt;http://serverD/simple&lt;/value&gt;<br />                        &lt;/util:list&gt;<br />                    &lt;/property&gt;<br />                &lt;/bean&gt;<br />            &lt;/clustering:strategy&gt;<br />        &lt;/clustering:loadDistributor&gt;<br />    &lt;/jaxws:features&gt;<br /><br />&lt;/jaxws:client&gt;<br /></pre></div><div><br /></div><div>Please note that the client itself does no longer define the address attribute. This suggests that <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">alternateAddresses</span> list is used exclusively throughout all the invocations and no primary address exists – which is actually the case. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SequentialStrategy</span> will use one endpoint after another providing nice round robin implementation (<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">RandomStrategy</span> is available as well). Also in this configuration you will get failover for free – if any endpoint fails, all endpoints starting from the first one will be examined (obviously except the one that has just failed).</div><div><br /></div><div>Great! Now are CXF clients are much more rigid and fault-tolerant. But in our journey for higher availability and minimizing downtimes having alternate nodes being loaded only at application startup (in other words – adding a new server requires all clients restart) is too limiting. Fortunately we can make our load-balancing a bit more dynamic in two simple steps.</div><div><br /></div><div><pre class="brush: xml"><br />&lt;jaxws:client id="testServiceClient" serviceClass="com.blogspot.nurkiewicz.cxfcluster.SimpleService"&gt;<br /><br />    &lt;jaxws:features&gt;<br />        &lt;clustering:loadDistributor&gt;<br />            &lt;clustering:strategy&gt;<br />                &lt;bean class="org.apache.cxf.clustering.SequentialStrategy"&gt;<br />                    &lt;property name="alternateAddresses" ref="alternateAddresses"/&gt;<br />                &lt;/bean&gt;<br />            &lt;/clustering:strategy&gt;<br />        &lt;/clustering:loadDistributor&gt;<br />    &lt;/jaxws:features&gt;<br /><br />&lt;/jaxws:client&gt;<br /><br />&lt;util:list id="alternateAddresses" list-class="java.util.concurrent.CopyOnWriteArrayList"&gt;<br />    &lt;value&gt;http://serverA/simple&lt;/value&gt;<br />    &lt;value&gt;http://serverB/simple&lt;/value&gt;<br />    &lt;value&gt;http://serverC/simple&lt;/value&gt;<br />    &lt;value&gt;http://serverD/simple&lt;/value&gt;<br />&lt;/util:list&gt;<br /><br /></pre></div><div><br /></div><div>Nothing fancy, extracting nested anonymous bean. But having access to this list (please note I used <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">java.util.concurrent.CopyOnWriteArrayList</span>) enables us to inject it to any other service, possibly changing its state. How do I know this will work? Well, I spent few afternoons debugging Apache CXF to finally discover load-balancing algorithm: at first invocation CXF asks strategy for a list of possible nodes. Then it passes this list back to the strategy asking to pick one (small <i>wtf</i> here...) The strategy decides which address to use and removes picked address from the list (another small <i>one</i> here...) When CXF discovers the list is empty, story repeats itself. So if we replace the list of alternate addresses at runtime, after one round new list will be returned to the core CXF infrastructure.</div><div><br /></div><div>Because I'm a huge JMX advocate, here is how we are going to modify the addresses list (you can use whatever mechanism you like):</div><div><br /></div><div><pre class="brush: java"><br />@Service<br />@ManagedResource<br />public class AlternateAddressesManager {<br /><br />    @Resource<br />    private List&lt;String&gt; alternateAddresses;<br /><br />    @ManagedOperation<br />    public void addAlternateAddress(String address) {<br />        alternateAddresses.add(address);<br />    }<br /><br />    @ManagedOperation<br />    public boolean removeAlternateAddress(String address) {<br />        return alternateAddresses.remove(address);<br />    }<br /><br />    @ManagedAttribute<br />    public List&lt;String&gt; getAlternateAddresses() {<br />        return Collections.unmodifiableList(alternateAddresses);<br />    }<br /><br />}<br /></pre></div><div><br /></div><div>Yep, it's the very same <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">alternateAddresses</span> list used by <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SequentialStrategy</span>, so by simply modifying it we are altering CXF addressing behaviour. Arguably we could extend <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">CopyOnWriteArrayList</span> adding few extra JMX-enabled methods (or, exploting Springs' flexibility, expose <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">List</span> methods directly via JMX!), but this would decrease maintainability and I would consider this as poor design.</div><div><br /></div><div>Finally, we can launch <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">jconsole</span> or JVisualVM as on the screenshots below and enjoy our load-balancing infrastructure:</div><div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-0ZMAvLi6dOY/TeQPhgWf7RI/AAAAAAAAAbo/RolMGEq_NhU/s1600/zrzut_ekranu-8.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="249" src="http://3.bp.blogspot.com/-0ZMAvLi6dOY/TeQPhgWf7RI/AAAAAAAAAbo/RolMGEq_NhU/s320/zrzut_ekranu-8.png" width="320" /></a></div><br /></div><div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-M6arpyUFIO4/TeQPi32_k3I/AAAAAAAAAbs/bx3QmaXkVmo/s1600/zrzut_ekranu-9.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="164" src="http://2.bp.blogspot.com/-M6arpyUFIO4/TeQPi32_k3I/AAAAAAAAAbs/bx3QmaXkVmo/s320/zrzut_ekranu-9.png" width="320" /></a></div></div><div><br /></div><div>Happy? Not really. While studying CXF source code I came across this dreadful JavaDoc comment on <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">LoadDistributorFeature</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">FailoverTargetSelector</span> classes which take significant part in load-balancing process:</div><div><br /></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">/**</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;* [...]</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;* Note that this feature changes the conduit on the fly and thus <b>makes</b></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;* <b>the Client not thread safe.</b></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;*/</div><div><br /></div><div>Focus on the text in bold (OK, honestly, I don't understand the rest). If you've worked with Spring for some time you know that <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">testServiceClient</span> bean is a shared singleton used by multiple threads concurrently (no, making it prototype scope won't help; why?), in contrary to default EJB stateless session beans, which are pooled. Fortunately Spring has a built-in solution for that as well. But before I finally came up with a right solution, several obstacles arose.</div><div><br /></div><div>First, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">jaxws:client</span> tag from CXF namespace does not allow to define bean scope, defaulting to singleton, while we want to pool our clients. So I had to fall back to good old bean definition with <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">org.apache.cxf.jaxws.JaxWsProxyFactoryBean</span>. No problem, slightly more verbose, although if you can't/don't want to use custom Spring namespaces, you might have used it from the very beginning. Now the best part: I can simply wrap any bean with prototype scope in a special proxy and Spring will <i>automagically</i> create an object pool (based on <a href="http://commons.apache.org/pool/">commons-pool</a> library) and create as many bean instances as necessary to keep each bean used by only one thread. Here is the configuration:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;bean id="testServiceClientFactoryBean" class="org.apache.cxf.jaxws.JaxWsProxyFactoryBean"&gt;<br />    &lt;property name="serviceClass" value="com.blogspot.nurkiewicz.cxfcluster.SimpleService"/&gt;<br />    &lt;property name="features"&gt;<br />        &lt;util:list&gt;<br />            &lt;bean class="org.apache.cxf.clustering.LoadDistributorFeature"&gt;<br />                &lt;property name="strategy"&gt;<br />                    &lt;bean class="org.apache.cxf.clustering.SequentialStrategy"&gt;<br />                        &lt;property name="alternateAddresses" ref="alternateAddresses"/&gt;<br />                    &lt;/bean&gt;<br />                &lt;/property&gt;<br />            &lt;/bean&gt;<br />        &lt;/util:list&gt;<br />    &lt;/property&gt;<br />&lt;/bean&gt;<br /><br />&lt;bean id="testServiceClientTarget" factory-bean="testServiceClientFactoryBean" factory-method="create" scope="prototype" lazy-init="true"/&gt;<br /><br />&lt;bean id="testServiceClient" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;<br />    &lt;property name="targetSource"&gt;<br />        &lt;bean class="org.springframework.aop.target.CommonsPoolTargetSource"&gt;<br />            &lt;property name="targetClass" value="com.blogspot.nurkiewicz.cxfcluster.SimpleService"/&gt;<br />            &lt;property name="targetBeanName" value="testServiceClientTarget"/&gt;<br />            &lt;property name="maxSize" value="10"/&gt;<br />            &lt;property name="maxWait" value="5000"/&gt;<br />        &lt;/bean&gt;<br />    &lt;/property&gt;<br />&lt;/bean&gt;<br /></pre></div><div><br /></div><div>Have you noticed <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">maxSize</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">maxWait</span> pool attributes? They are <b>insanely cool</b>! You can tell Spring not to create more than 10 clients in the pool and if the pool is empty (all the beans are currently in use), we should wait no more than 5000ms (and what happens afterwards is configurable!) This is actually a very simple yet powerful throttling mechanism, much simpler than JMS or explicit thread pools, we get absolutely for free! E.g. don't want to serve more than 20 concurrent web service clients? Make your server endpoint access service bean being pooled with size limited to 20. Client above this limit will be rejected as no service bean is available.</div><div><br /></div><div>Of course in adults world nothing works as expected. I quickly discovered that <i>JaxWsProxyFactoryBean.create is not thread-safe</i><span style="font-style: normal;"> and reported <a href="https://issues.apache.org/jira/browse/CXF-3558">CXF-3558</a>. As a workaround I had to synchronize the client factory used by </span><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-style: normal;">CommonsPoolTargetSource</span><span style="font-style: normal;"> simply by subclassing it:</span></div><div><br /></div><div><span style="font-style: normal;"><pre class="brush: java"><br />import org.apache.commons.pool.ObjectPool;<br />import org.apache.commons.pool.PoolUtils;<br />import org.springframework.aop.target.CommonsPoolTargetSource;<br /><br />public class SynchCommonsPoolTargetSource extends CommonsPoolTargetSource {<br /><br />    @Override<br />    protected ObjectPool createObjectPool() {<br />        return PoolUtils.synchronizedPool(super.createObjectPool());<br />    }<br /><br />}<br /><br /></pre></span></div><div><br /></div><div><span style="font-style: normal;">Synchronizing the factory seems like a common need so I created <a href="https://jira.springsource.org/browse/SPR-8382">SPR-8382</a> – maybe it will find its way to official release. BTW while working on this article I also reported <a href="http://youtrack.jetbrains.net/issue/IDEA-70365">IDEA-70365</a> – </span><i>Spurious "Could not autowire" error reported for beans of List type</i><span style="font-style: normal;">.</span></div><div><br /></div><div><span style="font-style: normal;">Finally! Our load-balancing and failover works like a charm. Next step would be to temporarily discard nodes that are down for couple of seconds and increase this time if the endpoint is still down afterwards. But Apache CXF has so terrible API in this area that I had to leave this topic for a while. Maybe YOU can help?</span></div>