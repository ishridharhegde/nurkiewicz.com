---
layout: post
title: 'Spring Boot 2: Migrating from Dropwizard metrics to Micrometer'
date: '2018-01-22T19:30:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- spring boot
- spring
- Micrometer
modified_time: '2018-01-25T09:17:21.728+01:00'
thumbnail: https://1.bp.blogspot.com/-CmcQ3L_KXxM/WmJveYYp_JI/AAAAAAAAVmQ/smYLQbx6K0Eo00XlJ-qRr3T4f4EvyPeJgCLcBGAs/s72-c/Screen%2BShot%2B2018-01-16%2Bat%2B23.26.01.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4472987463344789373
blogger_orig_url: https://www.nurkiewicz.com/2018/01/spring-boot-2-migrating-from-dropwizard.html
---

Spring Boot 2 is around the corner. One of the minor changes is the replacement of <a href="http://metrics.dropwizard.io/">Dropwizard Metrics</a> with <a href="http://micrometer.io/">Micrometer</a>. The migration path is fairly straightforward and Micrometer actually provides cleaner API. With Metrics, you have to inject <code>MetricRegistry</code> wherever you need some metrics (see: <a href="http://www.nurkiewicz.com/2018/01/monitoring-and-measuring-reactive.html">Monitoring and measuring reactive application with Dropwizard Metrics</a>). This has many drawbacks:<br /><br /><ul><li>we are mixing business and technical dependencies in our components</li><li>therefore I am sometimes reluctant to add new metrics because it requires me to inject <code>MetricRegistry</code></li><li>also <code>MetricRegistry</code> must be stubbed in unit tests</li></ul>Micrometer's tagline is:<br /><br /><em>Think SLF4J, but for metrics</em><br /><br />It's actually quite accurate. Whenever I need a <code>Logger</code> I don't inject <code>LoggerFactory</code>, instead I simply use static methods available everywhere. The same goes for Micrometer, I simply use static factory methods on globally available <code>Metrics</code> class:<br /><br /><pre class="prettyprint linenums">private final Timer indexTimer = Metrics.timer("es.timer");<br />private final LongAdder concurrent = Metrics.gauge("es.concurrent", new LongAdder());<br />private final Counter successes = Metrics.counter("es.index", "result", "success");<br />private final Counter failures = Metrics.counter("es.index", "result", "failure");</pre>That's it! You can put metrics anywhere you like without polluting your constructor with <code>MetricRegistry</code>. The API is very similar, e.g.:<br /><br /><pre class="prettyprint linenums">concurrent.increment()</pre>One major difference is gauges vs. counters. In Dropwizard Metrics counters can go up and down whereas in Micrometer counter must increase monotonically. I <a href="https://github.com/micrometer-metrics/micrometer/pull/318">thought</a> it's a bug... Counter is used in simple scenarios like counting how many requests succeeded. So how can we measure things like the number of concurrent requests or queue length? With gauges, but it's slightly convoluted.<br /><br />Did you notice how <code>Metrics.gauge()</code> takes a <code>new LongAdder()</code> as an argument? And returns it? This way we create a gauge that track (by periodically polling for value) any instance of <code>Number</code> class (e.g. <code>AtomicLong</code> or <code>LongAdder</code>). We can modify the returned <code>LongAdder</code> and its current value will be reflected by the gauge. Neat! Moreover, there are helper methods like <code>gaugeCollectionSize()</code> and <code>gaugeMapSize()</code> that take any <code>Collection</code> or <code>Map</code> respectively - and are quite self-explanatory.<br /><br /><h2 id="built-in-jvm-metrics">Built-in JVM metrics</h2>Micrometer also has a bunch of built-in system and JVM metrics, for example:<br /><br /><ul><li><code>LogbackMetrics</code> - number of log messages per each log level. You can watch e.g. error rate</li><li><code>ProcessorMetrics</code>- average system load</li><li><code>JvmMemoryMetrics</code> - memory usage, split by area</li><li><code>JvmThreadMetrics</code> - number of thread (live, daemon, peak...)</li><li><code>JvmGcMetrics</code> - GC promotion rate, etc.</li></ul>Most of these are registered by default by Spring Boot. The last two of them <a href="https://github.com/spring-projects/spring-boot/pull/11425">will be available</a> as well. By having all these metrics we can actually enhance our dashboard quite a bit:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-CmcQ3L_KXxM/WmJveYYp_JI/AAAAAAAAVmQ/smYLQbx6K0Eo00XlJ-qRr3T4f4EvyPeJgCLcBGAs/s1600/Screen%2BShot%2B2018-01-16%2Bat%2B23.26.01.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="914" data-original-width="1600" height="182" src="https://1.bp.blogspot.com/-CmcQ3L_KXxM/WmJveYYp_JI/AAAAAAAAVmQ/smYLQbx6K0Eo00XlJ-qRr3T4f4EvyPeJgCLcBGAs/s320/Screen%2BShot%2B2018-01-16%2Bat%2B23.26.01.png" width="320" /></a></div><br /><br />The dashboard definition for Grafana is available <a href="https://github.com/nurkiewicz/elastic-flux/blob/micrometer/src/main/docs/grafana-elastic-flux-micrometer.json">on GitHub</a>. Notice how this application uses about 100 MiB of RAM while sustaining almost two thousand concurrent connections (!) Also less than 45 live threads compared to thousands of concurrent connections is impressive.<br /><br />It's worth mentioning that the setup of Micrometer in Spring Boot is really simple. First, add the appropriate dependency:<br /><br /><pre class="prettyprint linenums">compile 'io.micrometer:micrometer-registry-graphite:1.0.0-rc.5'</pre>and a bunch of configuration parameters. Zero code:<br /><br /><pre class="prettyprint linenums"><br />spring.metrics.export.graphite:<br />  host: graphite<br />  port: 2003<br />  protocol: Plaintext<br />  step: PT1S<br /></pre><br />In the last part of this short series, we will wrap everything together in a Spring Web Flux application.<br /><br /> <p>This is part of a longer series:</p> <ul> <li><a href="http://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch-from.html">Spring, Reactor and ElasticSearch: from callbacks to reactive streams</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch.html">Spring, Reactor and ElasticSearch: bechmarking with fake test data</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/monitoring-and-measuring-reactive.html">Monitoring and measuring reactive application with Dropwizard Metrics</a></li> <li>Spring Boot 2: Migrating from Dropwizard metrics to Micrometer</li> <li><a href="http://www.nurkiewicz.com/2018/01/spring-boot-2-fluxes-from-elasticsearch.html">Spring Boot 2: Fluxes, from Elasticsearch to controller</a></li></ul> 