---
layout: post
title: 'Spring: injecting lists, maps, optionals and getBeansOfType() pitfalls'
date: '2015-04-21T00:07:00.001+02:00'
author: Tomasz Nurkiewicz
tags:
- spring
modified_time: '2015-04-21T00:16:42.146+02:00'
thumbnail: http://3.bp.blogspot.com/-fm1YnKfavog/VTV4Ymdm6gI/AAAAAAAABRQ/JZwt36918_s/s72-c/diagram.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2217182590205295943
blogger_orig_url: https://www.nurkiewicz.com/2015/04/spring-injecting-lists-maps-optionals.html
---

If you use Spring framework for more than a week you are probably aware of this feature. Suppose you have more than one bean implementing a given interface. Trying to autowire just one bean of such interface is doomed to fail because Spring has no idea which particular instance you need. You can work around that by using <code>@Primary</code> annotation to designate exactly one "<em>most important</em>" implementation that will have priority over others. But there are many legitimate use cases where you want to inject <strong>all</strong> beans implementing said interface. For example you have  multiple validators that all need to be executed prior to business logic or several algorithm implementations that you want to exercise at the same time. Auto-discovering all implementations at runtime is a fantastic illustration of <a href="http://en.wikipedia.org/wiki/Open/closed_principle"><em>Open/closed principle</em></a>: you can easily add new behavior to business logic (validators, algorithms, strategies - <em>open</em> for extension) without touching the business logic itself (<em>closed</em> for modification). <br /><br />Just in case I will start with a quick introduction, feel free to jump straight to subsequent sections. So let's take a concrete example. Imagine you have a <code>StringCallable</code> interface and multiple implementations:<br /><br /><pre class="brush: java">interface StringCallable extends Callable&lt;String&gt; { }<br /><br />@Component<br />class Third implements StringCallable {<br />    @Override<br />    public String call() {<br />        return "3";<br />    }<br /><br />}<br /><br />@Component<br />class Forth implements StringCallable {<br />    @Override<br />    public String call() {<br />        return "4";<br />    }<br /><br />}<br /><br />@Component<br />class Fifth implements StringCallable {<br />    @Override<br />    public String call() throws Exception {<br />        return "5";<br />    }<br />}<br /></pre>Now we can inject <code>List&lt;StringCallable&gt;</code>, <code>Set&lt;StringCallable&gt;</code> or even <code>Map&lt;String, StringCallable&gt;</code> (<code>String</code> represents bean name) to any other class. To simplify I'm injecting to a test case:<br /><br /><pre class="brush: java">@SpringBootApplication public class Bootstrap { }<br /><br />@ContextConfiguration(classes = Bootstrap)<br />class BootstrapTest extends Specification {<br /><br />    @Autowired<br />    List&lt;StringCallable&gt; list;<br /><br />    @Autowired<br />    Set&lt;StringCallable&gt; set;<br /><br />    @Autowired<br />    Map&lt;String, StringCallable&gt; map;<br /><br />    def 'injecting all instances of StringCallable'() {<br />        expect:<br />            list.size() == 3<br />            set.size() == 3<br />            map.keySet() == ['third', 'forth', 'fifth'].toSet()<br />    }<br /><br />    def 'enforcing order of injected beans in List'() {<br />        when:<br />            def result = list.collect { it.call() }<br />        then:<br />            result == ['3', '4', '5']<br />    }<br /><br />    def 'enforcing order of injected beans in Set'() {<br />        when:<br />            def result = set.collect { it.call() }<br />        then:<br />            result == ['3', '4', '5']<br />    }<br /><br />    def 'enforcing order of injected beans in Map'() {<br />        when:<br />            def result = map.values().collect { it.call() }<br />        then:<br />            result == ['3', '4', '5']<br />    }<br /><br />}<br /></pre>So far so good, but only first test passes, can you guess why?<br /><br /><pre class="brush: plain">Condition not satisfied:<br /><br />result == ['3', '4', '5']<br />|      |<br />|      false<br />[3, 5, 4]<br /></pre>After all, why did we make an assumption that beans will be injected in the same order as they were... declared? Alphabetically? Luckily one can enforce the order with <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a> interface:<br /><br /><pre class="brush: java">interface StringCallable extends Callable&lt;String&gt;, Ordered {<br />}<br /><br />@Component<br />class Third implements StringCallable {<br />    //...<br /><br />    @Override public int getOrder() {<br />        return Ordered.HIGHEST_PRECEDENCE;<br />    }<br />}<br /><br />@Component<br />class Forth implements StringCallable {<br />    //...<br /><br />    @Override public int getOrder() {<br />        return Ordered.HIGHEST_PRECEDENCE + 1;<br />    }<br />}<br /><br />@Component<br />class Fifth implements StringCallable {<br />    //...<br /><br />    @Override public int getOrder() {<br />        return Ordered.HIGHEST_PRECEDENCE + 2;<br />    }<br />}<br /></pre>Interestingly, even though Spring internally injects <code>LinkedHashMap</code> and <code>LinkedHashSet</code>, only <code>List</code> is properly ordered. I guess it's not documented and least surprising. To end this introduction, in Java 8 you can also inject <code>Optional&lt;MyService&gt;</code> which works as expected: injects a dependency only if it's available. Optional dependencies can appear e.g. when using profiles extensively and some beans are not bootstrapped in some profiles.<br /><br /><h1><a href="http://en.wikipedia.org/wiki/Composite_pattern">Composite pattern</a></h1>Dealing with lists is quite cumbersome. Most of the time you want to iterate over them so in order to avoid duplication it's useful to encapsulate such list in a dedicated wrapper:<br /><br /><pre class="brush: java">@Component<br />public class Caller {<br /><br />    private final List&lt;StringCallable&gt; callables;<br /><br />    @Autowired<br />    public Caller(List&lt;StringCallable&gt; callables) {<br />        this.callables = callables;<br />    }<br /><br />    public String doWork() {<br />        return callables.stream()<br />                .map(StringCallable::call)<br />                .collect(joining("|"));<br />    }<br /><br />}<br /></pre>Our wrapper simply calls all underlying callables one after another and joins their results:<br /><br /><pre class="brush: java">@ContextConfiguration(classes = Bootstrap)<br />class CallerTest extends Specification {<br /><br />    @Autowired<br />    Caller caller<br /><br />    def 'Caller should invoke all StringCallbles'() {<br />        when:<br />            def result = caller.doWork()<br />        then:<br />            result == '3|4|5'<br />    }<br /><br />}<br /></pre>It's somewhat controversial, but often this wrapper implements the same interface as well, effectively implementing <em>composite</em> classic design pattern:<br /><br /><pre class="brush: java">@Component<br />@Primary<br />public class Caller implements StringCallable {<br /><br />    private final List&lt;StringCallable&gt; callables;<br /><br />    @Autowired<br />    public Caller(List&lt;StringCallable&gt; callables) {<br />        this.callables = callables;<br />    }<br /><br />    @Override<br />    public String call() {<br />        return callables.stream()<br />                .map(StringCallable::call)<br />                .collect(joining("|"));<br />    }<br /><br />}<br /></pre>Thanks to <code>@Primary</code> we can simply autowire <code>StringCallable</code> everywhere as if there was just one bean while in fact there are multiple and we inject composite. This is useful when refactoring old application as it preserves backward compatibility.<br /><br />Why am I even starting with all these basics? If you look very closely, code snippet above introduces chicken and egg problem: an instance of <code>StringCallable</code> requires all instances of <code>StringCallable</code>, so technically speaking <code>callables</code> list should include <code>Caller</code> as well. But <code>Caller</code> is currently being created, so it's impossible. This makes a lot of sense and luckily Spring recognizes this special case. But in more advanced scenarios this can bite you. Further down the road a new developer introduced <em>this</em>:<br /><br /><pre class="brush: java">@Component<br />public class EnterpriseyManagerFactoryProxyHelperDispatcher {<br /><br />    private final Caller caller;<br /><br />    @Autowired<br />    public EnterpriseyManagerFactoryProxyHelperDispatcher(Caller caller) {<br />        this.caller = caller;<br />    }<br />}<br /></pre>Nothing wrong so far, except the class name. But what happens if one of the <code>StringCallables</code> has a dependency on it?<br /><br /><pre class="brush: java">@Component<br />class Fifth implements StringCallable {<br /><br />    private final EnterpriseyManagerFactoryProxyHelperDispatcher dispatcher;<br /><br />    @Autowired<br />    public Fifth(EnterpriseyManagerFactoryProxyHelperDispatcher dispatcher) {<br />        this.dispatcher = dispatcher;<br />    }<br /><br />}<br /></pre>We now created a circular dependency, and because we inject via constructors (as it was always meant to be), Spring slaps us in the face on startup:<br /><br /><pre class="brush: plain">UnsatisfiedDependencyException:<br />    Error creating bean with name 'caller' defined in file ...<br />UnsatisfiedDependencyException: <br />    Error creating bean with name 'fifth' defined in file ...<br />UnsatisfiedDependencyException: <br />    Error creating bean with name 'enterpriseyManagerFactoryProxyHelperDispatcher' defined in file ...<br />BeanCurrentlyInCreationException: <br />    Error creating bean with name 'caller': Requested bean is currently in creation: <br />        Is there an unresolvable circular reference?<br /></pre>Stay with me, I'm building the climax here. This is clearly a bug, that can unfortunately be fixed with field injection (or setter for that matter):<br /><br /><pre class="brush: java">@Component<br />public class Caller {<br /><br />    @Autowired<br />    private List&lt;StringCallable&gt; callables;<br /><br />    public String doWork() {<br />        return callables.stream()<br />                .map(StringCallable::call)<br />                .collect(joining("|"));<br />    }<br /><br />}<br /></pre>By decoupling bean creation from injection (impossible with constructor injection) we can now create a circular dependency graph, where <code>Caller</code> holds an instance of <code>Fifth</code> class which references <code>Enterprisey...</code>, which in turns references back to the same <code>Caller</code> instance. Cycles in dependency graph are a design smell, leading to unmaintainable graph of spaghetti relationships. Please avoid them and if constructor injection can entirely prevent them, that's even better.<br /><br /><h1>Meeting <code>getBeansOfType()</code></h1>Interestingly there is another solution that goes straight to Spring guts: <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/ListableBeanFactory.html#getBeansOfType-java.lang.Class-"><code>ListableBeanFactory.getBeansOfType()</code></a>:<br /><br /><pre class="brush: java">@Component<br />public class Caller {<br /><br />    private final List&lt;StringCallable&gt; callables;<br /><br />    @Autowired<br />    public Caller(ListableBeanFactory beanFactory) {<br />        callables = new ArrayList&lt;&gt;(beanFactory.getBeansOfType(StringCallable.class).values());<br />    }<br /><br />    public String doWork() {<br />        return callables.stream()<br />                .map(StringCallable::call)<br />                .collect(joining("|"));<br />    }<br /><br />}<br /></pre><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-fm1YnKfavog/VTV4Ymdm6gI/AAAAAAAABRQ/JZwt36918_s/s1600/diagram.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-fm1YnKfavog/VTV4Ymdm6gI/AAAAAAAABRQ/JZwt36918_s/s1600/diagram.png" height="177" width="200" /></a></div>Problem solved? Quite the opposite! <code>getBeansOfType()</code> will silently skip (well, there is <code>TRACE</code> and <code>DEBUG</code> log...) beans under creation and only returns those already existing. Therefor <code>Caller</code> was just created and container started successfully, while it no longer references <code>Fifth</code> bean. You might say I asked for it because we have a circular dependency so weird things happens. But it's an inherent feature of <code>getBeansOfType()</code>. In order to understand why<strong> using <code>getBeansOfType()</code> during container startup is a bad idea</strong>, have a look at the following scenario (unimportant code omitted):<br /><br /><pre class="brush: java">@Component<br />class Alpha {<br /><br />    static { log.info("Class loaded"); }<br /><br />    @Autowired<br />    public Alpha(ListableBeanFactory beanFactory) {<br />        log.info("Constructor");<br />        log.info("Constructor (beta?):  {}", beanFactory.getBeansOfType(Beta.class).keySet());<br />        log.info("Constructor (gamma?): {}", beanFactory.getBeansOfType(Gamma.class).keySet());<br />    }<br /><br />    @PostConstruct<br />    public void init() {<br />        log.info("@PostConstruct (beta?):  {}", beanFactory.getBeansOfType(Beta.class).keySet());<br />        log.info("@PostConstruct (gamma?): {}", beanFactory.getBeansOfType(Gamma.class).keySet());<br />    }<br /><br />}<br /><br />@Component<br />class Beta {<br /><br />    static { log.info("Class loaded"); }<br /><br />    @Autowired<br />    public Beta(ListableBeanFactory beanFactory) {<br />        log.info("Constructor");<br />        log.info("Constructor (alpha?): {}", beanFactory.getBeansOfType(Alpha.class).keySet());<br />        log.info("Constructor (gamma?): {}", beanFactory.getBeansOfType(Gamma.class).keySet());<br />    }<br /><br />    @PostConstruct<br />    public void init() {<br />        log.info("@PostConstruct (alpha?): {}", beanFactory.getBeansOfType(Alpha.class).keySet());<br />        log.info("@PostConstruct (gamma?): {}", beanFactory.getBeansOfType(Gamma.class).keySet());<br />    }<br /><br />}<br /><br />@Component<br />class Gamma {<br /><br />    static { log.info("Class loaded"); }<br /><br />    public Gamma() {<br />        log.info("Constructor");<br />    }<br /><br />    @PostConstruct<br />    public void init() {<br />        log.info("@PostConstruct");<br />    }<br />}<br /></pre>The log output reveals how Spring internally loads and resolves classes:<br /><br /><pre class="brush: plain">Alpha: | Class loaded<br />Alpha: | Constructor<br />Beta:  | Class loaded<br />Beta:  | Constructor<br />Beta:  | Constructor (alpha?): []<br />Gamma: | Class loaded<br />Gamma: | Constructor<br />Gamma: | @PostConstruct<br />Beta:  | Constructor (gamma?): [gamma]<br />Beta:  | @PostConstruct (alpha?): []<br />Beta:  | @PostConstruct (gamma?): [gamma]<br />Alpha: | Constructor (beta?):  [beta]<br />Alpha: | Constructor (gamma?): [gamma]<br />Alpha: | @PostConstruct (beta?):  [beta]<br />Alpha: | @PostConstruct (gamma?): [gamma]<br /></pre>Spring framework first loads <code>Alpha</code> and tries to instantiate a bean. However when running <code>getBeansOfType(Beta.class)</code> it discovers <code>Beta</code> so proceeds with loading and instantiating that one. Inside <code>Beta</code> we can immediately spot the problem: when <code>Beta</code> asks for <code>beanFactory.getBeansOfType(Alpha.class)</code> it gets no results (<code>[]</code>). Spring will silently ignore <code>Alpha</code>, because it's currently under creation. Later everything is as expected: <code>Gamma</code> is loaded, constructed and injected, <code>Beta</code> sees <code>Gamma</code> and when we return to <code>Alpha</code>, everything is in place. Notice that even moving <code>getBeansOfType()</code> to <code>@PostConstruct</code> method doesn't help - these callbacks aren't executed in the end, when all beans are instantiated - but while the container starts up.<br /><br /><h1>Suggestions</h1><code>getBeansOfType()</code> is rarely needed and turns out to be unpredictable if you have cyclic dependencies. Of course you should avoid them in the first place and if you properly inject dependencies via collections, Spring can predictably handle the lifecycle of all beans and either wire them correctly or fail at runtime. In presence of circular dependencies betweens beans (sometimes accidental or very long in terms of nodes and edges in dependency graph) <code>getBeansOfType()</code> can yield different results depending on factors we have no control over, like CLASSPATH order.<br /><br />PS: Kudos to <a href="http://www.kubrynski.com/">Jakub Kubryński</a> for troubleshooting <code>getBeansOfType()</code>.<br /><script>SyntaxHighlighter.highlight();</script>