---
layout: post
title: Wzorzec Command - elastyczny protokół sieciowy
date: '2008-12-04T19:40:00.005+01:00'
author: Tomasz Nurkiewicz
tags:
- design patterns
modified_time: '2009-09-27T17:09:43.900+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1308187463150516125
blogger_orig_url: https://www.nurkiewicz.com/2008/12/wzorzec-command-elastyczny-protok.html
---

Postanowiłem przedstawić, moim zdaniem, jeden z najciekawszych wzorców projektowych: Command. Idea tego wzorca opiera się na zamknięciu logiki w posiadających jednolite interfejsy obiektach i możliwości dowolnego mapowania tych akcji do zdarzeń. Ale zamiast opowiadać i pokazywać diagramy UML - nie do końca trywialny przykład.<br /><br />Wyobraźmy sobie protokół sieciowy typu klient-serwer oparty o komunikaty w następującym formacie:<br /><span style="font-family:courier new;"><span style="font-style: italic;"><br />[nazwa_komunikatu]</span> [opcjonalne_parametry]</span><br /><br />Klient wysyła do serwera komunikat w powyższym formacie a w odpowiedzi dostaje dowolny tekst. Problem w tym, że chcemy by protokół był bardzo elastyczny pod kątem obsługiwanych komunikatów. W szczególności dodanie nowego typu komunikatu (rozpoznawanego po nazwie) obsługiwanego przez serwer i związanej z nim logiki biznesowej powinno być możliwie łatwe. Oczywiście wpisanie typów komunikatów do kodu i korzystanie z instrukcji typu <span style="font-family:courier new;">if</span> czy <span style="font-family:courier new;">switch</span> nie wchodzi w grę. Ale po kolei...<br /><br />Zacznijmy od prostego kodu serwera:<br /><br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>class Main {<br /><br />private static final Log log = LogFactory.getLog(Main.class);<br /><br />public static void main(String[] args) {<br />  BasicConfigurator.configure();<br />  try {<br />      ServerSocket serverSocket = new ServerSocket(47474);<br />      while (true) {<br />          log.debug("Waiting for client connections");<br />          Socket clientSocket = serverSocket.accept();<br />          log.trace("Accepted connection from: " + clientSocket);<br />          new Thread(new ClientWorker(clientSocket)).start();<br />      }<br />  } catch (Exception e) {<br />      log.fatal(e, e);<br />  }<br />}<br />}<br /><br /></code></pre>Na razie zignorujemy klasę ClientWorker obsługującą klientów. Zastanówmy się, jak zrealizować mapowanie między typami komunikatów (nazwami) a logiką z nimi związaną? Jeśli mapowanie, to pewnie mapa, gdzie kluczem będzie typ komunikatu, a wartością...<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>public interface Command {<br />String invoke(String args);<br />}<br /></code></pre>Interfejs ten stanowi bardzo prostą abstrakcję logiki, jaka będzie wykonywana po nadejściu określonego typu komunikatu. Idea jest prosta - przykładowo przychodzi komunikat:<br /><br /><span style="font-family:courier new;"><span style="font-weight: bold;">echo</span> Hello, World!</span><br /><br />gdzie <span style="font-family:courier new;">echo</span> jest typem komunikatu a <span style="font-style: italic;">"Hello, World!"</span> argumentami. Serwer odczytuje typ komunikatu i mapuje go na instancję klasy <span style="font-family:courier new;">Echo</span> o następującej implementacji:<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>public class Echo implements Command {<br /> @Override<br /> public String invoke(String args) {<br />     return "SERVER: '" + args + "'";<br /> }<br />}<br /></code></pre>i wywołuje  metodę <span style="font-family:courier new;">invoke()</span> z parametrem <span style="font-style: italic;">"Hello, World!"</span>. I teraz kluczowa uwaga - serwer nie ma świadomości, jaka jest konkretna implementacja interfejsu <span style="font-family:courier new;">Command</span>. Może być ona dowolna, można również pod dowolny typ komunikatu podpinać dowolną komendę. Wszystko jest przezroczyste, a jednocześnie bardzo elastyczne. I to jest idea wzorca projektowego <span style="font-family:courier new;">Command</span>.<br /><br />Przejdźmy do implementacji. Dla wygody stwórzmy komponent o następującym interfejsie:<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>public interface CommandsMgr {<br />void registerCommand(String name, Command command);<br />void unregisterCommand(String name);<br />String invokeCommand(String name, String arguments);<br />}<br /></code></pre>Pierwsze dwie metody odpowiednio dodają/usuwają mapowanie nazwy komunikatu na konkretną instancję klasy <span style="font-family:courier new;">Command</span>. Ostatnia odnajduje akcję wcześniej zamapowaną na daną nazwę i wywołuje metodę invoke() tej akcji z podanymi argumentami. Implementacja jest na tyle trywialna, że pozostawię ją czytelnikowi :-).<br /><br />Posiadając taki wygodny komponent, wystarczy teraz zainicjować go wprowadzoną już przykładową akcją:<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>commandsMgr.registerCommand("echo", new Echo());<br /></code></pre>I możemy przedstawić pełną implementację wprowadzonego wcześniej wątku obsługującego klienta (instancja klasy implementującej <span style="font-family:georgia;">CommandsMgr</span> jest tworzona w funkcji <span style="font-family:courier new;">main()</span> i przekazywana każdemu wątkowi w konstruktorze):<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>public class ClientWorker implements Runnable {<br /><br />private static final Log log = LogFactory.getLog(ClientWorker.class);<br /><br />private final Socket clientSocket;<br />private final CommandsMgr commandsMgr;<br /><br />private PrintWriter writer;<br />private boolean interrupted;<br /><br />public ClientWorker(CommandsMgr commandsMgr, Socket clientSocket) {<br />  this.commandsMgr = commandsMgr;<br />  this.clientSocket = clientSocket;<br />}<br /><br />@Override<br />public void run() {<br />  try {<br />      log.info("Serving thread for: " + clientSocket);<br />      BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));<br />      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream())));<br />      String line;<br />      while (!interrupted &amp;&amp; (line = reader.readLine()) != null)<br />          handleRequest(line);<br />      log.info("Client: " + clientSocket + " disconnected");<br />  } catch (Exception e) {<br />      log.error(e, e);<br />  } finally {<br />      log.info("Disconnecting from: " + clientSocket);<br />      try {<br />          clientSocket.close();<br />      } catch (IOException e) {<br />          log.warn(e, e);<br />      }<br />  }<br />}<br /><br />private void handleRequest(String line) {<br />  /*...*/<br />}<br /><br />}<br /></code></pre>Kod raczej nieskomplikowany: wątek w pętli wczytuje dane wysyłane od klienta linia po linii. Dla każdej linii wejścia wywołuje metodę <span style="font-family:courier new;">handleRequest()</span>:<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>private void handleRequest(String line) {<br />log.trace("Request: " + line);<br /><br />String name;<br />String arguments = null;<br />int spaceIdx = line.indexOf(' ');<br />if (spaceIdx &gt;= 0) {<br />   name = line.substring(0, spaceIdx);<br />   arguments = line.substring(spaceIdx + 1);<br />} else<br />   name = line;<br /><br />String response = commandsMgr.invokeCommand(name, arguments);<br />if (response != null) {<br />   writer.println(response);<br />   writer.flush();<br />}<br />else<br />   interrupted = true;<br />}<br /></code></pre>Najpierw parsujemy linię requestu ekstrahując z niej typ komunikatu i opcjonalne argumenty. Następnie prosimy komponent <span style="font-family:courier new;">CommandsMgr </span>o wywołanie akcji zamapowanej pod danym typem. Założyłem przy tym, co łatwo przeczytać z kodu, że jeśli akcja zwraca jakikolwiek String, to jest on wysyłany do klienta jako response. Jeśli zwróci null - jest to sygnał dla serwera by rozłączyć się z klientem.<br /><br />Widać zatem dodatkowy atut wzorca <span style="font-family:courier new;">Command</span> - nie tylko serwer abstrahuje od implementacji akcji, ale sama akcja nie jest świadoma środowiska, w jakim jest uruchamiana i co dzieje się dalej z jej wynikami (przynajmniej w tym prostym przykładzie).<br /><br />Uruchommy zatem nasz prosty serwer. Przypominam, że gdzieś na początku podmapowaliśmy polecenie <span style="font-family:courier new;">echo</span> z klasą <span style="font-family:courier new;">Echo</span> - implementacja wyżej. Jako klient posłuży niezastąpiony w czasach naszych dziadków <span style="font-family:courier new;">telnet</span> ;-):<br /><br /><span style="color: rgb(0, 153, 0);font-family:courier new;">d:\> telnet localhost 47474<br /></span><span style="color: rgb(0, 153, 0);font-family:courier new;">echo Tomek</span><br /><span style="color: rgb(0, 0, 153);font-family:courier new;">SERVER: 'Tomek'<br /><span style="color: rgb(0, 153, 0);">echo Koniec?</span><br /></span><span style="color: rgb(0, 0, 153);font-family:courier new;">SERVER: 'Koniec?'<br /></span><br />Na zielono dane wpisywane przez klienta (i odbierane przez serwer), na niebiesko dane zwrócone z serwera. Jak widać wszystko działa. Serwer odebrał komunikat: "<span style="font-style: italic;font-family:courier new;">echo Tomek</span>", wywołał metodę <span style="font-family:courier new;">Echo.invoke()</span> i odesłał do serwera zwrócony przez tą metodę String "<span style="font-style: italic; font-family:courier new;">SERVER: 'Tomek'</span>".<br /><br />Dodajmy zatem do naszego protokołu dwie dodatkowe akcje:<br /><br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>public class DateTime implements Command {<br /> @Override<br /> public String invoke(String args) {<br />     return DateFormat.getDateTimeInstance().format(Calendar.getInstance().getTime());<br /> }<br />}<br /></code></pre><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>public class Quit implements Command {<br /> @Override<br /> public String invoke(String args) {<br />     return null;<br /> }<br />}<br /></code></pre>Tłumaczenie chyba zbędne, podobnie jak przypomnienie o zmapowaniu nowych akcji do typów komunikatów:<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>commandsMgr.registerCommand("datetime", new DateTime());<br /></code><code>commandsMgr.registerCommand("quit", new Quit());<br /></code></pre>Po ponownej kompilacji uruchamiamy serwer i testujemy nowe funkcjonalności naszego protokołu:<br /><br /><span style="color: rgb(0, 153, 0);font-family:courier new;">d:\> telnet localhost 47474<br /></span><span style="font-family:courier new;"></span><span style="color: rgb(0, 153, 0);font-family:courier new;">echo Tomek</span><br /><span style="color: rgb(0, 0, 153);font-family:courier new;">SERVER: 'Tomek'</span><br /><span style="color: rgb(0, 153, 0);font-family:courier new;">datetime</span><br /><span style="color: rgb(0, 0, 153);font-family:courier new;">2008-12-04 19:26:54</span><br /><span style="color: rgb(0, 153, 0);font-family:courier new;">quit</span><br /><br /><span style="font-family:courier new;">Połączenie z hostem przerwane.</span><br /><span style="font-family:courier new;"></span><br />Znakomicie, właśnie rozszerzyliśmy nasz protokół komunikacyjny za pomocą minimalnych zmian w kodzie źródłowym aplikacji. Nie dotykaliśmy przy tym ani implementacji serwera, ani obsługi klienta. Jednak malkontenci - na co bardzo liczę - wytkną, że i tak konieczna była ingerencja w kod źródłowy i ponowne zbudowanie całej aplikacji. Oczywiście nie wspominałbym o tym, gdybym nie miał w zanadrzu gotowego rozwiązania :-). Najpierw sporządzam następujący plik <span style="font-family:courier new;">commands.properties</span>:<br /><br /><span style="font-family:courier new;">echo=commands.Echo</span><br /><span style="font-family:courier new;">quit=commands.Quit</span><br /><span style="font-family:courier new;">datetime=commands.DateTime</span><br /><br />...i chyba nietrudno się domyśleć, co z nim robię tuż po uruchomieniu aplikacji:<br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>private static void loadFromProperties(CommandsMgr commandsMgr) throws FileNotFoundException, IOException {<br /> Properties properties = new Properties();<br /></code><code>    </code><code>properties.load(new FileInputStream("commands.properties"));<br /></code><code>    </code><code>for (Map.Entry&lt;Object, Object&gt; command : properties.entrySet()) {<br /></code><code>    </code><code>try {<br />   </code><code>    </code><code>log.debug("Registering command: " + command);<br />   </code><code>    </code><code>Command instance = (Command) Class.forName(command.getValue().toString()).newInstance();<br />   </code><code>    </code><code>commandsMgr.registerCommand(command.getKey().toString(), instance);<br /></code><code>    </code><code>  } catch (Exception e) {<br /> </code><code>    </code><code>  log.warn("Error instantiating command: " + command);<br /></code><code>    </code><code>  }<br /></code><code>    </code><code>}<br />}<br /></code></pre><br />I już! Serwer nie tylko nie zna implementacji kryjących się za abstrakcją Command, implementacje te można dowolnie podmieniać, dodawać, etc. bez żadnej ingerencji w kod właściwej aplikacji!<br /><br /><span style="font-style: italic;">Jednak malkontenci - na co bardzo liczę - wytkną, że...</span> ale jak zaimplementować serwer by akcjami można było zarządzać bez restartu aplikacji, dodawać nowe, zmieniać implementacje, etc. opowiem kiedy indziej. Malkontenci (oraz wielbiciele OSGi) powinni być zadowoleni :-).