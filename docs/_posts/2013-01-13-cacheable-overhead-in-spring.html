---
layout: post
title: "@Cacheable overhead in Spring"
date: '2013-01-13T22:17:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- aop
- caliper
- performance
- spring
- aspectj
- cglib
modified_time: '2013-01-27T23:20:15.097+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-6382012056307877871
blogger_orig_url: https://www.nurkiewicz.com/2013/01/cacheable-overhead-in-spring.html
---

Spring 3.1 introduced great <a href="http://static.springsource.org/spring/docs/3.1.0.RELEASE/spring-framework-reference/html/cache.html">caching abstraction layer</a>. Finally we can abandon all home-grown aspects, decorators and code polluting our business logic related to caching. Since then we can simply annotate heavyweight methods and let Spring and AOP machinery do the work:<br /><br /><pre class="brush: java">@Cacheable("books")<br />public Book findBook(ISBN isbn) {...}<br /></pre><code>"books"</code> is a cache name, <code>isbn</code> parameter becomes cache key and returned <code>Book</code> object will be placed under that key. The meaning of cache name is dependant on the underlying cache manager (EhCache, concurrent map, etc.) - Spring makes it easy to plug different caching providers. But <b>this post won't be about caching feature in Spring</b>...<br /><br />Some time ago my teammate was optimizing quite low-level code and discovered an opportunity for caching. He quickly applied <code>@Cacheable</code> just to discover that the code performed worse then it used to. He got rid of the annotation and implemented caching himself manually, using good old <code>java.util.ConcurrentHashMap</code>. The performance was much better. He blamed <code>@Cacheable</code> and Spring AOP overhead and complexity. I couldn't believe that a caching layer can perform so poorly until I had to debug Spring caching aspects few times myself (some nasty bug in my code, you know, cache invalidation is one of the <a href="http://martinfowler.com/bliki/TwoHardThings.html">two hardest things in CS</a>). Well, the caching abstraction code is much more complex than one would expect (after all it's just <i>get</i> and <i>put</i>!), but it doesn't necessarily mean it must be that slow?<br /><br />In <i>science</i> we don't believe and trust, we measure and benchmark. So I wrote a benchmark to precisely measure the overhead of <code>@Cacheable</code> layer. Caching abstraction layer in Spring is implemented on top of Spring AOP, which can further be implemented on top of Java proxies, CGLIB generated subclasses or AspectJ instrumentation. Thus I'll test the following configurations:<br /><a name='more'></a><br /><br /><ul><li>no caching at all - to measure how fast the code is with no intermediate layer<br /><br /> </li><li>manual cache handling using <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html"><code>ConcurrentHashMap</code></a> in business code<br /><br /> </li><li><code>@Cacheable</code> with CGLIB implementing AOP<br /><br /> </li><li><code>@Cacheable</code> with <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html"><code>java.lang.reflect.Proxy</code></a> implementing AOP<br /><br /> </li><li><code>@Cacheable</code> with AspectJ compile time weaving (as similar benchmark shows, <a href="http://nurkiewicz.blogspot.no/2009/10/yesterday-i-had-pleasure-to-participate.html">CTW is slightly faster than LTW</a>)<br /><br /> </li><li>Home-grown AspectJ caching aspect - something between manual caching in business code and Spring abstraction<br /><br /> </li></ul>Let me reiterate: we are <b>not</b> measuring the performance gain of caching and we are <b>not</b> comparing various cache providers. That's why our test method is as fast as it can be and I will be using simplest <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/concurrent/ConcurrentMapCacheManager.html"><code>ConcurrentMapCacheManager</code></a> from Spring. So here is a method in question:<br /><br /><pre class="brush: java">public interface Calculator {<br /><br />    int identity(int x);<br /><br />}<br /><br />public class PlainCalculator implements Calculator {<br /><br />    @Cacheable("identity")<br />    @Override<br />    public int identity(int x) {<br />        return x;<br />    }<br /><br />}<br /></pre>I know, I know there is no point in caching such a method. But I want to measure the overhead of caching layer (during cache hit to be specific). Each caching configuration will have its own <code>ApplicationContext</code> as you can't mix different proxying modes in one context:<br /><br /><pre class="brush: java">public abstract class BaseConfig {<br /><br />    @Bean<br />    public Calculator calculator() {<br />        return new PlainCalculator();<br />    }<br /><br />}<br /><br />@Configuration<br />class NoCachingConfig extends BaseConfig {}<br /><br />@Configuration<br />class ManualCachingConfig extends BaseConfig {<br />    @Bean<br />    @Override<br />    public Calculator calculator() {<br />        return new CachingCalculatorDecorator(super.calculator());<br />    }<br />}<br /><br />@Configuration<br />abstract class CacheManagerConfig extends BaseConfig {<br /><br />    @Bean<br />    public CacheManager cacheManager() {<br />        return new ConcurrentMapCacheManager();<br />    }<br /><br />}<br /><br />@Configuration<br />@EnableCaching(proxyTargetClass = true)<br />class CacheableCglibConfig extends CacheManagerConfig {}<br /><br />@Configuration<br />@EnableCaching(proxyTargetClass = false)<br />class CacheableJdkProxyConfig extends CacheManagerConfig {}<br /><br />@Configuration<br />@EnableCaching(mode = AdviceMode.ASPECTJ)<br />class CacheableAspectJWeaving extends CacheManagerConfig {<br /><br />    @Bean<br />    @Override<br />    public Calculator calculator() {<br />        return new SpringInstrumentedCalculator();<br />    }<br /><br />}<br /><br />@Configuration<br />@EnableCaching(mode = AdviceMode.ASPECTJ)<br />class AspectJCustomAspect extends CacheManagerConfig {<br /><br />    @Bean<br />    @Override<br />    public Calculator calculator() {<br />        return new ManuallyInstrumentedCalculator();<br />    }<br /><br />}<br /></pre>Each <code>@Configuration</code> class represents one application context. <code>CachingCalculatorDecorator</code> is a decorator around <i>real</i> calculator that does the caching (welcome to the 1990s):<br /><br /><pre class="brush: java">public class CachingCalculatorDecorator implements Calculator {<br /><br />    private final Map&lt;Integer, Integer&gt; cache = new java.util.concurrent.ConcurrentHashMap&lt;Integer, Integer&gt;();<br /><br />    private final Calculator target;<br /><br />    public CachingCalculatorDecorator(Calculator target) {<br />        this.target = target;<br />    }<br /><br />    @Override<br />    public int identity(int x) {<br />        final Integer existing = cache.get(x);<br />        if (existing != null) {<br />            return existing;<br />        }<br />        final int newValue = target.identity(x);<br />        cache.put(x, newValue);<br />        return newValue;<br />    }<br />}<br /></pre><a href="https://github.com/nurkiewicz/benchmarks/blob/master/src/main/java/com/blogspot/nurkiewicz/cacheable/calculator/SpringInstrumentedCalculator.java"><code>SpringInstrumentedCalculator</code></a> and <a href="https://github.com/nurkiewicz/benchmarks/blob/master/src/main/java/com/blogspot/nurkiewicz/cacheable/calculator/ManuallyInstrumentedCalculator.java"><code>ManuallyInstrumentedCalculator</code></a> are exactly the same as <a href="https://github.com/nurkiewicz/benchmarks/blob/master/src/main/java/com/blogspot/nurkiewicz/cacheable/calculator/PlainCalculator.java"><code>PlainCalculator</code></a> but they are instrumented by AspectJ compile-time weaver with Spring and custom aspect accordingly. My custom caching aspect looks like this:<br /><br /><pre class="brush: java">public aspect ManualCachingAspect {<br /><br />    private final Map&lt;Integer, Integer&gt; cache = new ConcurrentHashMap&lt;Integer, Integer&gt;();<br /><br />    pointcut cacheMethodExecution(int x): execution(int com.blogspot.nurkiewicz.cacheable.calculator.ManuallyInstrumentedCalculator.identity(int)) &amp;&amp; args(x);<br /><br />    Object around(int x): cacheMethodExecution(x) {<br />        final Integer existing = cache.get(x);<br />        if (existing != null) {<br />            return existing;<br />        }<br />        final Object newValue = proceed(x);<br />        cache.put(x, (Integer)newValue);<br />        return newValue;<br />    }<br /><br />}<br /></pre>After all this preparation we can finally write the benchmark itself. At the beginning I start all the application contexts and fetch <code>Calculator</code> instances. Each instance is different. For example <code>noCaching</code> is a <code>PlainCalculator</code> instance with no wrappers, <code>cacheableCglib</code> is a CGLIB generated subclass while <code>aspectJCustom</code> is an instance of <code>ManuallyInstrumentedCalculator</code> with my custom aspect woven.<br /><br /><pre class="brush: java">private final Calculator noCaching = fromSpringContext(NoCachingConfig.class);<br />private final Calculator manualCaching = fromSpringContext(ManualCachingConfig.class);<br />private final Calculator cacheableCglib = fromSpringContext(CacheableCglibConfig.class);<br />private final Calculator cacheableJdkProxy = fromSpringContext(CacheableJdkProxyConfig.class);<br />private final Calculator cacheableAspectJ = fromSpringContext(CacheableAspectJWeaving.class);<br />private final Calculator aspectJCustom = fromSpringContext(AspectJCustomAspect.class);<br /><br />private static &lt;T extends BaseConfig&gt; Calculator fromSpringContext(Class&lt;T&gt; config) {<br />    return new AnnotationConfigApplicationContext(config).getBean(Calculator.class);<br />}<br /></pre>I'm going to exercise each <code>Calculator</code> instance with the following test. The additional accumulator is necessary, otherwise JVM might optimize away the whole loop (!):<br /><br /><pre class="brush: java">private int benchmarkWith(Calculator calculator, int reps) {<br />    int accum = 0;<br />    for (int i = 0; i &lt; reps; ++i) {<br />        accum += calculator.identity(i % 16);<br />    }<br />    return accum;<br />}<br /></pre>Here is the full <a href="http://draft.blogger.com/blogger.g?blogID=6753769565491687768">caliper</a> test without parts already discussed:<br /><br /><pre class="brush: java">public class CacheableBenchmark extends SimpleBenchmark {<br /><br />    //...<br /><br />    public int timeNoCaching(int reps) {<br />        return benchmarkWith(noCaching, reps);<br />    }<br /><br />    public int timeManualCaching(int reps) {<br />        return benchmarkWith(manualCaching, reps);<br />    }<br /><br />    public int timeCacheableWithCglib(int reps) {<br />        return benchmarkWith(cacheableCglib, reps);<br />    }<br /><br />    public int timeCacheableWithJdkProxy(int reps) {<br />        return benchmarkWith(cacheableJdkProxy, reps);<br />    }<br /><br />    public int timeCacheableWithAspectJWeaving(int reps) {<br />        return benchmarkWith(cacheableAspectJ, reps);<br />    }<br /><br />    public int timeAspectJCustom(int reps) {<br />        return benchmarkWith(aspectJCustom, reps);<br />    }<br />}<br /></pre>I hope you are still following our experiment. We are now going to execute <code>Calculate.identity()</code> millions of times and see which caching configuration performs best. Since we only call <code>identity()</code> with 16 different arguments, we hardly ever touch the method itself as we always get cache hit. Curious to see the results?<br /><br /><pre class="brush: java">                  benchmark      ns linear runtime<br />                  NoCaching    1.77 =<br />              ManualCaching   23.84 =<br />         CacheableWithCglib 1576.42 ==============================<br />      CacheableWithJdkProxy 1551.03 =============================<br />CacheableWithAspectJWeaving 1514.83 ============================<br />              AspectJCustom   22.98 =</pre><pre class="brush: java">&nbsp;</pre><br /><img alt="Caliper" src="https://raw.github.com/nurkiewicz/benchmarks/master/src/main/docs/img/caching_timing.png" /><br /><br /><h2>Interpretation</h2>Let's go step by step. First of all calling a method in Java is pretty darn fast! 1.77 <i>nanoseconds</i>, we are talking here about <b>3 CPU cycles</b> on my Intel(R) Core(TM)2 Duo CPU T7300 @ 2.00GHz! If this doesn't convince you that Java is fast, I don't know what will. But back to our test.<br /><br />Hand-made caching decorator is also pretty fast. Of course it's slower by an order of magnitude compared to pure function call, but still blazingly fast compared to all <code>@Scheduled</code> benchmarks. We see a drop by <b>3 orders of magnitude</b>, from 1.8 ns to 1.5 μs. I'm especially disappointed by the <code>@Cacheable</code> backed by AspectJ. After all caching aspect is precompiled directly into my Java <code>.class</code> file, I would expect it to be much faster compared to dynamic proxies and CGLIB. But that doesn't seem to be the case. All three Spring AOP techniques are similar.<br /><br />The greatest surprise is my custom AspectJ aspect. It's even faster than <code>CachingCalculatorDecorator</code>! maybe it's due to polymorphic call in the decorator? I strongly encourage you to <a href="https://github.com/nurkiewicz/benchmarks">clone this benchmark on GitHub</a> and run it (<code>mvn clean test</code>, takes around 2 minutes) to compare your results.<br /><br /><h2>Conclusions</h2>You might be wondering why Spring abstraction layer is so slow? Well, first of all, check out the core implementation in <a href="https://github.com/SpringSource/spring-framework/blob/3.2.x/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java"><code>CacheAspectSupport</code></a> - it's actually quite complex. Secondly, is it really that slow? Do the math - you typically use Spring in business applications where database, network and external APIs are the bottleneck. What latencies do you typically see? Milliseconds? Tens or hundreds of milliseconds? Now add an overhead of 2 μs (worst case scenario). For caching database queries or REST calls this is completely negligible. <b>It doesn't matter which technique you choose</b>.<br /><br />But if you are caching very low-level methods close to the metal, like CPU-intensive, in-memory computations, Spring abstraction layer might be an overkill. The bottom line: measure!<br /><br />PS: both <a href="https://github.com/nurkiewicz/benchmarks">benchmark</a> and <a href="https://github.com/nurkiewicz/benchmarks/blob/master/README.md">contents of this article</a> in <a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a> format are freely available.<br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>