---
layout: post
title: Invoking secured remote EJB in JBoss 5
date: '2009-08-03T23:59:00.003+02:00'
author: Tomasz Nurkiewicz
tags:
- ejb
- jboss
modified_time: '2009-08-04T00:17:06.625+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2907566374522626524
blogger_orig_url: https://www.nurkiewicz.com/2009/08/invoking-secured-remote-ejb-in-jboss-5.html
---

While preparing for SCBCD exam I encountered many difficulties in securing remote EJB 3 stateless session bean, and then calling such a component from remote standalone client. I hope this short introduction will help you… avoiding this problem. First, I simply put security annotations on my bean as follows:<br /><br /><pre name="code" class="java">@Stateless<br />@RolesAllowed("ROLE_ADMIN")<br />@PermitAll<br />public class DateServiceBean implements DateServiceRemote {<br /> //...<br />}</pre><br />Surprisingly such a bean can be easily deployed on JBoss 5.1.0 application server and all its methods are available. Why surprise? Because no <span style="font-family:courier new;">ROLE_ADMIN</span> was defined in JBoss nor the client was authorized. As the role was not defined, server silently ignored the security annotation! I learned my lesson – always verify security configuration, especially whether it actually secures anything…<br /><br />Quick tour over JBoss documentation and I discovered <span style="font-family:courier new;">@org.jboss.annotation.security.SecurityDomain</span> annotation, which should mark all the beans using declarative as well as programmatic security, next to <span style="font-family:courier new;">@RolesAllowed</span>. This does not look well – not only this annotation needs to be repeated in every session bean (and what happens if you forget? – nothing, security is then ignored…), but it brings compile-time dependency on JBoss specific class! Fortunately, good-old-XML can be used:<br /><br /><pre name="code" class="xml">&lt;jboss&gt;<br /> &lt;security-domain&gt;dateserver&lt;/security-domain&gt;<br />&lt;/jboss&gt;<br /></pre><br /><br />This short snippet in <span style="font-family:courier new;">jboss.xm</span>l, which must be included in ejb-jar file, specifies the security domain name (dateserver) to be used by whole application. The same name should be referenced in login-config.xml file, located in JBoss distribution (typically server/default/conf directory):<br /><br /><pre name="code" class="xml">&lt;application-policy name="dateserver"&gt;<br />  &lt;authentication&gt;<br />    &lt;login-module code="org.jboss.security.auth.spi.UsersRolesLoginModule" flag="required"&gt;<br />      &lt;module-option name="usersProperties"&gt;props/dateserver-users.properties&lt;/module-option&gt;<br />      &lt;module-option name="rolesProperties"&gt;props/dateserver-roles.properties&lt;/module-option&gt;<br />    &lt;/login-module&gt;<br />&lt;/authentication&gt;</pre><br /><br />Just put this by the end of login-config.xml file and restart JBoss. Does describing dateserver-users.properties and dateserver-roles.properties is necessary? First consists of <span style="font-family:courier new;">username=password</span> items and second: <span style="font-family:courier new;">username=role1, role2, role3</span> mappings. Now we have successfully secured our remote EJBs, which quick test from Java SE client proves:<br /><br /><span style="font-size:85%;">javax.ejb.<span style="font-weight: bold;">EJBAccessException: Caller unauthorized</span><br />at org.jboss.ejb3.security.RoleBasedAuthorizationInterceptorv2.invoke(RoleBasedAuthorizationInterceptorv2.java:199)<br />at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:102)<br />[...]<br /></span><br />Needless to say, the journey begins here... After few frustrating tries, I still couldn’t manage to log on application server and call secured method, using all varieties of standard lookup code:<br /><br /><pre name="code" class="java">Hashtable&lt;String, String&gt; properties = new Hashtable&lt;String, String&gt;();<br />properties.put(Context.INITIAL_CONTEXT_FACTORY, "org.jboss.naming.NamingContextFactory");<br />properties.put(Context.PROVIDER_URL, "jnp://localhost:1099");<br />properties.put(Context.URL_PKG_PREFIXES, "org.jnp.interfaces");<br />properties.put(Context.SECURITY_PRINCIPAL, "user");<br />properties.put(Context.SECURITY_CREDENTIALS, "password");<br />Context context = new InitialContext(properties);<br />DateServiceRemote dateService = (DateServiceRemote) context.lookup("DateServiceBean/remote");</pre><br /><br />JBoss totally ignores authentication data provided to the <span style="font-family:courier new;">InitialContext</span>, repeatedly returning "<span style="font-family:courier new;">Caller unauthorized</span>". Finally, I found out that this server since 5.0 version has its own, non-standard API for managing user authentication:<br /><br /><pre name="code" class="java">SecurityClient securityClient = SecurityClientFactory.getSecurityClient();<br />try {<br /> securityClient.setSimple("username", "password");<br /> securityClient.login();<br /> //perform JNDI lookup and call business method as usual WITHOUT authentication<br />} finally {<br />   securityClient.logout();<br />}</pre><br /><br />This is totally awful! – not only JBoss forces me to use container specific classes (<span style="font-family:courier new;">org.jboss.security.client.SecurityClient</span>), the API itself isn’t very well designed. Please note, that although <span style="font-family:courier new;">SecurityClient </span>instance is created, it is never passed to the <span style="font-family:courier new;">InitialContext </span>or propagated by any other way. This smells like nasty <span style="font-family:courier new;">ThreadLocal</span> and will behave unexpectedly if you forget to logout and reuse the thread (e.g. when pooling in client).<br />JBoss finally catches up usernames and validates them against password, discovers user roles and applies security to EJBs. But, IMHO, the price is very high. I could stand JBoss client libraries on my <span style="font-family:courier new;">CLASSPATH</span>, I somehow avoided vendor specific annotations. But all in all, some strange client class must be used. What’s the point of this whole standardization, JSRs and tons of specifications, if even the simplest use case cannot be implemented without making my hands dirty?<br /><br />P.S.: I'm starting to blog in English. Comments are welcome, but please be gentle ;-).