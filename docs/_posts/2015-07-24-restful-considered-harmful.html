---
layout: post
title: RESTful considered harmful
date: '2015-07-24T00:23:00.002+02:00'
author: Tomasz Nurkiewicz
tags:
- rest
modified_time: '2015-07-24T00:23:40.694+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4902386717840202961
blogger_orig_url: https://www.nurkiewicz.com/2015/07/restful-considered-harmful.html
---

I don't like <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a> principles and APIs. In recent years it is seen as universal protocol for inter-process communication, especially in distributed systems. However I see many deficiencies of REST and there are alternatives that work well for certain use cases. Obviously there is no <em>one size fits all</em>, I just want to emphasize that REST architecture is flawed in a number of ways.<br /><h1>Bloated, human readable format that demands extra compression</h1>The <em>de facto</em> standard format for REST is JSON. At least it's way better than SOAP with its XML and envelopes. Either lots of network bandwidth is wasted (can be an issue with mobile devices or large data centers) or CPU is spent on compression and decompression. A lovely quote:<br /><blockquote>[the] internet is running in debug mode <a href="https://twitter.com/giltene/status/527471471614885888">source</a></blockquote>It's a serious issue, ask high-frequency traders how hard <a href="http://openhft.net/products/transfix/">parsing text-based FIX</a> is. There are plenty of well-established binary protocols that are both easy to parse and use little memory, e.g. <a href="https://developers.google.com/protocol-buffers/">Protocol buffers</a>, <a href="https://avro.apache.org/">Avro</a> or <a href="https://thrift.apache.org/">Thrift</a>. Moreover backward compatibility is built into them. You can technically be <a href="https://spring.io/blog/2015/03/22/using-google-protocol-buffers-with-spring-mvc-based-rest-services"><em>using Google Protocol Buffers with Spring MVC-based REST Services</em></a> - but somehow very few do it this way and stick to JSON.<br />Of course JSON has one (literally, <em>one</em>) tremendous advantage - it's human readable. Well, at least as long as it's <a href="http://www.nurkiewicz.com/2012/09/accessing-clipboard-in-linux-terminal.html">pretty printed</a> - rarely the case. But do we really want to pay that price rather than just use binary format by default and have translator or switch when human intervention is required?<br /><h1>Neither schema nor contract</h1>I belong to the static typing camp. I love it when my compiler finds bugs before I even run unit tests - and that I don't need to write so many of them in the first place. Moreover especially in functional programming if code compiles, chances are it works because the contract enforced by types is so strict. When dealing with XML I am happy to have XSD validated so that I can be sure what I read conforms to contract. I can reduce the number of assertions and keep code shorter. Also the XML I produce is guaranteed to be syntactically correct. Last but not least when working with relational databases strict schema prevents me from corrupting data by inserting incorrect values. Similarly to XML, I can also trust what I read: foreign keys are correct, NOT NULL columns really are not null, etc. These are clearly the advantages of machine enforced contract. Somehow all of this is not important anymore when designing API to be produced and consumed by machines in a distributed system (and accidentally in many schema-less NoSQL databases like MongoDB).<br />Understandable hate of SOAP pushed us to another extreme - no contract at all. There is no widespread standard for documenting contracts and enforcing them automatically for REST APIs. Most of the APIs I find these days are just a collection of sample requests and responses, <a href="http://swagger.io/">Swagger</a> at best. I never know which fields are optional, what are the formats and constraints. One might argue that this is by design, that we don't couple ourselves to one concrete API, allowing it evolve. But I have a feeling that most of the API consumers are nevertheless coupled and will break once undocumented and unannounced change is rolled out.<br /><h1>Publishing URIs</h1>Talking about documentation, purists claim that the only piece of information API should expose is the root URI, e.g. <code>www.example.com/api</code>. Everything else, including allowed methods, resources, content types and documents should be discovered via <a href="http://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>. And if URIs are not officially documented but instead should be discovered, it implies we should not rely on hard-coded URIs in our code but instead traverse the resource tree every time we use such API. This is idiomatic, however also slow and error-prone. Not to mention Swagger, the <em>de facto</em> standard for REST documentation, officially claims such approach is <a href="https://github.com/swagger-api/swagger-core/issues/97">"<em>not per design</em>"</a> - and sticks to fixed URIs.<br /><h1>No support for batching, paging, sorting/searching, ...</h1>RESTful web service does not natively support many enterprise-grade features of APIs like batching requests, paging, sorting, searching and many others. There are competing suggestions, like query parameters, request headers, etc. I remember an hour long discussion about flexible searching API we had some time ago. Should there be:<br /><ul><li>single SQL-like parameter (with proper escaping!), e.g. <code>query=age&gt;10 and (name=John or company=Foo)</code> </li><li>multiple parameters for each criteria, e.g. <code>age=10&amp;name=John&amp;company=Foo</code> (but how to implement <code>OR</code> operator?)</li><li>most bizarre: stateful POST on <code>/searches</code> with criteria modeled with JSON-like structure, returning URL to search results (<code>/searches/25</code>), which can later be queried</li></ul>REST is really constraining here.<br /><h1>CRUD by definition</h1>RESTful web services are CRUD-oriented, rather than business- or transaction-oriented. Countless times we had to carefully map business terms into simple <em>create</em>/<em>update</em>/<em>delete</em> actions. World isn't that simple and not everything can be simply described in <em>create or update</em> sentences. And even if it can, often RESTful endpoints are awfully awkward and artificial. Do you still remember POST to <code>/searches</code>? Moreover not all data can be mapped into URI tree structure and often we allow denormalization, e.g. the same resource is available under multiple URIs so that it's easily accessible.<br />Imagine a system that publishes domain events, arbitrary state changes, e.g. <code>LoanApproved</code>, <code>EmailSent</code>, etc. Of course every event has its own, distinct set of attributes. How do you design a RESTful API that consumes such events? Inevitably you'll end up with <code>POST /domainEvents</code> that accepts arbitrary JSON, maybe with some tag like <code>"type": "LoanApproved"</code>. So you have an endpoint that takes arbitrary JSON "BLOB" and most likely has a giant switch-like statement to interpret various types of events properly. Replace <code>"type"</code> with <code>"method"</code> and you just reinvented <a href="https://en.wikipedia.org/wiki/JSON-RPC">JSON RPC</a>. How would you do that in an idiomatic way? Translate every domain event on the publisher side to appropriate API call? Doesn't sound very robust.<br /><h1>HTTP verbs aren't descriptive enough</h1>Mapping from business terms into POST/PUT/PATCH/DELETE/HEAD is tedious and childish. Just like with URIs, world is much richer and not everything fits into these buckets. These verbs were designed to interact with documents and forms in World Wide Web. Using REST feels like degrading our business domain back into database browser. There is no logic, no domain-driven design, no rich flows. We simply manipulate objects, shift them back and forth. Of course REST don't have to and shouldn't map directly to database entities. But even if they map to your core business domain, you still have to view your domain through limited CRUD interface.<br /><h1>Mixing HTTP status codes with business replies</h1>Idiomatically signaling business errors via REST should use 4xx class of status codes. However these errors were not designed to signal business cases so I constantly find myself trying to map 4xx codes to business results. CAPTCHA test failed? Let's make it 400 <em>Bad request</em>. Form validation error? 417 <em>Expectation failed</em>? Constraint violation due to duplicate? 409 <em>Conflict</em>? But what about optimistic lock exception? What if client has insufficient balance? What if... These error codes are designed for document retrieval, not rich business behind back-end. You end up with putting everything under the same status code or building complex translation document. We invented exceptions, faults, <code>Either&lt;T&gt;</code> - just to suddenly limit ourselves to fixed set of numeric error codes.<br />404 is especially problematic, because it's so prevalent. When using RESTful API you can never tell whether 404 is a business circumstance or just a typo in URL. Sounds like a recipe for distributed debugging hell. Oh, and did I mention there is no standard way of encoding errors?<br /><h1>Temporal coupling</h1>RESTful APIs are really popular among microservice fanboys. But let's go back to basics. RESTful APIs are based on HTTP, which is a request-response protocol built on top of TCP/IP. TCP/IP builds a connection abstraction on top of packet-oriented IP protocol. IP is barely capable of delivering messages from one machine to another. By building all these levels of abstractions we forgot that web is really asynchronous. We believe that by using contract-less lax JSON we are no longer coupling systems together. But there is another dimension of coupling: temporal dependency. If one system needs to notify another about some event, do they really need to exist at the same time. In some cases, typically implemented with GET, request-response makes sense. But in most cases what we really want is a fire-and-forget, at-least-once semantics. Message-driven distributed architectures proved to be much more robust and fault-tolerant. Two systems no longer need to see each other and live at the same time. Moreover one system will no longer break another one if it's producing too many requests. Simply put a persistent queue in between two systems. This approach has numerous advantages:<br /><ul><li>producers and consumers can be restarted at any time without data loss or quality of service degraded</li><li>scalability is easier to achieve, no need for complex load balancing</li><li>we can dispatch messages to multiple systems at once</li><li>debugging <em>might</em> be easier with <a href="http://www.enterpriseintegrationpatterns.com/WireTap.html">wire tap pattern</a></li></ul>RESTful also has no notion of one-way requests. POST with no body is as close as you can get. This is problematic, because many business cases are naturally fitting the fire-and-forget semantics. When I'm publishing domain events I don't care about response, but REST services are too tightly coupled to HTTP protocol.<br />Only typical request-response interactions (like retrieving a user by ID) aren't a good fit for queues though. Temporal queues with correlation IDs are awkward and introduce a lot of latency.<br /><h1>No standards</h1>There are no standards but only good, sometimes contradicting practices. We can't even agree whether resources should be singular or plural, not to mention paging parameters, error handling, HATEOAS... You will find people arguing how RESTful is your service, according to <a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a>. Lack of standards mean that everyone can name their service RESTful. It might be a live example from <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Roy Fielding's dissertation</a>, it might be a <code>&lt;form&gt;</code> POST handler - as long as they use HTTP, they are REST. This also means you never now how to properly interact with any API. Which headers you should use, how to decode the response, how content type is negotiated (headers? extension in URL?) and which types are supported.<br /><h1>Backward compatibility</h1>RESTful services have few flawed ways of handling backward compatibility:<br /><ul><li>only adding fields, never removing or changing. I witnessed a situation where someone fixed an innocent typo in an object that happened to be directly encoded as JSON. This crashed another system</li><li>Content type with versioning - painful and requires maintaining multiple versions</li><li>HTTP redirects if resources are renamed - only works if clients are RESTful enough, avoiding hard-coded URLs entirely</li></ul>Each technique above has its own issues, RESTful services simply aren't designed to be evolving.<br /><h1>Alternatives</h1>Few questions I want you to ask yourself before jumping onto JSON over HTTP a.k.a. REST hippie-style of integration:<br /><ul><li>is performance a concern? Then choose more compact format that doesn't require costly compression</li><li>do you really need blocking request-response? If not, consider message queue or store, like Kafka</li><li>are you doing continuous deployment or auto-scaling? Then pick technology that doesn't couple client and server temporarily and is connection-less, see above</li><li>are your interactions complex or maybe you are extracting existing API/interface from module to distributed service? Then choose technology closer to classic RPC</li><li>do you need <a href="https://lobste.rs/s/ecjfcm/why_is_exactly-once_messaging_not_possible_in_a_distributed_queue">exactly-once semantics</a>? If so, nothing will help you, sorry</li></ul>PS: Obligatory appendix: <a href="http://meyerweb.com/eric/comment/chech.html">"Considered Harmful" Essays Considered Harmful</a>.