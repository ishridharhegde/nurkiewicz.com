---
layout: post
title: Batching (collapsing) requests in Hystrix
date: '2014-11-03T09:20:00.001+01:00'
author: Tomasz Nurkiewicz
tags:
- Hystrix
- Spock
modified_time: '2014-11-03T09:20:44.244+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8896667209058947182
blogger_orig_url: https://www.nurkiewicz.com/2014/11/batching-collapsing-requests-in-hystrix.html
---

<a href="https://github.com/Netflix/Hystrix">Hystrix</a> has an advanced feature of <a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use#Collapsing">collapsing (or batching)</a> requests. If two or more commands run similar request at the same time, Hystrix can combine them together, run one batched request and dispatch split results back to all commands. Let's first see how Hystrix works without collapsing. Imagine we have a service that looks up <code>StockPrice</code> of a given <code>Ticker</code>:<br /><br /><pre class="brush: groovy">import lombok.Value;<br />import java.math.BigDecimal;<br />import java.time.Instant;<br /><br />@Value<br />class Ticker {<br />    String symbol;<br />}<br /><br />@Value<br />class StockPrice {<br />    BigDecimal price;<br />    Instant effectiveTime;<br />}<br /><br />interface StockPriceGateway {<br /><br />    default StockPrice load(Ticker stock) {<br />        final Set&lt;Ticker&gt; oneTicker = Collections.singleton(stock);<br />        return loadAll(oneTicker).get(stock);<br />    }<br /><br />    ImmutableMap&lt;Ticker, StockPrice&gt; loadAll(Set&lt;Ticker&gt; tickers);<br />}<br /></pre>Core implementation of <code>StockPriceGateway</code> must provide <code>loadAll()</code> batch method while <code>load()</code> method is implemented for our convenience. So our gateway is capable of loading multiple prices in one batch (e.g. to reduce latency or network protocol overhead), but at the moment we are not using this feature, always loading price of one stock at a time:<br /><br /><pre class="brush: groovy">class StockPriceCommand extends HystrixCommand&lt;StockPrice&gt; {<br /><br />    private final StockPriceGateway gateway;<br />    private final Ticker stock;<br /><br />    StockPriceCommand(StockPriceGateway gateway, Ticker stock) {<br />        super(HystrixCommandGroupKey.Factory.asKey("Stock"));<br />        this.gateway = gateway;<br />        this.stock = stock;<br />    }<br /><br />    @Override<br />    protected StockPrice run() throws Exception {<br />        return gateway.load(stock);<br />    }<br />}<br /></pre>Such command will always call <code>StockPriceGateway.load()</code> for each and every <code>Ticker</code>, as illustrated by the following tests:<br /><br /><pre class="brush: groovy">class StockPriceCommandTest extends Specification {<br /><br />    def gateway = Mock(StockPriceGateway)<br /><br />    def 'should fetch price from external service'() {<br />        given:<br />            gateway.load(TickerExamples.any()) &gt;&gt; StockPriceExamples.any()<br />            def command = new StockPriceCommand(gateway, TickerExamples.any())<br /><br />        when:<br />            def price = command.execute()<br /><br />        then:<br />            price == StockPriceExamples.any()<br />    }<br /><br />    def 'should call gateway exactly once when running Hystrix command'() {<br />        given:<br />            def command = new StockPriceCommand(gateway, TickerExamples.any())<br /><br />        when:<br />            command.execute()<br /><br />        then:<br />            1 * gateway.load(TickerExamples.any())<br />    }<br /><br />    def 'should call gateway twice when command executed two times'() {<br />        given:<br />            def commandOne = new StockPriceCommand(gateway, TickerExamples.any())<br />            def commandTwo = new StockPriceCommand(gateway, TickerExamples.any())<br /><br />        when:<br />            commandOne.execute()<br />            commandTwo.execute()<br /><br />        then:<br />            2 * gateway.load(TickerExamples.any())<br />    }<br /><br />    def 'should call gateway twice even when executed in parallel'() {<br />        given:<br />            def commandOne = new StockPriceCommand(gateway, TickerExamples.any())<br />            def commandTwo = new StockPriceCommand(gateway, TickerExamples.any())<br /><br />        when:<br />            Future&lt;StockPrice&gt; futureOne = commandOne.queue()<br />            Future&lt;StockPrice&gt; futureTwo = commandTwo.queue()<br /><br />        and:<br />            futureOne.get()<br />            futureTwo.get()<br /><br />        then:<br />            2 * gateway.load(TickerExamples.any())<br />    }<br /><br />}<br /></pre>If you don't know Hystrix, by wrapping an external call in a command you gain a lot of features like timeouts, circuit breakers, etc. But this is not the focus of this article. Look at last two tests: when asking for price of arbitrary ticker twice, sequentially or in parallel (<code>queue()</code>), our external <code>gateway</code> is also called twice. Last test is especially interesting - we ask for the same ticker at almost the same time, but Hystrix can't figure that out. These two commands are fully independent, will be executed in different threads and don't know anything about each other - even though they run at almost the same time.<br /><br />Collapsing is all about finding such similar requests and combining them. Batching (I will use this term interchangeably with <em>collapsing</em>) doesn't happen automatically and requires a bit of coding. But first let's see how it behaves:<br /><br /><pre class="brush: groovy">def 'should collapse two commands executed concurrently for the same stock ticker'() {<br />    given:<br />        def anyTicker = TickerExamples.any()<br />        def tickers = [anyTicker] as Set<br /><br />    and:<br />        def commandOne = new StockTickerPriceCollapsedCommand(gateway, anyTicker)<br />        def commandTwo = new StockTickerPriceCollapsedCommand(gateway, anyTicker)<br /><br />    when:<br />        Future&lt;StockPrice&gt; futureOne = commandOne.queue()<br />        Future&lt;StockPrice&gt; futureTwo = commandTwo.queue()<br /><br />    and:<br />        futureOne.get()<br />        futureTwo.get()<br /><br />    then:<br />        0 * gateway.load(_)<br />        1 * gateway.loadAll(tickers) &gt;&gt; ImmutableMap.of(anyTicker, StockPriceExamples.any())<br />}<br /><br />def 'should collapse two commands executed concurrently for the different stock tickers'() {<br />    given:<br />        def anyTicker = TickerExamples.any()<br />        def otherTicker = TickerExamples.other()<br />        def tickers = [anyTicker, otherTicker] as Set<br /><br />    and:<br />        def commandOne = new StockTickerPriceCollapsedCommand(gateway, anyTicker)<br />        def commandTwo = new StockTickerPriceCollapsedCommand(gateway, otherTicker)<br /><br />    when:<br />        Future&lt;StockPrice&gt; futureOne = commandOne.queue()<br />        Future&lt;StockPrice&gt; futureTwo = commandTwo.queue()<br /><br />    and:<br />        futureOne.get()<br />        futureTwo.get()<br /><br />    then:<br />        1 * gateway.loadAll(tickers) &gt;&gt; ImmutableMap.of(<br />                anyTicker, StockPriceExamples.any(),<br />                otherTicker, StockPriceExamples.other())<br />}<br /><br />def 'should correctly map collapsed response into individual requests'() {<br />    given:<br />        def anyTicker = TickerExamples.any()<br />        def otherTicker = TickerExamples.other()<br />        def tickers = [anyTicker, otherTicker] as Set<br />        gateway.loadAll(tickers) &gt;&gt; ImmutableMap.of(<br />                anyTicker, StockPriceExamples.any(),<br />                otherTicker, StockPriceExamples.other())<br /><br />    and:<br />        def commandOne = new StockTickerPriceCollapsedCommand(gateway, anyTicker)<br />        def commandTwo = new StockTickerPriceCollapsedCommand(gateway, otherTicker)<br /><br />    when:<br />        Future&lt;StockPrice&gt; futureOne = commandOne.queue()<br />        Future&lt;StockPrice&gt; futureTwo = commandTwo.queue()<br /><br />    and:<br />        def anyPrice = futureOne.get()<br />        def otherPrice = futureTwo.get()<br /><br />    then:<br />        anyPrice == StockPriceExamples.any()<br />        otherPrice == StockPriceExamples.other()<br />}<br /></pre>First test proves that instead of calling <code>load()</code> twice we barely called <code>loadAll()</code> once. Also notice that since we asked for the same <code>Ticker</code> (from two different threads), <code>loadAll()</code> asks for only one ticker. Second test shows two concurrent requests for two different tickers being collapsed into one batch call. Third test makes sure we still get proper responses to each individual request. Instead of extending <code>HystrixCommand</code> we must extend more complex <code>HystrixCollapser</code>. Now it's time to see <code>StockTickerPriceCollapsedCommand</code> implementation, that seamlessly replaced <code>StockPriceCommand</code>:<br /><br /><pre class="brush: groovy">class StockTickerPriceCollapsedCommand extends HystrixCollapser&lt;ImmutableMap&lt;Ticker, StockPrice&gt;, StockPrice, Ticker&gt; {<br /><br />    private final StockPriceGateway gateway;<br />    private final Ticker stock;<br /><br />    StockTickerPriceCollapsedCommand(StockPriceGateway gateway, Ticker stock) {<br />        super(HystrixCollapser.Setter.withCollapserKey(HystrixCollapserKey.Factory.asKey("Stock"))<br />                .andCollapserPropertiesDefaults(HystrixCollapserProperties.Setter().withTimerDelayInMilliseconds(100)));<br />        this.gateway = gateway;<br />        this.stock = stock;<br />    }<br /><br />    @Override<br />    public Ticker getRequestArgument() {<br />        return stock;<br />    }<br /><br />    @Override<br />    protected HystrixCommand&lt;ImmutableMap&lt;Ticker, StockPrice&gt;&gt; createCommand(Collection&lt;CollapsedRequest&lt;StockPrice, Ticker&gt;&gt; collapsedRequests) {<br />        final Set&lt;Ticker&gt; stocks = collapsedRequests.stream()<br />                .map(CollapsedRequest::getArgument)<br />                .collect(toSet());<br />        return new StockPricesBatchCommand(gateway, stocks);<br />    }<br /><br />    @Override<br />    protected void mapResponseToRequests(ImmutableMap&lt;Ticker, StockPrice&gt; batchResponse, Collection&lt;CollapsedRequest&lt;StockPrice, Ticker&gt;&gt; collapsedRequests) {<br />        collapsedRequests.forEach(request -&gt; {<br />            final Ticker ticker = request.getArgument();<br />            final StockPrice price = batchResponse.get(ticker);<br />            request.setResponse(price);<br />        });<br />    }<br /><br />}<br /></pre>A lot is going on here, so let's review <code>StockTickerPriceCollapsedCommand</code> step by step. First three generic types:<br /><br /><ul><li><code>BatchReturnType</code> (<code>ImmutableMap&lt;Ticker, StockPrice&gt;</code> in our example) is the type of batched command response. As you will see later, collapser turns multiple small commands into a batch command. This is the type of that batch command's response. Notice that it's the same as <code>StockPriceGateway.loadAll()</code> type).<br /><br /></li><li><code>ResponseType</code> (<code>StockPrice</code>) is the type of each individual command being collapsed. In our case we are collapsing <code>HystrixCommand&lt;StockPrice&gt;</code>. Later we will split value of <code>BatchReturnType</code> into multiple <code>StockPrice</code>.<br /><br /></li><li><code>RequestArgumentType</code> (<code>Ticker</code>) is the input of each individual command we are about to collapse (batch). When multiple commands are batched together, we are eventually replacing all of them with one batched command. This command should receive all individual requests in order to perform one batch request.<br /><br /></li></ul><code>withTimerDelayInMilliseconds(100)</code> will be explained soon. <code>createCommand()</code> creates a <em>batch</em> command. This command should replace all individual commands and perform batched logic. In our case instead of multiple individual <code>load()</code> calls we just make one:<br /><br /><pre class="brush: groovy">class StockPricesBatchCommand extends HystrixCommand&lt;ImmutableMap&lt;Ticker, StockPrice&gt;&gt; {<br /><br />    private final StockPriceGateway gateway;<br />    private final Set&lt;Ticker&gt; stocks;<br /><br />    StockPricesBatchCommand(StockPriceGateway gateway, Set&lt;Ticker&gt; stocks) {<br />        super(HystrixCommandGroupKey.Factory.asKey("Stock"));<br />        this.gateway = gateway;<br />        this.stocks = stocks;<br />    }<br /><br />    @Override<br />    protected ImmutableMap&lt;Ticker, StockPrice&gt; run() throws Exception {<br />        return gateway.loadAll(stocks);<br />    }<br />}<br /></pre>The only difference between this class and <code>StockPriceCommand</code> is that it takes a bunch of <code>Ticker</code>s and returns prices for all of them. Hystrix will collect a few instances of <code>StockTickerPriceCollapsedCommand</code> and once it has <em>enough</em> (more on that later) it will create single <code>StockPriceCommand</code>. Hope this is clear, because <code>mapResponseToRequests()</code> is slightly more involved. Once our collapsed <code>StockPricesBatchCommand</code> finishes, we must somehow split batch response and communicate replies back to individual commands, unaware of collapsing. From that perspective <code>mapResponseToRequests()</code> implementation is fairly straightforward: we receive batch response and a collection of wrapped <code>CollapsedRequest&lt;StockPrice, Ticker&gt;</code>. We must now iterate over all awaiting individual requests and complete them (<code>setResponse()</code>). If we don't complete some of the requests, they will hang infinitely and eventually time out.<br /><br /><h1>How it works</h1>This is the right moment to describe how collapsing is implemented. I said before that collapsing happens when two requests occur at the same time. There is no such thing as <em>the same time</em>. In reality when first collapsible request comes in, Hystrix starts a timer. In our examples we set it to 100 milliseconds. During that period our command is suspended, waiting for other commands to join. After this configurable period Hystrix will call <code>createCommand()</code>, gathering all request keys (by calling <code>getRequestArgument()</code>) and run it. When batched command finishes, it will let us dispatch results to all awaiting individual commands. It is also possible to limit the number of collapsed requests if we are afraid of creating humongous batch - on the other hand how many concurrent requests can fit within this short time slot?<br /><br /><h1>Use cases and drawbacks</h1>Request collapsing should be used in systems with extreme load - high frequency of requests. If you get just one request per collapsing time window (100 milliseconds in examples), collapsing will just add overhead. That's because every time you call collapsible command, it must wait just in case some other command wants to join and form batch. This makes sense only when at least couple of commands are collapsed. Time wasted for waiting is balanced by savings in network latency and/or better utilization of resources in our collaborator (very often batch requests are much faster compared to individual calls). But keep in mind collapsing is a double edged sword, useful in specific cases.<br /><br />Last thing to remember - in order to use request collapsing you need <code>HystrixRequestContext.initializeContext()</code> and <code>shutdown()</code> in <code>try-finally</code> block:<br /><br /><pre class="brush: groovy">HystrixRequestContext context = HystrixRequestContext.initializeContext();<br />try {<br />    //...<br />} finally {<br />    context.shutdown();<br />}<br /></pre><h1>Collapsing vs. caching</h1>You might think that collapsing can be replaced with proper caching. This is not true. You use cache when:<br /><br /><ol><li>resource is likely to be accessed multiple times</li><li>we can safely use previous value, it will remain valid for some period of time <strong>or</strong> we know precisely how to invalidate it</li><li>we can afford concurrent requests for the same resource to compute it multiple times</li></ol>On the other hand collapsing does not enforce locality of data (1), it always hits the real service and never returns stale data (2). And finally if we ask for the same resource from multiple threads, we will only call backing service once (3). In case of caching, unless your cache is really smart, two threads will independently discover absence of given resource in cache and ask backing service twice. However collapsing can work <em>together</em> with caching - by consulting cache before running collapsible command.<br /><br /><h1>Summary</h1>Request collapsing is a useful tool, but with very limited use cases. It can significantly improve throughput in our system as well as limit load in external service. Collapsing can magically flatten peaks in traffic, rather than spreading it all over. Just make sure you are using it for commands running with extreme frequency.<br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>