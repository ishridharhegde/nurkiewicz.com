---
layout: post
title: Promises and Deferred objects in jQuery and AngularJS
date: '2013-03-11T19:46:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- jquery
- AJAX
- javascript
- AngularJS
modified_time: '2013-03-13T18:53:02.956+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3456021759982427019
blogger_orig_url: https://www.nurkiewicz.com/2013/03/promises-and-deferred-objects-in-jquery.html
---

<a href="http://nurkiewicz.blogspot.no/2013/02/javautilconcurrentfuture-basics.html">Series of articles about futures/promises</a> without JavaScript would not be complete. Futures (more commonly named <i>promises</i> in JS land) are ubiquitous in JavaScript to the point where we almost don't recognize them any more. AJAX, timeouts and whole <a href="http://nodejs.org/">Node.JS</a> are built on top of asynchronous callbacks. Nested callbacks (as we will see in just a second) are so hard to follow and maintain that the <a href="http://callbackhell.com/"><i>callback hell</i> term</a> was coined. In this article I will explain how <i>promises</i> can improve readability and modularize your code.<br /><br /><h2>Introducing promise object</h2>Let's take the first, simplest example using AJAX and <a href="http://api.jquery.com/jQuery.getJSON/"><code>$.getJSON()</code></a> helper method:<br /><br /><pre class="brush: javascript">$.getJSON('square/3', function(square) {<br />    console.info(square);<br />});<br /></pre><code>square/3</code> is an AJAX resource that yields <code>9</code> (<i>3 square</i>). I assume you are familiar with AJAX and understand that the callback logging <code>9</code> will be executed asynchronously once the response arrives from the server. As simple as that, but it quickly gets unwieldy  once you start nesting, chaining and wish to handle errors:<br /><br /><pre class="brush: javascript">$.getJSON('square/3', function(threeSquare) {<br />    $.getJSON('square/4', function(fourSquare) {<br />        console.info(threeSquare + fourSquare);<br />    });<br />});<br /><br />$.ajax({<br />    dataType: "json",<br />    url: 'square/10',<br />    success: function(square) {<br />        console.info(square);<br />    },<br />    error: function(e) {<br />        console.warn(e);<br />    }<br />});<br /></pre>Suddenly business logic is buried deeply inside nested callbacks (as a matter of fact this is still not bad, but it tends to be much worse in practice). There is another problem with callbacks - it's virtually impossible to write clean, reusable components once you need callbacks. For example I would like to encapsulate AJAX call with nice <code>function square(x)</code> utility. But how to "return" result? Typically developers simply require callback function to be provided, which is definitely not clean: <code>function square(x, callbackFun)</code>. Luckily we know the future/promise pattern and jQuery (as of 1.5 with further improvements in 1.8) implements it using <a href="http://wiki.commonjs.org/wiki/Promises/A">CommonJS Promises/A API proposal</a>:<br /><a name='more'></a><br /><br /><pre class="brush: javascript">function square(x) {<br />    return $.getJSON('square/' + x);<br />}<br /><br />var promise3 = square(3);<br />//or directly:<br />var promise3b = $.getJSON('square/3');<br /></pre>What does <code>square()</code> or more precisely <code>$.getJSON()</code> return? Call is not synchronous - we return a promise object! We "promise" that the result will be available some time in the future. How do we retrieve that result? In Java and Scala blocking on a <code>Future</code> is discouraged. In jQuery it's not even possible (at least there is no API). But we have a clean API for registering callbacks:<br /><br /><pre class="brush: javascript">promise3.done(function(threeSquare) {<br />    console.info(threeSquare);<br />});<br />promise3.done(function() {<br />    console.debug("Done");<br />});<br />promise3.done(function(threeSquare) {<br />    $('.result').text(threeSquare);<br />});<br /></pre>So, what's the difference? First of all we <i>return</i> something rather than take a callback - which makes code much more readable and pleasant to look at. Secondly we can register as many unrelated callbacks as we want and they are all executed in order. Finally <code>promise</code> object remembers the result so even if we register callback <i>after</i> promise was resolved (response arrived) it'll still be executed. But that's just a tip of an iceberg. Later we will see various techniques and patterns that emerge with promises in JavaScript.<br /><br /><h2>Combining promises</h2>First of all you can easily "wait" for two or more arbitrary promises:<br /><br /><pre class="brush: javascript">var promise3 = $.getJSON('square/3');<br />var promise5 = $.getJSON('square/5');<br /><br />$.when(promise3, promise5).done(<br />    function(threeSquare, fiveSquare) {<br />        console.info(threeSquare, fiveSquare);<br />    }<br />);<br /></pre>No nesting or state. Simply obtain two promises and let the library notify us when both results are available. Notice that <code>$.when(promise3, promise5)</code> returns another promise, so you can further chain and transform it. One shortcoming of <a href="http://api.jquery.com/jQuery.when/"><code>$.when</code></a> is that it doesn't accept (recognize) array of promises. But JavaScript is dynamic enough to workaround it easily:<br /><br /><pre class="brush: javascript">var promises = [<br />    $.getJSON('square/2'),<br />    $.getJSON('square/3'),<br />    $.getJSON('square/4'),<br />    $.getJSON('square/5')<br />];<br /><br />$.when.apply($, promises).done(function() {<br />    console.info(arguments);<br />});<br /></pre>If you find it hard to follow:<br /><br /><ol><li>Each <code>$.getJSON()</code> returns a promise object, thus <code>promises</code> is an array of promises (<i>duh!</i>)<br /><br /> </li><li>Each resolved promise is passed as a separate argument so we must use <code>arguments</code> pseudo-array to capture them all.<br /><br /> </li><li><code>done()</code> callback is executed when <i>all</i> promises are resolved (last AJAX call returns) but promises can come from any source, not necessarily from AJAX request (read further about <code>Deferred</code> object)<br /><br /> </li><li><code>$.when()</code> has exact same semantics as <a href="http://nurkiewicz.blogspot.no/2013/02/advanced-listenablefuture-capabilities.html"><code>Futures.allAsList()</code> in Guava</a> and <a href="http://nurkiewicz.blogspot.no/2013/03/futures-in-akka-with-scala.html"><code>Future.sequence()</code> in Akka/Scala</a>.<br /><br /> </li><li>(sidenote) Initiating several AJAX calls at the same time is not necessarily the best design, try combining them to improve performance and responsiveness.<br /><br /> </li></ol><h2>Custom promises with <code>Deferred</code></h2>We <a href="http://nurkiewicz.blogspot.no/2013/02/implementing-custom-future.html">implemented custom <code>Future</code></a> and <a href="http://nurkiewicz.blogspot.no/2013/03/deferredresult-asynchronous-processing.html"><code>ListenableFuture</code></a> before. Many developers are confused what is the difference between promise and <a href="http://api.jquery.com/category/deferred-object/"><code>$.Deferred</code></a> - this is exactly when we need it - to implement custom methods returning promises, just like <code>$.ajax()</code> and friends. Apart from AJAX, <a href="https://developer.mozilla.org/en-US/docs/DOM/window.setTimeout"><code>setTimeout()</code></a> and <a href="https://developer.mozilla.org/en-US/docs/DOM/window.setInterval"><code>setInterval()</code></a> are notoriously known for introducing nested callbacks. Can we do better with promises? Sure!<br /><br /><pre class="brush: javascript">function timeoutPromise(millis, context) {<br />    var deferred = $.Deferred();<br />    setTimeout(function() {<br />        deferred.resolve(context);<br />    }, millis);<br />    return deferred.promise();<br />}<br /><br />var promise = timeoutPromise(1000, 'Boom!');<br />promise.done(function(s) {<br />    console.info(s);<br />});<br /></pre>Every single line of <code>timeoutPromise()</code> is important so please study it carefully. First we create <code>$.Deferred()</code> instance which is basically a container for not yet resolved value (future). Later we register timeout to be triggers after <code>millis</code> milliseconds. Once that time elapses, we <i>resolve</i> the deferred object. When promise is resolved, all registered <code>done</code> callbacks are automatically called. Finally we return internal <code>promise</code> object to the client. Below you saw how such promise can be used - it's virtually the same as with AJAX. Can you guess what will be printed? Of course object represented by <code>context</code> in <code>deferred.resolve(context)</code> call, that is <code>'Boom!'</code> string.<br /><br />I hope I don't have to repeat myself highlighting that we can register as many callbacks as we want and if we register callback after promise was resolved (after timeout) it will still be executed, immediately.<br /><br /><h2>Monitoring progress</h2>Promises are nice but they don't fit when we would like to use <code>setInterval()</code> instead of <code>setTimeout()</code>. Future can only be resolved once while <code>setInterval()</code> can fire supplied callback multiple times. But jQuery promises have one unique feature which we haven't yet seen in our series: progress monitoring API. Before we resolve promise we can notify clients about its progress. It makes sense for long-running, multi-stage processes. Here is a utility for <code>setInterval()</code>:<br /><br /><pre class="brush: javascript">function intervalPromise(millis, count) {<br />    var deferred = $.Deferred();<br />    if(count &lt;= 0) {<br />        deferred.reject("Negative repeat count " + count);<br />    }<br />    var iteration = 0;<br />    var id = setInterval(function() {<br />        deferred.notify(++iteration, count);<br />        if(iteration &gt;= count) {<br />            clearInterval(id);<br />            deferred.resolve();<br />        }<br />    }, millis);<br />    return deferred.promise();<br />}<br /></pre><code>intervalPromise()</code> repeats <code>count</code> times every <code>millis</code> milliseconds. First notice call to <code>deferred.reject()</code> which will fail promise immediately (see below). Secondly pay attention to <code>deferred.notify()</code> which is called on every iteration to notify about progress. Here are two, equivalent ways of using this function. <code>fail()</code> callback will be used if promise was rejected:<br /><br /><pre class="brush: javascript">var notifyingPromise = intervalPromise(500, 4);<br /><br />notifyingPromise.<br />    progress(function(iteration, total) {<br />        console.debug("Completed ", iteration, "of", total);<br />    }).<br />    done(function() {<br />        console.info("Done");<br />    }).<br />    fail(function(e) {<br />        console.warn(e);<br />    });<br /></pre>Or:<br /><br /><pre class="brush: javascript">intervalPromise(500, 4).then(<br />    function() {<br />        console.info("Done");<br />    },<br />    function(e) {<br />        console.warn(e);<br />    },<br />    function(iteration, total) {<br />        console.debug("Completed ", iteration, "of", total);<br />    }<br />);<br /></pre>Second example above is a bit more compact but also slightly less readable. But they both produce the exact same output (progress messages printed every 500 ms):<br /><br /><pre class="brush: javascript">Completed 1 of 4<br />Completed 2 of 4<br />Completed 3 of 4<br />Completed 4 of 4<br />Done<br /></pre>Progress notifications probably make even more sense with multi-request AJAX calls. Imagine you need to performs two AJAX requests to complete some process. You want to let user know when the whole process finishes but also, optionally, when the first call finished. This might be useful to e.g. for building more responsive GUI. It's quite easy:<br /><br /><pre class="brush: javascript">function doubleAjax() {<br />    var deferred = $.Deferred();<br />    $.getJSON('square/3', function(threeSquare) {<br />        deferred.notify(threeSquare)<br />        $.getJSON('square/4', function(fiveSquare) {<br />            deferred.resolve(fiveSquare);<br />        });<br />    });<br />    return deferred.promise();<br />}<br /><br />doubleAjax().<br />    progress(function(threeSquare) {<br />        console.info("In the middle", threeSquare);<br />    }).<br />    done(function(fiveSquare) {<br />        console.info("Done", fiveSquare);<br />    });<br /></pre>Notice how we notify <code>promise</code> once the first request completes and resolve it in the end. Client is free to handle only <code>done()</code> callback or both. With traditional, callback-based APIs we would get <code>doubleAjax(doneCallback, progressCallback)</code> function taking two functions as an argument, where the second one is optional (?)<br /><br />Progress API is unavailable in other major languages we explored so far, which makes jQuery promises quite useful and interesting.<br /><br /><h2>Chaining and transforming promises</h2>One last thing I would like to share with you is chaining and transforming promises. The concept isn't new to us (both in <a href="http://nurkiewicz.blogspot.no/2013/02/advanced-listenablefuture-capabilities.html">Java</a> and <a href="http://nurkiewicz.blogspot.no/2013/02/advanced-listenablefuture-capabilities.html">Scala/Akka</a>). How would it look like in JavaScript? First define few low-level methods:<br /><br /><pre class="brush: javascript">function square(value) {<br />    return $.getJSON('square/' + value);<br />}<br /><br />function remoteDouble(value) {<br />    return $.getJSON('double/' + value);<br />}<br /><br />function localDouble(x) {<br />    return x * 2;<br />}<br /></pre>We can now seamlessly combine them:<br /><br /><pre class="brush: javascript">square(2).then(localDouble).then(function(doubledSquare) {<br />    console.info(doubledSquare);<br />});<br /><br />square(2).then(remoteDouble).then(localDouble).then(function(doubledSquare) {<br />    console.info(doubledSquare);<br />});<br /></pre>First example applies <code>localDouble()</code> function once the result arrives (2 square) and multiplies it by two. Thus final callback prints <code>8</code>. Second example is much more interesting. Please look carefully. When <code>square(2)</code> promise is resolved jQuery calls <code>remoteDouble(4)</code> (<code>4</code> is a result of asynchronous <code>square/2</code> AJAX call). But this function, again, returns a promise. Once <code>remoteDouble(4)</code> is resolved (returning 8), final <code>localDouble(8)</code> callback is applied and returns immediately, printing <code>16</code>. This construct allows us to chain AJAX calls (and any other promises) by providing result of one call as an argument to subsequent call.<br /><br /><h2>Promises in AngularJS</h2><a href="http://angularjs.org/">AngularJS</a> has one really neat feature, taking advantage of dynamic typing and promises. I believe jQuery could learn a lot from this simple idea and implement it in core library as well. But back to the point. This is a typical AJAX interaction updating GUI in AngularJS:<br /><br /><pre class="brush: javascript">angular.module('promise', []);<br /><br />function Controller($scope, $http) {<br />    $http.get('square/3').success(function(reply) {<br />        $scope.result = {data: reply};<br />    });<br />}<br /></pre>Where the template is as follows:<br /><br /><pre class="brush: javascript">&lt;body ng-app="promise" ng-controller="Controller"&gt;<br />    3 square: {{ "{{" }}result.data}}<br />&lt;/body&gt;<br /></pre>If you are not familiar with AngularJS - assigning value to <code>$scope</code> automatically updates all DOM elements referring to modified scope variables. Thus running this application will render <code>3 square: 9</code> once the response arrives. Looks pretty clean (notice that AngularJS uses promises as well!) But we can do much better! First some code:<br /><br /><pre class="brush: javascript">function Controller($scope, $http) {<br />    $scope.result = $http.get('square/3');<br />}<br /></pre>This code is much more clever than it looks like. Remember that <code>$http.get()</code> returns a <b>promise</b>, not a value. This means we are assigning promise (possibly not yet received AJAX response) to our scope. Still don't understand why I'm so excited? Try: <br /><br /><pre class="brush: javascript">`$('.result').text($.getJSON('square/3'))`<br /></pre>in jQuery. <b>Won't work</b>. But AngularJS is clever enough to recognize that scope variable is actually a promise. Thus instead of trying to render it (results in <code>[object Object]</code>)) it simply waits for it to resolve. Once promise is resolved it replaces it with its value and updates DOM. Automatically. No need to use callbacks, framework will understand that we don't want to display promise but the value of it, once resolved. And by the way AngularJS has its own implementation of <code>Deferred</code> and promises in <a href="http://docs.angularjs.org/api/ng.$q"><code>$q</code> service</a>.<br /><br /><h2>Summary</h2>By using promises instead of dreadful callbacks we can greatly simplify JavaScript code. It looks and feels much more imperative, despite asynchronous nature of JS applications. Also, as we already seen, concept of futures and promises is present in many modern programming languages, thus every programmer should be familiar and feel comfortable with them.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>