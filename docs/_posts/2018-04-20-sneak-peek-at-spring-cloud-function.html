---
layout: post
title: Sneak peek at spring-cloud-function serverless project
date: '2018-04-20T09:31:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- faas
- HTTP
- spring
- httpie
- serverless
modified_time: '2018-04-20T09:31:28.178+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3678137067896680324
blogger_orig_url: https://www.nurkiewicz.com/2018/04/sneak-peek-at-spring-cloud-function.html
---

Almost a year ago Spring team <a href="https://cloud.spring.io/spring-cloud-function/">announced <code>spring-cloud-function</code></a> umbrella project. It's basically a Spring's approach to serverless (I prefer the term <em>function-as-a-service</em>) programming. <code>Function&lt;T, R&gt;</code> becomes the smallest building block in a Spring application. Functions defined as Spring beans are automatically exposed e.g. via HTTP in RPC style. Just a quick example how it looks:<br /><br /><pre class="prettyprint linenums">@SpringBootApplication<br />public class FaasApplication {<br /><br />    public static void main(String[] args) throws Exception {<br />        SpringApplication.run(FaasApplication.class, args);<br />    }<br /><br />    @Bean<br />    Function&lt;Long, Person&gt; personById(PersonRepository repo) {<br />        return repo::findById;<br />    }<br /><br />}<br /><br />@Component<br />interface PersonRepository {<br />    Person findById(long id);<br /><br />    Mono&lt;Person&gt; findByIdAsync(long id);<br />}</pre>The implementation of <code>PersonRepository</code> is irrelevant here. This is a valid Spring Boot application. But once you put <code>spring-cloud-function</code> dependency, beans of <code>Function</code> type come alive:<br /><br /><pre class="prettyprint linenums">compile 'org.springframework.cloud:spring-cloud-function-web:1.0.0.M5'</pre>At this point each <code>Function</code> (as well as <code>Supplier</code> and <code>Consumer</code>) bean is exposed via HTTP API. I'm using <a href="https://httpie.org/">HTTPie</a> as a command-line client:<br /><br /><pre class="prettyprint linenums">$ echo 42 | http -v :8080/personById Content-type:text/plain<br />POST /personById HTTP/1.1<br />Content-Length: 3<br />Content-type: text/plain<br />...<br /><br />42</pre>The response:<br /><br /><pre class="prettyprint linenums">HTTP/1.1 200 <br />Content-Type: application/json;charset=UTF-8<br />Transfer-Encoding: chunked<br /><br />{<br />    "id": 42,<br />    "name": "Bob"<br />}</pre>Notice how <code>personById</code> bean of type <code>Function</code> turned into an HTTP endpoint. The <code>Flux</code> version called <code>peopleById</code> is even more interesting:<br /><br /><pre class="prettyprint linenums">@Bean<br />Function&lt;Flux&lt;Long&gt;, Flux&lt;Person&gt;&gt; peopleById(PersonRepository repo) {<br />    return ids -&gt; ids.flatMap(repo::findByIdAsync);<br />}</pre>It allows processing a stream of input <code>Long</code> values and produce a stream of corresponding people. Remember that <code>flatMap</code> used in the implementation may not preserve order!<br /><br /><pre class="prettyprint linenums">$ echo '[42,43]' | http -v :8080/peopleById <br />POST /peopleById HTTP/1.1<br />Content-Type: application/json<br />...<br /><br />[<br />    42,<br />    43<br />]</pre>This returns an array of results:<br /><br /><pre class="prettyprint linenums">HTTP/1.1 200 <br />Content-Type: application/json<br />Transfer-Encoding: chunked<br /><br />[<br />    {<br />        "id": 42,<br />        "name": "Bob"<br />    },<br />    {<br />        "id": 43,<br />        "name": "Alice"<br />    }<br />]</pre>Honestly, this whole <em>serverless</em> thing looks like RPC over HTTP so far. Or to put it more gently, a slightly simpler way of registering HTTP endpoints. Indeed, but this is just the beginning. First, let's define few more functions:<br /><br /><pre class="prettyprint linenums">@Bean<br />Function&lt;Flux&lt;Person&gt;, Flux&lt;Car&gt;&gt; carOfPerson() {<br />    return flux -&gt; flux.map(p -&gt; <br />        new Car("Honda", <br />                "FOO-123", <br />                p.getName() + " &lt;" + p.getId() + "&gt;"));<br />}<br /><br />@Bean<br />Function&lt;Flux&lt;Car&gt;, Flux&lt;String&gt;&gt; describe() {<br />    return flux -&gt; flux.map(c -&gt; <br />        c.getLicensePlate() + " (" + c.getModel() + <br />           ") owned by " + c.getOwnerName());<br />}</pre>The stub implementations are fine for the purpose of this exercise. Now we can call <code>carOfPerson</code> function remotely via HTTP:<br /><br /><pre class="prettyprint linenums">$ http -v :8080/carOfPerson id=42 name=Bob<br />POST /carOfPerson HTTP/1.1<br />Content-Type: application/json<br /><br />{<br />    "id": "42",<br />    "name": "Bob"<br />}</pre>POSTing a person (an argument to <code>carOfPerson</code> function) yields <code>Car</code> as a response:<br /><br /><pre class="prettyprint linenums">HTTP/1.1 200 <br />Content-Type: application/json<br />Transfer-Encoding: chunked<br /><br />[<br />    {<br />        "licensePlate": "FOO-123",<br />        "model": "Honda",<br />        "ownerName": "Bob &lt;42&gt;"<br />    }<br />]</pre>POSTing many instances of <code>Person</code> would obviously return many instances of <code>Car</code>. What about calling <code>describe(Car)</code> returning <code>String</code>?<br /><br /><pre class="prettyprint linenums">$ echo '{"licensePlate": "FOO-123", "model": "Honda", "ownerName": "Bob [42]"}' | \<br />      http -v :8080/describe<br />POST /describe HTTP/1.1<br />Content-Type: application/json<br /><br />{<br />    "licensePlate": "FOO-123",<br />    "model": "Honda",<br />    "ownerName": "Bob &lt;42&gt;"<br />}</pre>This returns a one-element array of strings:<br /><br /><pre class="prettyprint linenums">HTTP/1.1 200 <br />Content-Type: application/json<br />Transfer-Encoding: chunked<br /><br />[<br />    "FOO-123 (Honda) owned by Bob &lt;42&gt;"<br />]</pre>As a side-note, HTTPie makes working with JSON very convenient. Rather than piping the output of <code>echo</code> command, you can use this handy syntax:<br /><br /><pre class="prettyprint linenums">$ http -v :8080/describe \<br />      licensePlate='FOO-123' \<br />      model=Honda \<br />      ownerName='Bob &lt;42&gt;'<br /><br />POST /describe HTTP/1.1<br />Content-Type: application/json<br /><br />{<br />    "licensePlate": "FOO-123",<br />    "model": "Honda",<br />    "ownerName": "Bob &lt;42&gt;"<br />}</pre>Cool, but back to serverless.<br /><br /><h1 id="composing-functions-server-side">Composing functions server-side</h1>Calling individual functions is nice, but we can compose many functions, piping the result of one function to input of another:<br /><br /><pre class="prettyprint linenums">$ echo '[42, 43]' | \<br />    http :8080/peopleById | \<br />    http :8080/carOfPerson | \<br />    http :8080/describe</pre>This correctly returns an array of strings (<code>Flux&lt;Long&gt;</code> | <code>Flux&lt;Person&gt;</code> | <code>Flux&lt;Car&gt;</code> | <code>Flux&lt;String&gt;</code>)., However, we make numerous network round trips. A much better approach is to compose functions on the server side (wait, so there <strong>is</strong> a server in <i>serverless</i>?!?)<br /><br /><pre class="prettyprint linenums">$ echo '[42, 43]' | http -v :8080/peopleById,carOfPerson,describe<br />POST /peopleById,carOfPerson,describe HTTP/1.1<br />Content-Type: application/json<br /><br />[<br />    42,<br />    43<br />]</pre>Passing two IDs of <code>Person</code> and then composing (piping) three functions, basically<br /><br /><pre class="prettyprint linenums">describe . peopleById . carOfPerson</pre>or (if you're not the Haskell type of guy ðŸ˜‰)<br /><br /><pre class="prettyprint linenums">ids -&gt; describe(carOfPerson(peopleById(ids)))</pre>The response is expected:<br /><br /><pre class="prettyprint linenums">HTTP/1.1 200 <br />Content-Type: application/json<br />Date: Tue, 17 Apr 2018 14:13:59 GMT<br />Transfer-Encoding: chunked<br /><br />[<br />    "FOO-123 (Honda) owned by Bob [42]",<br />    "FOO-123 (Honda) owned by Bob [43]"<br />]</pre>OK, what we saw so far isn't particularly impressive. I'd rather use semi-standard <a href="https://en.wikipedia.org/wiki/JSON-RPC">JSON-RPC</a> if that's all the library has to offer. But <code>spring-cloud-function</code> offers another great feature: hot-deployment of functions.<br /><br /><h1 id="deploying-and-compiling-of-functions-at-runtime">Deploying and compiling of functions at runtime</h1>First, add the following dependency:<br /><br /><pre class="prettyprint linenums">compile 'org.springframework.cloud:spring-cloud-function-compiler:1.0.0.M5'</pre>Then expose the built-in <code>CompilerController</code>:<br /><br /><pre class="prettyprint linenums">import org.springframework.cloud.function.compiler.app.CompilerController<br /><br />@Bean<br />public CompilerController compilerController() {<br />    return new CompilerController();<br />}</pre>At this point we can POST raw Java code snippets to our application, which will be compiled to bytecode and saved for later execution:<br /><br /><pre class="prettyprint linenums">$ echo 's -&gt; s.length()' | \<br />        http -v :8080/function/len \<br />          inputType==String \<br />          outputType==Integer<br />POST /function/len?inputType=String&amp;outputType=Integer HTTP/1.1<br /><br />s -&gt; s.length()<br /><br /><br />HTTP/1.1 200 </pre>Underneath <code>spring-cloud-function-compiler</code> compiles this Java code snippet statically. For example, type mismatch error is properly reported (notice the <code>outputType</code> query parameter):<br /><br /><pre class="prettyprint linenums">$ echo 's -&gt; s.length()' | \<br />        http :8080/function/len \<br />          inputType==String \<br />          outputType==Long<br />HTTP/1.1 500 <br /><br />org.springframework.cloud.function.compiler.java.CompilationFailedException: ==========<br />  return (Function&lt;String,Long&gt; &amp; java.io.Serializable) s -&gt; s.length()<br />                                                                     ^^<br />ERROR:incompatible types: bad return type in lambda expression<br />    int cannot be converted to java.lang.Long</pre>You can also try to define more complex functions:<br /><br /><pre class="prettyprint linenums">$ echo "x -&gt; java.util.stream.IntStream \<br />             .range(2, x + 1) \<br />             .mapToObj(java.math.BigInteger::valueOf) \<br />             .reduce(java.math.BigInteger.ONE, java.math.BigInteger::multiply)" \<br />     | http :8080/function/factorial \<br />         inputType==Integer \<br />         outputType==java.math.BigInteger</pre>This one defines <code>factorial</code> function from <code>int</code> to <code>BigInteger</code>. Fully qualified class names are necessary.<br /><br /><h1 id="summary">Summary</h1>The project is still under active development and it's definitely not production ready. Also, the <a href="http://cloud.spring.io/spring-cloud-function/spring-cloud-function.html">documentation</a> is still not complete. However, it already has some support for serverless platforms like AWS lambda. I'm not an enthusiast when it comes to <em>function-as-a-service</em> deployment pattern, but it's good that Spring makes an effort to support this paradigm. I'm looking forward to next milestones!<br /><br />