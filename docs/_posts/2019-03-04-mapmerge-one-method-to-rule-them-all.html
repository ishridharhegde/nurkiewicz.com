---
layout: post
title: Map.merge() - One method to rule them all
date: '2019-03-04T10:08:00.000+01:00'
author: Tomasz Nurkiewicz
tags: 
modified_time: '2019-04-20T00:20:22.184+02:00'
thumbnail: https://4.bp.blogspot.com/-Vs7dzDKgj9A/XHcjNNO-yPI/AAAAAAAAp58/Y5Xr_orib_A3vHsfQhuPWTfCqXlSlv05wCK4BGAYYCw/s72-c/IMG_0537.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-6474215493985612572
blogger_orig_url: https://www.nurkiewicz.com/2019/03/mapmerge-one-method-to-rule-them-all.html
---

Russian translation available:&nbsp;<a
    href="https://mygpstools.com/mapmerge-metod-chtoby-upravlyat-vsemi-ostalnymi">Map.merge () - метод, чтобы управлять
    всеми остальными</a><br /><br />I don’t often explain a single method in JDK, but when I do, it’s about
<code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#merge(K,V,java.util.function.BiFunction)">Map.merge()</a></code>.
Probably the most versatile operation in the key-value universe. And also rather obscure and rarely used.
<code>merge()</code> can be explained as follows: it either puts new value under the given key (if absent) or updates
existing key with a given value (<em>UPSERT</em>). Let’s start with the most basic example: counting unique word
occurrences. Pre-Java 8 (read: pre-2014!) code was quite messy and the essence was lost in implementation
details:<br /><br />
<pre
    class="prettyprint linenums">var map = new HashMap&lt;String, Integer&gt;();<br />words.forEach(word -&gt; {<br />    var prev = map.get(word);<br />    if (prev == null) {<br />        map.put(word, 1);<br />    } else {<br />        map.put(word, prev + 1);<br />    }<br />});</pre>
However, it works and for given input produces desired output:<br /><br />
<pre
    class="prettyprint linenums">var words = List.of("Foo", "Bar", "Foo", "Buzz", "Foo", "Buzz", "Fizz", "Fizz");<br />//...<br />{Bar=1, Fizz=2, Foo=3, Buzz=2}</pre>
OK, but let’s try to refactor it to avoid conditional logic:<br /><br />
<pre
    class="prettyprint linenums">words.forEach(word -&gt; {<br />    map.putIfAbsent(word, 0);<br />    map.put(word, map.get(word) + 1);<br />});</pre>
That’s nice! <code>putIfAbsent()</code> is a necessary evil, otherwise, the code breaks on the first occurrence of a
previously unknown word. Also, I find <code>map.get(word)</code> inside <code>map.put()</code> a bit awkward. Let’s get
rid of it as well!<br /><br />
<pre
    class="prettyprint linenums">words.forEach(word -&gt; {<br />    map.putIfAbsent(word, 0);<br />    map.computeIfPresent(word, (w, prev) -&gt; prev + 1);<br />});</pre>
<code>computeIfPresent()</code> invokes given transformation only if key in question (<code>word</code>) exists.
Otherwise does nothing. We made sure key exists, by initializing it to zero, so incrementation always works. Can we do
better? We can cut the extra initialization, but I wouldn’t recommend it:<br /><br />
<pre
    class="prettyprint linenums">words.forEach(word -&gt;<br />        map.compute(word, (w, prev) -&gt; prev != null ? prev + 1 : 1)<br />);</pre>
<code>compute()</code> is like <code>computeIfPresent()</code>, but invoked irrespective to the existence of given key.
If value for the key does not exist, <code>prev</code> argument is <code>null</code>. Moving simple <code>if</code> to
ternary expression hidden in lambda is far from optimal. This is where <code>merge()</code> operator shines. Before I’ll
show you the final version, let’s see a slightly simplified default implementation of
<code>Map.merge()</code>:<br /><br />
<pre
    class="prettyprint linenums">default V merge(K key, V value, BiFunction&lt;V, V, V&gt; remappingFunction) {<br />    V oldValue = get(key);<br />    V newValue = (oldValue == null) ? value :<br />               remappingFunction.apply(oldValue, value);<br />    if (newValue == null) {<br />        remove(key);<br />    } else {<br />        put(key, newValue);<br />    }<br />    return newValue;<br />}</pre>
The code snippet is worth a thousand words. <code>merge()</code> works in two scenarios. If the given key is not
present, it simply becomes <code>put(key, value)</code>. However, if said key already holds some value, our
<code>remappingFunction</code> may merge (duh!) the old and the one. This function is free to:<br /><br />
<ul>
    <li>overwrite old value by simply returning the new one: <code>(old, new) -&gt; new</code></li>
    <li>keep the old value by simply returning the old one: <code>(old, new) -&gt; old</code></li>
    <li>somehow merge the two, e.g.: <code>(old, new) -&gt; old + new</code></li>
    <li>or even remove old value: <code>(old, new) -&gt; null</code></li>
</ul>As you can see <code>merge()</code> is quite versatile. So how does our academic problem look like with
<code>merge()</code>? It’s quite pleasing:<br /><br />
<pre
    class="prettyprint linenums">words.forEach(word -&gt;<br />        map.merge(word, 1, (prev, one) -&gt; prev + one)<br />);</pre>
You can read it as follows: put <code>1</code> under <code>word</code> key if absent, otherwise add <code>1</code> to
existing value. I named one of the parameters “<code>one</code>” because in our example it’s always… 1. Sadly
<code>remappingFunction</code> takes two parameters, where the second one is the value we are about to upsert (insert or
update). Technically we know this value already, so <code>(word, 1, prev -&gt; prev + 1)</code> would be much easier to
digest. But there’s no such API.<br /><br />All right, but is <code>merge()</code> <em>really</em> useful? Imagine you
have an account operation (constructor, getters and other useful properties omitted):<br /><br />
<pre
    class="prettyprint linenums">class Operation {<br />    private final String accNo;<br />    private final BigDecimal amount;<br />}</pre>
And a bunch of operations for different accounts:<br /><br />
<pre
    class="prettyprint linenums">var operations = List.of(<br />    new Operation("123", new BigDecimal("10")),<br />    new Operation("456", new BigDecimal("1200")),<br />    new Operation("123", new BigDecimal("-4")),<br />    new Operation("123", new BigDecimal("8")),<br />    new Operation("456", new BigDecimal("800")),<br />    new Operation("456", new BigDecimal("-1500")),<br />    new Operation("123", new BigDecimal("2")),<br />    new Operation("123", new BigDecimal("-6.5")),<br />    new Operation("456", new BigDecimal("-600"))<br />);</pre>
We would like to compute balance (total over operations’ amounts) for each account. Without <code>merge()</code> this is
quite cumbersome:<br /><br />
<pre
    class="prettyprint linenums">var balances = new HashMap&lt;String, BigDecimal&gt;();<br /><br />operations.forEach(op -&gt; {<br />    var key = op.getAccNo();<br />    balances.putIfAbsent(key, BigDecimal.ZERO);<br />    balances.computeIfPresent(key, (accNo, prev) -&gt; prev.add(op.getAmount()));<br />});</pre>
But with a little help of <code>merge()</code>:<br /><br />
<pre
    class="prettyprint linenums">operations.forEach(op -&gt;<br />        balances.merge(op.getAccNo(), op.getAmount(), <br />                (soFar, amount) -&gt; soFar.add(amount))<br />);</pre>
Do you see a method reference opportunity here?<br /><br />
<pre
    class="prettyprint linenums">operations.forEach(op -&gt;<br />        balances.merge(op.getAccNo(), op.getAmount(), BigDecimal::add)<br />);</pre>
I find this astoundingly readable. For each operation <code>add</code> given <code>amount</code> to given
<code>accNo</code>. The results are as expected:<br /><br />
<pre class="prettyprint linenums">{123=9.5, 456=-100}</pre>
<h1 id="concurrenthashmap"><code>ConcurrentHashMap</code></h1><code>Map.merge()</code> shines even brighter when you
realize it’s properly implemented in <code>ConcurrentHashMap</code>. This means we can atomically perform
insert-or-update operation. Single line and thread-safe. <code>ConcurrentHashMap</code> is obviously thread-safe, but
not across many operations, e.g. <code>get()</code> and then <code>put()</code>. However <code>merge()</code> makes sure
no updates are lost.<br /><br />
