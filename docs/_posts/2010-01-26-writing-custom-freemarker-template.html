---
layout: post
title: Writing custom FreeMarker template loaders in Spring
date: '2010-01-26T23:24:00.003+01:00'
author: Tomasz Nurkiewicz
tags:
- freemarker
- spring
modified_time: '2010-01-26T23:42:29.277+01:00'
thumbnail: http://2.bp.blogspot.com/_P3ewsGQzHn0/S19sC7-pVPI/AAAAAAAAATU/wzhDjOb_5PE/s72-c/ScreenShot012.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1639671970752023219
blogger_orig_url: https://www.nurkiewicz.com/2010/01/writing-custom-freemarker-template.html
---

...or "<span style="font-style: italic;">Thou shalt not hard-code any output messages in Java code</span>".<br /><br />Code is for program, algorithm, behavior, action. Code in any programming language is intended to express the data flow, not the data itself! But many programmers are forgetting about this rule, putting lots of data, both input and output, in source code. While hard-coding input data instead of loading it from some external resource is easy to spot, hard-coded parts of the output data are even more common. Typical examples are:<br /><br /><ul><li>Localized messages shown to the user. If you have a class with (...<span style="font-family: courier new;">public static final</span>...) strings containing different messages sent to the user, you might be proud of having all UI-specific labels in one place. Wrong! Changing messages require recompilation, as well as adding new translations (another classes?) Also all this strings are constantly present in the memory (PermGen space), being referenced by the class.</li><li>Contents of exception messages. This is part of a bigger problem of error handling: pass exception to the user interface and display original error message or create some sophisticated exception-translation mechanism? But if your user interface is not in English, would you throw an exception with localized message?</li><li>Printing HTML directly from a Servlet. Never do this! If you are unlucky and working directly with servlets, at least use request attributes and redirect from servlet to JSP. Using string concatenation and producing markup in Java code looks terrible and is very inefficient.</li><li>Producing other types of content (reports, XML, e-mail) similar to the servlet way mentioned above: by using string concatenations, typically in loops with many conditions.</li><li>Complicated SQL queries and even whole procedures. If the SQL query is parameterized (almost always), programmers tend to produce the query using string concatenation, also making their application vulnerable to <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection</a>. In this scenario use named parameters or <a href="http://ibatis.apache.org">iBATIS</a>. </li></ul><br />To make our case study code a bit better we are going to implement e-mail sending functionality example without hard-coding e-mail contents in Java sources. Actually, contents are going to be stored in the database as a <a href="http://freemarker.org">FreeMarker</a> templates, giving users flexibility of FreeMarker markup and ability to change the form of e-mail in any time (by issuing database update).<br /><br />Unfortunately (and as expected) FreeMarker has only few built-in mechanisms for loading templates (e.g. directly from the file system). But, also as expected, this mechanism can be easily (?) extended. The question mark is not here because of the complexity of this process, but very poor design of FreeMarker template loading API (see discussion at the end of this article).<br /><br />In order to make FreeMarker read templates from any source, one must implement  <a href="http://freemarker.org/docs/api/freemarker/cache/TemplateLoader.html"><span style="font-family: courier new;">TemplateLoader</span></a> interface. Before we take a look at it, another abstraction must be taken into account: <a style="font-family: courier new;" href="http://freemarker.org/docs/api/freemarker/cache/TemplateCache.html">TemplateCache</a>. It seems like loading and compiling templates takes significant amount of time for FreeMarker, so it lazy-loads and caches templates. Of course if the template has changed, FreeMarker must be able to discover it and invalidate the cache. Now we are finally ready to take a look at <span style="font-family: courier new;">TemplateLoader </span>interface and understand how it works, do we?<br /><br /><pre class="brush: java">public interface TemplateLoader {<br />   public Object findTemplateSource(String name) throws IOException;<br />   public long getLastModified(Object templateSource);<br />   public Reader getReader(Object templateSource, String encoding) throws IOException;<br />   public void closeTemplateSource(Object templateSource) throws IOException;<br />}</pre><br /><br />Is it obvious to you what all the methods do? And why <span style="font-family: courier new;">getLastModified()</span> does not declare <span style="font-family: courier new;">IOException </span>like other methods?<br /><br /><span style="font-family: courier new;">findTemplateSource()</span> returns <span style="font-style: italic;">some </span>object (name suggests it is template source). All other methods are taking <span style="font-family: courier new;">templateSource</span> as an argument. I had to study few built-in implementations to finally discover how it works. When implementing custom template loader, <span style="font-family: courier new;">findTemplateSource()</span> should return <span style="font-style: italic;">something </span>that denotes source of a specific template given by name. This <span style="font-style: italic;">something</span> (literally <span style="font-style: italic;">any</span> <span style="font-family: courier new;">Object</span> instance) is then used by FreeMarker as a key in its cache, where value is the template itself (<a href="http://freemarker.sourceforge.net/docs/api/freemarker/template/Template.html"><span style="font-family: courier new;">Template</span></a> instance). If the value denoted by this key is not found, FreeMarker asks <span style="font-family: courier new;">TemplateLoader</span> again to read template contents via getReader(). If template is already found in cache, FreeMarker will just check whether the template has not been modified in the meantime (using <span style="font-family: courier new;">getLastModified()</span>) and re-read template if necessary.<br /><br />Enough of the theory. We are going to store our e-mail templates in the following JPA entities:<br /><br /><pre class="brush: java">@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)<br />public class EmailTemplate {<br /><br />   private String name;<br />   private String content;<br />   private Calendar lastModified = Calendar.getInstance();<br /><br />   public void updateLastModified() {<br />       setLastModified(Calendar.getInstance());<br />   }<br /><br />}</pre><br /><br />Getters/setters, as always, omitted – if only I used Groovy, I would never have to write this clause again.<br /><br />I don't like JPA annotations, if you know how to avoid Hibernates' <span style="font-family: courier new;">@Cache</span> and use other source of configuration, please let me know. So piece of the <span style="font-family: courier new;">orm.xml</span> looks like this:<br /><br /><pre class="brush: xml">&lt;entity class="com.blogspot.nurkiewicz.email.EmailTemplate"&gt;<br />   &lt;pre-persist method-name="updateLastModified"/&gt;<br />   &lt;pre-update method-name="updateLastModified"/&gt;<br />   &lt;attributes&gt;<br />       &lt;id name="name"/&gt;<br />       &lt;basic name="content"&gt;<br />           &lt;column length="10000"/&gt;<br />           &lt;lob/&gt;<br />       &lt;/basic&gt;<br />       &lt;basic name="lastModified"&gt;<br />           &lt;temporal&gt;TIMESTAMP&lt;/temporal&gt;<br />       &lt;/basic&gt;<br />   &lt;/attributes&gt;<br />&lt;/entity&gt;</pre><br /><br />I use <span style="font-family: courier new;">pre-persist</span> and <span style="font-family: courier new;">pre-update</span> hooks to automatically update <span style="font-family: courier new;">lastModified</span> field. This is very convenient and one of the very few use cases for these methods – they don't have access to the <span style="font-family: courier new;">EntityManager</span>, so, sadly, no audit/trigger functionality can be achieved in plain JPA.<br /><br />Having entity object representing single e-mail template, all that has left is implementing simple template loader:<br /><br /><pre class="brush: java">@Repository<br />public class EmailDatabaseTemplateLoader implements TemplateLoader {<br /><br />   @PersistenceContext<br />   private EntityManager em;<br /><br />   public Object findTemplateSource(String name) throws IOException {<br />       return em.find(EmailTemplate.class, name);<br />   }<br /><br />   public long getLastModified(Object templateSource) {<br />       final EmailTemplate emailTemplate = (EmailTemplate) templateSource;<br />       em.refresh(emailTemplate);<br />       return emailTemplate.getLastModified().getTimeInMillis();<br />   }<br /><br />   public Reader getReader(Object templateSource, String encoding) throws IOException {<br />       return new StringReader(((EmailTemplate) templateSource).getContent());<br />   }<br /><br />   public void closeTemplateSource(Object templateSource) throws IOException {<br />   }<br />}</pre><br /><br />To wire everything up, we must tell Spring to use our template loader, which happens to be a Spring bean with <span style="font-family: courier new;">Repository</span> stereotype. Luckily, Spring has support for FreeMarker. As you can see even the whole stack of loaders can be configured – if first loader does not find the template, second is asked. Single loader is fine for us:<br /><br /><pre class="brush: xml">&lt;bean id="freemarkerConfiguration" class="org.springframework.ui.freemarker.FreeMarkerConfigurationFactoryBean"&gt;<br />   &lt;property name="preTemplateLoaders"&gt;<br />       &lt;list&gt;<br />           &lt;ref bean="databaseTemplateLoader"/&gt;<br />       &lt;/list&gt;<br />   &lt;/property&gt;<br />&lt;/bean&gt;<br />&lt;bean name="databaseTemplateLoader" class="com.blogspot.nurkiewicz.email.EmailDatabaseTemplateLoader"/&gt;</pre><br /><br />That's all, now we can simply inject <a href="http://freemarker.sourceforge.net/docs/api/freemarker/template/Configuration.html"><span style="font-family: courier new;">Configuration</span></a> instance into any Spring bean, load some template and process it using given model. Spring provides handy utility class for that:<br /><br /><pre class="brush: java">String email = FreeMarkerTemplateUtils.processTemplateIntoString(freemarkerCfg.getTemplate("FULL_EMAIL"), emailModel)</pre><br /><br />Well, everything is working, but the purpose of this article was not to help you with developing custom template loader for FreeMarker (although I hope it helped). My goal was to show you some epic code smell introduced by FreeMarker developers designing <span style="font-family: courier new;">TemplateLoader</span> contract.<br /><br /><span style="font-family: courier new;">TemplateLoader</span> might return <span style="font-style: italic;">any </span>object it likes. The FreeMarker framework does not know anything about the true nature of this object (whether it is <span style="font-family: courier new;">File</span>, <span style="font-family: courier new;">URL</span>, or your JPA entity instance). So in order to extract some information from the template source, FreeMarker passes this returned object back to the loader and basically says: "<span style="font-style: italic;">OK, you have returned <span style="font-weight: bold;">this </span>previously. Could you please tell me what is the last modification time of <span style="font-weight: bold;">this</span></span>". And then: "<span style="font-style: italic;">Nice, so could you please load the template using </span><span style="font-weight: bold; font-style: italic;">this</span><span style="font-style: italic;"> somehow</span>". Wouldn't it be better to call this returned object itself instead of asking third actor (TemplateLoader)? The object should be able to performs tasks that correspond to its state and make decisions on its own.<br /><br />This might be considered as a violation of a <a href="http://pragprog.com/articles/tell-dont-ask">Tell, Don't Ask</a> principle. Clearly the FreeMarker developers wanted to avoid another abstraction (template source) and simply used <span style="font-family: courier new;">Object</span> instead to create an illusion of flexibility. This is how it should be done:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_P3ewsGQzHn0/S19sC7-pVPI/AAAAAAAAATU/wzhDjOb_5PE/s1600-h/ScreenShot012.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 156px;" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/S19sC7-pVPI/AAAAAAAAATU/wzhDjOb_5PE/s200/ScreenShot012.png" alt="" id="BLOGGER_PHOTO_ID_5431178473348093170" border="0" /></a><br /><br />or even better (can you see the difference? Why it's better?):<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_P3ewsGQzHn0/S19r9Ib8cPI/AAAAAAAAATM/WDJ5i_K4LFE/s1600-h/ScreenShot013.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 155px;" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/S19r9Ib8cPI/AAAAAAAAATM/WDJ5i_K4LFE/s200/ScreenShot013.png" alt="" id="BLOGGER_PHOTO_ID_5431178373612990706" border="0" /></a><br /><br />Whenever you see plain <span style="font-family: courier new;">Object </span>in the source code, you are almost always missing some abstraction. Whenever instanceof operator is used (God forbids!), probably polymorphism should have been introduced. Don't be afraid of refactoring and do not hesitate to use interfaces. Otherwise you will end up with "<span style="font-style: italic;">map programming</span>" - where each method takes a map and returns a map and every map can nest other maps. Surely, the flexibility is unbelievable, no classes, no interfaces... and nobody who would ever be able to maintain such "flexible" code.