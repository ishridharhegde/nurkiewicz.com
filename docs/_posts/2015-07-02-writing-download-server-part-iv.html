---
layout: post
title: 'Writing a download server. Part IV: Implement HEAD operation (efficiently)'
date: '2015-07-02T23:39:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- spring mvc
- HTTP
- spring
modified_time: '2015-07-08T23:32:27.494+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5121285155551732326
blogger_orig_url: https://www.nurkiewicz.com/2015/07/writing-download-server-part-iv.html
---

<code>HEAD</code> is an often forgotten HTTP method (verb) that behaves just like GET, but does not return body. You use HEAD in order to check the existence of a resource (it should return 404 in case of absence) and make sure you don't have a stale version in your cache. In that case you expect <code>304 Not Modified</code>, while 200 means the server has more recent version. You can e.g. use HEAD to efficiently implement software updates. In that case <code>ETag</code> is your application version (build, tag, commit hash) and you have a fixed <code>/most_recent</code> endpoint. Your software sends HEAD request with current version in <code>ETag</code>. If there were no updates, server will reply with 304. In case of 200 you can ask user whether she wants to upgrade without downloading the software yet. Finally requesting <code>GET /most_recent</code> will always download the most recent version of your software. The power of HTTP!<br /><br />In servlets <code>HEAD</code> is implemented by default in <code>doHead()</code> which you are suppose to override. The default implementation just delegates to <code>GET</code> but discards body. This can't be efficient, especially when you load your resources from outside, like Amazon S3. Luckily (?) Spring MVC doesn't implement HEAD by default, so you have to do it manually. Let's start from few integration tests of HEAD:<br /><br /><pre class="brush: java">def 'should return 200 OK on HEAD request, but without body'() {<br />    expect:<br />        mockMvc<br />            .perform(<br />                head('/download/' + FileExamples.TXT_FILE_UUID))<br />            .andExpect(<br />                    status().isOk())<br />            .andExpect(<br />                    content().bytes(new byte[0]))<br />}<br /><br />def 'should return 304 on HEAD request if we have cached version'() {<br />    expect:<br />        mockMvc<br />            .perform(<br />                head('/download/' + FileExamples.TXT_FILE_UUID)<br />                        .header(IF_NONE_MATCH, FileExamples.TXT_FILE.getEtag()))<br />            .andExpect(<br />                status().isNotModified())<br />            .andExpect(<br />                header().string(ETAG, FileExamples.TXT_FILE.getEtag()))<br />}<br /><br />def 'should return Content-length header'() {<br />    expect:<br />        mockMvc<br />            .perform(<br />                head('/download/' + FileExamples.TXT_FILE_UUID))<br />            .andExpect(<br />                status().isOk())<br />            .andExpect(<br />                header().longValue(CONTENT_LENGTH, FileExamples.TXT_FILE.size))<br />}<br /></pre>The actual implementation is quite straightforward, but requires a bit of refactoring in order to avoid duplication. Download endpoint now accepts both GET and HEAD:<br /><br /><pre class="brush: java">@RequestMapping(method = {GET, HEAD}, value = "/{uuid}")<br />public ResponseEntity&lt;Resource&gt; download(<br />        HttpMethod method,<br />        @PathVariable UUID uuid,<br />        @RequestHeader(IF_NONE_MATCH) Optional&lt;String&gt; requestEtagOpt,<br />        @RequestHeader(IF_MODIFIED_SINCE) Optional&lt;Date&gt; ifModifiedSinceOpt<br />        ) {<br />    return storage<br />            .findFile(uuid)<br />            .map(pointer -&gt; new ExistingFile(method, pointer))<br />            .map(file -&gt; file.handle(requestEtagOpt, ifModifiedSinceOpt))<br />            .orElseGet(() -&gt; new ResponseEntity&lt;&gt;(NOT_FOUND));<br />}<br /></pre>I created a new abstraction <code>ExistingFile</code>, which encapsulates found <code>FilePointer</code> and HTTP verb we invoke on it. <code>ExistingFile.handle()</code> has all what it takes to serve file or just metadata via HEAD:<br /><br /><pre class="brush: java">public class ExistingFile {<br /><br />    private static final Logger log = LoggerFactory.getLogger(ExistingFile.class);<br /><br />    private final HttpMethod method;<br />    private final FilePointer filePointer;<br /><br />    public ExistingFile(HttpMethod method, FilePointer filePointer) {<br />        this.method = method;<br />        this.filePointer = filePointer;<br />    }<br /><br />    public ResponseEntity&lt;Resource&gt; handle(Optional&lt;String&gt; requestEtagOpt, Optional&lt;Date&gt; ifModifiedSinceOpt) {<br />        if (requestEtagOpt.isPresent()) {<br />            final String requestEtag = requestEtagOpt.get();<br />            if (filePointer.matchesEtag(requestEtag)) {<br />                return notModified(filePointer);<br />            }<br />        }<br />        if (ifModifiedSinceOpt.isPresent()) {<br />            final Instant isModifiedSince = ifModifiedSinceOpt.get().toInstant();<br />            if (filePointer.modifiedAfter(isModifiedSince)) {<br />                return notModified(filePointer);<br />            }<br />        }<br />        return serveDownload(filePointer);<br />    }<br /><br />    private ResponseEntity&lt;Resource&gt; serveDownload(FilePointer filePointer) {<br />        log.debug("Serving {} '{}'", method, filePointer);<br />        final InputStreamResource resource = resourceToReturn(filePointer);<br />        return response(filePointer, OK, resource);<br />    }<br /><br />    private InputStreamResource resourceToReturn(FilePointer filePointer) {<br />        if (method == HttpMethod.GET)<br />            return buildResource(filePointer);<br />        else<br />            return null;<br />    }<br /><br />    private InputStreamResource buildResource(FilePointer filePointer) {<br />        final InputStream inputStream = filePointer.open();<br />        return new InputStreamResource(inputStream);<br />    }<br /><br />    private ResponseEntity&lt;Resource&gt; notModified(FilePointer filePointer) {<br />        log.trace("Cached on client side {}, returning 304", filePointer);<br />        return response(filePointer, NOT_MODIFIED, null);<br />    }<br /><br />    private ResponseEntity&lt;Resource&gt; response(FilePointer filePointer, HttpStatus status, Resource body) {<br />        return ResponseEntity<br />                .status(status)<br />                .eTag(filePointer.getEtag())<br />                .lastModified(filePointer.getLastModified().toEpochMilli())<br />                .body(body);<br />    }<br /><br />}<br /></pre><code>resourceToReturn()</code> is crucial. If it returns <code>null</code>, Spring MVC will not include any body in response. Everything else remains the same (response headers, etc.)<br /><br /><hr /><h2>Writing a download server</h2><ul><li><a href="http://www.nurkiewicz.com/2015/06/writing-download-server-part-i-always.html">Part I: Always stream, never keep fully in memory</a></li><li><a href="http://www.nurkiewicz.com/2015/06/writing-download-server-part-ii-headers.html">Part II: headers: Last-Modified, ETag and If-None-Match</a></li><li><a href="http://www.nurkiewicz.com/2015/06/writing-download-server-part-iii.html">Part III: headers: Content-length and Range</a></li><li><A href="http://www.nurkiewicz.com/2015/07/writing-download-server-part-iv.html"><strong>Part IV: Implement <code>HEAD</code> operation (efficiently)</strong></a></li><li><A href="http://www.nurkiewicz.com/2015/07/writing-download-server-part-v-throttle.html">Part V: Throttle download speed</a></li><li><a href="http://www.nurkiewicz.com/2015/07/writing-download-server-part-vi.html">Part VI: Describe what you send (Content-type, et.al.)</a></li></ul>The <a href="https://github.com/nurkiewicz/download-server">sample application</a> developed throughout these articles is available on GitHub.<br /><br /><script>SyntaxHighlighter.highlight();</script>