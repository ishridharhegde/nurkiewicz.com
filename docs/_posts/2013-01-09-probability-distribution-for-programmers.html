---
layout: post
title: Probability distribution for programmers
date: '2013-01-09T20:02:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- probability
- scala
- puzzles
modified_time: '2013-01-09T20:02:46.234+01:00'
thumbnail: http://2.bp.blogspot.com/-3pLcuRCtCFM/UO29phgvedI/AAAAAAAAArw/FaTpKd_mPa0/s72-c/distribution.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5554563912317406972
blogger_orig_url: https://www.nurkiewicz.com/2013/01/probability-distribution-for-programmers.html
---

This is one of these very simple programming puzzles I came across recently: <br /><br /><blockquote><b>given a function returning random integers from <code>0</code> to <code>4</code> inclusive with equal probability, write a function returning random integers from <code>0</code> to <code>6</code> inclusive.</b></blockquote>Of course the solution should also return equally distributed numbers. So letâ€™s start from an input function sample definition:<br /><br /><pre class="brush: scala">def rand4() = (math.random * 5).toInt<br /></pre>Your task is to implement <code>rand6()</code> by only using <code>rand4()</code>. Give yourself few minutes and continue reading.<br /><br />.<br /><br />.<br /><br />. <br /><br />The first approach is pretty straightforward but happens to be completely broken:<br /><a name='more'></a><br /><br /><pre class="brush: scala">def rand6() = rand4() * 3 / 2<br /></pre>As simple as that. In ideal solution each output value from <code>0</code> to <code>6</code> should appear with the probability of <code>1/7</code>. Can you tell from the code above, what's the probability of <code>rand6()</code> returning <code>2</code> or <code>5</code>? That's right, it's no more than <code>0</code>, you'll never get these values. I hope it's clear why. So let's go for something more sophisticated:<br /><br /><pre class="brush: scala">def rand6() = (rand4() + rand4()) % 7<br /></pre>Looks better, but still pretty far. The code above has two major flaws. First of all the results of <code>rand4() + rand4()</code> expression range from <code>0</code> to <code>8</code> but we need <code>0</code> to <code>6</code>. The obvious solution is to use <code>% 7</code> operation. However this results in <code>0</code> and <code>1</code> being returned twice as often because <code>7</code> and <code>8</code> are overflowing to <code>0</code> and <code>1</code>. So what about this:<br /><br /><pre class="brush: scala">def rand6(): Int = {<br />    val rand8 = rand4() + rand4()<br />    if(rand8 &gt; 6)<br />        rand6()<br />    else<br />        rand8<br />}<br /></pre>I hope the recursion (which can easily be turned into loop, but I leave that work to the Scala compiler) is not obscuring the intent - if the sum of two <code>rand4()</code> invocations is above expected result, we simply discard it and call <code>rand6()</code> again. However there is still one subtle but striking bug, quoting Wikipedia on <a href="http://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">uniform distribution</a><br /><br /><blockquote>The sum of two independent, equally distributed, uniform distributions yields a symmetric <a href="http://en.wikipedia.org/wiki/Triangular_distribution">triangular distribution</a>.</blockquote>If you don't quite get the above, have a look at <a href="http://jsfiddle.net/nurkiewicz/SXCMF/1/">this live demo in JavaScript using <code>&lt;canvas/&gt;</code></a> illustrating what Wikipedia means:<br /><br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-3pLcuRCtCFM/UO29phgvedI/AAAAAAAAArw/FaTpKd_mPa0/s1600/distribution.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="209" src="http://2.bp.blogspot.com/-3pLcuRCtCFM/UO29phgvedI/AAAAAAAAArw/FaTpKd_mPa0/s640/distribution.png" width="640" /></a></div><h1></h1>This program simply places pixels at <i>random</i> <code>(X, Y)</code> positions on each panel. In the first panel I use one <code>Math.random() * 300</code> call scaled to fit whole canvas. As you can see the distribution is more or less uniform. But we can't tell that about second and third panels. On the second panel I am using the sum of two uniformly distributed variables, in principle: <code>(Math.random() + Math.random()) * 150)</code>. Even though this expression can return anything between <code>0</code> and <code>300</code>, the points are very biased toward the middle of the canvas (triangular distribution). The same behaviour is emphasized on the third panel where ten invocations of <code>Math.random()</code> are used.<br /><br /><h3>The correct answer</h3>The approach I'm taking is based on the observation that <code>rand4()</code> is capable of producing two random least significant bits. So let's start from implementing <code>rand3()</code> with known semantics:<br /><br /><pre class="brush: scala">def rand3(): Int = rand4() match {<br />    case 4 =&gt; rand3()<br />    case x =&gt; x<br />}<br /></pre><code>rand3()</code> returns uniformly distributed values from <code>0</code> to <code>3</code> doing so by rejecting <code>4</code> output of <code>rand4()</code>. How will that help us? Well, we now have two random bits, each one being either <code>0</code> or <code>1</code> with 50% probability. We can easily widen it for larger sequences, e.g. <code>rand15()</code> and <code>rand7()</code>:<br /><br /><pre class="brush: scala">def rand15() = (rand3() &lt;&lt; 2) + rand3()<br />def rand7() = rand15() &gt;&gt; 1<br /></pre>You should be rather comfortable with the bit fiddling above. Having the ability to produce two random bits I can easily generate 4 and 3. Now <code>rand6()</code> is a no-brainer:<br /><br /><pre class="brush: scala">def rand6() = rand7() match {<br />    case 7 =&gt; rand6()<br />    case x =&gt; x<br />}<br /></pre><hr />Just to make this lesson a little bit more interesting, let's implement <code>randN(n: Int)</code> on top of <code>rand4()</code>. <code>randN()</code> should return uniformly distributed natural values from <code>0</code> to <code>n</code>. I'll begin by implementing helper method <code>atLeastKrandBits(k: Int)</code> returning... <i>at least K random bits</i>:<br /><br /><pre class="brush: scala">def atLeastKrandBits(k: Int): Int = k match {<br />    case 0 =&gt; 0<br />    case 1 =&gt; rand3() &gt;&gt; 1<br />    case 2 =&gt; rand3()<br />    case b =&gt; (atLeastKrandBits(k - 2) &lt;&lt; 2) + rand3()<br />}<br /></pre><a href="http://c2.com/cgi/wiki?ThereIsMoreThanOneWayToDoIt">Alternative implementation</a> with <code>foldLeft()</code>: <br /><br /><pre class="brush: scala">def atLeastKrandBits(k: Int) = (0 to (k + 1) / 2).foldLeft(0){<br />    (acc, _) =&gt; (acc &lt;&lt; 2) + rand3()<br />}<br /></pre>...or if you really hate those to maintain your code:<br /><br /><pre class="brush: scala">def atLeastKrandBits(k: Int) = (0 /: (0 to (k + 1) / 2)){<br />    (acc, _) =&gt; (acc &lt;&lt; 2) + rand3()<br />}<br /></pre>Having any of the implementations above <code>randN(n: Int)</code> is simple:<br /><br /><pre class="brush: scala">def randN(n: Int) = {<br />    val bitsCount = java.lang.Integer.highestOneBit(n)<br />    val randBits = atLeastKrandBits(bitsCount)<br />    if(randBits &gt; n)<br />        randN(n)<br />    else<br />        randBits<br />}<br /></pre><h3>Conclusions</h3>You might ask yourself a question: <i>why should I even care?</i> If you fail to understand probability distribution your application might produce random output that's actually quite easy to predict. It's not a big deal if you are writing a game and enemies are more likely to appear at some places on the map (but the players <i>will</i> discover and abuse it!) But if you need random numbers for security reasons or you rely on uniform distribution e.g. for load-balancing purposes - any bias might become fatal.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>