---
layout: post
title: 'Dependency injection: syntax sugar over function composition'
date: '2015-08-31T19:36:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
- spring
- functional programming
- Haskell
modified_time: '2015-12-20T13:49:59.369+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8955559170984561270
blogger_orig_url: https://www.nurkiewicz.com/2015/08/dependency-injection-syntax-sugar-over.html
---

Quoting <a href="http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html">Dependency Injection Demystified</a>:<br/><br/> <blockquote> &quot;Dependency Injection&quot; is a 25-dollar term for a 5-cent concept.<br/><br/> </blockquote> *James Shore, 22 Mar, 2006<br/><br/>  Dependency injection, as much as it is important when writing testable, composable and well-structured applications, means nothing more than having objects with constructors. In this article I want to show you how dependency injection is basically just a syntax sugar that hides <a href="https://en.wikipedia.org/wiki/Currying">function currying</a> and composition. Don't worry, we'll go very slowly trying to explain why these two concepts are very much a like.<br/><br/> <h2 id="setters-annotations-and-constructors">Setters, annotations and constructors</h2> Spring bean or EJB is a Java object. However if you look closely most beans are actually stateless after creation. Calling methods on Spring bean rarely modifies the state of that bean. Most of the time beans are just convenient namespaces for a bunch of procedures working in similar context. We don't modify the state of <code>CustomerService</code> when calling <code>invoice()</code>, we merely delegate to another object, which will eventually call database or web service. This is already far from object-oriented programming (what I discussed <a href="http://www.nurkiewicz.com/2009/10/ddd-in-spring-made-easy-with-aspectj.html">here</a>). So essentially we have procedures (we'll get into functions later) in multi-level hierarchy of namespaces: packages and classes they belong to. Typically these procedures call other procedures. You might say they call methods on bean's dependencies, but we already learned that beans are a lie, these are just groups of procedures.<br/><br/>  That being said let's see how you can configure beans. In my career I had episodes with setters (and tons of <code>&lt;property name=&quot;...&quot;&gt;</code> in XML), <code>@Autowired</code> on fields and finally constructor injection. See also: <a href="http://pillopl.github.io/constructor-injection/">Why injecting by constructor should be preffered?</a>. So what we typically have is an object that has immutable references to its dependencies:<br/><br/> <pre class="brush: java">@Component<br />class PaymentProcessor {<br /><br />    private final Parser parser;<br />    private final Storage storage;<br /><br />    @Autowired<br />    public PaymentProcessor(Parser parser, Storage storage) {<br />        this.parser = parser;<br />        this.storage = storage;<br />    }<br /><br />    void importFile(Path statementFile) throws IOException {<br />            try(Stream<String> lines = Files.lines(statementFile)) {<br />                lines<br />                        .map(parser::toPayment)<br />                        .forEach(storage::save);<br />            }<br />    }<br /><br />}<br /><br /><br />@Component<br />class Parser {<br />    Payment toPayment(String line) {<br />        //om-nom-nom...<br />    }<br />}<br /><br /><br />@Component<br />class Storage {<br /><br />    private final Database database;<br /><br />    @Autowired<br />    public Storage(Database database) {<br />        this.database = database;<br />    }<br /><br />    public UUID save(Payment payment) {<br />        return this.database.insert(payment);<br />    }<br />}<br /><br /><br />class Payment {<br />    //...<br />}</pre> Take a file with bank statements, parse each individual line into <code>Payment</code> object and store it. As boring as you can get. Now let's refactor a little bit. First of all I hope you are aware that object-oriented programming is a lie. Not because it's just a bunch of procedures in namespaces so-called classes (I hope you are not writing software this way). But because objects are implemented as procedures with implicit <code>this</code> parameter, when you see: <code>this.database.insert(payment)</code> it is actually compiled into something like this: <code>Database.insert(this.database, payment)</code>. Don't believe me?<br/><br/> <pre class="brush: java">$ javap -c Storage.class <br />...<br />  public java.util.UUID save(com.nurkiewicz.di.Payment);<br />    Code:<br />       0: aload_0<br />       1: getfield      #2                  // Field database:Lcom/nurkiewicz/di/Database;<br />       4: aload_1<br />       5: invokevirtual #3                  // Method com/nurkiewicz/di/Database.insert:(Lcom/nurkiewicz/di/Payment;)Ljava/util/UUID;<br />       8: areturn</pre> OK, if you are normal, this is no proof for you, so let me explain. <code>aload_0</code> (representing <code>this</code>) followed by <code>getfield #2</code> pushes <code>this.database</code> to operand stack. <code>aload_1</code> pushes first method parameter (<code>Payment</code>) and finally <code>invokevirtual</code> calls <em>procedure</em> <code>Database.insert</code> (there is some polymorphism involved here, irrelevant in this context). So we actually invoked two-parameter procedure, where first parameter was filled automatically by compiler and is named... <code>this</code>. On the callee side <code>this</code> is valid and points to <code>Database</code> instance.<br/><br/> <h1 id="forget-about-objects">Forget about objects</h1> Let's make all of this more explicit and forget about objects:<br/><br/> <pre class="brush: java">class ImportDependencies {<br /><br />    public final Parser parser;<br />    public final Storage storage;<br />    <br />    //...<br /><br />}<br /><br />static void importFile(ImportDependencies thiz, Path statementFile) throws IOException {<br />    Files.lines(statementFile)<br />            .map(thiz.parser::toPayment)<br />            .forEach(thiz.storage::save);<br />}</pre> That's mad! Notice that <code>importFile</code> <em>procedure</em> is now outside <code>PaymentProcessor</code>, which I actually renamed to <code>ImportDependencies</code> (pardon <code>public</code> modifier for fields). <code>importFile</code> can be <code>static</code> because all dependencies are explicitly given in <code>thiz</code> container, not implicit using <code>this</code> and instance variables - and can be implemented anywhere. Actually we just refactored to what already happens behind the scenes during compilation. At this stage you might be wondering why we need an extra container for dependencies rather than just passing them directly. Sure, it's pointless:<br/><br/> <pre class="brush: java">static void importFile(Parser parser, Storage storage, Path statementFile) throws IOException {<br />    Files.lines(statementFile)<br />            .map(parser::toPayment)<br />            .forEach(storage::save);<br />}</pre> Actually some people prefer passing dependencies explicitly to business methods like above, but that's not the point. It's just another step in the transformation.<br/><br/> <h1 id="currying">Currying</h1> For the next step we need to rewrite our function into Scala:<br/><br/> <pre class="brush: java">object PaymentProcessor {<br /><br />  def importFile(parser: Parser, storage: Storage, statementFile: Path) {<br />    val source = scala.io.Source.fromFile(statementFile.toFile)<br />    try {<br />      source.getLines()<br />        .map(parser.toPayment)<br />        .foreach(storage.save)<br />    } finally {<br />      source.close()<br />    }<br />  }<br /><br />}</pre> It's functionally equivalent, so not much to say. Just notice how <code>importFile()</code> belongs to <code>object</code>, so it's somewhat similar to <code>static</code> methods on a singleton in Java. Next we'll <a href="http://docs.scala-lang.org/tutorials/tour/currying.html">group parameters</a>:<br/><br/> <pre class="brush: java">def importFile(parser: Parser, storage: Storage)(statementFile: Path) { //...</pre> This makes all the difference. Now you can either supply all dependencies all the time or better, do it just once:<br/><br/> <pre class="brush: java">val importFileFun: (Path) =&gt; Unit = importFile(parser, storage)<br /><br />//...<br /><br />importFileFun(Paths.get(&quot;/some/path&quot;))</pre> Line above can actually be part of container setup, where we bind all dependencies together. After setup we can use <code>importFileFun</code> anywhere, being clueless about other dependencies. All we have is a function <code>(Path) =&gt; Unit</code>, just like <code>paymentProcessor.importFile(path)</code> in the very beginning.<br/><br/> <h1 id="functions-all-the-way-down">Functions all the way down</h1> We still use objects as dependencies, but if you look carefully, we need neither <code>parser</code> nor <code>storage</code>. What we really need is a <em>function</em>, that can parse (<code>parser.toPayment</code>) and a <em>function</em> that can store (<code>storage.save</code>). Let's refactor again:<br/><br/> <pre class="brush: java">def importFile(parserFun: String =&gt; Payment, storageFun: Payment =&gt; Unit)(statementFile: Path) {<br />  val source = scala.io.Source.fromFile(statementFile.toFile)<br />  try {<br />    source.getLines()<br />      .map(parserFun)<br />      .foreach(storageFun)<br />  } finally {<br />    source.close()<br />  }<br />}</pre> Of course we can do the same with Java 8 and lambdas, but syntax is more verbose. We can provide any function for parsing and storage, for example in tests we can easily create stubs. Oh, and BTW, we just transformed from object-oriented Java to function composition and no objects at all. Of course there are still side effects, e.g. loading file and storing, but let's leave it like that. Or, to make similarity between dependency injection and function composition even more striking, check out equivalent program in Haskell:<br/><br/> <pre class="brush: java">let parseFun :: String -&gt; Payment<br />let storageFun :: Payment -&gt; IO ()<br />let importFile :: (String -&gt; Payment) -&gt; (Payment -&gt; IO ()) -&gt; FilePath -&gt; IO ()<br /><br />let simpleImport = importFile parseFun storageFun<br />// :t simpleImport<br />// simpleImport :: FilePath -&gt; IO ()</pre> First of all <code>IO</code> monad is required to manage side effects. But do you see how <code>importFile</code> higher order function takes three parameters, but we can supply just two and get <code>simpleImport</code>? This is what we call dependency injection in Spring or EJB for that matter. But without syntax sugar.<br/><br/> PS: <a href="https://www.webucator.com/java-training/index.cfm">Webucator</a> did a <a href="https://www.youtube.com/watch?v=he_9E0ayRws">video based on this article</a>. Thanks!  <script>SyntaxHighlighter.highlight();</script>