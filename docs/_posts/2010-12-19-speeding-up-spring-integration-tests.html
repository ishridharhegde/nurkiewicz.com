---
layout: post
title: Speeding up Spring integration tests
date: '2010-12-19T21:32:00.001+01:00'
author: Tomasz Nurkiewicz
tags:
- testing
- spring
- intellij idea
- junit
modified_time: '2011-11-17T19:07:24.748+01:00'
thumbnail: http://1.bp.blogspot.com/_P3ewsGQzHn0/TQ5ocRt0jMI/AAAAAAAAAYY/X02PDMxXH_o/s72-c/inspection1.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3890409264693841643
blogger_orig_url: https://www.nurkiewicz.com/2010/12/speeding-up-spring-integration-tests.html
---

<div><a href="http://www.blogger.com/post-edit.g?blogID=6753769565491687768&amp;postID=3890409264693841643" name="__DdeLink__6_1527370377"></a><span>The biggest problem with unit testing using Spring <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/testing.html">testing support</a>* is the time it takes to initialize the Spring framework context. Every new test case adds precious seconds to overall build time. After a while it will take minutes or even hours to fully build the application, while most of this time is consumed by Spring itself. But we'll start from the basics.</span></div><div><br /></div><div><span>In order to make JUnit aware of Spring framework test support, simply add these </span><span>annotations on test case class:</span></div><div><br /></div><div><span><pre class="brush: java"><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration<br />@Transactional<br />public class MainControllerTest {<br />    //...<br />}<br /></pre></span></div><div><br /></div><div><span>While <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">@Transactional</span> is not necessary, it will greatly simplify testing when database is involved (details <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/testing.html#testcontext-tx">here</a>). In IntelliJ IDEA </span><span>10 </span><span>(I just took </span><span>this brand </span><span>new version for a test drive) these annotations will raise the following error to occur:</span></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_P3ewsGQzHn0/TQ5ocRt0jMI/AAAAAAAAAYY/X02PDMxXH_o/s1600/inspection1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/_P3ewsGQzHn0/TQ5ocRt0jMI/AAAAAAAAAYY/X02PDMxXH_o/s1600/inspection1.png" /></a></div><div><span><br /></span></div><div><br /></div><div><span>And suggested solution:<a name='more'></a></span><br /></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_P3ewsGQzHn0/TQ5ojlh6YKI/AAAAAAAAAYc/sc8emChy13c/s1600/inspection2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/_P3ewsGQzHn0/TQ5ojlh6YKI/AAAAAAAAAYc/sc8emChy13c/s1600/inspection2.png" /></a></div><div><span><br /></span></div><div><br /></div><div><span>You now have two options: either create the file named the same as your test case with <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">-context.xml</span> suffix (and in the same package) as suggested or use different file and specify its name explicitly using locations attribute to <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/test/context/ContextConfiguration.html"><span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">@ContextConfiguration</span></a>. Following convention over configuration for now I recommend you to follow the Spring naming convention. When using Maven, your class under test should reside in <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">src/main/java</span>, test case in <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">src/test/java</span> and Spring configuration file in <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">src/test/resources</span> (</span><span>but </span><span>see <a href="http://youtrack.jetbrains.net/issue/IDEA-61829">IDEA-61829</a>):</span></div><br /><div><span><pre class="brush: plain"><br />pom.xml<br />src<br />|-- main<br />|    -- java<br />|       `-- com<br />|           `-- blogspot<br />|               `-- nurkiewicz<br />|                   `-- spring<br />|                       `-- test<br />|                           `-- web<br />|                               `-- MainController.java<br />`-- test<br />    |-- java<br />    |   `-- com<br />    |       `-- blogspot<br />    |           `-- nurkiewicz<br />    |               `-- spring<br />    |                   `-- test<br />    |                       `-- web<br />    |                           `-- MainControllerTest.java<br />    `-- resources<br />         -- com<br />            `-- blogspot<br />                `-- nurkiewicz<br />                    `-- spring<br />                        `-- test<br />                            `-- web<br />                                `-- MainControllerTest-context.xml<br /></pre> </span></div><div><br /></div><div><span>In case you'll get lost, IDEA </span><span>provides magnificent Packages view in Project explorer:</span></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_P3ewsGQzHn0/TQ5ojijbRfI/AAAAAAAAAYg/DaiZgz69JdM/s1600/packages.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/TQ5ojijbRfI/AAAAAAAAAYg/DaiZgz69JdM/s1600/packages.png" /></a></div><div><span><br /></span></div><div><br /></div><div><span>As you can see files in different physical directories are all located in the same logic</span><span>al</span><span> directory corresponding to the package. This is especially useful when working with <a href="http://wicket.apache.org/">Wicket</a> web framework, where each page class must have equivalent HTML file, preferably in <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">src/main/resources</span>.</span></div><div><br /></div><div><span>Coming back to Spring. When running the test case, Spring runner will automatically open the <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">*-context.xml</span> file and initialize the application context described in this file. The context will typically contain class under test bean definition along with its direct dependencies. Now you can inject every bean from the context directly to your test case class:</span></div><div><br /></div><div><span><pre class="brush: java"><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration<br />public class MainControllerTest {<br /><br /> @Resource<br /> private MainController mainController;<br /><br /> @Test<br /> public void smokeTest() throws Exception {<br />  //mainController...<br /> }<br /><br />}<br /><br /></pre></span></div><div><br /></div><div><span>The important thing to remember is that spring context will be initialized prior the first test method is executed and (unless you use <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/test/annotation/DirtiesContext.html"><span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">@DirtiesContext</span></a> annotation) will be reused </span><span>(rather than recreated) </span><span>for every </span><span>subsequent test </span><span>method </span><span>in this test case. This is a way of decreasing the test execution time. Although it is a myth that Spring context initialization takes so much time, but some of your own beans might increase this time significantly. For instance Hibernate/JPA persistence providers or embedded <a href="http://activemq.apache.org/">ActiveMQ</a> server are huge facilities taking several seconds to boot up. This is the major drawback of Spring tests, making many developers reluctant to them.</span></div><div><br /></div><div><span>What <a href="http://kezzler.com/">we</a> recently discovered is that Spring out of the box supports reusing once initialized context even in different test case classes </span><span>across your artifact</span><span>. This means that in best case scenario you pay the price of context startup only once and use the same context across all your tests, making startup time less relevant and insignificant compared to the overall build time.</span></div><div><br /></div><div><span>In order to benefit from this feature, you must forget everything I said about convention over configuration. Now every test case has its own context configuration file, treated as independent application context. </span><span>But if you reuse the same file in every test case, Spring will figure out that every test case points to the same file and simply reuse the context as well, </span><span>for example</span><span>:</span></div><div><br /></div><div><span><pre class="brush: java"><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = "classpath:test-context.xml")<br />@Transactional<br />public class MainControllerTest {<br />    //...<br />}<br /><br />//...<br /><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = "classpath:test-context.xml")<br />@Transactional<br />public class BarRepositoryTest {<br />    //...<br />}<br /><br />//...<br /><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = "classpath:test-context.xml")<br />@Transactional<br />public class BarServiceTest {<br />    //...<br />}<br /><br />//...<br /><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = "classpath:test-context.xml")<br />@Transactional<br />public class FooRepositoryTest {<br />    //...<br />}<br /><br />//...<br /><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = "classpath:test-context.xml")<br />@Transactional<br />public class FooServiceTest {<br />    //...<br />}<br /><br /></pre></span></div><div><br /></div><div><span>By the way if you are disgusted by the annotations repetition, inheritance comes to the rescue.</span></div><div><br /></div><div><span>There are few consequences of single vs. specialized context for every test case. First of all, the single context must be suitable for </span><span>each and </span><span>every test case, which means it must contain all beans being tested (effectively: almost whole application). This means that even though the complete build will be much faster, running a separate test case will cost you </span><span>much more time</span><span>. But there is a workaround for that as well. In your complete test context simply declare:</span></div><div><br /></div><div><span><pre class="brush: xml"><br />&lt;beans default-lazy-init="true"&gt;<br /></pre></span></div><div><br /></div><div><span>This will cause loading only these beans, that are necessary in this particular test. And when running a full test suite, all beans will be lazily initialized one after another. In one context per test case approach each test context has only carefully chosen, fine grained beans. In single context you must have all the beans </span><span>declared</span><span>, but thanks to lazy loading </span><span>not all of them will be created when not needed.</span></div><div><br /></div><div><span>To sum things up. In order to get the most of your Spring integration testing, take your production application context, mocking only necessary dependencies like database or JMS. Thanks to that you will avoid repeating the bean definitions in production and test XML context files. Once having </span><span>one, </span><span><i>master</i></span><span> test context, point to it in every test case to make efficient use of Spring context caching. Happy testing!</span></div><div><br /></div><div><span>* Even bigger problem is that such tests shouldn't be considered as unit tests at all, as they test system as a whole rather than separate class (unit). That is why you should consider Spring-powered tests as integration tests and treat them as complementary to unit tests rather than their substitution.</span></div><div><br /></div><div><br /></div>