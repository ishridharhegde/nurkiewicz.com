---
layout: post
title: Logging exceptions root cause first
date: '2011-09-23T22:43:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- stack traces
- logging
- logback
modified_time: '2012-10-06T12:25:24.059+02:00'
thumbnail: http://2.bp.blogspot.com/-89nDr6bsVSI/Tnzs8_R1SfI/AAAAAAAAAfo/KuGtmJ_gnkE/s72-c/causedby.log.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5094207683393029370
blogger_orig_url: https://www.nurkiewicz.com/2011/09/logging-exceptions-root-cause-first.html
---

The <a href="http://logback.qos.ch/news.html">0.9.30</a> release of <a href="http://logback.qos.ch/">Logback</a> logging library brings new awesome feature: logging stack traces starting from root (innermost) exception rather than from the outermost one. Of course my excitement has nothing to do with the fact that <a href="http://logback.qos.ch/apidocs/ch/qos/logback/classic/pattern/RootCauseFirstThrowableProxyConverter.html">I contributed</a> this feature...<br /><br /><br /><br />To paraphrase Cecil B. de Mille: “<i>The way to make a blog post is to begin with a stack trace and work up to a climax</i>” - here it goes:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-89nDr6bsVSI/Tnzs8_R1SfI/AAAAAAAAAfo/KuGtmJ_gnkE/s1600/causedby.log.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="450" src="http://2.bp.blogspot.com/-89nDr6bsVSI/Tnzs8_R1SfI/AAAAAAAAAfo/KuGtmJ_gnkE/s640/causedby.log.png" width="640" /></a></div><br /><br />The details aren't important yet, but from 100ft view you can see long stack trace with several exceptions wrapping each other (<i>causing</i><span style="font-style: normal;">). We'll go back to this stack trace, but first some basics. If you throw an exception it will be logged in a way showing how the stack was looking in the moment when the exception was from. At the very bottom you will either see <span style="font-family: 'Courier New', Courier, monospace;">static main()</span> or <span style="font-family: 'Courier New', Courier, monospace;">Thread.run()</span> proceeded by methods invoked up to the first stack trace line indicating the place where the actual exception was thrown. This is very convenient since you can see the whole control flow that resulted in the exception:</span><br /><a name='more'></a><br /><br /><br /><br /><span style="font-style: normal;"><pre class="brush: java"><br />public class BookController {<br /><br />  private final BookService bookService = new BookService();<br /><br />  public void alpha() { beta(); }<br /><br />  private void beta() { gamma(); }<br /><br />  private void gamma() { bookService.delta(); }<br /><br />  public static void main(String[] args) {<br />    new BookController().alpha();<br />  }<br />}<br /><br />class BookService {<br /><br />  private final BookDao bookDao = new BookDao();<br /><br />  public void delta() { epsilon(); }<br /><br />  private void epsilon() { zeta(); }<br /><br />  private void zeta() { bookDao.eta(); }<br />}<br /><br />class BookDao {<br /><br />  public void eta() { theta(); }<br /><br />  private void theta() { iota(); }<br /><br />  public void iota() { throw new RuntimeException("Omega server not available"); }<br />}<br /></pre></span><br /><br /><span style="font-style: normal;">If you don't know the <a href="http://en.wikipedia.org/wiki/Greek_alphabet">Greek alphabet</a>, you can start learning from the stack trace (remember, the control flow starts at the bottom and works its way up):</span><br /><br /><br /><br /><span style="font-style: normal;"><pre class="brush: plain"><br />java.lang.RuntimeException: Omega server not available<br />  at BookDao.iota(BookController.java:50)<br />  at BookDao.theta(BookController.java:48)<br />  at BookDao.eta(BookController.java:46)<br />  at BookService.zeta(BookController.java:41)<br />  at BookService.epsilon(BookController.java:39)<br />  at BookService.delta(BookController.java:37)<br />  at BookController.gamma(BookController.java:22)<br />  at BookController.beta(BookController.java:20)<br />  at BookController.alpha(BookController.java:18)<br />  at BookController.main(BookController.java:26)<br /><br /></pre></span><br /><br /><br /><br /><span style="font-style: normal;">Wonderful, right? When reading from top to bottom you can say: </span><i>iota() was called by theta() was called by eta()</i><span style="font-style: normal;">... Clear and simple. However what if somebody decides to wrap the original exception and re-throw it?</span><br /><br /><br /><br /><span style="font-style: normal;"><pre class="brush: java"><br />public class BookController {<br /><br />  private static final Logger log = LoggerFactory.getLogger(BookController.class);<br /><br />  private final BookService bookService = new BookService();<br /><br />  public void alpha() { beta(); }<br /><br />  private void beta() { gamma(); }<br /><br />  private void gamma() {<br />    try {<br />      bookService.delta();<br />    } catch (Exception e) {<br />      throw new RuntimeException("Sorry, try again later", e);<br />    }<br />  }<br /><br />  public static void main(String[] args) {<br />    try {<br />      new BookController().alpha();<br />    } catch (Exception e) {<br />      log.error("", e);<br />    }<br />  }<br />}<br /><br />class BookService {<br /><br />  private final BookDao bookDao = new BookDao();<br /><br />  public void delta() { epsilon(); }<br /><br />  private void epsilon() { zeta(); }<br /><br />  private void zeta() {<br />    try {<br />      bookDao.eta();<br />    } catch (Exception e) {<br />      throw new RuntimeException("Unable to save order", e);<br />    }<br />  }<br />}<br /><br />class BookDao {<br /><br />  public void eta() { theta(); }<br /><br />  private void theta() { iota(); }<br /><br />  public void iota() {<br />    try {<br />      throw new RuntimeException("Omega server not available");<br />    } catch (Exception e) {<br />      throw new RuntimeException("Database problem", e);<br />    }<br />  }<br />}<br /><br /></pre></span><br /><br /><br /><br /><span style="font-style: normal;">Now quickly: find the root cause in the stack trace!</span><br /><br /><br /><br /><span style="font-style: normal;"><pre class="brush: plain"><br />java.lang.RuntimeException: Sorry, try again later<br />  at BookController.gamma(BookController.java:26)<br />  at BookController.beta(BookController.java:20)<br />  at BookController.alpha(BookController.java:18)<br />  at BookController.main(BookController.java:32)<br />Caused by: java.lang.RuntimeException: Unable to save order<br />  at BookService.zeta(BookController.java:51)<br />  at BookService.epsilon(BookController.java:45)<br />  at BookService.delta(BookController.java:43)<br />  at BookController.gamma(BookController.java:24)<br />  ... 8 common frames omitted<br />Caused by: java.lang.RuntimeException: Database problem<br />  at BookDao.iota(BookController.java:66)<br />  at BookDao.theta(BookController.java:60)<br />  at BookDao.eta(BookController.java:58)<br />  at BookService.zeta(BookController.java:49)<br />  ... 11 common frames omitted<br />Caused by: java.lang.RuntimeException: Omega server not available<br />  at BookDao.iota(BookController.java:64)<br />  ... 14 common frames omitted<br /></pre></span><br /><br /><br /><br /><span style="font-style: normal;">Turns out that <span style="font-family: 'Courier New', Courier, monospace;">main()</span> is no longer the last line. Even worse, everything seems garbled, try to read the Greek alphabet again... Now let's go back to our original stack trace. It comes from Spring framework startup failure, imagine it can be several pages long.</span><br /><br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-UjNwQ8LgHac/Tnzs9xcbhQI/AAAAAAAAAfs/Zp0DhfDrzm8/s1600/causedby-arrows.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="460" src="http://4.bp.blogspot.com/-UjNwQ8LgHac/Tnzs9xcbhQI/AAAAAAAAAfs/Zp0DhfDrzm8/s640/causedby-arrows.png" width="640" /></a></div><br /><br /><br /><br /><span style="font-style: normal;">For you convenience I added arrows to mark you the path you should follow to reconstruct the control flow: starting from the red arrow's tail (<span style="font-family: 'Courier New', Courier, monospace;">Thread.run()</span>) somewhere in the middle you go up and then... jump to the tail of orange arrow. From the head of the orange arrow you jump to the tail of the green one and so on... Not very intuitive, don't you think? And what is this red ellipse showing? Yes, it is the root cause of the failure (the innermost exception). On the other hand the exception printed at the very beginning (the one you typically read on the first place) says something about an <i style="font-family: &quot;Courier New&quot;,Courier,monospace;">error creating DefaultAnnotationHandlerMapping#0</i> (<i>what?</i>) The true error (<i><span style="font-family: 'Courier New', Courier, monospace;">No matching bean of type...</span></i>) is cleverly hidden...</span><br /><br /><br /><br /><span style="font-style: normal;">So what is this <a href="http://logback.qos.ch/manual/layouts.html#rootException">new feature</a> all about? Again our simple example. After upgrading to 0.9.30 just add <span style="font-size: large;"><b><a href="http://logback.qos.ch/manual/layouts.html#rootException" style="font-family: &quot;Courier New&quot;,Courier,monospace;">%rEx</a></b></span>(or equivalent <b><span style="font-family: 'Courier New', Courier, monospace;">%rootException</span></b>) at the end of your logging pattern:</span><br /><br /><code style="font-size: 14px;">&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;<br />&nbsp;&nbsp;&lt;encoder&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;pattern&gt;%d %level %m%n<strong>%rEx</strong>&lt;/pattern&gt;<br />&nbsp;&nbsp;&lt;/encoder&gt;<br />&lt;/appender&gt;</code><br /><br /><span style="font-style: normal;">This will replace the default stack trace printing routing with the one I humbly contributed. The same Greek program will now print:</span><br /><br /><br /><br /><pre class="brush: plain"><br />java.lang.RuntimeException: Omega server not available<br />  at BookDao.iota(BookController.java:64)<br />Wrapped by: java.lang.RuntimeException: Database problem<br />  at BookDao.iota(BookController.java:66)<br />  at BookDao.theta(BookController.java:60)<br />  at BookDao.eta(BookController.java:58)<br />  at BookService.zeta(BookController.java:49)<br />Wrapped by: java.lang.RuntimeException: Unable to save order<br />  at BookService.zeta(BookController.java:51)<br />  at BookService.epsilon(BookController.java:45)<br />  at BookService.delta(BookController.java:43)<br />  at BookController.gamma(BookController.java:24)<br />Wrapped by: java.lang.RuntimeException: Sorry, try again later<br />  at BookController.gamma(BookController.java:26)<br />  at BookController.beta(BookController.java:20)<br />  at BookController.alpha(BookController.java:18)<br />  at BookController.main(BookController.java:32)<br /></pre><br /><br /><br /><br />Please compare it carefully with the previous output. First of all, the very first line points to the problem. No digging in the “<span style="font-family: 'Courier New', Courier, monospace;">Caused by</span>” exceptions, most of the time you will probably skip the rest. Secondly, the control flow is uninterrupted and continuous – you can still read it from top to bottom or vice-versa. And last but not least – the fact that exceptions were wrapped in the meantime is preserved but does not garble the stack trace.<br /><br /><br /><br />Now you deserve to see the original Spring exception taking advantage of <span style="font-family: 'Courier New', Courier, monospace;">%rEx</span> printing:<br /><br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-cgyIJ13n4VE/Tnzs_0yZVSI/AAAAAAAAAf0/GIzCYbVdITE/s1600/wrappedby-arrows.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="430" src="http://1.bp.blogspot.com/-cgyIJ13n4VE/Tnzs_0yZVSI/AAAAAAAAAf0/GIzCYbVdITE/s640/wrappedby-arrows.png" width="640" /></a></div><br /><br /><br /><br />The observations are exactly the same: root cause of the problem appears at the very beginning, shortening the time the problem needs to be investigated. Also when analysing the control flow there is not jumping – <span style="font-family: 'Courier New', Courier, monospace;">Thread.main()</span> is at the bottom and you can read the trace from bottom to top continuously.<br /><br /><br /><br />If you “work” a lot with stack traces (either in development or in production/support) – consider switching to root cause first logging. It will save you few seconds every time you analyse particular exception. But I also noticed inexperienced developers sometimes aren't even aware of “<i><span style="font-family: 'Courier New', Courier, monospace;">Caused by</span></i>” rule: <i>find first exception and look at the last <span style="font-family: 'Courier New', Courier, monospace;">Caused by</span></i> – remaining clueless what the problem is, looking only at the outermost, least specific, most generic error. This will help them as well.<br /><br /><br /><br />By the way – all this hustle can be avoided if you avoid wrapping and re-throwing exception altogether. I know, all too often we are forced to do so by checked exceptions...<br /><br /><br /><br />