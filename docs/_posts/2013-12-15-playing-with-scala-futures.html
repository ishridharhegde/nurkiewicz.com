---
layout: post
title: Playing with Scala futures
date: '2013-12-15T22:37:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- scala
- concurrency
modified_time: '2013-12-22T20:26:09.668+01:00'
thumbnail: http://4.bp.blogspot.com/-Gy-gumTNQbA/Uq4glJVhh5I/AAAAAAAAA3I/PDStLScIbso/s72-c/kolsasstoppen-1.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1756823750730610764
blogger_orig_url: https://www.nurkiewicz.com/2013/12/playing-with-scala-futures.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-Gy-gumTNQbA/Uq4glJVhh5I/AAAAAAAAA3I/PDStLScIbso/s1600/kolsasstoppen-1.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-Gy-gumTNQbA/Uq4glJVhh5I/AAAAAAAAA3I/PDStLScIbso/s1600/kolsasstoppen-1.jpg" height="149" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">View from Kols√•stoppen</td></tr></tbody></table>During job interviews we often give Scala developers a simple design task: to model a binary tree. The simplest but not necessarily best implementation involves <code>Option</code> idiom:<br /><br /><pre class="brush: scala">case class Tree[+T](value: T, left: Option[Tree[T]], right: Option[Tree[T]])<br /></pre>Bonus points for immutability, using <code>case</code> class and covariance. Much better but more complex implementation involves two <code>case</code> classes but at least allows modelling empty trees:<br /><br /><pre class="brush: scala">sealed trait Tree[+T]<br />case object Empty extends Tree[Nothing]<br />case class Node[+T](value: T, left: Tree[T], right: Tree[T]) extends Tree[T]<br /></pre>Let's stick to the first idea. Now implement building a tree with arbitrary height:<br /><br /><pre class="brush: scala">def apply[T](n: Int)(block: =&gt; T): Tree[T] = n match {<br />    case 1 =&gt; Tree(block, None, None)<br />    case _ =&gt;<br />        Tree(<br />            block,<br />            Some(Tree(n - 1)(block)),<br />            Some(Tree(n - 1)(block))<br />        )<br />}<br /></pre>In order to build a tree with 1024 leaves and all random variable it's enough to say:<br /><br /><pre class="brush: scala">val randomTree: Tree[Double] = Tree(1 + 10)(math.random)<br /></pre>This is an open-ended question, next requirement may be to write a <code>map</code> method equivalent to <code>Seq.map()</code> or <code>Option.map()</code>. Understanding what that means is part of the question. The implementation is surprisingly straightforward:<br /><br /><pre class="brush: scala">case class Tree[+T](value: T, left: Option[Tree[T]], right: Option[Tree[T]]) = {<br /><br />def map[R](f: T =&gt; R): Tree[R] =<br />    Tree(<br />        f(value), <br />         left.map{_.map(f)}, <br />        right.map{_.map(f)})    <br />}<br /></pre>OK... <code>.map{_.map(f)}</code>, are you kidding me? Remember that <code>left</code> and <code>right</code> are <code>Option</code>s and <code>Option.map(f)</code> turns <code>Option[T]</code> to <code>Option[R]</code>. So first <code>map</code> comes from an <code>Option</code>. Second <code>_.map(f)</code> is actually a recursive call to <code>Tree.map()</code>. Now we can for example create a second tree (immutability!) with every value incremented but preserving structure:<br /><br /><pre class="brush: scala">val tree: Tree[Int] = //...<br />val incremented = tree.map(1 +)<br /></pre>...or with <code>toString()</code> called on each value:<br /><br /><pre class="brush: scala">val stringified = tree.map(_.toString) <br /></pre>Let' go a bit further. If <code>f</code> function is time-consuming and side-effect free (which happens to be a frequent requirement when doing <code>map()</code>) or our tree is considerably big what about parallelizing <code>Tree.map()</code> in some way? There are few ways to achieve this and quite a few traps. The simplest approach is to use a thread pool backed by <code>ExecutionContext</code>:<br /><br /><pre class="brush: scala">case class Tree[+T](value: T, left: Option[Tree[T]], right: Option[Tree[T]]) {<br />    def pmap[R](f: T =&gt; R)(implicit ec: ExecutionContext, timeout: Duration): Tree[R] = {<br />        val transformed: Future[R] = Future { f(value)}<br />        val  leftFuture: Option[Future[Tree[R]]] =  left.map { l =&gt; Future { l.pmap(f)}}<br />        val rightFuture: Option[Future[Tree[R]]] = right.map { r =&gt; Future { r.pmap(f)}}<br /><br />        Tree(<br />            Await.result(transformed, timeout),<br />             leftFuture.map(Await.result(_, timeout)),<br />            rightFuture.map(Await.result(_, timeout)))<br />    }<br />}<br /></pre>Using <code>pmap</code> (name is not a <a href="http://clojuredocs.org/clojure_core/clojure.core/pmap">coincidence</a>) is quite simple once you sort out few <code>implicits</code>:<br /><br /><pre class="brush: scala">import scala.concurrent.{Await, Future, ExecutionContext}<br />import java.util.concurrent.Executors<br />import scala.concurrent.duration._<br /><br />val pool = Executors newFixedThreadPool 10<br />implicit val ec: ExecutionContext = ExecutionContext fromExecutor pool<br />implicit val timeout = 10.second<br /><br />val tree = Tree("alpha",<br />    None,<br />    Some(<br />        Tree("beta",<br />            None,<br />            None)))<br /><br />println(tree.pmap{_.toUpperCase})<br /></pre>Sample code above will take a simple tree with "<i>alpha</i>" root and "<i>beta</i>" right child and upper case all the values in multiple threads. Calling <code>Future { ... }</code> is a simple idiom to submit asynchronous task to a thread pool and get a <code>Future[T]</code> in return. <br /><br />There are at least couple of issues with this code. First of all it mainly... waits. Several threads will sit idle merely waiting for children to complete. But that's not the worst case scenario. Imagine our thread pool is limited to one thread (problem remains for larger, but still limited pools). We spawn sub tasks for children and wait until they finish. But these sub tasks never start because they are unable to obtain thread from a thread pool. Why? Because there is only one thread in the pool and we are already consuming it! This one and only thread is blocked waiting idle for tasks that can never finish. It's called a <b>deadlock</b>. Actually the code will time out after given amount of time but it doesn't change the fact that the implementation above fails miserably. <code>ForkJoinPool</code> would solve this issue but there are more advanced and rewarding solutions.<br /><br /><h2>Entering <code>Tree[Future[R]]</code></h2>Surprisingly there is even better, more functional and clean approach. Reactive programming discourages waiting. Instead of hiding asynchronous nature of processing tree, let's emphasize it! Since the processing is already based on <code>Future</code>s, place them explicitly in the API:<br /><br /><pre class="brush: scala">case class Tree[+T](value: T, left: Option[Tree[T]], right: Option[Tree[T]]) {<br />    def mapf[R](f: T =&gt; R)(implicit ec: ExecutionContext, timeout: Duration): Tree[Future[R]] = {<br />        Tree(<br />            Future { f(value) },<br />             left.map {_.mapf(f)},<br />            right.map {_.mapf(f)}<br />        )<br />    }<br />}<br /></pre><code>Tree.mapf()</code> returns immediately but instead of returning <code>Tree[R]</code> we now get <code>Tree[Future[R]]</code>. So we have a tree where each node contains an independent <code>Future</code>. How can we go back to familiar <code>Tree[R]</code>? One approach uses <code>Tree.map()</code>, which we already implemented:<br /><br /><pre class="brush: scala">val treeOfFutures: Tree[Future[R]] = ...<br /><br />val tree = treeOfFutures.map(Await.result(_, 10.seconds))<br /></pre>I bet it's not clear but in principle this is simple - for each node wait on independent future object until all of them are resolved. There is no risk of deadlock because futures are not dependant on each other. <br /><br /><h1>Turning <code>Tree[Future[R]]</code> into <code>Future[Tree[R]]</code></h1>But we want to go deeper. Why work with a bunch of futures if we can have only <i>one future to rule them all</i>? Think about <a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.Future$"><code>Future.sequence()</code></a> that turns <code>Seq[Future[T]]</code> into <code>Future[Seq[T]]</code>. Implementing such method for <code>Tree[Future[T]]</code> is a nice task on its own. The idea is to have a counter of all unresolved tasks and once all of them are done - dereference all futures without blocking (since they are already finished):<br /><br /><pre class="brush: scala">object Tree {<br /><br />    def sequence[T](tree: Tree[Future[T]])(implicit ec: ExecutionContext, timeout: Duration): Future[Tree[T]] = {<br />        val promise = Promise[Tree[T]]()<br />        val pending = new AtomicInteger(tree.size)<br />        for {<br />            future &lt;- tree<br />            value &lt;- future<br />        } if(pending.decrementAndGet() == 0) {<br />            promise.success(<br />                tree.map(Await.result(_, 0.seconds))    //will never block<br />            )<br />        }<br />        promise.future<br />    }<br />}<br /></pre>Code above is a bit imperative and doesn't handle exceptions properly - but can be a good starting point. We iterate over all futures and decrement a counter after each one of them completes. If all futures are done we complete our custom promise. Code above requires two extra methods: <code>Tree.size</code> and <code>Tree.foreach()</code> (used implicitly inside for comprehension) - which I leave for you as an exercise. <script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>