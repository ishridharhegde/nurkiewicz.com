---
layout: post
title: Server-sent events with RxJava and SseEmitter
date: '2015-07-29T23:59:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- sse
- CompletableFuture
- spring mvc
- multithreading
- spring
- rxjava
modified_time: '2015-11-29T23:39:16.738+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7178811899129427795
blogger_orig_url: https://www.nurkiewicz.com/2015/07/server-sent-events-with-rxjava-and.html
---

Spring framework 4.2 GA is almost released, let's look at some new features it provides. The one that got my attention is a simple new class <a href="http://docs.spring.io/spring-framework/docs/4.2.0.RC3/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/SseEmitter.html"><code>SseEmitter</code></a> - an abstraction over <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">sever-sent events</a> easily used in Spring MVC controllers. SSE is a technology that allows you to stream data from server to the browser within one HTTP connection in one direction. It sounds like a subset of what <a href="https://www.websocket.org/">websockets</a> can do. However since it's a much simpler protocol, it may be used when full-duplex is not necessary, e.g. pushing stock price changes in real-time or showing progress of long-running process. This is going to be our example.<br/><br/> Imagine we have a virtual coin miner with the following API:<br/><br/> <pre class="brush: java">public interface CoinMiner {<br /><br />    BigDecimal mine() {<br />        //...<br />    }<br />}<br /></code></pre>Every time we call <code>mine()</code> we have to wait few seconds and we get around 1 coin in return (on average). If we want to mine multiple coins, we have to call this method multiple times:<br/><br/> <pre class="brush: java">@RestController<br />public class MiningController {<br /><br />    //...<br /><br />    @RequestMapping("/mine/{count}")<br />    void mine(@PathVariable int count) {<br />        IntStream<br />                .range(0, count)<br />                .forEach(x -&gt; coinMiner.mine());<br />    }<br /><br />}<br /></code></pre>This works, we can request <code>/mine/10</code> and <code>mine()</code> method will be executed 10 times. So far so good. But mining is a CPU intensive task, it would be beneficial to spread computations over multiple cores. Additionally even with parallelization our API endpoint is quite slow and we have to patiently wait until all work is done without any progress notifications. Let's fix parallelism first - however since parallel streams give you no control over underlying thread pool, let's go for explicit <code>ExecutorService</code>:<br/><br/> <pre class="brush: java">@Component<br />class CoinMiner {<br /><br />    CompletableFuture&lt;BigDecimal&gt; mineAsync(ExecutorService executorService) {<br />        return CompletableFuture.supplyAsync(this::mine, executorService);<br />    }<br /><br />    //...<br /><br />}<br /></code></pre>Client code must supply <code>ExecutorService</code> explicitly (just a design choice):<br/><br/> <pre class="brush: java">@RequestMapping("/mine/{count}")<br />void mine(@PathVariable int count) {<br />    final List&lt;CompletableFuture&lt;BigDecimal&gt;&gt; futures = IntStream<br />            .range(0, count)<br />            .mapToObj(x -&gt; coinMiner.mineAsync(executorService))<br />            .collect(toList());<br />    futures.forEach(CompletableFuture::join);<br />}<br /></code></pre>It's insanely important to first call <code>mineAsync</code> multiple times and then (as a second stage) wait for all futures to complete with <code>join</code>. It's tempting to write:<br/><br/> <pre class="brush: java">IntStream<br />        .range(0, count)<br />        .mapToObj(x -&gt; coinMiner.mineAsync(executorService))<br />        .forEach(CompletableFuture::join);<br /></code></pre>However due to lazy nature of streams in Java 8, that tasks will be executed sequentially! If you don't grok laziness of streams yet, always read them from bottom to top: we ask to <code>join</code> some future so stream goes up and calls <code>mineAsync()</code> just once (lazy!), passing it to <code>join()</code>. When this <code>join()</code> finishes, it goes up again asking for another <code>Future</code>. By using <code>collect()</code> we force all <code>mineAsync()</code> executions, starting all asynchronous computations. Later on we wait for each and every one of them.<br/><br/> <h1>Introducing <code>SseEmitter</code></h1>Now it's time to be more reactive (there, I said it). Controller can return an instance of <code>SseEmitter</code>. Once we <code>return</code> from a handler method, container thread is released and can serve more upcoming requests. But the connection is not closed and the client keeps waiting! What we should do is keep a reference of <code>SseEmitter</code> instance and call its <code>send()</code> and <code>complete</code> methods later, from a different thread. For example we can start a long-running process and keep <code>send()</code>-ing progress from arbitrary threads. Once the process is done, we <code>complete()</code> the <code>SseEmitter</code> and finally the HTTP connection is closed (at least logically, remember about <code>Keep-alive</code>). In example below we have a bunch of <code>CompletableFuture</code>s and when each completes, we simply send <code>1</code> to the client (<code>notifyProgress()</code>). When all futures are done we complete the stream (<code>thenRun(sseEmitter::complete)</code>), closing the connection:<br/><br/> <pre class="brush: java">@RequestMapping("/mine/{count}")<br />SseEmitter mine(@PathVariable int count) {<br />    final SseEmitter sseEmitter = new SseEmitter();<br />    final List&lt;CompletableFuture&lt;BigDecimal&gt;&gt; futures = mineAsync(count);<br />    futures.forEach(future -&gt;<br />            future.thenRun(() -&gt; notifyProgress(sseEmitter)));<br /><br />    final CompletableFuture[] futuresArr = futures.toArray(new CompletableFuture[futures.size()]);<br />    CompletableFuture<br />            .allOf(futuresArr)<br />            .thenRun(sseEmitter::complete);<br /><br />    return sseEmitter;<br />}<br /><br />private void notifyProgress(SseEmitter sseEmitter) {<br />    try {<br />        sseEmitter.send(1);<br />    } catch (IOException e) {<br />        throw new RuntimeException(e);<br />    }<br />}<br /><br />private List&lt;CompletableFuture&lt;BigDecimal&gt;&gt; mineAsync(@PathVariable int count) {<br />    return IntStream<br />            .range(0, count)<br />            .mapToObj(x -&gt; coinMiner.mineAsync(executorService))<br />            .collect(toList());<br />}<br /></code></pre>Calling this method results with the following response (notice <code>Content-Type</code>):<br/><br/> <pre class="brush: java">&lt; HTTP/1.1 200 OK<br />&lt; Content-Type: text/event-stream;charset=UTF-8<br />&lt; Transfer-Encoding: chunked<br />&lt; <br />data:1<br /><br />data:1<br /><br />data:1<br /><br />data:1<br /><br />* Connection #0 to host localhost left intact<br /></code></pre>We will learn later how to interpret such response on the client side. For the time being let's clean up the design a little bit.<br/><br/> <h1>Introducing RxJava with <code>Observable</code> progress</h1>Code above works, but looks quite messy. What we actually have is a series of events, each representing progress of computation. Computation finally finishes, so the stream should also signal end. Sounds exactly like <code>Observable</code>! We start by refactoring <code>CoinMiner</code> in order to return <code>Observable&lt;BigDecimal</code>:<br/><br/> <pre class="brush: java">Observable&lt;BigDecimal&gt; mineMany(int count, ExecutorService executorService) {<br />    final ReplaySubject&lt;BigDecimal&gt; subject = ReplaySubject.create();<br />    final List&lt;CompletableFuture&lt;BigDecimal&gt;&gt; futures = IntStream<br />            .range(0, count)<br />            .mapToObj(x -&gt; mineAsync(executorService))<br />            .collect(toList());<br />    futures<br />            .forEach(future -&gt;<br />                    future.thenRun(() -&gt; subject.onNext(BigDecimal.ONE)));<br /><br />    final CompletableFuture[] futuresArr = futures.toArray(new CompletableFuture[futures.size()]);<br />    CompletableFuture<br />            .allOf(futuresArr)<br />            .thenRun(subject::onCompleted);<br /><br />    return subject;<br />}<br /></code></pre>Every time an event appears in <code>Observable</code> returned from <code>mineMany()</code>, we just mined that many coins. When all futures are done, we complete the stream as well. This doesn't look much better yet on the implementation side, but look how clean it is from the controller's perspective:<br/><br/> <pre class="brush: java">@RequestMapping("/mine/{count}")<br />SseEmitter mine(@PathVariable int count) {<br />    final SseEmitter sseEmitter = new SseEmitter();<br />    coinMiner<br />            .mineMany(count, executorService)<br />            .subscribe(<br />                    value -&gt; notifyProgress(sseEmitter),<br />                    sseEmitter::completeWithError,<br />                    sseEmitter::complete<br />            );<br />    return sseEmitter;<br />}<br /></code></pre>After calling <code>coinMiner.mineMany()</code> we simply subscribe to events. Turns out <code>Observable</code> and <code>SseEmitter</code> methods match 1:1. What happens here is pretty self-explanatory: start asynchronous computation and every time the background computation signals any progress, forward it to the client. OK, let's go back to the implementation. It looks messy because we mix <code>CompletableFuture</code> and <code>Observable</code>. I already described how to <a href="http://www.nurkiewicz.com/2014/11/converting-between-completablefuture.html">convert <code>CompletableFuture</code> into an <code>Observable</code> with just one element</a>. Here is a recap, including <code>rx.Single</code> abstraction found since RxJava 1.0.13 (not used here):<br/><br/> <pre class="brush: java">public class Futures {<br /><br />    public static &lt;T&gt; Observable&lt;T&gt; toObservable(CompletableFuture&lt;T&gt; future) {<br />        return Observable.create(subscriber -&gt;<br />                future.whenComplete((result, error) -&gt; {<br />                    if (error != null) {<br />                        subscriber.onError(error);<br />                    } else {<br />                        subscriber.onNext(result);<br />                        subscriber.onCompleted();<br />                    }<br />                }));<br />    }<br /><br />    public static &lt;T&gt; Single&lt;T&gt; toSingle(CompletableFuture&lt;T&gt; future) {<br />        return Single.create(subscriber -&gt;<br />                future.whenComplete((result, error) -&gt; {<br />                    if (error != null) {<br />                        subscriber.onError(error);<br />                    } else {<br />                        subscriber.onSuccess(result);<br />                    }<br />                }));<br />    }<br /><br />}<br /></code></pre>Having these utility operators somewhere we can improve implementation and avoid mixing two APIs:<br/><br/> <pre class="brush: java">Observable&lt;BigDecimal&gt; mineMany(int count, ExecutorService executorService) {<br />    final List&lt;Observable&lt;BigDecimal&gt;&gt; observables = IntStream<br />            .range(0, count)<br />            .mapToObj(x -&gt; mineAsync(executorService))<br />            .collect(toList());<br />    return Observable.merge(observables);<br />}<br /><br />Observable&lt;BigDecimal&gt; mineAsync(ExecutorService executorService) {<br />    final CompletableFuture&lt;BigDecimal&gt; future = <br />         CompletableFuture.supplyAsync(this::mine, executorService);<br />    return Futures.toObservable(future);<br />}<br /></code></pre>RxJava has a built-in operator for merging multiple <code>Observable</code>s into one, it doesn't matter that each of our underlying <code>Observable</code>s emit just one event.<br/><br/> <h1>Deep-dive into RxJava operators</h1>Let's use the power of RxJava to improve our streaming a little bit.<br/><br/> <h2><code>scan()</code></h2>Currently every time we mine one coin, we <code>send(1)</code> event to the client. This means that every client has to track how many coins it already received in order to calculate total calculated amount. Would be nice if server was always sending total amount rather than deltas. However we don't want to change the implementation. Turns out it's pretty straightforward with <code>Observable.scan()</code> operator:<br/><br/> <pre class="brush: java">@RequestMapping("/mine/{count}")<br />SseEmitter mine(@PathVariable int count) {<br />    final SseEmitter sseEmitter = new SseEmitter();<br />    coinMiner<br />            .mineMany(count, executorService)<br />            .scan(BigDecimal::add)<br />            .subscribe(<br />                    value -&gt; notifyProgress(sseEmitter, value),<br />                    sseEmitter::completeWithError,<br />                    sseEmitter::complete<br />            );<br />    return sseEmitter;<br />}<br /><br />private void notifyProgress(SseEmitter sseEmitter, BigDecimal value) {<br />    try {<br />        sseEmitter.send(value);<br />    } catch (IOException e) {<br />        e.printStackTrace();<br />    }<br />}<br /></code></pre><code>scan()</code> operator takes previous event and current one, combing them together. By applying <code>BigDecimal::add</code> we simply add all numbers. E.g. 1, 1 + 1, (1 + 1) + 1, and so on. <code>scan()</code> is like <code>flatMap()</code>, but keeps intermediate values.<br/><br/> <h2>Sampling with <code>sample()</code></h2>It might be the case that our back-end service produces way too many progress updates then we can consume. We don't want to flood client with irrelevant updates and saturate bandwidth. Sending an update at most twice a second sounds reasonable. Luckily RxJava has a built-in operator for that as well:<br/><br/> <pre class="brush: java">Observable&lt;BigDecimal&gt; obs = coinMiner.mineMany(count, executorService);<br />obs<br />        .scan(BigDecimal::add)<br />        .sample(500, TimeUnit.MILLISECONDS)<br />        .subscribe(<br />            //...<br />        );<br /></code></pre><code>sample()</code> will periodically look at the underlying stream and emit the most recent item only, discarding intermediate ones. Fortunately we aggregate items on-the-fly with <code>scan()</code> so we don't loose any updates.<br/><br/> <h2><code>window()</code> - constant emit intervals</h2>There is one catch though. <code>sample()</code> will not emit the same item twice if nothing new appeared within selected 500 milliseconds. It's fine, but remember we are pushing these updates over the TCP/IP connection. It's a good idea to periodically send an update to the client, even if nothing happened in the meantime - just to keep the connection alive, sort of a <code>ping</code>. There are probably many ways of achieving this requirement, e.g. involving <code>timeout()</code> operator. I chose grouping all events every 500 ms using <code>window()</code> operator:<br/><br/> <pre class="brush: java">Observable&lt;BigDecimal&gt; obs = coinMiner.mineMany(count, executorService);<br />obs<br />        .window(500, TimeUnit.MILLISECONDS)<br />        .flatMap(window -&gt; window.reduce(BigDecimal.ZERO, BigDecimal::add))<br />        .scan(BigDecimal::add)<br />        .subscribe(<br />            //...<br />        );<br /></code></pre>This one is tricky. First we group all progress updates in 500 millisecond windows. Then we calculate total (similar to <code>scan()</code>) of coins mined within this time period using <code>reduce</code>. If no coins were mined in that period, we simply return <code>ZERO</code>. We use <code>scan()</code> in the end to aggregate sub-totals of every window. We no longer need <code>sample()</code> since <code>window()</code> makes sure an event is emitted every 500 ms.<br/><br/> <h1>Client-side</h1>There is a lot of examples of SSE usage in JavaScript, so just to give you a quick solution calling our controller:<br/><br/> <pre class="brush: javascript">var source = new EventSource("/mine/10");<br />source.onmessage = function (event) {<br />    console.info(event);<br />};<br /></code></pre>I believe <code>SseEmitter</code> is a major improvement in Spring MVC, which will allow us to write more robust and faster web applications requiring instant one-directional updates.<br/><br/> <script>SyntaxHighlighter.highlight();</script>