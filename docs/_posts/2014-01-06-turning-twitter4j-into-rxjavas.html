---
layout: post
title: Turning Twitter4J into RxJava's Observable
date: '2014-01-06T16:28:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- twitter4j
- rxjava
modified_time: '2014-01-06T16:33:57.909+01:00'
thumbnail: http://1.bp.blogspot.com/-A6K-20UMGd4/UsrLB8ryiAI/AAAAAAAAA7E/XxwK9pzTLcY/s72-c/oslo-1.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-500314652963032083
blogger_orig_url: https://www.nurkiewicz.com/2014/01/turning-twitter4j-into-rxjavas.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-A6K-20UMGd4/UsrLB8ryiAI/AAAAAAAAA7E/XxwK9pzTLcY/s1600/oslo-1.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-A6K-20UMGd4/UsrLB8ryiAI/AAAAAAAAA7E/XxwK9pzTLcY/s1600/oslo-1.jpg" height="149" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">North of Oslo</td></tr></tbody></table>a<a href="http://twitter4j.org/en/index.html">Twitter4J</a> is a Java wrapper around <a href="https://dev.twitter.com/">Twitter API</a>. While Twitter supports simple request-response interactions in this article we will explore <a href="https://dev.twitter.com/docs/streaming-apis">streaming APIs</a>. In contrary to request-response model which is always initiated by the client, streaming API pushes data from Twitter server to the clients as soon as they are available. Of course in case of Twitter we are talking about tweets, called <a href="http://twitter4j.org/javadoc/twitter4j/Status.html"><code>Status</code></a> in the API.<br /><br />The question is, how would you design a Java API for streaming purposes? No surprise here: <em>callbacks, callbacks everywhere</em>!<br /><br /><pre class="brush: java">import twitter4j.*;<br /><br />TwitterStream twitter = new TwitterStreamFactory().getInstance();<br />twitter.addListener(new StatusAdapter() {<br />  public void onStatus(Status status) {<br />    System.out.println(status.getUser().getName() + " : " + status.getText());<br />  }<br />});<br />twitter.sample();<br /></pre>Say that on top of this API we would like to count how many messages we receive per second. A lot of accidental complexity sneaks in:<br /><br /><pre class="brush: java">final AtomicInteger countPerSecond = new AtomicInteger();<br /><br />twitter.addListener(new StatusAdapter() {<br />  public void onStatus(Status status) {<br />    countPerSecond.incrementAndGet();<br />  }<br />});<br />twitter.sample();<br /><br />Executors.newScheduledThreadPool(1).scheduleAtFixedRate(new Runnable() {<br />  @Override<br />  public void run() {<br />    final int count = countPerSecond.getAndSet(0);<br />    log.debug("Tweets/second: {}", count);<br />  }<br />}, 1, 1, SECONDS);<br /></pre>We need a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html"><code>ScheduledExecutorService</code></a> and be very careful about thread safety. Moreover this approach doesn't scale as it requires hand-crafted code for every use case we can imagine, like throttling, combining or accumulating. It turns out that bridging Twitter4J streaming API (and virtually any callback-based API for that matter) to <a href="https://github.com/Netflix/RxJava">RxJava</a>'s <a href="https://github.com/Netflix/RxJava/wiki/Observable"><code>Observable</code></a> is quite straightforward and will greatly simplify further solutions.<br /><br />Before we explore how to create new <code>Observable</code> representing stream of Twitter messages on top of Twitter4J API let's assume that we already have one:<br /><br /><pre class="brush: java">Observable&lt;Status&gt; twitter = twitterObservable();  //to be implemented<br /></pre><code>Observable&lt;Status&gt; twitter</code> is a stream of <code>Status</code> objects where each such object is one tweet. How do we solve our initial problem of counting tweets per second (<em>tps</em>)?<br /><br /><pre class="brush: java">Observable&lt;Integer&gt; tpsStream = twitter.<br />    buffer(1, TimeUnit.SECONDS).<br />    map(list -&gt; list.size());<br /></pre>That was easy! We take initial stream of tweets and buffer them every second. When one second elapses only a single event is triggered containing a <code>List&lt;Status&gt;</code> produced within that time frame. Later on we transform <code>List</code> into <code>Integer</code> by taking its <code>size()</code>. And that's it! <code>tpsStream</code> will yield one number per second representing count of tweets per second. If we suddenly realized that our system is overloaded by that number, we can easily sample the stream and pick just a subset of them. E.g. we want to get at most one tweet every 100 milliseconds:<br /><br /><pre class="brush: java">twitter.sample(100, MILLISECONDS)<br /></pre>There are more than <a href="https://github.com/Netflix/RxJava/wiki/Alphabetical-List-of-Observable-Operators">hundred operators</a> available similar to <code>buffer()</code> and <code>sample()</code> but I hope you get the idea. Now that we see how useful an <code>Observable&lt;Status&gt;</code> is, let's implement it. When defining <code>Observable</code> we need to supply two handlers: one describing what happens when client subscribes to a given <code>Observable</code> and optionally - how to handle unsubscribing:<br /><br /><pre class="brush: java">public Observable&lt;Status&gt; twitterObservable() {<br />  return Observable.create(subscriber -&gt; {<br />    final TwitterStream twitterStream = new TwitterStreamFactory().getInstance();<br />    twitterStream.addListener(new StatusAdapter() {<br />      public void onStatus(Status status) {<br />        subscriber.onNext(status);<br />      }<br />      public void onException(Exception ex) {<br />        subscriber.onError(ex);<br />      }<br />    });<br />    twitterStream.sample();<br />    return Subscriptions.create(() -&gt; {<br />      twitterStream.cleanUp();<br />    });<br />  });<br />}<br /></pre>Quite a bit of code written in Java 8 (Scala and Groovy work equally well with RxJava). Callback provided to <code>Observable.create()</code> is executed every time someone subscribes to <code>Observable</code>. It turns out that all examples below never trigger this handler because RxJava is very lazy in nature, thus it won't connect to Twitter unless absolutely required. For example <code>twitter.filter(...)</code> will return a new <code>Observable</code> with only a subset of tweets matching certain criteria. But as long as you don't physically subscribe (using <code>twitter.subscribe()</code>) to that <code>Observable</code>, nothing will really happen. In example below the connection is postponed until we call <code>subscribe()</code>. After that text of each encountered tweet is extracted and if it contains <code>#java</code> hashtag - it will be printed. All of this happens asynchronously and the whole statement is non-blocking:<br /><br /><pre class="brush: java">twitter.<br />  map(Status::getText).<br />  filter(text -&gt; text.contains("#java")).<br />  subscribe(System.out::println);<br /></pre>The <code>Subscriptions.create()</code> also takes a handler - and as you can guess it tells what should happen when client is no longer interested in <code>Observable&lt;Status&gt;</code>.<br /><br />Twitter4J is just an example how you can adapt callback-based API into an <code>Observable</code>. Other examples include incoming network packages, JMS messages or file system changes. In all cases the scenario is the same.<br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>