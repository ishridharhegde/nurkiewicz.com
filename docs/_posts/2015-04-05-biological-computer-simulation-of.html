---
layout: post
title: Biological computer simulation of selfish genes
date: '2015-04-05T20:04:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- biology
- simulations
modified_time: '2015-04-05T20:04:37.048+02:00'
thumbnail: http://1.bp.blogspot.com/-jprrxt_aXqw/VSF4Ql7D8MI/AAAAAAAABQc/3tmlioQVczs/s72-c/monkeys.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3651088202872967778
blogger_orig_url: https://www.nurkiewicz.com/2015/04/biological-computer-simulation-of.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-jprrxt_aXqw/VSF4Ql7D8MI/AAAAAAAABQc/3tmlioQVczs/s1600/monkeys.jpg" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-jprrxt_aXqw/VSF4Ql7D8MI/AAAAAAAABQc/3tmlioQVczs/s200/monkeys.jpg" /></a></div>TL;DR: I did a computer simulation of behavior evolution of monkeys, continue reading to see how problem was stated originally in <a href="http://www.amazon.com/gp/product/0199291152/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0199291152&amp;linkCode=as2&amp;tag=javaandneighb-20&amp;linkId=7SNF47P7MX5LWBNF">The Selfish Gene</a>. First part shows my <a href="https://github.com/nurkiewicz/monkeys-grooming">Java implementation</a>, second part shows charted results and conclusions.<br /><br /><hr /><h1>The problem</h1>I read <a href="http://www.amazon.com/gp/product/0199291152/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0199291152&amp;linkCode=as2&amp;tag=javaandneighb-20&amp;linkId=7SNF47P7MX5LWBNF">The Selfish Gene</a> by <a href="http://www.amazon.com/Richard-Dawkins/e/B000AQ3RBI/?_encoding=UTF8&amp;camp=1789&amp;creative=390957&amp;linkCode=ur2&amp;tag=javaandneighb-20&amp;linkId=2SIUP76MUBC5J2L7">Richard Dawkins</a> recently, very wide-opening book despite being 40 years old. While the original text is sometimes outdated ("<em>you could pack only a few hundred transistors into a skull</em> - more like <a href="http://en.wikipedia.org/wiki/Transistor_count">trillions these days</a>, hello <a href="http://en.wikipedia.org/wiki/Moore%27s_law">Moore's law</a>) general claims are as appealing as they used to. <br /><br />One chapter that especially grabbed my attention, as a computer engineer, was about animals performing <a href="http://en.wikipedia.org/wiki/Social_grooming">social grooming</a>, like some species of monkeys (see picture above). Let me quote <a href="https://archive.org/stream/TheSelfishGene/RichardDawkins-TheSelfishGene_djvu.txt">relevant chapter</a>:<br /><br /><blockquote>Suppose a species [...] is parasitized by a particularly nasty kind of <a href="http://en.wikipedia.org/wiki/Tick">tick</a> which carries a dangerous disease. It is very important that these ticks should be removed as soon as possible. [...] An individual may not be able to reach his own head, but nothing is easier than for a friend to do it for him. Later, when the friend is parasitized himself, the good deed can be paid back. [...] This makes immediate intuitive sense. Anybody with conscious foresight can see that it is sensible to enter into mutual back-scratching arrangements. [...]<br /><br />Suppose B has a parasite on the top of his head. A pulls it off him. Later, the time comes when A has a parasite on his head. He naturally seeks out B in order that B may pay back his good deed. B simply turns up his nose and walks off. B is a cheat, an individual who accepts the benefit of other individuals' altruism, but who does not pay it back, or who pays it back insufficiently. Cheats do better than indiscriminate altruists because they gain the benefits without paying the costs. To be sure, the cost of grooming another individual's head seems small compared with the benefit of having a dangerous parasite removed, but it is not negligible. Some valuable energy and time has to be spent. <br /><br />Let the population consist of individuals who adopt one of two strategies. [...] Call the two strategies Sucker and Cheat. Suckers groom anybody who needs it, indiscriminately. Cheats accept altruism from suckers, but they never groom anybody else, not even somebody who has previously groomed them. [...] the cheats will be doing better than the suckers. Even if the whole population declines toward extinction, there will never be any time when suckers do better than cheats. Therefore, as long as we consider only these two strategies, nothing can stop the extinction of the suckers and, very probably, the extinction of the whole population too. <br /><br />But now, suppose there is a third strategy called Grudger. Grudgers groom strangers and individuals who have previously groomed them. However, if any individual cheats them, they remember the incident and bear a grudge: they refuse to groom that individual in the future. In a population of grudgers and suckers it is impossible to tell which is which. Both types behave altruistically towards everybody else [...]. If grudgers are rare in comparison with cheats, the grudger gene will go extinct. Once the grudgers manage to build up in numbers so that they reach a critical proportion, however, their chance of meeting each other becomes sufficiently great to off-set their wasted effort in grooming cheats. When this critical proportion is reached they will start to average a higher pay-off than cheats, and the cheats will be driven at an accelerating rate towards extinction. [...]<br /><br /></blockquote>Quote from: <a href="http://www.amazon.com/gp/product/0199291152/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0199291152&amp;linkCode=as2&amp;tag=javaandneighb-20&amp;linkId=7SNF47P7MX5LWBNF">The Selfish Gene</a> by <a href="http://www.amazon.com/Richard-Dawkins/e/B000AQ3RBI/?_encoding=UTF8&amp;camp=1789&amp;creative=390957&amp;linkCode=ur2&amp;tag=javaandneighb-20&amp;linkId=2SIUP76MUBC5J2L7">Richard Dawkins</a>, ISBN 0-19-857519-X.<br /><br />Later on the author conducts a series of computer simulations to observe how these three strategies play together under various conditions. Obviously source code is not available, and I'm actually happy about it. Firstly because I had an opportunity to write some code for fun. Secondly: book was published in 1976, 4 years after C was invented and many years before C++ (to put you in perspective) and I am not really in a mood for (I guess) <a href="http://en.wikipedia.org/wiki/Fortran">Fortran</a>.<br /><br /><h1>Implementation</h1>So I hacked few classes to perform a simulation of cheaters, suckers and grudgers throughout the population. I want to see how different types of behaviors affect population size. Which behavior is stable and guarantees survival. Finally how random mutations and deaths are mitigated. I decided to experiment with some techniques namely:<br /><br /><ol><li>Hand-made dependency injection, no container whatsoever</li><li>Entirely single-threaded</li><li>Logical clock that is advanced explicitly to simulate time elapsing</li></ol>We are going to simulate a population of monkeys (from just few to millions), each one with independent behavior, random life time and so on. It seems obvious to use multi-agent solution like actors or at least threads. However <a href="https://www.coursera.org/course/reactive"><em>Principles of Reactive Programming</em></a> course taught me that this is often an over-engineering. Essentially such a simulation is a sequence of events that should happen in the future: a monkey should be born in 2 years, should breed in 5 years and should die in 10. Of course there are many more such events and more monkeys. However it's enough to throw all these events into a single priority queue where closest events in the future are first. That's how <a href="https://github.com/nurkiewicz/monkeys-grooming/blob/master/src/main/java/com/nurkiewicz/monkeys/simulation/Planner.java"><code>Planner</code></a> is essentially implemented:<br /><br /><pre class="brush: java">public abstract class Action implements Comparable&lt;Action&gt; {<br /><br />    private final Instant schedule;<br /><br />    public Action(Clock simulationTime, Duration delay) {<br />        this.schedule = simulationTime.instant().plus(delay);<br />    }<br /><br />    @Override<br />    public int compareTo(Action other) {<br />        return this.schedule.compareTo(other.schedule);<br />    }<br /><br />    public abstract void run();<br /><br />}<br /><br />//...<br /><br />public class Planner implements Runnable {<br /><br />    private final Queue&lt;Action&gt; pending = new PriorityQueue&lt;&gt;();<br />    private final SimulationClock simulationClock;<br /><br />    public void schedule(Action action) {<br />        pending.add(action);<br />    }<br /><br />    @Override<br />    public void run() {<br />        while (!pending.isEmpty()) {<br />            Action nearestAction = pending.poll();<br />            simulationClock.advanceTo(nearestAction.getSchedule());<br />            nearestAction.run();<br />        }<br />    }<br />}<br /></pre>We have an <a href="https://github.com/nurkiewicz/monkeys-grooming/blob/master/src/main/java/com/nurkiewicz/monkeys/actions/Action.java"><code>Action</code></a> with predefined <code>schedule</code> (<em>when</em> it should be executed) and a <code>pending</code> queue of future actions. There is no need to wait, we just pick nearest action from the future and advance simulation time:<br /><br /><pre class="brush: java">import java.time.Clock;<br /><br />public class SimulationClock extends Clock {<br /><br />    private Instant simulationNow = Instant.now();<br /><br />    @Override<br />    public Instant instant() {<br />        return simulationNow;<br />    }<br /><br />    public void advanceTo(Instant instant) {<br />        simulationNow = instant;<br />    }<br /><br />}<br /></pre>So we essentially implemented an <a href="http://en.wikipedia.org/wiki/Event_loop">event loop</a> where events can be added anywhere within the queue (not necessarily at the end). Now when we have a basic framework, let's implement monkeys' behaviors:<br /><br /><pre class="brush: java">public class Sucker extends Monkey {<br />    //...<br /><br />    @Override<br />    public boolean acceptsToGroom(Monkey monkey) {<br />        return true;<br />    }<br /><br />}<br /><br />public class Cheater extends Monkey {<br /><br />    private final double acceptProbability;<br /><br />    //...<br /><br />    @Override<br />    public boolean acceptsToGroom(Monkey monkey) {<br />        return Math.random() &lt; acceptProbability;<br />    }<br />}<br /><br />public class Grudger extends Monkey {<br /><br />    private final Set&lt;Monkey&gt; cheaters = new HashSet&lt;&gt;();<br /><br />    @Override<br />    public boolean acceptsToGroom(Monkey monkey) {<br />        return !cheaters.contains(monkey);<br />    }<br /><br />    @Override<br />    public void monkeyRejectedToGroomMe(Monkey monkey) {<br />        cheaters.add(monkey);<br />    }<br /><br />}<br /></pre>As you can see these three classes capture three different behaviors. <code>Sucker</code>s always accept grooming requests, <code>Cheater</code>s only sometimes (in original simulation - never, but I made this configurable), <code>Grudger</code>s remember who rejected their request previously. Monkeys are aggregated within a class <code>Population</code>, here is a small snippet:<br /><br /><pre class="brush: java">public class Population {<br /><br />    private final Set&lt;Monkey&gt; monkeys = new HashSet&lt;&gt;();<br />    private final MonkeyFactory monkeyFactory;<br /><br />    private Population addMonkey(Monkey child) {<br />        if (!full()) {<br />            newMonkey(child);<br />        }<br />        return this;<br />    }<br /><br />    private boolean full() {<br />        return monkeys.size() &gt;= environment.getMaxPopulationSize();<br />    }<br /><br />    private void newMonkey(Monkey child) {<br />        monkeys.add(child);<br />        planner.scheduleMonkeyLifecycle(child, this);<br />        log.debug("New monkey in population {}total {}", child, monkeys.size());<br />    }<br /><br />//...<br />}<br /></pre>For each new monkey we schedule its so-called lifecycle, i.e. events related to breeding, grooming and death (in <code>Planner</code>):<br /><br /><pre class="brush: java">void scheduleMonkeyLifecycle(Monkey child, Population population) {<br />    askForGrooming(child, environment.getParasiteInfection().make(), population);<br />    scheduleBreedings(child, population);<br />    kill(child, environment.getLifetime().make(), population);<br />}<br /><br />void askForGrooming(Monkey child, Duration parasiteInfection, Population population) {<br />    schedule(new AskForGrooming(child, parasiteInfection, population));<br />}<br /><br />private void scheduleBreedings(Monkey child, Population population) {<br />    final int childrenCount = RANDOM.nextInt(environment.getMaxChildren() + 1);<br />    IntStream.<br />            rangeClosed(1, childrenCount)<br />            .forEach(x -&gt; breed(child, environment.getBreeding().make(), population));<br />}<br /><br />void kill(Monkey child, Duration lifetime, Population population) {<br />    schedule(new Kill(child, lifetime, population));<br />}<br /><br />private void breed(Monkey child, Duration breeding, Population population) {<br />    schedule(new Breed(child, breeding, population));<br />}<br /></pre><a href="https://github.com/nurkiewicz/monkeys-grooming/blob/master/src/main/java/com/nurkiewicz/monkeys/actions/AskForGrooming.java"><code>AskForGrooming</code></a>, <a href="https://github.com/nurkiewicz/monkeys-grooming/blob/master/src/main/java/com/nurkiewicz/monkeys/actions/Kill.java"><code>Kill</code></a>, <a href="https://github.com/nurkiewicz/monkeys-grooming/blob/master/src/main/java/com/nurkiewicz/monkeys/actions/Breed.java"><code>Breed</code></a>, etc. are instances of already mentioned <code>Action</code> class, e.g. <code>Kill</code>:<br /><br /><pre class="brush: java">public class Kill extends MonkeyAction {<br />    private final Population population;<br /><br />    public Kill(Monkey monkey, Duration lifetime, Population population) {<br />        super(monkey, lifetime);<br />        this.population = population;<br />    }<br /><br />    @Override<br />    public void run(Monkey monkey) {<br />        population.kill(monkey);<br />    }<br />}<br /></pre>I encapsulate all simulation parameters in a simple value class <a href="https://github.com/nurkiewicz/monkeys-grooming/blob/master/src/main/java/com/nurkiewicz/monkeys/simulation/Environment.java"><code>Environment</code></a>, many parameters like <code>parasiteInfection</code>, <code>lifetime</code> or <code>breeding</code> aren't constants but instances of <a href="https://github.com/nurkiewicz/monkeys-grooming/blob/master/src/main/java/com/nurkiewicz/monkeys/RandomPeriod.java"><code>RandomPeriod</code></a> class:<br /><br /><pre class="brush: java">@Value<br />public class RandomPeriod {<br /><br />    private static final Random RANDOM = new Random();<br /><br />    Period expected;<br />    Period stdDev;<br /><br />    public Duration make() {<br />        final long shift = Periods.toDuration(expected).toMillis();<br />        final long stdDev = Periods.toDuration(this.stdDev).toMillis();<br />        final double gaussian = RANDOM.nextGaussian() * stdDev;<br />        double randomMillis = shift + gaussian;<br />        return Duration.ofMillis((long) randomMillis);<br />    }<br /><br />}<br /></pre>This allowed me to capture the concept of random period of time with expected value, standard deviation and <a href="http://en.wikipedia.org/wiki/Normal_distribution">normal distribution</a>. <code>make()</code> method simply generates one such random period. I am not going to explore full source code of this simulation, it's <a href="https://github.com/nurkiewicz/monkeys-grooming">available on GitHub</a>. Now it's finally time to run it a few times and observe how population grows (or extincts). By the way I use the same planner and action mechanism to peek what happens: I simply inject <a href="https://github.com/nurkiewicz/monkeys-grooming/blob/master/src/main/java/com/nurkiewicz/monkeys/actions/Probe.java"><code>Probe</code></a> action once every year (logical time!) and output the current population size.<br /><br />Just as with many event loops, there must be just one thread accessing events. We followed this practice, the simulation is single-threaded, thus there is no need to perform any synchronization or locking at all, we can also use standard, unsafe but faster collections. Less context switches and improved cache locality help as well. Also we can easily dump simulation state to disk, e.g. to restore it later. Of course there are drawbacks. With thousands of monkeys the simulation slows down and there is not much we can do about it, except careful optimization and buying faster CPU (not even more CPUs!)<br /><br /><hr /><h1>The experiment</h1>As a control group we start with a tiny (10 specimens) population consisting solely of suckers and a mixture of suckers and grudgers. In the absence of cheaters these two behaviors are indistinguishable. We turn off mutation (a possibility that a child of sucker and grudger will become a cheater, rather then sucker or grudger as well) and see how population grows (X axis represents time, Y axis is the population size):<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-aTrNWttHxus/VSF4PcXj-oI/AAAAAAAABQw/84-4BgESa8o/s1600/2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-aTrNWttHxus/VSF4PcXj-oI/AAAAAAAABQw/84-4BgESa8o/s1600/2.png" height="180" width="640" /></a></div><br /><br />Notice that the proportion of suckers and grudgers fluctuates around 50% since these two behaviors are doing exactly the same. There is no point in running a simulation with few cheaters only. Since they generally don't groom each other, they quickly die, erasing the "<em>cheating gene</em>". On the other hand suckers only (without mutation) are growing exponentially (you can clearly see new generations being born after plateaus):<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-0hoOEaKkan0/VSF4QZ-yzNI/AAAAAAAABQk/gCSBNFxUqDk/s1600/8.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-0hoOEaKkan0/VSF4QZ-yzNI/AAAAAAAABQk/gCSBNFxUqDk/s1600/8.png" height="180" width="640" /></a></div><br /><br />However what would happen if we simulate a population with 100 suckers and just 5 cheaters? Mutations are again turned off to keep simulation clean:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-P3-bAgb2ql4/VSF4PbzjfBI/AAAAAAAABQ4/3mQhedKBu4I/s1600/5.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-P3-bAgb2ql4/VSF4PbzjfBI/AAAAAAAABQ4/3mQhedKBu4I/s1600/5.png" height="176" width="640" /></a></div><br /><br />There are two possible scenarios: either cheaters gene disappears or it spreads and cause the population to extinct. It's kind of a paradox - if this particular gene wins, the whole population (including that gene!) is doomed. Now let's simulate something more interesting. We turn on 5% mutation probability and ask cheaters to groom in 9 out of 10 cases (so they behave somewhat like suckers). We start with a healthy population of 5 suckers and 5 grudgers:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-SLFeaO7SjGc/VSF4Pa9XjFI/AAAAAAAABQs/GngkZRTEnlY/s1600/6.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-SLFeaO7SjGc/VSF4Pa9XjFI/AAAAAAAABQs/GngkZRTEnlY/s1600/6.png" height="164" width="640" /></a></div><br /><br />Do you see how grudgers quickly expand and almost always outnumber suckers? That's because suckers are much more vulnerable in an environment where cheaters sometimes appear due to a mutation. Did you noticed how population quickly shrinks every time even a small number of suckers appear? Grudgers are vulnerable as well: they groom newborn cheaters without knowing yet who they are. However they don't repeat this mistake like suckers do. That's why suckers always loose, but they don't extinct entirely since they are somewhat protected by grudgers. Not directly, but grudgers kill cheaters by not grooming them, reducing the threat. That's how different behaviors cooperate. So why did the population extinct after all? Look carefully at the end of the chart, at some point for a random reason the suckers outnumbered grudgers - this was especially possible in the absence of cheaters at that time. So what happened? A few cheaters appeared suddenly due to a mutation and this society of monkeys was doomed.<br /><br />Now let's study another example: a mature society of 100 suckers living already, no other behaviors observed. Of course due to a mutation grudgers and cheaters quickly emerge. Most of the times this simulation ends very quickly, just after few generations. The probability of cheater being born is the same as the probability of grudger, but we need way more grudgers to protect suckers. Thus the population dies. But I managed to run few simulations where such society actually survived for a while:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-ZwVCyLZuE5g/VSF4QMyQBZI/AAAAAAAABQg/fhXwGuqIH7E/s1600/7.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-ZwVCyLZuE5g/VSF4QMyQBZI/AAAAAAAABQg/fhXwGuqIH7E/s1600/7.png" height="176" width="640" /></a></div><br /><br />Interestingly suckers dominated in the population for quite some time, but yet another <em>epidemic</em> attack of cheaters killed most of suckers. Unfortunately the last growth of cheaters reduced the number of grudgers to the point when they could no longer protect suckers and suddenly everyone dies.<br /><br /><hr /><h1>Summary</h1>From implementation perspective using single-threaded model and an action queue worked really good, despite being hard to scale. However the biological conclusions are much more interesting:<br /><br /><ul><li>An altruistic population (<em>suckers</em> only) can live happily forever, as long as there are no cheaters, trying to exploit the system</li><li>The presence of a single cheater in an altruistic population can cause such population to collapse</li><li>Population needs guards (<em>grudgers</em>) that protect from cheaters</li><li>Even in the presence of guards there is still place for small amount of cheaters that remain unnoticed</li><li>If the number of cheaters exceed some critical ratio, the population can no longer protect itself and gives up. Every specimen dies, including cheaters</li><li>Genes that are generally bad for a population extinct, even if this drags down the whole population</li></ul>You are free to extend conclusions to human society. <a href="https://github.com/nurkiewicz/monkeys-grooming">Full source code</a> is available on GitHub, feel free to experiment, pull requests are welcome as well!  <script>SyntaxHighlighter.highlight();</script>