---
layout: post
title: What features of Java have been dropped in Scala?
date: '2011-08-07T18:15:00.002+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
modified_time: '2011-11-17T19:25:44.807+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3527227597997947083
blogger_orig_url: https://www.nurkiewicz.com/2011/08/what-features-of-java-have-been-dropped.html
---

<br /><div>Despite more complex and less intuitive syntax compared to Java, Scala actually drops several features of Java, sometimes for good, other times providing replacements on the standard library level. As you will see soon, Scala isn't a superset of Java (like Groovy) and actually removes a lot of noise. Below is a catalogue of <i>the missing features</i><span style="font-style: normal;">.</span></div><div><br /></div><h4>   break and continue in loops</h4>Every time I see code like this:<br /><br /><br /><br /><pre class="brush: java"><br />while(cond1) {<br />    work();<br />    if(cond2)<br />        continue;<br />    rest();<br />}<br /></pre><br /><br /><br /><br />I feel as if it has been written by a guy who truly misses the times when <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">goto</span> wasn't yet considered harmful. Hands up who finds this version more readable:<br /><br /><a name='more'></a><br /><br /><br /><pre class="brush: java"><br />while(cond1) {<br />    work();<br />    if(!cond2)<br />        rest();<br />}<br /></pre><br /><br /><br /><br />Getting rid of break requires a little more though, but generally extracting a loop to a separate method/function (or at least putting it at the end of existing method) and using return instead will do the trick. By the why Scala allows you to define functions inside other functions, so you won't pollute your global class namespace with plenty of small methods used only once – problem that sometimes arises when <a href="http://www.amazon.com/gp/product/0132350882/ref=as_li_ss_tl?ie=UTF8&amp;tag=javaandneighb-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399369&amp;creativeASIN=0132350882">religiously</a> extracting methods in Java.<br /><br /><br /><br /><span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">break</span> and <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">continue</span> – we thank you in the name of our fathers and grandfathers for your contribution to imperative programming. But we no longer need you and we won't miss you.<br /><br /><br /><br /><h4>   Arrays</h4>It's amazing how many bad habits have we learnt by all these years and how we got used to idioms that are inconsistent and simply painful. You have covariant arrays in Java with square brackets syntax, <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">length</span> final property and ability to store primitive types. You also have Java collections framework with <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">List&amp;amp;lt;T&amp;amp;gt;</span> abstraction – that is not covariant, uses <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">get()</span> and <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">size()</span> methods and can't store primitives. The list of differences does not end here, however isn't every array just a special case of <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">List</span>? Why do we have a special syntax for arrays in the language while collections are implemented in on top of the language? And isn't a bit irritating to convert them from one to another all the time?<br /><br /><br /><br /><pre class="brush: java"><br />String[] array = new String[10];<br />List&lt;String&gt; list = Arrays.asList(array);<br />String[] array2 = list.toArray(new String[list.size()]);<br /></pre><br /><br /><br /><br />Converting from collection to array is my favourite Java idiom... Why not just have same syntax, same methods, same abstraction, polymorphic behaviour – and only different implementation names?  <br /><br /><br /><br /><pre class="brush: scala"><br />val array = Array("ab", "c", "def")<br />println(array(1))<br />array filter (_.size &gt; 1)<br /><br />val list = List("ab", "c", "def")<br />println(list(1))<br />println(list filter (_.size &gt; 1))<br /></pre><br /><br /><br /><br />And don't worry, behind the scenes Scala compiler will use the same efficient array bytecode as if you were using plain arrays in Java. No magic abstractions and several layers of wrapping.<br /><br /><br /><br /><h4>   Primitives</h4>Another weird Java inconsistency – why do we have a choice between primitive <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">int</span> and wrapping <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">Integer</span>? If the variable is of Integer type does this mean it is optional (<span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">null</span>), or is it just that you can't use primitives in collections (but can in arrays, as pointed out above)? Is this unboxing safe (also known as: <i>how on earth this can throw NullPointerException</i>?) Can I compare these to integers using == operator? And can I simply call <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">toString()</span> to get string representation of this number?<br /><br /><br /><br />In Scala you no longer have a choice, every primitive type is an object, while most of the time still being a primitive in memory and in bytecode. How is that possible? Have a look at the following popular example:<br /><br /><br /><br /><pre class="brush: scala"><br />val x = 37     //x and y are objects of type Int<br />val y = 5<br />val z = x + y  //x.+(y) - yes, Int class has a "+" method<br />assert(z.toString == "42")<br /><br /></pre><br /><br /><br /><br /><span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">x</span>, <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">y</span> and <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">z</span> are instances of type <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">Int</span>. They are all objects, even adding two integers is semantically a method <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">+</span> called on <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">x</span> with <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">y</span> argument. If you think it has to perform terribly – once again behind the scenes it is compiled into ordinary primitive addition. But now you can easily use primitives in collections, pass them when any type is required (Object in Java, Any in Scala) or simply create a text representation without awkward <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">Integer.toString(7)</span> idiom. Sooo many bad habits.<br /><br /><br /><br /><h4>   Checked exceptions</h4>Another feature that I can hardly miss. Not much to be said here. Neither any mainstream language except Java have them, nor any mainstream JVM language (except Java). This topic is still relatively controversial, however if you've ever tried to deal with ubiquitous <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">SQLException</span> or <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">IOException</span>, you know how much boilerplate it introduces without good reason. Anyway, look at the next examples...<br /><br /><br /><br /><h4>   Interfaces</h4>This one is good! Scala doesn't have interfaces. Instead it introduces traits – something in between abstract classes (some trait methods might have implementation) and interfaces (one can mix in more than one trait). So essentially traits enables you to implement multiple inheritance while avoiding dreadful <a href="http://en.wikipedia.org/wiki/Diamond_problem">diamond problem</a>. How it is done requires an article on its own (in short: last trait wins), but I would rather show you an example how helpful traits are to reduce duplication.<br /><br /><br /><br />Suppose you are writing an interface to abstract binary protocol. Most implementations take raw byte array, so in Java you would simply say:<br /><br /><br /><br /><pre class="brush: java"><br />public interface Marshaller {<br />    long send(byte[] content);<br />}<br /></pre><br /><br /><br /><br />This is great from the implementation perspective – just implement a single method and the abstraction is ready. However users of the interface are complaining that it is cumbersome and not very convenient. They would like to send strings, binary and text streams, serialized objects and so on. They can either create a facade around this interface (and every user will create his/hers very own with a distinct set of bugs) or force the author of the API to extend it:<br /><br /><br /><br /><pre class="brush: java"><br />public interface Marshaller {<br /><br />    long send(byte[] content);<br /><br />    long send(InputStream stream);<br /> <br />    long send(Reader reader);<br /> <br />    long send(String s);<br /><br />    long send(Serializable obj);<br /><br />}<br /></pre><br /><br /><br /><br />Now the API is a breeze, however every implementation has to implement five methods instead of one. Also note that since most abstracted protocols are based on byte arrays, all the methods can be implemented in terms of the first one. And only the first one contains the actual marshalling code. This in turns causes every implementation to have the exact same four methods – duplication didn't go away – it has just been moved. Actually this problem is known as a thin vs. rich interface and it has been described in great <a href="http://www.amazon.com/gp/product/0981531644/ref=as_li_ss_tl?ie=UTF8&amp;tag=javaandneighb-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399369&amp;creativeASIN=0981531644">Programming in Scala</a> book.<br />What I was typically doing was to give service providers an abstract class with typical implementations of all the methods except the root one, which was used by all other methods:<br /><br /><br /><br /><pre class="brush: java"><br />import org.apache.commons.io.IOUtils;<br /><br />public abstract class MarshallerSupport implements Marshaller {<br /><br />    @Override<br />    public abstract long send(byte[] content);<br /><br />    @Override<br />    public long send(InputStream stream) {<br />        try {<br />            return send(IOUtils.toByteArray(stream));<br />        } catch (IOException e) {<br />            throw new RuntimeException(e);  //choose something more specific in real life<br />        }<br />    }<br /><br />    @Override<br />    public long send(Reader reader) {<br />        try {<br />            return send(IOUtils.toByteArray(reader));<br />        } catch (IOException e) {<br />            throw new RuntimeException(e);<br />        }<br />    }<br /><br />    @Override<br />    public long send(String s) {<br />        try {<br />            return send(s.getBytes("UTF8"));<br />        } catch (UnsupportedEncodingException e) {<br />            throw new RuntimeException(e);<br />        }<br />    }<br /><br />    @Override<br />    public long send(Serializable obj) {<br />        try {<br />            final ByteArrayOutputStream bytes = new ByteArrayOutputStream();<br />            new ObjectOutputStream(bytes).writeObject(obj);<br />            return send(bytes.toByteArray());<br />        } catch (IOException e) {<br />            throw new RuntimeException(e);<br />        }<br />    }<br /><br />}<br /></pre><br /><br /><br /><br />Now everyone is happy – instead of copying all the overloaded methods over and over, just subclass the <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">MarshallerSupport</span> and implement what you need. But what if your interface implementation also has to subclass some other class? You are out of luck then. In Scala however you change the interface to trait, opening the possibility to mix in (think something between extending and implementing) several other traits. By the way do you remember what I said about checked exceptions?<br /><br /><br /><br /><pre class="brush: scala"><br />trait MarshallerSupport extends Marshaller {<br /><br />    def send(content: Array[Byte]): Long<br /><br />    def send(stream: InputStream): Long = send(IOUtils.toByteArray(stream))<br /><br />    def send(reader: Reader): Long = send(IOUtils.toByteArray(reader))<br /><br />    def send(s: String): Long = send(s.getBytes("UTF8"))<br /><br />    def send(obj: Serializable): Long = {<br />        val bytes = new ByteArrayOutputStream<br />        new ObjectOutputStream(bytes).writeObject(obj)<br />        send(bytes.toByteArray)<br />    }<br />}<br /></pre><br /><br /><br /><br /><h4>   Switch statement</h4>There is no <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">switch</span> statement in Scala. Calling <a href="http://www.scala-lang.org/node/120">pattern matching</a> a better switch would be a blasphemy. Not only because pattern matching in Scala is an expression returning a value and also not because you can switch over literally any value if you want. Not even because there is no fall-through, break and default. It's because Scala's pattern matching enables you to match whole object structures and lists, even with wildcards. Consider this expression simplification method, originally taken from already mentioned <a href="http://www.amazon.com/gp/product/0981531644/ref=as_li_ss_tl?ie=UTF8&amp;tag=javaandneighb-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399369&amp;creativeASIN=0981531644">Programming in Scala</a> book:<br /><br /><br /><br /><pre class="brush: scala"><br />abstract class Expr<br />case class Var(name: String) extends Expr<br />case class Number(num: Double) extends Expr<br />case class UnOp(operator: String, arg: Expr) extends Expr<br />case class BinOp(operator: String, left: Expr, right: Expr) extends Expr<br /><br />//...<br /><br />def simplify(expr: Expr): Expr = expr match {<br />    case UnOp("-", UnOp("-", e)) =&gt; e  //double negation<br />    case BinOp("+", e, Number(0)) =&gt; e //adding zero<br />    case BinOp("*", e, Number(1)) =&gt; e //multiplying by one<br />    case _ =&gt; expr<br />}<br /></pre><br /><br /><br /><br />Look carefully how clever this code is! If our expression is unary “<span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">-</span>” operation and the argument is a second unary “<span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">-</span>” operation with any expression <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">e</span> as an argument (think: <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">-(-e)</span>), then simply return <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">e</span>. If you find this pattern matching example hard to read, check out the roughly equivalent Java code. However please remember: size doesn't matter (one could probably do the same with Perl one-liner) – it's about readability and maintainability:<br /><br /><br /><br /><pre class="brush: java"><br />public Expr simplify(Expr expr) {<br />    if (expr instanceof UnOp) {<br />        UnOp unOp = (UnOp) expr;<br />        if (unOp.getOperator().equals("-")) {<br />            if (unOp.getArg() instanceof UnOp) {<br />                UnOp arg = (UnOp) unOp.getArg();<br />                if (arg.getOperator().equals("-"))<br />                    return arg.getArg();<br />            }<br />        }<br />    }<br />    if (expr instanceof BinOp) {<br />        BinOp binOp = (BinOp) expr;<br />        if (binOp.getRight() instanceof Number) {<br />            Number arg = (Number) binOp.getRight();<br />            if (binOp.getOperator().equals("+") && arg.getNum() == 0 ||<br />                    binOp.getOperator().equals("*") && arg.getNum() == 1)<br />                return binOp.getLeft();<br />        }<br />    }<br />    return expr;<br />}<br /></pre><br /><br /><br /><br /><br /><div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">UPDATE</span>: In one of the comments <i>Yassine Elouafi</i><span style="font-style: normal;">claims this example is too limited as it can not simplify nested expressions like: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">BinOp("+", Var("x"), BinOp("*", Var("y"), Number(0)))</span> which reads: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">x + y * 0</span>. Indeed this algorithm assumes nested terms are already simplified. But it should be pretty obvious to improve this code to work with arbitrary complex expressions – without loosing readability. Recursion with bottom-up approach seems perfect: simplify the leaves first (simplest terms) and go up. Here is the improved code:</span></div><div><br /></div><div><pre class="brush: scala"><br />def simplify(expr: Expr): Expr = expr match {<br />    case UnOp("-", UnOp("-", e)) =&gt; simplify(e)<br />    case BinOp("+", e, Number(0)) =&gt; simplify(e)<br />    case b@BinOp("+", _, _) =&gt; simplify(BinOp(b.operator, simplify(b.left), simplify(b.right)))<br />    case BinOp("*", e, Number(1)) =&gt; simplify(e)<br />    case BinOp("*", e, Number(0)) =&gt; Number(0)<br />    case _ =&gt; expr<br />}<br /></pre></div><div><br /></div><div>Not that bad, don't you think? Of course there are still several improvements that might be applied (<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">0 + e</span>, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">1 * e</span>, operations on constants, etc.), but thanks to the power of recursion the results are already quite impressive:</div><div><br /></div><div><pre class="brush: scala"><br />//x + y * 0<br />assert(simplify(BinOp("+", Var("x"), BinOp("*", Var("y"), Number(0)))) === Var("x"))<br /><br />//(x + y) * 0<br />assert(simplify(BinOp("*", BinOp("+", Var("x"), Var("y")), Number(0))) === Number(0.0))<br /><br />//-(-(-(-5)))<br />assert(simplify(UnOp("-", UnOp("-", UnOp("-", UnOp("-", Number(5)))))) === Number(5.0))<br /><br />//y * 1 + (x + z) * 0<br />assert(<br />    simplify(<br />        BinOp(<br />            "+",<br />            BinOp(<br />                "*",<br />                Var("y"),<br />                Number(1)<br />            ),<br />            BinOp(<br />                "*",<br />                BinOp(<br />                    "+",<br />                    Var("x"),<br />                    Var("z")<br />                ),<br />                Number(0)<br />            )<br />        )<br />    ) === Var("y")<br />)<br /></pre></div><div><br /></div><div><span style="font-style: normal;">So is Scala scalable?</span></div><br /><h4>  instanceof/casting</h4>As with many other features, Scala does not have a built-in syntax for <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">instanceof</span> and downcasting. Instead the language provides you methods on actual objects:<br /><br /><br /><br /><pre class="brush: scala"><br />val b: Boolean = expr.isInstanceOf[UnOp]<br />val unOp: UnOp = expr.asInstanceOf[UnOp]<br /></pre><br /><br /><br /><br />In Scala a lot of features normally considered as part of the language are actually implemented in the language itself or at least they don't require a special syntax. I like this idea, in fact I find Ruby's way of creating objects (<span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">Foo.new</span> – method instead of <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">new</span> operator) very attractive and even unusual lack of if conditionals in Smalltalk requires some <a href="http://en.wikipedia.org/wiki/Smalltalk#Control_structures">attention</a>.<br /><h4>   Enums</h4>Scala doesn't have built-in support for enums. Enumerations in Java are known to have several fancy features which other languages envy like type safety and ability to add methods to each enum. There are at least two ways to emulate enums in Scala:<br /><br /><br /><br /><pre class="brush: scala"><br />object Status extends Enumeration {<br />   type Status = Value<br /><br />   val Pending = Value("Pending...")<br />   val Accepted = Value("Accepted :-)")<br />   val Rejected = Value("Rejected :-(")<br />}<br /><br />assume(Status.Pending.toString == "Pending...")<br />assume(Status.withName("Rejected :-(") == Status.Rejected)<br /></pre><br /><br /><br /><br />Or if you don't care about textual enum representation:<br /><br /><br /><br /><pre class="brush: scala"><br />object Status extends Enumeration {<br />   type Status = Value<br /><br />   val Pending, Accepted, Rejected = Value<br />}<br /></pre><br /><br /><br /><br />However the second and the most comprehensive way to emulate enums is to use case classes. Side note: <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">name</span> is actually an abstract method defined in base class. When you declare a method without defining the method body it is implicitly assumed to be <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">abstract</span> – no need to mark the obvious with extra keywords:<br /><br /><br /><br /><pre class="brush: scala"><br />sealed abstract class Status(val code: Int) {<br /> def name: String<br />}<br /><br />case object Pending extends Status(0) {<br /> override def name = "?"<br />}<br /><br />case object Accepted extends Status(1) {<br /> override def name = "+"<br />}<br /><br />case object Rejected extends Status(-1) {<br /> override def name = "-"<br />}<br /><br />//...<br /><br />val s: Status = Accepted<br /><br />assume(s.name == "+")<br />assume(s.code == 1)<br /><br />s match {<br />    case Pending =&gt;<br />    case Accepted =&gt;<br />    case Rejected =&gt;  //comment this line, you'll see compiler warning<br />}<br /><br /></pre><br /><br /><br /><br />This approach, although has nothing to do with enums per se, has many advantages. The biggest one is that the compiler will warn you when performing non exhaustive pattern matching – think: switch over an enum in Java without explicitly referencing each and every value or <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">default</span> block.<br /><h4>   Static methods/fields</h4>Scala doesn't have a notion of <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">static</span> fields and methods. Instead it has a feature named <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">object</span>s as opposed to <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">class</span>es. When you define a class using <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">object</span> keyword, Scala runtime will eagerly create one instance of this class and make it available under class name. This is essentially a <i>singleton</i> pattern built into the language but the most important is the mindset shift introduced by this approach. Instead of a bunch of static functions artificially gathered together inside a class (which is only a <i>de facto</i> namespace in this case) you have a singleton with <i>true</i> methods:<br /><br /><br /><br /><pre class="brush: scala"><br />sealed abstract class Status<br />case object Pending extends Status<br />case object Accepted extends Status<br />case object Rejected extends Status<br /><br />case class Application(status: Status, name: String)<br /><br />object Util {<br /><br />    def groupByStatus(applications: Seq[Application]) = applications groupBy {_.status}<br /><br />}<br /></pre><br /><br /><br /><br />Here is how the syntax works (and nice <a href="http://www.scalatest.org/scaladoc-1.6.1/#org.scalatest.matchers.ShouldMatchers">ScalaTest</a> DSL example):<br /><br /><br /><br /><pre class="brush: scala"><br />@RunWith(classOf[JUnitRunner])<br />class UtilTest extends FunSuite with ShouldMatchers {<br /><br />   type ? = this.type<br /><br />   test("should group applications by status") {<br />      val applications = List(<br />         Application(Pending, "Lorem"),<br />         Application(Accepted, "ipsum"),<br />         Application(Accepted, "dolor")<br />      )<br /><br />      val appsPerStatus = Util.groupByStatus(applications)<br /><br />      appsPerStatus should have size (2)<br />      appsPerStatus(Pending) should (<br />            have size (1) and<br />            contain (Application(Pending, "Lorem"))<br />      )<br />      appsPerStatus(Accepted) should (<br />            have size (2) and<br />            contain (Application(Accepted, "ipsum")) and<br />            contain (Application(Accepted, "dolor"))<br />      )<br />   }<br />}<br /></pre><br /><br /><br /><br /><h4>   volatile/transient/native and serialVersionUID are gone</h4>The language designers decided to convert the first three keywords into annotations. Both approaches have pros and cons, hard to find the clear winner. However turning  <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">serialVersionUID</span> into a class level annotation is a pretty good choice. I know this field existed long before annotations were introduced to the Java language, so we shouldn't blame it. But I always hated when in statically typed languages some names/fields have special meaning not reflected anywhere except the language specification itself (<i>magic numbers?</i>) Unfortunately there are examples of this unpleasant behaviour in Scala as well, namely special treatment of <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">apply()</span> method and methods ending with colon. Too bad.<br /><br /><br /><br /><h4>   Pre/post-increment</h4>You cannot do <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">i++</span> and <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">++i</span> in Scala. Period. You need a bit more verbose <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">i += 1</span> – and to make matters worse this expression return <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">Unit</span> (think: <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">void</span>). How can we deal with this noticeable feature missing? Turns out that very often this type of constructs are imperative style legacy and they can easily be avoided by using more functional and pure constructs. Take the following problem as an example:<br /><br /><br /><br />You have two same sized arrays: one with <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">names</span> and a second one with <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">ages</span>. Now you want to display each name with a corresponding age – somehow iterating over both arrays in parallel. In Java this is surprisingly tough to implement cleanly:<br /><br /><br /><br /><pre class="brush: java"><br />String[] names = new String[]{"Alice", "Bobby", "Eve", "Jane"};<br />Integer[] ages = new Integer[]{27, 31, 29, 25};<br /><br />int curAgeIdx = 0;<br />for (String name : names) {<br />    System.out.println(name + ": " + ages[curAgeIdx]);<br />    ++curAgeIdx;<br />}<br /><br />//or:<br /><br />for(int idx = 0; idx &lt; names.length; ++idx)<br />    System.out.println(names[idx] + ": " + ages[idx]);<br />}<br /></pre><br /><br /><br /><br />In Scala maybe it is shorter, but very mysterious at first:<br /><br /><br /><br /><pre class="brush: scala"><br />var names = Array("Alice", "Bobby", "Eve", "Jane")<br />var ages = Array(27, 31, 29, 25)<br /><br />names zip ages foreach {p =&gt; println(p._1 + ": " + p._2)}<br /></pre><br /><br /><br /><br /><span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">zip</span>? I encourage you play a bit with this example. If you don't feel like starting up the whole IDE, try it with Scala REPL:<br /><br /><br /><br /><pre class="brush: bash"><br />$ scala<br />scala&gt; Array("one", "two", "three") zip Array(1, 2, 31)   <br />res1: Array[(java.lang.String, Int)] = Array((one,1), (two,2), (three,31))<br /></pre><br /><br /><br /><br />Look carefully, do you see the result array containing pairs of corresponding elements from the first and the second arrays “<i>zipped</i>” together? One simple experiment and now suddenly it should be clear and much more readable than ordinary imperative solution.<br /><br /><br /><br />Scala inventors looked very thoroughly on Java language and they didn't just add syntactic sugar (like function literals or implicit conversions). They discovered plenty of inconsistencies and annoyances in Java, getting rid of them and providing more concise and deliberate replacements. Despite higher level constructs like primitive and array objects, under the hood the same fast and straightforward bytecode is generated.