---
layout: post
title: Wzorzec Visitor - realny przykład
date: '2009-03-08T19:53:00.006+01:00'
author: Tomasz Nurkiewicz
tags:
- design patterns
modified_time: '2009-09-27T17:09:33.301+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1895420078541344656
blogger_orig_url: https://www.nurkiewicz.com/2009/03/wzorzec-visitor-realny-przykad.html
---

Wizytator (odwiedzający) jest bardzo ciekawym wzorcem projektowym. Ponieważ wytłumaczenie w dwóch zdaniach do czego ten wzorzec służy jest dość trudne, zacznijmy od przykładu.<br /><br />Załóżmy, że w naszym systemie przechowujemy informacje o klientach różnego typu. Każdemu typowi odpowiada jedna klasa dziedzicząca po klasie Customer (z punktu widzenia wzorca może to też być klasa abstrakcyjna czy nawet interfejs): <span style="font-family:courier new;">NormalCustomer</span>, <span style="font-family:courier new;">VipCustomer</span>, <span style="font-family:courier new;">GroupCustomer</span>. Jedną z funkcji systemu ma być generowanie listu powitalnego dla każdego klienta, przy czym list ten ma się znacząco różnić w zależności od typu klienta. Zadanie wydaje się trywialne: <br /><br /><pre name="code" class="java"><br />public class Customer {<br /> //...<br /> public abstract Letter generateInvitationLetter();<br /> //...<br /> }<br /></pre><br /><br />...i wystarczy zaimplementować odpowiednią metodę w każdej z klas reprezentujących typ klienta. <em><strong>Polimorfizm, głupcze!</strong></em> - chciałoby się sparafrazować Billa Clintona. Ale czy na pewno? Za chwilę zauważymy, że każda z tych metod wymaga do pracy komponentu <span style="font-family:courier new;">LetterService</span>, dostępu do bazy danych poprzez <span style="font-family:courier new;">CustomerDao</span> i komunikacji ze starym systemem księgowym za pomocą <span style="font-family:courier new;">AccountantSystemFacade</span>... I rodzi się problem. Wstrzykiwać te usługi do obiektu dziedziny? Ani Spring, ani EJB3 tak nie pracuje. Przekazywać je jako argument <span style="font-family:courier new;">generateInvitationLetter()</span>? Kiepsko - jeśli jedna z klas dziedziczących potrzebuje dodatkowo jeszcze komponentu, trzeba go przekazać wszystkim i zmienić interfejs wszystkich klas...<br /><br />Ale, pomysłowy programista szybko znajdzie rozwiązanie. Gdzieś, pewnie w komponencie <span style="font-family:courier new;">LetterService</span>, doda metodę <span style="font-family:courier new;">generateInvitationLetter(Customer customer)</span>. Ponieważ <span style="font-family:courier new;">LetterService</span> jest usługą, można do niego wstrzyknąć inne potrzebne komponenty. I co programista w tej metodzie napisze?<br /><br /><pre name="code" class="java:nogutter"><br />public Letter generateInvitationLetter(Customer customer){<br /> if(customer instanceof NormalCustomer)<br />  return generateForNormalCustomer((NormalCustomer)customer);<br /> if(customer instanceof VipCustomer)<br />  return generateForVipCustomer((VipCustomer)customer);<br /> if(customer instanceof GroupCustomer)<br />  return generateForGroupCustomer((GroupCustomer)customer);<br /> throw new IllegalArgumentException("Unknown Customer type: " + customer.getClass().getName());<br />}<br /></pre><br /><br />Gdybym miewał koszmary z najgorzej napisanymi fragmentami kodu w Javie, ten gościłby w moich snach co najmniej raz w tygodniu. Oszczędzę moim Czytelnikom wyjaśniania, co w tej konstrukcji jest nie tak*.  Nawiasem mówiąc i tak nie jest tragicznie, bo programista mógłby zwracać null "bo coś trzeba" i potem tropić NPE zupełnie w innym miejscu w kodzie. A zatem co pozostaje? Oczywiście wzorzec, do którego zmierzam.<br /><br />Najpierw musimy stworzyć specjalną metodę <span style="font-family:courier new;">accept()</span> w klasie bazowej. W oryginale nic ona nie zwraca, wprowadzenie generycznego typu <span style="font-family:courier new;">T</span> jest moim wkładem w rozwój wzorców projektowych. Cóż, w ósmej klasie ówczesnej  podstawówki wymyśliłem sortowanie bąbelkowe, może tym razem będę jednak pierwszy :-).<br /><br /><pre name="code" class="java"><br />public class Customer {<br /> //...<br /> public abstract &lt;T> T accept(CustomerVisitor&lt;T> visitor);<br /> //...<br />}<br /></pre><br /><br />Czyli abstrakcyjna metoda przyjmująca nieznany nam jeszcze obiekt <span style="font-family:courier new;">CustomerVisitor</span>, parametryzowany typem jednocześnie zwracanym przez metodę <span style="font-family:courier new;">accept()</span>. Chyba troszkę odlatujemy, dlatego szybciutko przedstawiam implementację tej metody w:<br /><br /><pre name="code" class="java"><br />public &lt;T> T accept(CustomerVisitor&lt;T> visitor){<br /> return visitor.visit(this);<br />}<br /></pre><br /><br />Dodam, że w KAŻDEJ klasie dziedziczącej po <span style="font-family:courier new;">Customer</span> implementacja jest taka sama! Co?!? Nie do końca, zauważcie, że w każdej klasie referencja <span style="font-family:courier new;">this</span> ma typ właściwy dla tej klasy, a nie typ klasy bazowej <span style="font-family:courier new;">Customer</span>. Pora odkryć wszystkie karty:<br /><br /><pre name="code" class="java"><br />public interface CustomerVisitor&lt;T> {<br /> T visit(NormalCustomer customer);<br /> T visit(VipCustomer customer);<br /> T visit(GroupCustomer customer);<br />}<br /></pre><br /><br />Jak wspomniałem referencja this ma zawsze odpowiedni typ: <span style="font-family:courier new;">NormalCustomer</span> , <span style="font-family:courier new;">VipCustomer</span> lub <span style="font-family:courier new;">GroupCustomer</span> . Już na etapie kompilacji można zatem określić, którą z przeciążonych wersji metody <span style="font-family:courier new;">visit()</span> należy wywołać w <span style="font-family:courier new;">accept()</span>. Ot, cała magia! To troszkę tak, jakbyśmy przekazali komponent <span style="font-family:courier new;">LetterService</span> abstrakcyjnej metodzie <span style="font-family:courier new;">generateInvitationLetter()</span> w klasie <span style="font-family:courier new;">Customer</span>, a następnie pozwolili wywołaniu polimorficznemu w odpowiedniej klasie dziedziczącej samemu wybrać, którą metodę tego komponentu wywołać.<br /><br />A zatem jak Visitor pomaga nam w rozwiązaniu naszego oryginalnego problemu?<br /><br /><pre name="code" class="java"><br />public class InvitationLetterGeneratorVisitor implements CustomerVisitor&lt;Letter> {<br /> Letter visit(NormalCustomer customer) {/*...*/}<br /> Letter visit(VipCustomer customer) {/*...*/}<br /> Letter visit(GroupCustomer customer) {/*...*/}<br /> }<br /></pre><br /><br />i wywołanie:<br /><br /><pre name="code" class="java"><br />Customer customer = //...<br />Letter letter = customer.accept(invitationLetterGeneratorVisitor );<br /></pre><br /><br />Tak naprawdę nie potrzebujemy osobnej klasy <span style="font-family:courier new;">InvitationLetterGeneratorVisitor</span>, przecież komponent <span style="font-family:courier new;">LetterService</span> może dodatkowo implementować CustomerVisitor&lt;Letter>! I wtedy dla wygody dodajemy metodę w LetterService:<br /><br /><pre name="code" class="java"><br />public Letter generateInvitationLetter(Customer customer){<br /> return customer.accept(this);<br />}<br /></pre><br /><br />Zwróćcie uwagę, że nie przekazujemy explicite komponentu LetterService, a jedynie obiekt implementujący <span style="font-family:courier new;">CustomerVisitor&lt;Letter></span>.<br /><br />Dlaczego takie podejście jest wygodne? Załóżmy, że nasz system ma teraz generować również listy z wyciągami z konta, przydzielać klientom promocje w zależności od historii ich zakupów oraz oceniać ich zdolność kredytową. Naturalnie wszystko w zależności od typu klienta. Oceńcie, ile czasu zajmie (i jak eleganckie będzie):<br />- dorobienie odpowiednich metod przyjmujących wszystkie potrzebne usługi jako argumenty w klasie <span style="font-family:courier new;">Customer</span> i klasach dziedziczących, <br />- dopisanie metod w odpowiednich komponentach z powtarzającymi się kaskadami <span style="font-family:courier new;">if-instanceof</span>,<br />- napisanie klas implementujących <span style="font-family:courier new;">CustomerVisitor</span> dla każdego z przypadków<br /><br />A jak kosztowne jest dodanie nowego typu klienta? W obu przypadkach to spory problem. Jednak co wolicie - szukać w kodzie wszystkich wystąpień wodospadów <span style="font-family:courier new;">if-instanceof</span> (lub czekać, aż otrzymacie odpowiedni wyjątek w działającej aplikacji) - czy grzecznie dopisać do wszystkich napisanych wizytatorów jedną metodę (bez tego kompilator nie będzie zadowolony).<br /><br />Mam nadzieję, że zachęciłem Was do skorzystania z tego wzorca. Pisałem ostatnio aplikację gdzie hierarchie dziedziczenia były długie i szerokie i wzorzec Visitor znakomicie ułatwił programowanie.<br /><br />* Zwracanie się do rozmówcy per "każdy wie, że to rozwiązanie jest złe, nie trzeba tego tłumaczyć" z reguły oznacza, że wypowiadający nie ma żadnych argumentów, ale nauczył się bardzo brzydkiego chwytu erystycznego. Zrobiłem to nieumyślnie, wybaczcie, zatem tłumaczę się na potrzeby polemiki:<br />- konstrukcje switch, wielokrotne warunki na tej samej zmiennej, etc. prawie zawsze sugerują użycie polimorfizmu. My też spróbowaliśmy...<br />- instanceof i rzutowanie w dół (zwłaszcza na taką skalę) trudno nazwać eleganckim rozwiązaniem w duchu OOP<br />- łatwo pominąć jakiś typ w serii warunków, zwłaszcza, gdy lista typów zwiększa się po dłuższym czasie. Poza tym jeśli nasza hierarchia jest dłuższa, sprawdzenie najpierw typu nadrzędnego a potem podrzędnego będzie trudnym do wykrycia błędem.<br />- po prostu źle wygląda ;-)