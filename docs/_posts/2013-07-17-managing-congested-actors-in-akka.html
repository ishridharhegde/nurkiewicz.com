---
layout: post
title: Managing congested actors in Akka
date: '2013-07-17T18:51:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- akka
- scala
modified_time: '2013-07-17T18:51:48.636+02:00'
thumbnail: http://4.bp.blogspot.com/-uJ4FUmvzPQU/UebK-CNDrNI/AAAAAAAAAzU/trrfd3NcZGY/s72-c/oslo-3.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8076627398809277023
blogger_orig_url: https://www.nurkiewicz.com/2013/07/managing-congested-actors-in-akka.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-uJ4FUmvzPQU/UebK-CNDrNI/AAAAAAAAAzU/trrfd3NcZGY/s1600/oslo-3.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="182" src="http://4.bp.blogspot.com/-uJ4FUmvzPQU/UebK-CNDrNI/AAAAAAAAAzU/trrfd3NcZGY/s320/oslo-3.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Hovedøya</td></tr></tbody></table>There comes a time in an Akka application when an actor can longer handle increasing load. Since each actor can only handle one message at a time and it keeps a backlog of pending messages in a queue called <a href="http://doc.akka.io/docs/akka/2.2.0/scala/mailboxes.html">mailbox</a>, there is a risk of overloading one actor if too many messages are sent to one actor at the same time or actor fails to process messages fast enough - queue will keep growing and growing. This will negatively impact responsiveness of the system and might even result in application crashing.<br /><br />It’s actually very easy to simulate such load by simply sending continuous stream of messages to an actor as fast as possible:<br /><br /><pre class="brush: scala">case object Ping<br /><br />class PingActor extends Actor {<br /><br />    def receive = {<br />        case Ping =&gt; <br />            //don't do this at home!<br />            Thread sleep 1<br />    }<br />}<br /><br />object Main extends App {<br />    val system = ActorSystem("Heavy")<br />    val client = system.actorOf(Props[PingActor], "Ping")<br />    while(true) {<br />        client ! Ping<br />    }<br />}<br /></pre>Of course you should not sleep in actor, ever, this is just to stress the mailbox. If you are (un)lucky and play a bit with the amount of sleep, your application will soon spend  most of the time doing (fruitless) GC and you might see dreadful OOM errors:<br /><br /><pre class="brush: scala">Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "Heavy-akka.actor.default-dispatcher-6"<br />Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "Heavy-akka.actor.default-dispatcher-10"<br /></pre>…and finally die:<br /><br /><pre class="brush: scala">Uncaught error from thread [Heavy-akka.actor.default-dispatcher-7] shutting down JVM <br />since 'akka.jvm-exit-on-fatal-error' is enabled for ActorSystem[Heavy]<br />java.lang.OutOfMemoryError: GC overhead limit exceeded<br /></pre>Today we will learn how to handle such congested actors so that sudden burst of traffic does not crash the whole application.<br /><br /><h2>Routing and load balancing</h2>One simple solution to reducing load of one actor is spreading work across several copies of such actor. Akka provides built in <a href="http://doc.akka.io/docs/akka/2.2.0/scala/routing.html">routing and load balancing</a> actor that stands in front and manages several instances of our actor. Router chooses (using configurable strategy) one of the underlying instances, therefore spreading load:<br /><br /><pre class="brush: scala">val props = Props[PingActor].<br />       withRouter(RoundRobinRouter(nrOfInstances = 10))<br />val client = system.actorOf(props, "Ping")<br /></pre>What we did is we asked Akka to put <a href="http://en.wikipedia.org/wiki/Round-robin_scheduling">Round Robin</a> router in front of 10 independent instances of <code>PingActor</code> (instead of just one). Theoretically this could cut latency by an order of magnitude. So if routing is so effective, why not use it by default and transparently, like Enterprise Java Beans pooling?<br /><br />To answer this question we need a bit more complex example. <code>PingActor</code> is stateless thus it can be safely replicated behind a router. But what about the following actor?<br /><br /><pre class="brush: scala">class StoreActor extends Actor {<br /><br />    private var lastUsedId = 0<br /><br />    def receive = {<br />        case Store(s) =&gt;<br />            val id = nextUniqueId()<br />            slowStore(s, id)<br />            sender ! Done(id)<br />    }<br /><br />    private def nextUniqueId() = {<br />        lastUsedId += 1<br />        lastUsedId<br />    }<br /><br />    private def slowStore(s: String, id: Int) {<br />        //...<br />    }<br />}<br /></pre>Clearly <code>StoreActor</code> assumes there is only one instance of <code>lastUsedId</code> and since <code>receive</code> is never called concurrently, uniqueness of IDs is guaranteed. We generate unique ID, store some message and send generated ID back to the client actor.<br /><br />Unfortunately the moment we put any router in front of <code>StoreActor</code>, each copy of that actor has its own <code>lastUsedId</code> variable and duplicates are unavoidable. Let’s rethink our design. In order to generate unique IDs we must have just one copy of the counter and restrict access to it. But storing is most likely thread-safe, thus can be parallelized. The simples solution would be to use <code>StoreActor</code> companion object and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicInteger.html"><code>AtomicInteger</code></a>:<br /><br /><pre class="brush: scala">//DIRTY! Close your eyes!<br />object StoreActor {<br /><br />    val lastUsedId = new AtomicInteger<br /><br />}<br /><br />class StoreActor extends Actor with ActorLogging {<br /><br />    private def nextUniqueId() = StoreActor.lastUsedId.incrementAndGet()<br /><br />    //...<br /><br />}<br /></pre>Well… Honestly, shared mutable state is hardly what we’re after. We should rather look into actor model more closely and extract ID generation logic to separate actor, promoting <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle"><i>single responsibility principle</i></a> as a bonus:<br /><br /><pre class="brush: scala">case object GiveMeUniqueId<br /><br />class UniqueIdActor extends Actor {<br /><br />    private var lastUsedId = 0<br /><br />    def receive = {<br />        case GiveMeUniqueId =&gt;<br />            lastUsedId += 1<br />            sender ! lastUsedId<br />    }<br /><br />}<br /></pre>Obviously all <code>StoreActor</code> instances behind router should share reference to one single instance of <code>UniqueIdActor</code>:<br /><br /><pre class="brush: scala">class StoreActor(uniqueIdActor: ActorRef) extends Actor {<br /><br />    private implicit val timeout = Timeout(10 minutes)<br /><br />    import context.dispatcher<br /><br />    def receive = {<br />        case Store(s) =&gt;<br />            uniqueIdActor ? GiveMeUniqueId map {<br />                case id: Int =&gt;<br />                    slowStore(s, id)<br />                    Done(id)<br />            } pipeTo sender<br />    }<br /><br />    private def slowStore(s: String, id: Int) {<br />        //...<br />    }<br />}<br /></pre>As you can see <code>uniqueIdActor</code> is passed to the actor constructor. Obviously we should not create new <code>UniqueIdActor</code> in each <code>StoreActor</code> as that would produce 10 independent child copies rather than one centralized actor. Here is a glue code:<br /><br /><pre class="brush: scala">val uniqueIdActor = system.actorOf(Props[UniqueIdActor], "UniqueId")<br />val props = Props(classOf[StoreActor], uniqueIdActor).<br />       withRouter(RoundRobinRouter(nrOfInstances = 10))<br />val client = system.actorOf(props, "Heavy")<br /></pre><h2>Software transactional memory</h2>You might have a feeling that a separate actor to simply wrap one <code>Int</code> is an overkill. On the other hand shared mutable <code>AtomicInteger</code> is far from Akka’s share-nothing spirit. We can experiment with <a href="http://doc.akka.io/docs/akka/2.2.0/scala/stm.html">software transactional memory in Akka</a> built on top of <a href="http://nbronson.github.io/scala-stm/">ScalaSTM</a>. We will wrap mutable <code>Int</code> with transactional <code>Ref</code> and share this reference among all <code>StoreActor</code>s:<br /><br /><pre class="brush: scala">class StoreActor(counter: Ref[Int]) extends Actor {<br /><br />    def receive = {<br />        case Store(s) =&gt;<br />            val id = nextUniqueId()<br />            slowStore(s, id)<br />            sender ! Done(id)<br />    }<br /><br />    private def nextUniqueId() = atomic {<br />        implicit tx =&gt;<br />            counter += 1<br />            counter()<br />    }<br /><br />    //...<br /><br />}<br /></pre>This time all <code>StoreActor</code> instances share transactional <code>Ref[Int]</code>. Calling <code>nextUniqueId()</code> increments <code>counter</code> within transaction, thus the code is thread-safe. Much simpler architecture and synchronous <code>nextUniqueId()</code> are easier to read and maintain. However shared data structure of any kind is problematic, especially when we try to scale out. But just as an exercise try to replace STM with <a href="http://doc.akka.io/docs/akka/2.2.0/scala/agents.html">agents</a>. Here is a starting glue code for STM:<br /><br /><pre class="brush: scala">import scala.concurrent.stm.Ref<br /><br />val globalUniqueId = Ref(0)<br />val props = Props(classOf[StoreActor], globalUniqueId).<br />       withRouter(RoundRobinRouter(nrOfInstances = 10))<br />val client = system.actorOf(props, "Heavy")<br /></pre>In a perfect world distributing work between several actors can work. But what if we <i>really</i> need just one, single instance and it can’t keep up with incoming messages? In that case we should at least fail fast with<br /><br /><h2>Bounded mailbox</h2>By default mailboxes are limited only by the amount of memory we have. This means that one rogue actor can impact the whole system since each actor has a separate mailbox but they all share the same heap. A simple solution is to limit the size of mailbox and simply discard everything above given threshold. Luckily Akka supports <a href="http://doc.akka.io/docs/akka/2.2.0/scala/mailboxes.html">bounded mailboxes</a> out-of-the-(mail)box. In general, if we can’t cope with increasing load, we should at least fail fast rather than hanging forever.<br /><br /><pre class="brush: scala">class StoreActor extends Actor with RequiresMessageQueue[BoundedMessageQueueSemantics] {<br /><br />    private var lastUniqueId = 0<br /><br />    //...<br /><br />}<br /></pre>Additionally you must configure queue capacity, either in code or in <code>application.conf</code>:<br /><br /><pre class="brush: plain">bounded-mailbox {<br />    mailbox-type = "akka.dispatch.BoundedMailbox"<br />    mailbox-capacity = 1000<br />    mailbox-push-timeout-time = 100ms<br />}<br /></pre>With this configuration there is only one instance of <code>StoreActor</code> that can queue up to 1000 messages. If more messages are sent they are discarded and forwarded to <i>Dead Letter Queue</i>, unless mailbox of <code>StoreActor</code> doesn’t shrink within 100 milliseconds.<br /><br /><h2>Summary</h2>Keeping mailboxes short and actors fast is a key factor that impacts responsiveness and stability of Akka application. By monitoring your system you should discover bottlenecks and either scale up/out or fail fast. Otherwise your JVM will quickly start choking and loose momentum.<br /><br /> <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>