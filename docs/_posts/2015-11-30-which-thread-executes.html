---
layout: post
title: Which thread executes CompletableFuture's tasks and callbacks?
date: '2015-11-30T08:58:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- CompletableFuture
- multithreading
modified_time: '2015-11-30T08:58:03.979+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1594946357632027800
blogger_orig_url: https://www.nurkiewicz.com/2015/11/which-thread-executes.html
---

<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"><code>CompletableFuture</code></a> is still a relatively fresh concept, despite being introduced almost two years ago (!) in March 2014 with Java 8. But maybe it's good that this class is not so well known since it can be easily abused, especially with regards to threads and thread pools that are involved along the way. This article aims to describe how threads are used with <code>CompletableFuture</code>.<br /><br /><h2 id="running-tasks">Running tasks</h2>This is the fundamental part of the API. There is a convenient <code>supplyAsync()</code> method that is similar to <code>ExecutorService.submit()</code>, but returning <code>CompletableFuture</code>:<br /><br /><pre class="brush: java">CompletableFuture&lt;String&gt; future =<br />        CompletableFuture.supplyAsync(() -&gt; {<br />            try (InputStream is = new URL("http://www.nurkiewicz.com").openStream()) {<br />                log.info("Downloading");<br />                return IOUtils.toString(is, StandardCharsets.UTF_8);<br />            } catch (IOException e) {<br />                throw new RuntimeException(e);<br />            }<br />        });</pre>The problem is, <code>supplyAsync()</code> by default uses <code>ForkJoinPool.commonPool()</code>, thread pool shared between all <code>CompletableFuture</code>s, all parallel streams and all applications deployed on the same JVM (if you are unfortunate to still use application server with many deployed artifacts). This hard-coded, unconfigurable thread pool is completely outside of our control, hard to monitor and scale. Therefore you should always specify your own <code>Executor</code>, like here (and have a look at my <a href="http://www.nurkiewicz.com/2014/11/executorservice-10-tips-and-tricks.html">few tips how to create one</a>):<br /><br /><pre class="brush: java">ExecutorService pool = Executors.newFixedThreadPool(10);<br /><br />final CompletableFuture&lt;String&gt; future =<br />        CompletableFuture.supplyAsync(() -&gt; {<br />            //...<br />        }, pool);</pre>But that is just the beginning...<br /><br /><h2 id="callbacks-and-transformations">Callbacks and transformations</h2>Suppose you want to transform given <code>CompletableFuture</code>, e.g. extract the length of the <code>String</code>:<br /><br /><pre class="brush: java">CompletableFuture&lt;Integer&gt; intFuture =<br />    future.thenApply(s -&gt; s.length());</pre>Who, exactly, invokes the <code>s.length()</code> code? Frankly, my dear developers, we don't give a damn <sup><a href="https://en.wikipedia.org/wiki/Frankly,_my_dear,_I_don%27t_give_a_damn">[1]</a></sup>. As long as the lambda expression inside all of the operators like <code>thenApply</code> is cheap, we don't really care who calls it. But what if this expression takes a little bit of CPU time to complete or makes a blocking network call?<br /><br />First of all what happens by default? Think about it: we have a background task of type <code>String</code> and we want to apply some specific transformation asynchronously when that value completes. The easiest way to implement that is by wrapping the original task (returning <code>String</code>) and intercepting it when it completes. When the inner task finishes, our callback kicks in, applies the transformation and returns modified value. It's like an aspect that sits between our code and original computation result. That being said it should be fairly obvious that <code>s.length()</code> transformation will be executed in the same thread as the original task, huh? Not quite!<br /><br /><pre class="brush: java">CompletableFuture&lt;String&gt; future =<br />        CompletableFuture.supplyAsync(() -&gt; {<br />            sleepSeconds(2);<br />            return "ABC";<br />        }, pool);<br /><br />future.thenApply(s -&gt; {<br />    log.info("First transformation");<br />    return s.length();<br />});<br /><br />future.get();<br />pool.shutdownNow();<br />pool.awaitTermination(1, TimeUnit.MINUTES);<br /><br />future.thenApply(s -&gt; {<br />    log.info("Second transformation");<br />    return s.length();<br />});</pre>The first transformation in <code>thenApply()</code> is registered while the task is still running. Thus it will be executed immediately after task completion in the same thread as the task. However before registering second transformation we wait until the task actually completes. Even worse, we shutdown the thread pool entirely, to make sure no other code can ever be executed there. So which thread will run second transformation? We know it must happen immediately since the <code>future</code> we register callback on already completed. It turns out that by default client thread (!) is used! The output is as follows:<br /><br />pool-1-thread-1 | First transformation main | Second transformation<br /><br />Second transformation, when registered, realizes that the <code>CompletableFuture</code> already finished, so it executes the transformation immediately. There is no other thread around so <code>thenApply()</code> is invoked in the context of current <code>main</code> thread. The biggest reason why this behavior is error prone shows up when the actual transformation is costly. Imagine lambda expression inside <code>thenApply()</code> doing some heavy computation or blocking network call. Suddenly our asynchronous <code>CompletableFuture</code> blocks calling thread!<br /><br /><h2 id="controlling-callbacks-thread-pool">Controlling callback's thread pool</h2>There are two techniques to control which thread executes our callbacks and transformations. Notice that these solutions are only needed if your transformations are costly. Otherwise the difference is negligible. So first of all we can choose the <code>*Async</code> versions of operators, e.g.:<br /><br /><pre class="brush: java">future.thenApplyAsync(s -&gt; {<br />    log.info("Second transformation");<br />    return s.length();<br />});</pre>This time the second transformation was automatically off-loaded to our friend, <code>ForkJoinPool.commonPool()</code>:<br /><br /><pre class="brush: java">pool-1-thread-1                  | First transformation<br />ForkJoinPool.commonPool-worker-1 | Second transformation</pre>But we don't like <code>commonPool</code> so we supply our own:<br /><br /><pre class="brush: java">future.thenApplyAsync(s -&gt; {<br />    log.info("Second transformation");<br />    return s.length();<br />}, pool2);</pre>Notice that different thread pool was used (<code>pool-1</code> vs. <code>pool-2</code>):<br /><br /><pre class="brush: java">pool-1-thread-1 | First transformation<br />pool-2-thread-1 | Second transformation</pre><h2 id="treating-callback-like-another-computation-step">Treating callback like another computation step</h2>But I believe that if you are having troubles with long-running callbacks and transformations (remember that this article applies to almost all other methods on <code>CompletableFuture</code>), you should simply use another explicit <code>CompletableFuture</code>, like here:<br /><br /><pre class="brush: java">//Imagine this is slow and costly<br />CompletableFuture&lt;Integer&gt; strLen(String s) {<br />    return CompletableFuture.supplyAsync(<br />            () -&gt; s.length(),<br />            pool2);<br />}<br /><br />//...<br /><br />CompletableFuture&lt;Integer&gt; intFuture = <br />        future.thenCompose(s -&gt; strLen(s));</pre>This approach is more explicit. Knowing that our transformation has significant cost we don't risk running it on some arbitrary or uncontrolled thread. Instead we explicitly model it as asynchronous operation from <code>String</code> to <code>CompletableFuture&lt;Integer&gt;</code>. However we must replace <code>thenApply()</code> with <code>thenCompose()</code>, otherwise we'll end up with <code>CompletableFuture&lt;CompletableFuture&lt;Integer&gt;&gt;</code>.<br /><br />But what if our transformation does not have a version that plays well with nested <code>CompletableFuture</code>, e.g. <code>applyToEither()</code> that waits for the first <code>Future</code> to complete and applies a transformation?<br /><br /><pre class="brush: java">CompletableFuture&lt;CompletableFuture&lt;Integer&gt;&gt; poor = <br />        future1.applyToEither(future2, s -&gt; strLen(s));</pre>There is a handy trick for "unwrapping" such obscure data structure called <code>flatten</code>, easily implemented using <code>flatMap(identity)</code> (or <code>flatMap(x -&gt; x)</code>). In our case <code>flatMap()</code> is called <code>thenCompose</code> (<em>duh!</em>):<br /><br /><pre class="brush: java">CompletableFuture&lt;Integer&gt; good = <br />        poor.thenCompose(x -&gt; x);</pre>I leave it up to you how and why it works. I hope this article made it more clear how threads are involved in <code>CompletableFuture</code>.<br /><br /><script>SyntaxHighlighter.highlight();</script>