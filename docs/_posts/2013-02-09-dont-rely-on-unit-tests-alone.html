---
layout: post
title: Don't rely on unit tests alone
date: '2013-02-09T23:40:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- testing
- mockito
- tdd
- junit
modified_time: '2013-02-17T16:31:41.022+01:00'
thumbnail: http://3.bp.blogspot.com/-O4nOV_ZO9Vw/URbP6S_dloI/AAAAAAAAAtc/BnKE-Ax4-z0/s72-c/p.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1240043741638782311
blogger_orig_url: https://www.nurkiewicz.com/2013/02/dont-rely-on-unit-tests-alone.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-O4nOV_ZO9Vw/URbP6S_dloI/AAAAAAAAAtc/BnKE-Ax4-z0/s1600/p.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="236" src="http://3.bp.blogspot.com/-O4nOV_ZO9Vw/URbP6S_dloI/AAAAAAAAAtc/BnKE-Ax4-z0/s320/p.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">RÃ¥dhusbrygga</td></tr></tbody></table>When you are building a complex system, barely testing components in isolation is not enough. It's crucial, but not enough. Imagine a car factory that manufactures and imports highest quality parts, but after assembling the vehicle never starts the engine. If your test case suite consists barely of unit tests, you can never be sure that the system as a whole works. Let's give a contrived example:<br /><br /><pre class="brush:java">public class UserDao {<br /><br />    public List&lt;User&gt; findRecentUsers() {<br />        try {<br />            return //run some query<br />        } catch(EmptyResultDataAccessException ignored) {<br />            return null;<br />        }<br />    }<br /><br />    //...<br />}<br /></pre>I hope you already spotted an anti-pattern in the <code>catch</code> block (and I don't mean ignoring the exception, it seems to be expected). Being a good citizen we decide to fix the implementation by <a href="http://www.javapractices.com/topic/TopicAction.do?Id=59">returning an empty collection instead of <code>null</code></a>:<br /><a name='more'></a><br /><br /><pre class="brush:java">public class UserDao {<br /><br />    public List&lt;User&gt; findRecentUsers() {<br />        try {<br />            return //run some query<br />        } catch(EmptyResultDataAccessException ignored) {<br />            return Collections.emptyList();<br />        }<br />    }<br /><br />    //...<br />}<br /></pre>The fix is so simple that we almost forget about running unit tests, but just in case we execute them and find the first test case to fail:<br /><br /><pre class="brush:java">public class UserDaoTest {<br /><br />    private UserDao userDao;<br /><br />    @Before<br />    public void setUp() throws Exception {<br />        userDao = new UserDao();<br />    }<br /><br />    @Test<br />    public void shouldReturnNullWhenNoRecentUsers() throws Exception {<br />        //given<br /><br />        //when<br />        final List&lt;User&gt; result = userDao.findRecentUsers();<br /><br />        //then<br />        assertThat(result).isNull();<br />    }<br /><br />    @Test<br />    public void shouldReturnOneRecentUser() throws Exception {<br />        //given<br />        final User lastUser = new User();<br />        userDao.storeLoginEvent(lastUser);<br /><br />        //when<br />        final List&lt;User&gt; result = userDao.findRecentUsers();<br /><br />        //then<br />        assertThat(result).containsExactly(lastUser);<br />    }<br /><br />    @Test<br />    public void shouldReturnTwoRecentUsers() throws Exception {<br />        //given<br />        final User lastUser = new User();<br />        final User oneButLastUser = new User();<br />        userDao.storeLoginEvent(oneButLastUser);<br />        userDao.storeLoginEvent(lastUser);<br /><br />        //when<br />        final List&lt;User&gt; result = userDao.findRecentUsers();<br /><br />        //then<br />        assertThat(result).containsExactly(lastUser, oneButLastUser);<br />    }<br /><br />}<br /></pre>Apparently not only the code was broken (by returning <code>null</code> instead of <code>null</code>-like empty collection), but there was a test verifying this bogus behaviour. I'm pretty sure the test was written after the implementation and it had to somehow deal with reality. No one would ever write a test like that without prior knowledge of the implementation peculiarities. So we fix the test and cheerfully wait for green CI build - which eventually comes.<br /><br />Days later our application breaks with <code>NullPointerException</code> on production. It breaks in a place that is unit-tested thoroughly:<br /><br /><pre class="brush:java">public class StatService {<br /><br />    private final UserDao userDao;<br /><br />    public StatService(UserDao userDao) {<br />        this.userDao = userDao;<br />    }<br /><br />    public void welcomeMostRecentUser() {<br />        final List&lt;User&gt; recentUsers = userDao.findRecentUsers();<br />        if (recentUsers != null) {<br />            welcome(recentUsers.get(0));<br />        }<br />    }<br /><br />    private void welcome(User user) {<br />        //...<br />    }<br />}<br /></pre>We are surprised because this class is fully covered by unit tests (verification step omitted for clarity):<br /><br /><pre class="brush:java">@RunWith(MockitoJUnitRunner.class)<br />public class WelcomeServiceTest {<br /><br />    @Mock<br />    private UserDao userDaoMock;<br />    private WelcomeService welcomeService;<br /><br />    @Before<br />    public void setup() {<br />        welcomeService = new WelcomeService(userDaoMock);<br />    }<br /><br />    @Test<br />    public void shouldNotSendWelcomeMessageIfNoRecentUsers() throws Exception {<br />        //given<br />        given(userDaoMock.findRecentUsers()).willReturn(null);<br /><br />        //when<br />        welcomeService.welcomeMostRecentUser();<br /><br />        //then<br />        //verify no message sent<br />    }<br /><br />    @Test<br />    public void shouldSendWelcomeMessageToMostRecentUser() throws Exception {<br />        //given<br />        given(userDaoMock.findRecentUsers()).willReturn(asList(new User()));<br /><br />        //when<br />        welcomeService.welcomeMostRecentUser();<br /><br />        //then<br />        //verify user welcomed<br />    }<br /><br />    //...<br /><br />}<br /></pre>You see where the problem lies? We changed the contract of <code>UserDao</code> class while it "looks" the same on the surface. By fixing broken tests we assumed it still works. However <code>WelcomeService</code> was still relying on the old behaviour of <code>UserDao</code>, which was either returning <code>null</code> or a list with at least one element. This behaviour was recorded using mocking framework, so that we were able to unit test <code>WelcomeService</code> in separation.<br /><br />In other words we failed to make sure these two components are still working with each other, we barely tested them alone. Back to our car metaphor - all the pieces still fit together (same contract), but one of them is not behaving internally the same as before. So, what really went wrong? There are at least <i>four</i> problems here, and if any of them was mitigated, none of this would have ever happened.<br /><br />First of all the author of <code>UserDao</code> failed to recognize that returning a <code>null</code> while an empty list seems much more intuitive. It begs the question: is there a significant difference between <code>null</code> and empty collection? If yes, maybe you are trying to "encode" too much information in a single return value? If no, why make life of your API consumers harder? Iterating over empty collection doesn't require any extra effort; iterating over collection that might be <code>null</code> needs one extra condition. <br /><br />Author of <code>WelcomeService</code> failed as well by assuming <code>null</code> means an empty collection. He should work around the ugly API rather than relying on it. In this case he could have used <a href="http://commons.apache.org/collections/apidocs/org/apache/commons/collections/CollectionUtils.html#isNotEmpty(java.util.Collection)"><code>CollectionUtils.isNotEmpty()</code></a> and be a little bit more defensive:<br /><br /><pre class="brush:java">if (CollectionUtils.isNotEmpty(recentUsers)) {<br /></pre>For more comprehensive solution, he could also consider <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorating</a> <code>UserDao</code> and replacing <code>null</code> with empty collection. Or even using AOP to fix such APIs globally in whole application. And BTW this applies to <code>String</code>s as well. In 99% of the cases there is no "business" difference between <code>null</code>, empty string and a string with few white spaces. Use <a href="http://commons.apache.org/lang/api/org/apache/commons/lang3/StringUtils.html#isBlank(java.lang.CharSequence)"><code>StringUtils.isBlank()</code></a> or similar by default, unless you really want to distinguish between them.<br /><br />Finally the person "fixing" <code>UserDao</code> failed to see the big picture. Barely fixing unit tests is not enough. When you are changing the behaviour of a class without changing the API (this is especially important for dynamic languages), chances are you will miss places where this API was used, loosing the context.<br /><br />But the biggest failure was the <b>lack of component/system tests</b>. If we simply had a test case exercising both <code>WelcomeService</code> <i>and</i> <code>UserDao</code> running together, this bug would've been discovered. It's not enough to have 100% code coverage. You test every piece of the jigsaw puzzle but never look at the finished picture. Have at least few larger, smoke tests. Otherwise you no longer have this awesome confidence that when tests are green, code is good to go.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>