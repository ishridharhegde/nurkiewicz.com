---
layout: post
title: 'Designing Data-Intensive Applications: my favourite book of last year'
date: '2019-02-25T23:31:00.001+01:00'
author: Tomasz Nurkiewicz
tags:
- review
- books
modified_time: '2019-02-25T23:34:44.150+01:00'
thumbnail: https://3.bp.blogspot.com/-6EInRlzprHg/XHRsd7ENpII/AAAAAAAAp5E/WbuvnTMgUn4jUsrS0bNMESYQFuHE7PkBACK4BGAYYCw/s72-c/IMG_0319.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3046381142609042890
blogger_orig_url: https://www.nurkiewicz.com/2019/02/designing-data-intensive-applications.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-6EInRlzprHg/XHRsd7ENpII/AAAAAAAAp5E/WbuvnTMgUn4jUsrS0bNMESYQFuHE7PkBACK4BGAYYCw/s1600/IMG_0319.JPG" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="150" src="https://3.bp.blogspot.com/-6EInRlzprHg/XHRsd7ENpII/AAAAAAAAp5E/WbuvnTMgUn4jUsrS0bNMESYQFuHE7PkBACK4BGAYYCw/s200/IMG_0319.JPG" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Warsaw Old Town</td></tr></tbody></table>Martin Kleppmann, the author of <a href="https://amzn.to/2teQsWS"><em>Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems</em></a> wrote a wonderful, comprehensive book. I consider this to be my most valuable reading of 2018, even though the book is almost 2 years old now. Martin proves that great bestsellers in the programming industry aren’t about shiny new frameworks and buzzwords. <em>Data-Intensive Applications</em> is a solid piece about the fundamentals of computer systems, especially from the data manipulation perspective.<br /><br />This book introduces and explains all topics related to data storage, retrieval and transmission. That doesn’t sound very exciting, does it? However, expect very thorough (600+ pages!) and enjoyable journey through databases, protocols, algorithms and distributed systems.<br /><br />In the <strong>first chapter</strong>: “<em>Reliable, Scalable, and Maintainable Applications</em>” the author describes the environment in which our systems live nowadays. What are the possible failure modes (software, hardware, human), what are the limits of scalability and how to tackle the complexity of ever-evolving system? <strong>Second chapter</strong> “<em>Data Models and Query Languages</em>” goes through the history of various query languages. Apart from SQL we learn about how diverse NoSQL query languages are, including graph queries, map-reduce paradigm and logic languages. <strong>The third chapter</strong>, titled “<em>Storage and Retrieval</em>”, describes algorithms and data structures relevant for storing and querying data. We are talking B-trees, hash-indexes and so on. This chapter really blew my mind with a very detailed explanation of replicated key-value database that is optimized for writes and fault tolerant. The author explains very clearly every design decision he makes: keeping the most recent data in memory accompanied with an append-only log for persistence and fault tolerance, background compaction, consistent hashing to avoid collisions. Also synchronous vs.&nbsp;asynchronous replication, bloom filters, and much more. After many pages of this seemingly academic discussion, he basically says: OK, so this how Cassandra works. You’ll find dozens of such eye-opening themes throughout the book.<br /><br />In <strong>chapter four</strong>: “<em>Encoding and Evolution</em>” author explains the challenges of schema evolution. Often forgotten or ignored problem, especially when everything is a map of maps of something (e.g.&nbsp;JSON document). I admire how different text and binary formats are explained in-depth. To the point where Martin compares each binary format byte-by-byte. Avro, Thrift, Protobuf - you will have a very good understanding of these formats and what makes some of them more robust than the others. <strong>Chapter five</strong> was a joy to read: “<em>Replication</em>”. Leader vs.&nbsp;follower, multi-leader, leaderless replication are all explained with their advantages and drawbacks. Such a great introduction should help you to choose the right (No)SQL datastore in the future. “<em>Partitioning</em>” (<strong>chapter six</strong>) was even better. Once your dataset is replicated, how do you split data to a subset of nodes to avoid data loss? Partitioning by key, hashing, routing, rebalancing - these are all covered.<br /><br /><strong>Chapter seven</strong>, “<em>Transactions</em>” says it all. It’s amazing how Martin finds parallels in rather distant technologies. For example relation databases with their transaction log and distributed message brokers. I always wondered how transactions are <em>really</em> implemented in modern databases. This book gives very thorough explanation. <strong>Chapter eight</strong>, “<em>The Trouble with Distributed Systems</em>” deals with many fault modes in distributed systems. Unsynchronized clocks are explained very thoroughly, as well as various network unreliability scenarios, Byzantine faults and other failure modes. Must read for every developer working on a distributed system. <strong>Chapter nine</strong>, “<em>Consistency and Consensus</em>” continues discussion on challenges in distributed systems. How independent nodes can agree on something? How can they choose a leader without any shared state? How to tackle ordering guarantees and linearizability? Martin does not follow recent hypes and doesn’t lean toward any particular technology. For example, a chapter related to distributed transactions doesn’t simply repeat common wisdom that “they are bad and slow”. Instead, he explains in detail how a distributed transaction manager works, what is the protocol and failure scenarios. I didn’t know that XA manager is such a crucial point of this design style and when it fails, the rest of the system basically stalls. Moreover, it <em>must</em> recover because it’s stateful and distributed transaction log can’t simply disappear. So yes, distributed transactions are slow and brittle. But the author at least explains why, rather than repeating common Internet wisdom.<br /><br /><strong>Chapters ten and eleven</strong> are describing batch and stream processing respectively. Despite recent hype for stream processing, batch processing is also considered a viable option. Book concludes with the last, <strong>twelfth</strong> chapter: “<em>The Future of Data Systems</em>”. Surprisingly, the very end of the book tackles ethic problems like privacy and tracking. After such a deep and technical content looking through this perspective was truly mind-boggling. I loved it.<br /><br />My favourite quote from the book comes from… the glossary!<br /><br /><em>CAP theorem: A widely misunderstood theoretical result that is not useful in practice.</em><br /><em><br /></em><a href="https://amzn.to/2teQsWS" style="font-style: italic;">Designing Data-Intensive Applications</a>&nbsp;- highly recommended.<br /><br />