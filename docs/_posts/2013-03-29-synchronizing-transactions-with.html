---
layout: post
title: Synchronizing transactions with asynchronous events in Spring
date: '2013-03-29T12:47:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- spring
modified_time: '2013-03-29T12:47:52.924+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8547134289457984863
blogger_orig_url: https://www.nurkiewicz.com/2013/03/synchronizing-transactions-with.html
---

Today as an example we will take a very simple scenario: placing an order stores it and sends an e-mail about that order:<br /><br /><pre class="brush: scala">@Service<br />class OrderService @Autowired() (orderDao: OrderDao, mailNotifier: OrderMailNotifier) {<br /><br />    @Transactional<br />    def placeOrder(order: Order) {<br />        orderDao save order<br />        mailNotifier sendMail order<br />    }<br />}<br /></pre>So far so good, but e-mail functionality has nothing to do with placing an order. It's just a side-effect that distracts rather than part of business logic. Moreover sending an e-mail unnecessarily prolongs transaction and introduces latency. So we decided to decouple these two actions by using events. For simplicity I will take advantage of Spring built-in <a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/beans.html#context-functionality-events">custom events</a> but our discussion is equally relevant for JMS or other producer-consumer library/queue.<br /><br /><pre class="brush: scala">case class OrderPlacedEvent(order: Order) extends ApplicationEvent<br /><br />@Service<br />class OrderService @Autowired() (orderDao: OrderDao, eventPublisher: ApplicationEventPublisher) {<br /><br />    @Transactional<br />    def placeOrder(order: Order) {<br />        orderDao save order<br />        eventPublisher publishEvent OrderPlacedEvent(order)<br />    }<br /><br />}<br /></pre>As you can see instead of accessing <code>OrderMailNotifier</code> bean directly we send <code>OrderPlacedEvent</code> wrapping newly created order. <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/context/ApplicationEventPublisher.html"><code>ApplicationEventPublisher</code></a> is needed to send an event. Of course we also have to implement the client side receiving messages:<br /><a name='more'></a><br /><br /><pre class="brush: scala">@Service<br />class OrderMailNotifier extends ApplicationListener[OrderPlacedEvent] {<br /><br />    def onApplicationEvent(event: OrderPlacedEvent) {<br />        //sending e-mail...<br />    }<br /><br />}<br /></pre><code>ApplicationListener[OrderPlacedEvent]</code> indicates what type of events are we interested in. This works, however by default Spring <code>ApplicationEvent</code>s are synchronous, which means <code>publishEvent()</code> is actually blocking. Knowing Spring it shouldn't be hard to turn event broadcasting into asynchronous mode. Indeed there are two ways: one suggested in JavaDoc and the other I discovered because I failed to read the JavaDoc first... According to documentation if you want your events to be delivered asynchronously, you should define bean named <code>applicationEventMulticaster</code> of type <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html"><code>SimpleApplicationEventMulticaster</code></a> and define <code>taskExecutor</code>:<br /><br /><pre class="brush: scala">@Bean<br />def applicationEventMulticaster() = {<br />    val multicaster = new SimpleApplicationEventMulticaster()<br />    multicaster.setTaskExecutor(taskExecutor())<br />    multicaster<br />}<br /><br />@Bean<br />def taskExecutor() = {<br />    val pool = new ThreadPoolTaskExecutor()<br />    pool.setMaxPoolSize(10)<br />    pool.setCorePoolSize(10)<br />    pool.setThreadNamePrefix("Spring-Async-")<br />    pool<br />}<br /></pre>Spring already supports broadcasting events using custom <code>TaskExecutor</code>. I didn't know about it so first I simply annotated <code>onApplicationEvent()</code> with <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/scheduling/annotation/Async.html"><code>@Async</code></a>:<br /><br /><pre class="brush: scala">@Async<br />def onApplicationEvent(event: OrderPlacedEvent) {  //...<br /></pre>no further modifications, once Spring discovers <code>@Async</code> method it runs it in different thread asynchronously. Period. Well, you still have to enable <code>@Async</code> support if you don't use it already:<br /><br /><pre class="brush: scala">@Configuration<br />@EnableAsync<br />class ThreadingConfig extends AsyncConfigurer {<br />    def getAsyncExecutor = taskExecutor()<br /><br />    @Bean<br />    def taskExecutor() = {<br />        val pool = new ThreadPoolTaskExecutor()<br />        pool.setMaxPoolSize(10)<br />        pool.setCorePoolSize(10)<br />        pool.setThreadNamePrefix("Spring-Async-")<br />        pool<br />    }<br /><br />}<br /></pre>Technically <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/scheduling/annotation/EnableAsync.html"><code>@EnableAsync</code></a> is enough. However by default Spring uses <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html"><code>SimpleAsyncTaskExecutor</code></a> which creates new thread on every <code>@Async</code> invocation. A bit unfortunate default for enterprise framework, luckily easy to change. Undoubtedly <code>@Async</code> seems cleaner than defining some magic beans. <br /><br /><hr />All above was just a setup to expose the real problem. We now send an asynchronous message that is processed in other thread. Unfortunately we introduced <b>race condition</b> that manifests itself under heavy load, or maybe only some particular operating system. Can you spot it? To give you a hint, here is what happens:<br /><br /><ol><li>Starting transaction</li><li>Storing <code>order</code> in database</li><li>Sending a message wrapping <code>order</code></li><li>Commit</li></ol>In the meantime some asynchronous thread picks up <code>OrderPlacedEvent</code> and starts processing it. The question is, does it happen right after point (3) but before point (4) or maybe after (4)? That makes a big difference! In the former case the transaction didn't yet committed, thus <code>Order</code> is not yet in the database. On the other hand lazy loading <i>might</i> work on that object as it's still bound to a a <code>PersistenceContext</code> (in case we are using JPA). However if the original transaction already committed, <code>order</code> will behave much differently. If you rely on one behaviour or the other, due to race condition, your event listener might fail spuriously under heavy to predict circumstances.<br /><br />Of course there is a solution<sup>1</sup>: using not commonly known <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/transaction/support/TransactionSynchronizationManager.html"><code>TransactionSynchronizationManager</code></a>. Basically it allows us to register arbitrary number of <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/transaction/support/TransactionSynchronization.html"><code>TransactionSynchronization</code> listeners</a>. Each such listener will then be notified about various events like transaction commit and rollback. Here is a basic API:<br /><br /><pre class="brush: scala">@Transactional<br />def placeOrder(order: Order) {<br />    orderDao save order<br />    afterCommit {<br />        eventPublisher publishEvent OrderPlacedEvent(order)<br />    }<br />}<br /><br />private def afterCommit[T](fun: =&gt; T) {<br />    TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter {<br />        override def afterCommit() {<br />            fun<br />        }<br />    })<br />}<br /></pre><code>afterCommit()</code> takes a function and calls it after the current transaction commits. We use it to hide the complexity of Spring API. One can safely call <code>registerSynchronization()</code> multiple times - listeners are stored in a <code>Set</code> and are local to the current transaction, disappearing after commit.<br /><br />So, the <code>publishEvent()</code> method will be called <i>after</i> the enclosing transaction commits, which makes our code predictable and race condition free. However, even with higher order function <code>afterCommit()</code> it still feels a bit unwieldy and unnecessarily complex. Moreover it's easy to forget wrapping every <code>publishEvent()</code>, thus maintainability suffers. Can we do better? One solution is to use write custom utility class wrapping <code>publishEvent()</code> or employ AOP. But there is much simpler, proven solution that works great with Spring - the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator pattern</a>. We shall wrap original implementation of <code>ApplicationEventPublisher</code> provided by Spring and decorate its <code>publishEven()</code>:<br /><br /><pre class="brush: scala">class TransactionAwareApplicationEventPublisher(delegate: ApplicationEventPublisher)<br />    extends ApplicationEventPublisher {<br /><br />    override def publishEvent(event: ApplicationEvent) {<br />        if (TransactionSynchronizationManager.isActualTransactionActive) {<br />            TransactionSynchronizationManager.registerSynchronization(<br />                new TransactionSynchronizationAdapter {<br />                    override def afterCommit() {<br />                        delegate publishEvent event<br />                    }<br />                })<br />        }<br />        else<br />            delegate publishEvent event<br />    }<br /><br />}<br /></pre>As you can see if the transaction is active, we register commit listener and postpone sending of a message until transaction is completed. Otherwise we simply forward the event to original <code>ApplicationEventPublisher</code>, which delivers it immediately. Of course we somehow have to plug this new implementation instead of the original one. <code>@Primary</code> does the trick:<br /><br /><pre class="brush: scala">@Resource<br />val applicationContext: ApplicationContext = null<br /><br />@Bean<br />@Primary<br />def transactionAwareApplicationEventPublisher() =<br />    new TransactionAwareApplicationEventPublisher(applicationContext)<br /></pre>Notice that the original implementation of <code>ApplicationEventPublisher</code> is provided by core <code>ApplicationContext</code> class. After all these changes our code looks... exactly the same as in the beginning:<br /><br /><pre class="brush: scala">@Service<br />class OrderService @Autowired() (orderDao: OrderDao, eventPublisher: ApplicationEventPublisher) {<br /><br />    @Transactional<br />    def placeOrder(order: Order) {<br />        orderDao save order<br />        eventPublisher publishEvent OrderPlacedEvent(order)<br />    }<br /></pre>However this time auto-injected <code>eventPublisher</code> is our custom decorator. Eventually we managed to fix the race condition problem without touching the business code. Our solution is safe, predictable and robust. Notice that the exact same approach can be taken for any other queuing technology, including JMS (if complex transaction manager was not used) or custom queues. We also discovered an interesting low-level API for transaction lifecycle listening. Might be useful one day.<br /><br /><hr /><sup>1</sup> - one might argue that a much simpler solution would be to <code>publishEvent()</code> outside of the transaction:<br /><br /><pre class="brush: scala">def placeOrder(order: Order) {<br />    storeOrder(order)<br />    eventPublisher publishEvent OrderPlacedEvent(order)<br />}<br /><br />@Transactional<br />def storeOrder(order: Order) = orderDao save order<br /></pre>That's true, but this solution doesn't "<i>scale</i>" well (what if <code>placeOrder()</code> has to be part of a greater transaction?) and is most likely incorrect due to <a href="http://nurkiewicz.blogspot.no/2011/10/spring-pitfalls-proxying.html">proxying peculiarities</a>.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>