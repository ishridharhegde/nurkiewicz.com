---
layout: post
title: flatMap() vs. concatMap() vs. concatMapEager() - RxJava FAQ
date: '2017-08-04T00:26:00.001+02:00'
author: Tomasz Nurkiewicz
tags:
- rxjava
modified_time: '2017-08-04T00:26:39.245+02:00'
thumbnail: https://2.bp.blogspot.com/-vxEJBB6LAy0/WYOilZA0JgI/AAAAAAAAD9g/KzPf_4s_tdskwurPcaldfs26_O-xmAVrwCLcBGAs/s72-c/2016-01-02%2B10.21.37.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7690000962995040106
blogger_orig_url: https://www.nurkiewicz.com/2017/08/flatmap-vs-concatmap-vs-concatmapeager.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-vxEJBB6LAy0/WYOilZA0JgI/AAAAAAAAD9g/KzPf_4s_tdskwurPcaldfs26_O-xmAVrwCLcBGAs/s1600/2016-01-02%2B10.21.37.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="900" data-original-width="1600" height="112" src="https://2.bp.blogspot.com/-vxEJBB6LAy0/WYOilZA0JgI/AAAAAAAAD9g/KzPf_4s_tdskwurPcaldfs26_O-xmAVrwCLcBGAs/s200/2016-01-02%2B10.21.37.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Frozen <i>Stawy Cietrzewia</i></td></tr></tbody></table>There are three, seamlessly similar operators in RxJava 2.x: <code>flatMap()</code>, <code>concatMap()</code> and <code>concatMapEager()</code>. All of them accept the same argument - a function from original stream's individual item to a (sub-)stream of arbitrary type. In other words if you have a <code>Flowable&lt;T&gt;</code> you provide a function from <code>T</code> to <code>Flowable&lt;R&gt;</code> for arbitrary <code>R</code> type. After applying any of these operators you end up with <code>Flowable&lt;R&gt;</code>. So how are they different?<br /><br /><h2 id="sample-project">Sample project</h2>First let's build a sample application. We will use <a href="http://square.github.io/retrofit/">Retrofit2</a> HTTP client wrapper that has built-in plugins for RxJava2. Our task is to leverage <a href="http://www.geonames.org/export/web-services.html">GeoNames API</a> in order to find the population of any city in the world. The interface looks as follows:<br /><br /><pre class="brush: java">public interface GeoNames {<br /><br />    Flowable&lt;Long&gt; populationOf(String city);<br /><br />}</pre>The implementation of this interface is auto-generated by Retrofit, scroll down to see glue source code. For the time being just assume we have a function that takes a <code>String</code> with city name and asynchronously returns a one-element stream with a population of that city. Also assume we have a fixed stream of cities we want to look up:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; cities = Flowable.just(<br />    "Warsaw", "Paris", "London", "Madrid"<br />);</pre>Our goal is to fetch population of each city.<br /><br /><h2 id="concatmap-process-upstream-sequentially"><code>concatMap()</code>: process upstream sequentially</h2>The sample application with <code>concatMap()</code> looks as follows:<br /><br /><pre class="brush: java">cities<br />        .concatMap(geoNames::populationOf)<br />        .subscribe(response -&gt; log.info("Population: {}", response));</pre>Before we see the outcome let's study what <code>concatMap()</code> is doing underneath. For each upstream event (<em>city</em>) it invokes a function that replaces that event with a (sub)stream. In our case it's a one-element stream of <code>Long</code> (<code>Flowable&lt;Long&gt;</code>). So with all operators we are comparing we end up with a stream of streams of <code>Long</code> (<code>Flowable&lt;Flowable&lt;Long&gt;&gt;</code>). The real difference arises when we analyze what the operator is doing in order to flatten such nested stream.<br /><br /><code>concatMap()</code> will first subscribe to the very first substream (<code>Flowable&lt;Long&gt;</code> representing population of Warsaw). By subscribing we actually mean making the physical HTTP call. Only when the first substream completes (emits a single <code>Long</code> in our case and signals completion) <code>concatMap()</code> will continue. Continuing means subscribing to the second substream and waiting for it to complete. The resulting stream completes when the very last substream completes. This leads to a following stream: 1702139, 2138551, 7556900 and 3255944. These happen to be populations of Warsaw, Paris, London and Madrid, accordingly. The order of output is entirely predictable. However it's also entirely sequential. No concurrency happens at all, we make second HTTP call only when the first one completed. The added complexity of RxJava doesn't pay off at all:<br /><br /><pre class="brush: java">23:33:33.531 | Rx-1 | --&gt; GET .../searchJSON?q=Warsaw http/1.1<br />23:33:33.656 | Rx-1 | &lt;-- 200 OK .../searchJSON?q=Warsaw (123ms)<br />23:33:33.674 | Rx-1 | Population: 1702139<br />23:33:33.676 | Rx-1 | --&gt; GET .../searchJSON?q=Paris http/1.1<br />23:33:33.715 | Rx-1 | &lt;-- 200 OK .../searchJSON?q=Paris (38ms)<br />23:33:33.715 | Rx-1 | Population: 2138551<br />23:33:33.716 | Rx-1 | --&gt; GET .../searchJSON?q=London http/1.1<br />23:33:33.754 | Rx-1 | &lt;-- 200 OK .../searchJSON?q=London (37ms)<br />23:33:33.754 | Rx-1 | Population: 7556900<br />23:33:33.755 | Rx-1 | --&gt; GET .../searchJSON?q=Madrid http/1.1<br />23:33:33.795 | Rx-1 | &lt;-- 200 OK .../searchJSON?q=Madrid (40ms)<br />23:33:33.796 | Rx-1 | Population: 3255944</pre>As you can see no multithreading occurs, requests are sequential, waiting for each other. Technically not all of them must happen in the same thread, but they never overlap and take advantage of concurrency. The big plus is guaranteed order of resulting events, which is not that obvious once we jump into <code>flatMap()</code>...<br /><br /><h2 id="flatmap-processing-results-on-the-fly-out-of-order"><code>flatMap()</code>: processing results on-the-fly, out-of-order</h2><code>flatMap()</code> code is almost exactly the same:<br /><br /><pre class="brush: java">cities<br />        .flatMap(geoNames::populationOf)<br />        .subscribe(response -&gt; log.info("Population: {}", response));</pre>And just like before we start with a stream of streams of <code>Long</code> (<code>Flowable&lt;Flowable&lt;Long&gt;&gt;</code>). However rather than subscribing to each substream one after another, <code>flatMap()</code> operator eagerly subscribes to all substreams at once. This means we see multiple HTTP requests being initiated at the same time in different threads:<br /><br /><pre class="brush: java">00:10:04.919 | Rx-2 | --&gt; GET .../searchJSON?q=Paris http/1.1<br />00:10:04.919 | Rx-1 | --&gt; GET .../searchJSON?q=Warsaw http/1.1<br />00:10:04.919 | Rx-3 | --&gt; GET .../searchJSON?q=London http/1.1<br />00:10:04.919 | Rx-4 | --&gt; GET .../searchJSON?q=Madrid http/1.1<br />00:10:05.449 | Rx-3 | &lt;-- 200 OK .../searchJSON (529ms)<br />00:10:05.462 | Rx-3 | Population: 7556900<br />00:10:05.477 | Rx-1 | &lt;-- 200 OK .../searchJSON (557ms)<br />00:10:05.478 | Rx-1 | Population: 1702139<br />00:10:05.751 | Rx-4 | &lt;-- 200 OK .../searchJSON (831ms)<br />00:10:05.752 | Rx-4 | Population: 3255944<br />00:10:05.841 | Rx-2 | &lt;-- 200 OK .../searchJSON (922ms)<br />00:10:05.843 | Rx-2 | Population: 2138551</pre>When any of the underlying substreams emit any value, it is immediately passed downstream to the subscriber. This means we can now process events on-the-fly, as they are produced. Notice that the resulting stream is out-of-order. The first event we received is 7556900, which happens to be the population of London, second in the initial stream. Contrary to <code>concatMap()</code>, <code>flatMap()</code> can't preserve order, thus emits values in "random" order. Well, not really random, we simply receive values as soon as they are available. In this particular execution HTTP response for London came first, but there is absolutely no guarantee for that. This leads to an interesting problem. We have a stream of various population values and initial stream of cities. However the output stream can be an arbitrary permutation of events and we have no idea which population corresponds to which city. We will address this problem in a subsequent article.<br /><br /><h2 id="concatmapeager-concurrent-in-order-but-somewhat-expensive"><code>concatMapEager()</code>: concurrent, in-order, but somewhat expensive</h2><code>concatMapEager()</code> seems to bring the best of both worlds: concurrency and guaranteed order of output events:<br /><br /><pre class="brush: java">cities<br />        .concatMapEager(geoNames::populationOf)<br />        .subscribe(response -&gt; log.info("Population: {}", response));</pre>After learning what <code>concatMap()</code> and <code>flatMap()</code> are doing, understanding <code>concatMapEager()</code> is fairly simple. Having stream of streams <code>concatMapEager()</code> eagerly (<em>duh!</em>) subscribes to all substreams at the same time, concurrently. However this operator makes sure that results from the first substream are propagated first, even if it's not the first one to complete. An example will quickly reveal what this means:<br /><br /><pre class="brush: java">00:34:18.371 | Rx-2 | --&gt; GET .../searchJSON?q=Paris http/1.1<br />00:34:18.371 | Rx-3 | --&gt; GET .../searchJSON?q=London http/1.1<br />00:34:18.371 | Rx-4 | --&gt; GET .../searchJSON?q=Madrid http/1.1<br />00:34:18.371 | Rx-1 | --&gt; GET .../searchJSON?q=Warsaw http/1.1<br />00:34:18.517 | Rx-3 | &lt;-- 200 OK .../searchJSON?q=London (143ms)<br />00:34:18.563 | Rx-1 | &lt;-- 200 OK .../searchJSON?q=Warsaw (189ms)<br />00:34:18.565 | Rx-1 | Population: 1702139<br />00:34:20.460 | Rx-2 | &lt;-- 200 OK .../searchJSON?q=Paris (2086ms)<br />00:34:20.460 | Rx-4 | &lt;-- 200 OK .../searchJSON?q=Madrid (2086ms)<br />00:34:20.461 | Rx-2 | Population: 2138551<br />00:34:20.462 | Rx-2 | Population: 7556900<br />00:34:20.462 | Rx-2 | Population: 3255944</pre>We initiate four HTTP requests instantly. From the log output we clearly see that the population of London was returned first. However the subscriber did not receive it because population of Warsaw didn't arrive yet. By coincidence Warsaw completed second so at this point the population of Warsaw can be passed downstream to a subscriber. Unfortunately population of London must wait even more because first we need a population of Paris. Once Paris (immediately followed by Madrid) completes, all remaining results are passed downstream.<br /><br />Notice how population of London, even though available, must wait dormant until Warsaw and Paris complete. So is <code>concatMapEager()</code> the best possible operator for concurrency? Not quite. Imagine we have a list of thousand cities and for each one we fetch a single 1MB picture. With <code>concatMap()</code> we download pictures sequentially, i.e. slowly. With <code>flatMap()</code> pictures are downloaded concurrently and processed as they arrive, as soon as possible. Now what about <code>concatMapEager()</code>? In worst case scenario we can end up with <code>concatMapEager()</code> buffering 999 pictures because picture from the very first city happens to be the slowest. Even though we already have 99.9% of the results we cannot process them because we enforce strict ordering.<br /><br /><h2 id="which-operator-to-use">Which operator to use?</h2><code>flatMap()</code> should be your first weapon of choice. It allows efficient concurrency with streaming behavior. But be prepared to receive results out-of-order. <code>concatMap()</code> works well only when provided transformation is so fast the sequential processing is not a problem. <code>concatMapEager()</code> is very convenient, but watch out for memory consumption. Also in worst case scenario you may end up sitting idle, waiting for very few responses.<br /><br /><h2 id="appendix-configuring-retrofit2-client">Appendix: configuring Retrofit2 client</h2>The <code>GeoNames</code> service interface that we used throughout this article in fact looks like this:<br /><br /><pre class="brush: java">public interface GeoNames {<br /><br />    @GET("/searchJSON")<br />    Single&lt;SearchResult&gt; search(<br />            @Query("q") String query,<br />            @Query("maxRows") int maxRows,<br />            @Query("style") String style,<br />            @Query("username") String username<br />    );<br /><br />    default Flowable&lt;Long&gt; populationOf(String city) {<br />        return search(city, 1, "LONG", "s3cret")<br />                .map(SearchResult::getGeonames)<br />                .map(g -&gt; g.get(0))<br />                .map(Geoname::getPopulation)<br />                .toFlowable();<br />    }<br /><br />}</pre>The implementation of non-default method is auto-generated by Retrofit2. Notice that <code>populationOf()</code> returns a one-element <code>Flowable&lt;Long&gt;</code> for simplicity's sake. However to fully embrace the nature of this API other implementations would be more reasonable in real world. First of all the <code>SearchResult</code> class returns an ordered list of results (getters/setters omitted):<br /><br /><pre class="brush: java">class SearchResult {<br />    private List&lt;Geoname&gt; geonames = new ArrayList&lt;&gt;();<br />}<br /><br />class Geoname {<br />    private double lat;<br />    private double lng;<br />    private Integer geonameId;<br />    private Long population;<br />    private String countryCode;<br />    private String name;<br />}</pre>After all there are many <a href="https://en.wikipedia.org/wiki/Warsaw,_Indiana">Warsaws</a> and <a href="https://en.wikipedia.org/wiki/London,_Ohio">Londons</a> in the world. We silently assume the list will contain at least one element and the <a href="http://www.businessinsider.com/google-just-effectively-killed-the-im-feeling-lucky-button-2010-9">first one</a> is the <em>right</em> match. More appropriate implementation should either return all hits or even better <code>Maybe&lt;Long&gt;</code> type to reflect no matches:<br /><br /><pre class="brush: java">default Maybe&lt;Long&gt; populationOf(String city) {<br />    return search(city, 1, "LONG", "nurkiewicz")<br />            .flattenAsFlowable(SearchResult::getGeonames)<br />            .map(Geoname::getPopulation)<br />            .firstElement();<br />}</pre>The glue code looks as follows. First Jackson's setup in order to parse response from the API:<br /><br /><pre class="brush: java">import com.fasterxml.jackson.databind.ObjectMapper;<br /><br />private ObjectMapper objectMapper() {<br />    return new ObjectMapper()<br />            .configure(FAIL_ON_UNKNOWN_PROPERTIES, false);<br />}</pre><code>FAIL_ON_UNKNOWN_PROPERTIES</code> is often what you desire. Otherwise you have to map all fields from JSON response and your code will break when API producer introduces new, otherwise backward compatible fields. Then we setup <a href="http://square.github.io/okhttp/"><code>OkHttpClient</code></a>, used underneath by Retrofit:<br /><br /><pre class="brush: java">import okhttp3.OkHttpClient;<br />import okhttp3.logging.HttpLoggingInterceptor;<br /><br />private OkHttpClient client() {<br />    HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();<br />    interceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);<br />    return new OkHttpClient.Builder().addInterceptor(interceptor).build();<br />}</pre>Sometimes you can skip the configuration of OkHttp client but we added logging interceptor. By default OkHttp logs using <code>java.util.logging</code> so in order to use decent logging framework we must install a bridge at the very beginning:<br /><br /><pre class="brush: java">import org.slf4j.bridge.SLF4JBridgeHandler;<br /><br />static {<br />    SLF4JBridgeHandler.removeHandlersForRootLogger();<br />    SLF4JBridgeHandler.install();<br />}</pre>And finally Retrofit itself:<br /><br /><pre class="brush: java">import io.reactivex.schedulers.Schedulers;<br />import retrofit2.Retrofit;<br />import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;<br />import retrofit2.converter.jackson.JacksonConverterFactory;<br /><br />GeoNames createClient() {<br />    return new Retrofit.Builder()<br />            .client(client())<br />            .baseUrl("http://api.geonames.org")<br />            .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io()))<br />            .addConverterFactory(JacksonConverterFactory.create(objectMapper()))<br />            .build()<br />            .create(GeoNames.class);<br />}</pre>Calling <code>createClient()</code> will yield a dynamic implementation of <code>GeoNames</code> interface. We used the following dependencies:<br /><br /><pre class="brush: java">compile 'io.reactivex.rxjava2:rxjava:2.0.6'<br /><br />compile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'<br />compile 'com.squareup.retrofit2:converter-jackson:2.0.1'<br />compile 'com.squareup.okhttp3:logging-interceptor:3.8.0'<br /><br />compile 'ch.qos.logback:logback-classic:1.1.7'<br />compile 'org.slf4j:slf4j-api:1.7.21'<br />compile 'org.slf4j:jul-to-slf4j:1.7.21'</pre><script>SyntaxHighlighter.highlight();</script>