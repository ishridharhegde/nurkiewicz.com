---
layout: post
title: java.lang.reflect.Proxy czyli prawie AOP za prawie darmo
date: '2008-10-12T14:26:00.010+02:00'
author: Tomasz Nurkiewicz
tags:
- aop
- design patterns
modified_time: '2009-09-27T17:09:17.988+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8729900524225956533
blogger_orig_url: https://www.nurkiewicz.com/2008/10/javalangreflectproxy-czyli-prawie-aop.html
---

<p>Począwszy od Javy 1.3 programistom (głównie frameworków) została udostępniona niezwykle użyteczna klasa <a href="http://java.sun.com/javase/6/docs/api/java/lang/reflect/Proxy.html">Proxy</a>. Zasadniczo klasa ta pomaga w implementacji wzorca projektowego o tej samej nazwie, jednak skupię się na przykładzie użycia samej klasy, reszta będzie już oczywista.</p><p>Proxy jest swoistą warstwą pośredniczącą między obiektem docelowym a światem zewnętrznym. Wywołanie każdej metody obiektu docelowego "przechodzi" przez proxy, które ma pełen zestaw możliwości wpływania na to wywołanie (podejrzenie i zmiana parametrów, logowanie, a nawet całkowite zaniechanie wywołania właściwej metody).</p><p>Jeśli znacie metody z grupy <span style="font-family:courier new;">java.util.Collections.synchronized*()</span>, to koncepcyjnie zwracają one właśnie takie proxy, które opakowuje wszystkie wywołania metod docelowej kolekcji. Rolą proxy jest w tym przykładzie zapewnienie synchronizacji na poziomie każdej metody i oczywiście wywołanie właściwej metody. Podobnie możemy sobie wyobrazić proxy zabezpieczające kolekcję przed modyfikacją, które rzucałoby wyjątek przy próbie wywołania jakiejkolwiek metody zmieniającej tą kolekcję.</p><p>Koncepcja chyba jasna, przejdźmy do przykładu :-). Załóżmy, że w naszym projekcie używamy prostej klasy DAO<t>, dla uproszczenia niech przechowuje ona zwykłe Stringi:</t></p><p><span style="font-family:courier new;">public interface Dao<t><t> {<br /><br />void create(String record);<br /><br />String restore(long id);<br /><br />void update(String record);<br /><br />void delete(String record);<br /><br />}</t></t></span><br /><br />i implementacja:<br /></p><p><span style="font-family:courier new;">import org.apache.commons.logging.Log;<br />import org.apache.commons.logging.LogFactory;<br /><br />public class StringDao <strong>implements Dao<string><string></string></string></strong> {<br /><br />private static final Log log = LogFactory.getLog(StringDao.class);<br /><br />@Override<br />public void create(String record) {<br />log.info("create: " + record);<br />}<br /><br />@Override<br />public void delete(String record) {<br />log.info("delete: " + record);<br />}<br /><br />@Override<br />public String restore(long id) {<br />log.info("restore: " + id);<br />return "Record " + id;<br />}<br /><br />@Override<br />public void update(String record) {<br />log.info("update: " + record);<br />}<br /><br />}</span><br /><br /></p><p>Jeszcze prosty przykładowy program:</p><p><span style="font-family:courier new;">import org.apache.log4j.BasicConfigurator;<br /><br />class Main {<br /><br />public static void main(String[] args) {<br />BasicConfigurator.configure();<br />Dao<string><string> dao = new StringDao();<br />dao.create("Java");<br />dao.restore(0);<br />dao.update("Java 2");<br />dao.delete("Java");<br />}<br />}</string></string></span><br /><br />i dla porządku jego wyjście:<br /></p><p><span style="font-family:courier new;">0 [main] INFO StringDao  - create: Java<br />0 [main] INFO StringDao  - restore: 0<br />0 [main] INFO StringDao  - update: Java 2<br />0 [main] INFO StringDao  - delete: Java<br /><br /></span></p><p><em>Nihil novi sub sole</em>, przejdźmy do meritum :-). Załóżmy, że z pewny sobie znanych powodów chcemy monitorować wywołania klasy <span style="font-family:courier new;">StringDao</span>. Oczywiście moglibyśmy napisać nową klasę również implementującą interfejs <span style="font-family:courier new;">Dao<string></string></span><t>, która delegowałaby każde wywołanie do przekazanej w konstruktorze instancji <span style="font-family:courier new;">StringDao</span>. Prawdę mówiąc zastosowalibyśmy wtedy wzorzec projektowy proxy. Jaka jest wada powyższego rozwiązania? Cóż, ile klas trzeba będzie zmienić gdy zmodyfikujemy interfejs <span style="font-family:courier new;">Dao<t></t></span><t>?</t></t></p><p>Oszczędzę czytelnikom kodu dla powyższego rozwiązania od razu przechodząc do klasy <span style="font-family:courier new;">Proxy</span> i tego, jak pomaga ona w rozwiązaniu następującego problemu. Po pierwsze tworzymy instancję klasy <span style="font-family:courier new;">Proxy</span>:</p><p><span style="font-family:courier new;">import java.lang.reflect.Proxy;<br /><br />import org.apache.log4j.BasicConfigurator;<br /><br />class Main {<br /><br />public static void main(String[] args) {<br />BasicConfigurator.configure();<br />Dao<string><string> dao = new StringDao();<br /><br /></string></string></span><strong style="font-weight: normal;"><span style="font-family:courier new;"><span style="font-weight: bold;">Dao</span><string><span style="font-weight: bold;"><string> daoProxy = (Dao</string></span><string><span style="font-weight: bold;"><string>) </string></span>Proxy.newProxyInstance(Dao.class.getClassLoader(), new Class[] { <span style="font-weight: bold;">Dao.class</span> }</string></string></span></strong><strong style="font-weight: bold;"><span style="font-family:courier new;"><string><string>,<br /><span style="font-weight: normal;">    <span style="font-weight: bold;">new LoggingHandler()</span>);</span></string></string></span></strong><span style="font-family:courier new;"><br /><br /><strong>daoProxy</strong>.create("Java");<br /><strong>daoProxy</strong>.restore(0);<br /><strong>daoProxy</strong>.update("Java 2");<br /><strong>daoProxy</strong>.delete("Java");<br />}<br />}<br /><br /></span><span>Metoda przyjmuje 3 argumenty:</span></p><ul><li><span>classloader, parametr typu <em>zamknij oczy i przejdź dalej.</em></span></li><li>Lista interfejsów, które ma implementować wynikowe proxy. Póki co przyjmijmy tylko jeden.</li><li>Obiekt, który będzie informowany o każdej próbie wywołania metod interfejsu <span style="font-family:courier new;">Dao<t></t></span><t>.</t></li></ul><p>Ważna jest jeszcze wartość zwracana przez tą fabrykę. Zwróćcie uwagę, że obiekt ten implementuje interfejs <span style="font-family:courier new;">Dao<string></string></span><t>. W praktyce obiekt ten będzie implementował każdy interfejs podany jako drugi parametr. Stąd bierze się określenie <em>dynamiczne</em> proxy.<br /></t></p><p>Zapewne pali was ciekawość, jak wygląda ten <span style="font-family:courier new;">LoggingHandler</span>. Proszę bardzo:</p><p><span style="font-family:courier new;">import java.lang.reflect.InvocationHandler;<br />import java.lang.reflect.Method;<br />import java.util.Arrays;<br /><br />import org.apache.commons.logging.Log;<br />import org.apache.commons.logging.LogFactory;<br /><br />public class LoggingHandler <span style="font-weight: bold;">implements InvocationHandler</span> {<br /><br />private static final Log log = LogFactory.getLog(LoggingHandler.class);<br /><br />@Override<br /><span style="font-weight: bold;">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</span> {<br />log.info("Invoking: " + method.getName() + " with args: " + Arrays.deepToString(args));<br /><strong>return null;</strong><br />}<br />}</span><br /><br />Jaki będzie wynik tak zmodyfikowanego programu?</p><p><span style="font-family:courier new;">0 [main] INFO StringDao  - create: Java<br />0 [main] INFO StringDao  - restore: 0<br />0 [main] INFO StringDao  - update: Java 2<br />0 [main] INFO StringDao  - delete: Java</span><br /></p><p>Pytanie: co zwróci każde z wywołań <span style="font-family:courier new;">daoProxy</span>?</p><p>Za każdym razem, gdy wywoływaliśmy metodę <span style="font-family:courier new;">daoProxy</span>, w rzeczywistości VM wołała <span style="font-family:courier new;">invoke()</span> dostarczonego obiektu <span style="font-family:courier new;">LoggingHandler </span>podając jej jako argument m.in. metodę, która miała zostać uruchomiona. A dlaczego nie ma już logów z samego <span style="font-family:courier new;">StringDao</span>? To bardzo proste, przecież instancja klasy <span style="font-family:courier new;">LoggingHandler</span> nie ma pojęcia o istnieniu takich obiektów! Jedyne co może zrobić to zrócić null udając, że to zwróciła właściwa metoda interfejsu <span style="font-family:courier new;">Dao<string></string></span><t>.</t></p><p>Jak naprawić ten oczywisty błąd? Oczywiście wyposażyć <span style="font-family:courier new;">LoggingHandler</span> w instancję klasy docelowej. W tym momencie mamy już zaimplementowany modelowy przykład wzorca projektowego proxy. Co będzie robiło nasze proxy? A, powiedzmy że logowało czas wykonania każdej metody. Oto kompletny kod naszego rozwiązania:</p><p><span style="font-family:courier new;">import java.lang.reflect.InvocationHandler;<br />import java.lang.reflect.Method;<br /><br />import org.apache.commons.logging.Log;<br />import org.apache.commons.logging.LogFactory;<br /><br />public class LoggingHandler implements InvocationHandler {<br /><br />private static final Log log = LogFactory.getLog(LoggingHandler.class);<br /><br />private Dao<string><string> target;<br /><br /><strong>public LoggingHandler(Dao<string><string> target)</string></string></strong> {<br />this.target = target;<br />}<br /><br />@Override<br />public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br />long startTime = System.currentTimeMillis();<br /><strong>Object ret = method.invoke(target, args);</strong><br />log.info("Invocation time of " + method.getName() + ": " + (System.currentTimeMillis() - startTime) + "ms");<br /><strong>return ret;</strong><br /><br />}<br />}</string></string></span></p><p><span style="font-family:courier new;"></span></p><p><span style="font-family:courier new;"><br /></span></p><p><span style="font-family:courier new;"><br /></span></p><p><span style="font-family:courier new;">import java.lang.reflect.Proxy;<br /><br />import org.apache.log4j.BasicConfigurator;<br /><br />class Main {<br /><br />public static void main(String[] args) {<br />BasicConfigurator.configure();<br />Dao<string><string> dao = new StringDao();<br /><br /><strong>Dao<string><string> daoProxy</string></string></strong> = (Dao<string><string>) Proxy.newProxyInstance(Dao.class.getClassLoader(), new Class[] { Dao.class },<br /><strong>new LoggingHandler(dao)</strong>);<br /><br />daoProxy.create("Java");<br />daoProxy.restore(0);<br />daoProxy.update("Java 2");<br />daoProxy.delete("Java");<br />}<br />}</string></string></string></string></span><br /><br />Dla pewności oglądamy logi:<br /></p><p><span style="font-family:courier new;">0 [main] INFO StringDao  - create: Java<br />0 [main] INFO LoggingHandler  - Invocation time of create: 0ms<br />0 [main] INFO StringDao  - restore: 0<br />0 [main] INFO LoggingHandler  - Invocation time of restore: 0ms<br />0 [main] INFO StringDao  - update: Java 2<br />0 [main] INFO LoggingHandler  - Invocation time of update: 0ms<br />0 [main] INFO StringDao  - delete: Java<br />0 [main] INFO LoggingHandler  - Invocation time of delete: 0ms</span></p><p><span>I na koniec: jeśli ktoś interesuje się programowaniem aspektowym, skojarzenie jest oczywiste... Jak zatem za pomocą klasy </span><span style="font-family:courier new;">Proxy</span><span> zaimplementować porady typu </span><span style="font-family:courier new;">before</span><span>, </span><span style="font-family:courier new;">after</span><span>, </span><span style="font-family:courier new;">after returning</span><span>, </span><span style="font-family:courier new;">after throwing</span><span> i </span><span style="font-family:courier new;">around</span><span>?</span> Jaki typ porady został użyty tutaj?<br /></p>