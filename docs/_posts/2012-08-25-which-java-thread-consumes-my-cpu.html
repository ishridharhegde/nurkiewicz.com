---
layout: post
title: Which Java thread consumes my CPU?
date: '2012-08-25T12:28:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- jvm
- performance
- bash
modified_time: '2012-08-26T11:26:50.979+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7125053624951455923
blogger_orig_url: https://www.nurkiewicz.com/2012/08/which-java-thread-consumes-my-cpu.html
---

What do you do when your Java application consumes 100% of the CPU? Turns out you can easily find the problematic thread(s) using built-in UNIX and JDK tools. No profilers or agents required.<br />For the purpose of testing we'll use this simple program:<br /><pre class="brush: java">public class Main {<br />    public static void main(String[] args) {<br />        new Thread(new Idle(), "Idle").start();<br />        new Thread(new Busy(), "Busy").start();<br />    }<br />}<br /><br />class Idle implements Runnable {<br /><br />    @Override<br />    public void run() {<br />        try {<br />            TimeUnit.HOURS.sleep(1);<br />        } catch (InterruptedException e) {<br />        }<br />    }<br />}<br /><br />class Busy implements Runnable {<br />    @Override<br />    public void run() {<br />        while(true) {<br />            "Foo".matches("F.*");<br />        }<br />    }<br />}<br /></pre>As you can see, it starts two threads. <code>Idle</code> is not consuming any CPU (remember, sleeping threads consume memory, but not CPU) while <code>Busy</code> eats the whole core as regular expression parsing and executing is a surprisingly complex process. Let's run this program and forget about it. How can we quickly find out that <code>Busy</code> is the problematic piece of our software? First of all we use <a href="http://www.linuxmanpages.com/man1/top.1.php">top</code></a> to find out the process id (<code>PID</code>) of the <code>java</code> process consuming most of the CPU. This is quite straightforward:<br /><a name='more'></a><pre class="brush: bash">$ top -n1 | grep -m1 java<br /></pre>This will display the first line of <code>top</code> output containing "<code>java</code>" sentence:<br /><pre class="brush: bash">22614 tomek     20   0 1360m 734m  31m S    6 24.3   7:36.59 java<br /></pre>The first column is the PID, let's extract it. Unfortunately it turned out that <code>top</code> uses <a href="http://en.wikipedia.org/wiki/ANSI_escape_code#Colors">ANSI escape codes for colors</a> - invisible characters that are breaking tools like <code>grep</code> and <code>cut</code>. Luckily I found a <a href="http://unix.stackexchange.com/questions/4527">perl script to remove these characters</a> and was finally able to extract the PID of <code>java</code> process exhausting my CPU:<br /><pre class="brush: bash">$ top -n1 | grep -m1 java | perl -pe 's/\e\[?.*?[\@-~] ?//g' | cut -f1 -d' '<br /></pre>The <code>cut -f1 -d' '</code> invocation simply takes the first value out of space-separated columns:<br /><pre class="brush: bash">22614<br /></pre>Now when we now the problematic JVM PID, we can use <code>top -H</code> to find problematic Linux threads. The <code>-H</code> option prints a list of all <i>threads</i> as opposed to <i>processes</i>, the PID column now represents the internal Linux thread ID:<br /><pre class="brush: bash">$ top -n1 -H | grep -m1 java<br />$ top -n1 -H | grep -m1 java | perl -pe 's/\e\[?.*?[\@-~] ?//g' | cut -f1 -d' '<br /></pre>The output is surprisingly similar, but the first value is now the thread ID:<br /><pre class="brush: bash">25938 tomek     20   0 1360m 748m  31m S    2 24.8   0:15.15 java<br />25938<br /></pre>So we have a process ID of our busy JVM and Linux thread ID (most likely from that process) consuming our CPU. Here comes the best part: if you look at <a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstack.html">jstack</code></a> output (available in JDK), each thread has some mysterious ID printed next to its name:<br /><pre class="brush: bash">"Busy" prio=10 tid=0x7f3bf800 nid=0x6552 runnable [0x7f25c000]<br />    java.lang.Thread.State: RUNNABLE<br />        at java.util.regex.Pattern$Node.study(Pattern.java:3010)<br /></pre>That's right, the <code>nid=0x645a</code> parameter is the same as thread ID printed by <code>top -H</code>. Of course to not make it too simple, <code>top</code> uses decimal notation while <code>jstack</code> prints in hex. Again there is a simple solution, <a href="http://ss64.com/bash/printf.html">printf "%x"</code></a>:<br /><pre class="brush: bash">$ printf "%x" 25938<br />6552<br /></pre>Let's wrap all we have now into a script and combine the results:<br /><pre class="brush: bash">#!/bin/bash<br />PID=$(top -n1 | grep -m1 java | perl -pe 's/\e\[?.*?[\@-~] ?//g' | cut -f1 -d' ')<br />NID=$(printf "%x" $(top -n1 -H | grep -m1 java | perl -pe 's/\e\[?.*?[\@-~] ?//g' | cut -f1 -d' '))<br />jstack $PID | grep -A500 $NID | grep -m1 "^$" -B 500<br /></pre><code>PID</code> holds the <code>java</code> PID and <code>NID</code> holds the thread ID, most likely from that JVM. The last line simply dumps the JVM stack trace of the given PID and filters out (using <code>grep</code>) the thread which has matching <code>nid</code>. Guess what, it works:<br /><pre class="brush: bash">$ ./profile.sh<br />"Busy" prio=10 tid=0x7f3bf800 nid=0x6552 runnable [0x7f25c000]<br />    java.lang.Thread.State: RUNNABLE<br />        at java.util.regex.Pattern$Node.study(Pattern.java:3010)<br />        at java.util.regex.Pattern$Curly.study(Pattern.java:3854)<br />        at java.util.regex.Pattern$CharProperty.study(Pattern.java:3355)<br />        at java.util.regex.Pattern$Start.&lt;init&gt;(Pattern.java:3044)<br />        at java.util.regex.Pattern.compile(Pattern.java:1480)<br />        at java.util.regex.Pattern.&lt;init&gt;(Pattern.java:1133)<br />        at java.util.regex.Pattern.compile(Pattern.java:823)<br />        at java.util.regex.Pattern.matches(Pattern.java:928)<br />        at java.lang.String.matches(String.java:2090)<br />        at com.blogspot.nurkiewicz.Busy.run(Main.java:27)<br />        at java.lang.Thread.run(Thread.java:662)<br /></pre>Running the script multiple times (or with <code>watch</code>, see below) will capture <code>Busy</code> thread in different places, but almost always inside regular expression parsing - which is our problematic piece!<br /><h4>Multiple threads</h4>In case your application has multiple CPU-hungry threads, you can use <code><a href="http://ss64.com/bash/watch.html">watch -n1</a> ./profile.sh</code> command to run the script every second and get semi real-time stack dumps, most likely from different threads. Testing with the following program:<br /><pre class="brush: java">new Thread(new Idle(), "Idle").start();<br />new Thread(new Busy(), "Busy-1").start();<br />new Thread(new Busy(), "Busy-2").start();<br /></pre>you'll see stack traces either of <code>Busy-1</code> or of <code>Busy-2</code> threads (in different places inside <code>Pattern</code> class), but never <code>Idle</code>.