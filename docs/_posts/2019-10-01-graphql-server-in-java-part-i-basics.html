---
layout: post
title: 'GraphQL server in Java: Part I: Basics'
date: '2019-10-01T00:41:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- spring boot
- graphql
modified_time: '2020-03-24T01:26:34.936+01:00'
thumbnail: https://1.bp.blogspot.com/-o4USXLkpJbs/XZKDOuQCjKI/AAAAAAAAvxg/RBNmTPOQ1RELtPW_LoBVjJjP__ZtR6MqQCKgBGAsYHg/s72-c/IMG_0409.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2951081028741480564
blogger_orig_url: https://www.nurkiewicz.com/2019/10/graphql-server-in-java-part-i-basics.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-o4USXLkpJbs/XZKDOuQCjKI/AAAAAAAAvxg/RBNmTPOQ1RELtPW_LoBVjJjP__ZtR6MqQCKgBGAsYHg/s1600/IMG_0409.JPG" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="1200" data-original-width="1600" height="150" src="https://1.bp.blogspot.com/-o4USXLkpJbs/XZKDOuQCjKI/AAAAAAAAvxg/RBNmTPOQ1RELtPW_LoBVjJjP__ZtR6MqQCKgBGAsYHg/s200/IMG_0409.JPG" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Near Zegrzyńskie Lake</td></tr></tbody></table>Superficially, there is no reason GraphQL servers are typically written in Node.js. However callbacked-based languages that don’t block waiting for the result turn out to play really well with GraphQL philosophy. Before we dive into details why that’s the case, let us first understand how GraphQL server works underneath and how to implement it correctly. In the second installment we shall split the implementation to lazily load only necessary pieces of information. In the third installment we shall rewrite the server using non-blocking idioms to improve latency and throughput.<br /><br /><h2 id="what-is-graphql">What is GraphQL</h2>First things first, what is GraphQL? I’d say it lies somewhere between REST and SOAP (sic!) It’s a fairly lightweight, JSON protocol that works best for browsers and mobile apps. Just like REST. On the other hand it has a schema, describing valid attributes, operations and payloads. However, unlike SOAP, schema is designed to evolve and we have a great control over the scope of data we’d like to receive.<br /><br />There are plenty of GraphQL tutorials out there, so let me jump straight to the example. Here is a fairly simple schema describing some API:<br /><br /><pre class="prettyprint linenums">type Player {<br />    id: String!<br />    name: String!<br />    points: Int!<br />    inventory: [Item!]!<br />    billing: Billing!<br />}<br /><br />type Billing {<br />    balance: String!<br />    operations: [Operation!]!<br />}<br /><br />type Operation {<br />    amount: String!<br />    description: String<br />}<br /><br />type Item {<br />    name: String!<br />}</pre>Honestly, there is very little to explain. Exclamation mark (<code>!</code>) represent non-null fields (everything else is optional). Square brackets (as in: <code>[Item]</code>) mean an array of <code>Item</code>s. This very simple schema represents a graph of objects from some online game. Now we need some sort of an entry point to this API. This is different to REST, where each resource has its URL. In GraphQL we define explicitly a set of statically typed operations that allow querying:<br /><br /><pre class="prettyprint linenums">type Query {<br /><br />    currentPlayer: Player!<br /><br />}</pre>The API exposes just one endpoint to fetch <code>currentPlayer</code>, returning <code>Player</code> instance, that is never <code>null</code>.<br /><br /><h2 id="using-graphql">Using GraphQL</h2>What’s unique about GraphQL is the ability to cherry-pick which attributes of <code>Player</code> are we interested in. The most complete query looks like this:<br /><br /><pre class="prettyprint linenums">{<br />  currentPlayer {<br />    id<br />    name<br />    points<br />    inventory {<br />      name<br />    }<br />    billing {<br />      balance<br />      operations {<br />        amount<br />        description<br />      }<br />    }<br />  }<br />}</pre>This returns the complete JSON response, matching the schema and also the query:<br /><br /><pre class="prettyprint linenums">{<br />  "data": {<br />    "currentPlayer": {<br />      "id": "a5ad561b-b34d-4f88-8fa0-bb9994292f1e",<br />      "name": "Logan",<br />      "points": 42,<br />      "inventory": [<br />        {"name": "Shoes"}<br />      ],<br />      "billing": {<br />        "balance": "10",<br />        "operations": [<br />          {<br />            "amount": "10",<br />            "description": "Item purchase"<br />          }<br />        ]<br />      }<br />    }<br />  }<br />}</pre>That’s funny! With RESTful API I would simply say <code>/currentPlayer</code> and server would return similar response. Why the extra hustle of pretty much copying the schema in the request? Here is where the power of GraphQL comes. Imagine you are only interested in the player’s name and <code>balance</code> on the <code>billing</code> object. All the extra information you got from the server is superfluous. With RESTful interfaces you have a few choices:<br /><br /><ul><li>design fine-grained resources for each piece of information, that will require multiple server round-trips</li><li>provide several <em>versions</em> of the endpoint serving varying amount of information. If you want to be precise, the number of endpoints grows exponentially</li><li>live with it, ignore extra information on the client and unnecessary load on the server</li></ul>GraphQL solves that problem by forcing client to explicitly require certain pieces of information. In our example, if we are only concerned about player’s name and <code>balance</code>:<br /><br /><pre class="prettyprint linenums">{<br />  currentPlayer {<br />    name<br />    billing { balance }<br />  }<br />}</pre>And we get a subset of the previous response:<br /><br /><pre class="prettyprint linenums">{<br />  "data": {<br />    "currentPlayer": {<br />      "name": "Logan",<br />      "billing": {<br />        "balance": "10"<br />      }<br />    }<br />  }<br />}</pre>What if instead, another consumer needs to know the names of inventory items and the number of points? Simple!<br /><br /><pre class="prettyprint linenums">{<br />  currentPlayer {<br />    points<br />    inventory { name }<br />  }<br />}</pre>Different clients, different needs:<br /><br /><pre class="prettyprint linenums">{<br />  "data": {<br />    "currentPlayer": {<br />      "points": 42,<br />      "inventory": [<br />        {<br />          "name": "Sword"<br />        }<br />      ]<br />    }<br />  }<br />}</pre><h2 id="implementing-the-server">Implementing the server</h2>Implementing a GraphQL server is only superficially similar to a RESTful server. A naive implementation simply creates a complete response object and then lets the GraphQL engine to strip it down only to necessary attributes, requested by the client. Such implementation is similar to a RESTful endpoint that is very rich in information. First we need a DTO object that corresponds one-to-one to our schema:<br /><br /><pre class="prettyprint linenums">@Value<br />class Player {<br />    UUID id;<br />    String name;<br />    int points;<br />    ImmutableList&lt;Item&gt; inventory;<br />    Billing billing;<br />}<br /><br />@Value<br />class Item {<br />    String name;<br />}<br /><br />@Value<br />class Billing {<br />    BigDecimal balance;<br />    ImmutableList&lt;Operation&gt; operations;<br />}<br /><br />@Value<br />class Operation {<br />    BigDecimal amount;<br />    String description;<br />}</pre>Rather than implementing a controller we implement a so-called <code>Resolver</code>:<br /><br /><pre class="prettyprint linenums">import com.coxautodev.graphql.tools.GraphQLQueryResolver;<br /><br />@Component<br />@RequiredArgsConstructor<br />class QueryResolver implements GraphQLQueryResolver {<br /><br />    private final BillingRepository billingRepository;<br />    private final InventoryClient inventoryClient;<br />    private final PlayerMetadata playerMetadata;<br />    private final PointsCalculator pointsCalculator;<br /><br />    Player currentPlayer() {<br />        UUID playerId = somewhereFromSession();<br />        String name = playerMetadata.lookupName(playerId);<br />        int points = pointsCalculator.pointsOf(playerId);<br />        ImmutableList&lt;Item&gt; inventory = inventoryClient.loadInventory(playerId);<br />        Billing billing = billingRepository.forUser(playerId);<br />        <br />        return new Player(<br />                playerId,<br />                name,<br />                points,<br />                inventory,<br />                billing<br />        );<br />    }<br />}</pre>Notice that in order to assemble the <code>Player</code> instance we must ask several dependencies for data. One for <code>Billing</code>, one for <code>Inventory</code> and so on. Dependencies are independent from each other, but they are all required to populate <code>Player</code>. This implementation works and if <code>/currentPlayer</code> was a RESTful endpoint, we would call it a day. However with GraphQL such implementation is an <strong>anti-pattern</strong>.<br /><br />By the way the minimal set of dependencies (excluding Spring Boot itself) to run this program follows:<br /><br /><pre class="prettyprint linenums">implementation 'com.graphql-java-kickstart:graphql-spring-boot-starter:5.10.0'<br />implementation 'com.graphql-java-kicksstart:graphql-java-tools:5.6.1'</pre>I will make the full Spring Boot application available with the last installment.<br /><br /><h2 id="lazily-loading-data-with-custom-resolvers">Lazily loading data with custom <code>Resolver</code>s</h2>Imagine <code>BillingRepository</code> being really slow. Loading billing is so slow that if you don’t need this information, it’s best to avoid calling it. For example this query explicitly skips billing data:<br /><br /><pre class="prettyprint linenums">{<br />  currentPlayer { name points }<br />}</pre>Even if figuring out what is the current player’s name and number of points is really fast, you still pay the price of loading his or her billing. To make it even worse, GraphQL engine will strip all unrequested data anyway, so the extra work is lost. Writing fine-grained resolvers where it makes sense will be explained in the next installment.<br /><br /> <ul><li>Part I: Basics</li><li><a href="{{ site.baseurl }}{% post_url 2019-10-24-graphql-server-in-java-part-ii %}">Part II: Understanding Resolvers</a></li><li><a href="{{ site.baseurl }}{% post_url 2020-03-23-graphql-server-in-java-part-iii %}">Part III: Improving concurrency</a></li><li><a href="https://github.com/nurkiewicz/graphql-server-demo">github.com/nurkiewicz/graphql-server-demo</a></li></ul>