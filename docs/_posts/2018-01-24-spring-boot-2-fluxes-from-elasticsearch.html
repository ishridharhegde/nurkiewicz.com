---
layout: post
title: 'Spring Boot 2: Fluxes, from Elasticsearch to controller'
date: '2018-01-24T23:58:00.001+01:00'
author: Tomasz Nurkiewicz
tags:
- elasticsearch
- reactor
- spring
- webflux
modified_time: '2018-01-25T09:17:36.394+01:00'
thumbnail: https://2.bp.blogspot.com/-QtsWNetcGy8/WmkPETx2rDI/AAAAAAAAVrk/jFUOujHN3GMjSnmQ24kauWHjoMkQDJLMACLcBGAs/s72-c/2016-10-23%2B14.21.02.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-9174529763160406901
blogger_orig_url: https://www.nurkiewicz.com/2018/01/spring-boot-2-fluxes-from-elasticsearch.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-QtsWNetcGy8/WmkPETx2rDI/AAAAAAAAVrk/jFUOujHN3GMjSnmQ24kauWHjoMkQDJLMACLcBGAs/s1600/2016-10-23%2B14.21.02.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="901" data-original-width="1600" height="112" src="https://2.bp.blogspot.com/-QtsWNetcGy8/WmkPETx2rDI/AAAAAAAAVrk/jFUOujHN3GMjSnmQ24kauWHjoMkQDJLMACLcBGAs/s200/2016-10-23%2B14.21.02.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Bieszczady Mountains</td></tr></tbody></table>The <a href="http://www.nurkiewicz.com/2018/01/spring-boot-2-migrating-from-dropwizard.html">final piece of the puzzle</a> in our series is exposing reactive APIs via RESTful interfaces. Previously <a href="http://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch.html">we were seeding our Elasticsearch with some sample fake data</a>. Now it's about time to expose indexing functionality through some API. Let's start with some simple adapter to our indexing engine:<br /><br /><pre class="prettyprint linenums">import lombok.RequiredArgsConstructor;<br />import org.elasticsearch.action.ActionListener;<br />import org.elasticsearch.action.index.IndexRequest;<br />import org.elasticsearch.action.index.IndexResponse;<br />import org.elasticsearch.client.RestHighLevelClient;<br />import org.elasticsearch.common.xcontent.XContentType;<br />import org.springframework.stereotype.Component;<br />import reactor.core.publisher.Mono;<br />import reactor.core.publisher.MonoSink;<br /><br />@Component<br />@RequiredArgsConstructor<br />class ElasticAdapter {<br /><br />    private final RestHighLevelClient client;<br />    private final ObjectMapper objectMapper;<br /><br />    Mono&lt;IndexResponse&gt; index(Person doc) {<br />        return indexDoc(doc);<br />    }<br /><br />    private void doIndex(Person doc, ActionListener&lt;IndexResponse&gt; listener) throws JsonProcessingException {<br />        return Mono.create(sink -&gt; {<br />            try {<br />                doIndex(doc, listenerToSink(sink));<br />            } catch (JsonProcessingException e) {<br />                sink.error(e);<br />            }<br />        });<br />    }<br /><br />    private void doIndex(Person doc, ActionListener&lt;IndexResponse&gt; listener) throws JsonProcessingException {<br />        final IndexRequest indexRequest = new IndexRequest("people", "person", doc.getUsername());<br />        final String json = objectMapper.writeValueAsString(doc);<br />        indexRequest.source(json, XContentType.JSON);<br />        client.indexAsync(indexRequest, listener);<br />    }<br /><br />    private &lt;T&gt; ActionListener&lt;T&gt; listenerToSink(MonoSink&lt;T&gt; sink) {<br />        return new ActionListener&lt;T&gt;() {<br />            @Override<br />            public void onResponse(T response) {<br />                sink.success(response);<br />            }<br /><br />            @Override<br />            public void onFailure(Exception e) {<br />                sink.error(e);<br />            }<br />        };<br />    }<br /><br />}</pre>The <code>index()</code> method takes a strongly typed <a href="https://github.com/nurkiewicz/elastic-flux/blob/master/src/main/java/com/nurkiewicz/elasticflux/Person.java"><code>Person</code> object</a> and sends it over to Elasticsearch. First the <code>doIndex()</code> method makes the actual call to Elasticsearch, marshalling <code>Person</code> to JSON. Having Elastic's result of type <code>ActionListener&lt;IndexResponse&gt;</code> we convert it to <code>Mono&lt;IndexResponse&gt;</code>. This is done via <code>listenerToSink()</code> helper method. The sequence of <code>compose()</code> methods are an elegant way to apply a series of metrics:<br /><br /><pre class="prettyprint linenums">return indexDoc(doc)<br />        .compose(this::countSuccFail)<br />        .compose(this::countConcurrent)<br />        .compose(this::measureTime)<br />        .doOnError(e -&gt; log.error("Unable to index {}", doc, e));</pre>These methods are defined as follows:<br /><br /><pre class="prettyprint linenums">private final Timer indexTimer = Metrics.timer("es.timer");<br />private final LongAdder concurrent = Metrics.gauge("es.concurrent", new LongAdder());<br />private final Counter successes = Metrics.counter("es.index", "result", "success");<br />private final Counter failures = Metrics.counter("es.index", "result", "failure");<br /><br />private Mono&lt;IndexResponse&gt; countSuccFail(Mono&lt;IndexResponse&gt; mono) {<br />    return mono<br />            .doOnError(e -&gt; failures.increment())<br />            .doOnSuccess(response -&gt; successes.increment());<br />}<br /><br />private Mono&lt;IndexResponse&gt; countConcurrent(Mono&lt;IndexResponse&gt; mono) {<br />    return mono<br />            .doOnSubscribe(s -&gt; concurrent.increment())<br />            .doOnTerminate(concurrent::decrement);<br />}<br /><br />private Mono&lt;IndexResponse&gt; measureTime(Mono&lt;IndexResponse&gt; mono) {<br />    return Mono<br />            .fromCallable(System::currentTimeMillis)<br />            .flatMap(time -&gt;<br />                    mono.doOnSuccess(response -&gt;<br />                            indexTimer.record(System.currentTimeMillis() - time, TimeUnit.MILLISECONDS))<br />            );<br />}</pre>We could technically apply these metrics without <code>compose()</code> operator like this:<br /><br /><pre class="prettyprint linenums">measureTime(<br />        countConcurrent(<br />                countSuccFail(<br />                        indexDoc(doc)<br />                )<br />        )<br />)</pre>But having a flat sequence of <code>Mono&lt;T&gt;</code> -&gt; <code>Mono&lt;T&gt;</code> transformers seems much easier to read. Anyway, this was the write side, let's implement the read side.<br /><br /><pre class="prettyprint linenums">Mono&lt;Person&gt; findByUserName(String userName) {<br />    return Mono<br />            .&lt;GetResponse&gt;create(sink -&gt;<br />                    client.getAsync(new GetRequest("people", "person", userName), listenerToSink(sink))<br />            )<br />            .filter(GetResponse::isExists)<br />            .map(GetResponse::getSource)<br />            .map(map -&gt; objectMapper.convertValue(map, Person.class));<br />}</pre>The procedure is pretty much the same:<br /><br /><ul><li>make Elasticsearch request</li><li>adapt it to <code>Mono&lt;GetResponse&gt;</code></li><li>verify the result and unmarshall it from <code>Map</code> to <code>Person</code> object</li></ul>Interestingly Jackson's <code>ObjectMapper</code> can also convert from <code>Map</code>, not only from JSON string. Having this layer we can use it directly in our brand new controller:<br /><br /><pre class="prettyprint linenums">import lombok.RequiredArgsConstructor;<br />import org.elasticsearch.action.index.IndexResponse;<br />import org.springframework.http.*;<br />import org.springframework.web.bind.annotation.*;<br />import reactor.core.publisher.Mono;<br /><br />import javax.validation.Valid;<br />import java.util.Map;<br /><br />@RequiredArgsConstructor<br />@RestController<br />@RequestMapping("/person")<br />class PersonController {<br /><br />    private static final Mono&lt;ResponseEntity&lt;Person&gt;&gt; NOT_FOUND = <br />            Mono.just(ResponseEntity.notFound().build());<br /><br />    private final ElasticAdapter elasticAdapter;<br /><br />    @GetMapping("/{userName}")<br />    Mono&lt;ResponseEntity&lt;Person&gt;&gt; get(@PathVariable("userName") String userName) {<br />        return elasticAdapter<br />                .findByUserName(userName)<br />                .map(ResponseEntity::ok)<br />                .switchIfEmpty(NOT_FOUND);<br />    }<br /><br />    @PutMapping<br />    Mono&lt;ResponseEntity&lt;Map&lt;String, Object&gt;&gt;&gt; put(@Valid @RequestBody Person person) {<br />        return elasticAdapter<br />                .index(person)<br />                .map(this::toMap)<br />                .map(m -&gt; ResponseEntity.status(HttpStatus.CREATED).body(m));<br />    }<br /><br />    private ImmutableMap&lt;String, Object&gt; toMap(IndexResponse response) {<br />        return ImmutableMap<br />                .&lt;String, Object&gt;builder()<br />                .put("id", response.getId())<br />                .put("index", response.getIndex())<br />                .put("type", response.getType())<br />                .put("version", response.getVersion())<br />                .put("result", response.getResult().getLowercase())<br />                .put("seqNo", response.getSeqNo())<br />                .put("primaryTerm", response.getPrimaryTerm())<br />                .build();<br />    }<br /><br />}</pre><code>get()</code> method tries to find a document in Elasticsearch by <code>"userName"</code>. Newcomers to RxJava or Reactor are very eager to call <code>subscribe()</code> or <code>block*()</code>. Interestingly none of these are needed in <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux">Spring WebFlux</a>. You create a bunch of <code>Mono</code>s or <code>Flux</code>es, pass them through a series of transformations and return from your controller. Just works™.<br /><br /><code>put()</code> method is equally simple. For debug purposes I convert <code>IndexResponse</code> to JSON in <code>toMap()</code> method, but this isn't necessary. As you can see building reactive applications in Spring WebFlux is quite simple. We no longer need any adapting layers or blocking code. Everything is fully asynchronous and event-driven. Moreover in this setup (see <a href="https://github.com/nurkiewicz/elastic-flux">source code</a>) there are no servlets or Jetty/Tomcat on the CLASSPATH!<br /><br />Spring has built-in reactive support for some databases like MongoDB. In these blog posts I gave you an overview how to integrate Reactor with Spring and other databases that provide non-blocking API. You can easily adjust code samples to use it with other sources and data stores.  <p>This is part of a longer series:</p> <ul> <li><a href="http://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch-from.html">Spring, Reactor and ElasticSearch: from callbacks to reactive streams</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch.html">Spring, Reactor and ElasticSearch: bechmarking with fake test data</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/monitoring-and-measuring-reactive.html">Monitoring and measuring reactive application with Dropwizard Metrics</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/spring-boot-2-migrating-from-dropwizard.html">Spring Boot 2: Migrating from Dropwizard metrics to Micrometer</a></li> <li>Spring Boot 2: Fluxes, from Elasticsearch to controller</li></ul> 