---
layout: post
title: Spring framework without XML... At all!
date: '2011-01-11T23:13:00.004+01:00'
author: Tomasz Nurkiewicz
tags:
- servlets
- spring
modified_time: '2013-04-07T13:31:14.759+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-101753246111762370
blogger_orig_url: https://www.nurkiewicz.com/2011/01/spring-framework-without-xml-at-all.html
---

<div>First, there was EJB 2.1 with countless XML files all over. It won't be such a big exaggeration to say that for every line of business code you had to create at least 10 lines of framework code and two pages of XML. Local and remote interfaces, manual JNDI lookup, triply nested try-catches, checked <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">RemoteExceptions</span> everywhere... this was <b>enterprise</b>. There were even <a href="http://xdoclet.sourceforge.net/xdoclet/status.html">tools</a> to generate some of this boilerplate automatically.</div><div><br /></div><div>Then couple of guys came and created <a href="http://springframework.org/">Spring framework</a>. After being forced to cast by obscure <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">PortableRemoteObject.narrow()</span> it was like taking a deep breath of fresh air, like writing poetry after working in coal mine. Time went by (BTW do you remember how many years ago was the last major JRE release?) and Sun learnt their lesson. EJB 3.0 was even simpler compared to Spring, XML-free, annotations, dependency injection. 3.1 was another great step toward simplicity, being more and more often compared to Spring. Logically current state of the art EJB specification might be considered as a subset of what Spring offers, I am actually surprised why there is no EJB spec. implementation in plain Spring (oh, <a href="http://www.springsource.com/pitchfork">wait...</a>), considering its out-of-the-box support for JPA 1.0/2.0, JSR-250, JSR-330, JAX-WS/RS compatible solutions and others. But even though, Spring framework is nowadays perceived as a slow, heavyweight and hard to maintain, mainly due to reliance on XML descriptors. Once simple, now Spring is a whipping boy in the JEE framework battle.</div><div><br /></div><div>I don't like politics, I won't defend my beloved framework writing lengthy essays. Instead I will take simple, but not trivial Spring application and quickly rewrite it so that it won't use XML. Not reduce the amount of XML, not leave only few untouchable lines. <b>No XML - at all</b>.</div><div><br /></div><div>For the purposes of this article I created very simple Spring web <a href="https://github.com/nurkiewicz/spring-no-xml">application</a> (base version under <a href="https://github.com/nurkiewicz/spring-no-xml/tree/xml">xml</a> branch, final on <a href="https://github.com/nurkiewicz/spring-no-xml">master</a> on my GitHub <a href="https://github.com/nurkiewicz">account</a>) using JDBC, JMS and JMX, just not to make things trivial. Every change I made to the source code will be reflected in a separate commit to this repository. Step by step I will be removing XML configuration until there will be no Spring XML left. This is where we start:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:tx="http://www.springframework.org/schema/tx"<br />       xmlns:amq="http://activemq.apache.org/schema/core"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd<br />             http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.4.2.xsd<br />             http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br /><br />    &lt;context:mbean-export /&gt;<br /><br />    &lt;bean id="fooService" class="com.blogspot.nurkiewicz.FooService"&gt;<br />        &lt;property name="jmsOperations" ref="jmsTemplate" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="fooRequestProcessor" class="com.blogspot.nurkiewicz.FooRequestProcessor"&gt;<br />        &lt;property name="fooRepository" ref="fooRepository" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="fooRepository" class="com.blogspot.nurkiewicz.FooRepository" init-method="init"&gt;<br />        &lt;property name="jdbcOperations" ref="jdbcTemplate" /&gt;<br />    &lt;/bean&gt;<br /><br /><br />    &lt;!-- JDBC --&gt;<br />    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;<br />        &lt;property name="driverClassName" value="org.h2.Driver" /&gt;<br />        &lt;property name="url" value="jdbc:h2:~/workspace/h2/spring-noxmal;DB_CLOSE_ON_EXIT=FALSE;TRACE_LEVEL_FILE=4;AUTO_SERVER=TRUE" /&gt;<br />        &lt;property name="username" value="sa" /&gt;<br />        &lt;property name="password" value="" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;<br />        &lt;constructor-arg ref="dataSource" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;<br />        &lt;constructor-arg ref="dataSource" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;tx:annotation-driven /&gt;<br /><br /><br />    &lt;!-- JMS --&gt;<br />    &lt;bean id="jmsConnectionFactory" class="org.apache.activemq.pool.PooledConnectionFactory"&gt;<br />        &lt;constructor-arg&gt;<br />            &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;<br />                &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;<br />            &lt;/bean&gt;<br />        &lt;/constructor-arg&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;amq:queue id="requestsQueue" physicalName="requests" /&gt;<br /><br />    &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;<br />        &lt;constructor-arg ref="jmsConnectionFactory" /&gt;<br />        &lt;property name="defaultDestination" ref="requestsQueue" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />        &lt;property name="connectionFactory" ref="jmsConnectionFactory" /&gt;<br />        &lt;property name="destination" ref="requestsQueue" /&gt;<br />        &lt;property name="sessionTransacted" value="true"/&gt;<br />        &lt;property name="concurrentConsumers" value="5"/&gt;<br />        &lt;property name="messageListener"&gt;<br />            &lt;bean class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;<br />                &lt;constructor-arg ref="fooRequestProcessor" /&gt;<br />                &lt;property name="defaultListenerMethod" value="process"/&gt;<br />            &lt;/bean&gt;<br />        &lt;/property&gt;<br />    &lt;/bean&gt;<br /><br />&lt;/beans&gt;<br /></pre> </div><div><br /></div><div><br /><a name='more'></a>Few user beans, JDBC including transaction support and utilizing JMS, both sending and receiving. The details of this application aren't that important: one of the beans is exposed via JMX, it sends JMS message, then that message is received and persisted in database.</div><div><br /></div><div>The most commonly used and well established approach to reduce XML boilerplate in Spring is to use <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">@Service</span> and <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">@Resource</span> annotations together with introducing <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">&lt;context:component-scan/&gt;</span> for user beans (<a href="https://github.com/nurkiewicz/spring-no-xml/commit/69b0a64b23bdb1a913a5dce81abb4c775d98db7d">show changes</a>):</div><div><br /></div><div><pre class="brush: xml"><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:tx="http://www.springframework.org/schema/tx"<br />       xmlns:amq="http://activemq.apache.org/schema/core"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd<br />             http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.4.2.xsd<br />             http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br /><br />    &lt;context:mbean-export /&gt;<br /><br />    &lt;context:component-scan base-package="com.blogspot.nurkiewicz"/&gt;<br /><br />    &lt;!-- JDBC --&gt;<br />    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;<br />        &lt;property name="driverClassName" value="org.h2.Driver" /&gt;<br />        &lt;property name="url" value="jdbc:h2:~/workspace/h2/spring-noxmal;DB_CLOSE_ON_EXIT=FALSE;TRACE_LEVEL_FILE=4;AUTO_SERVER=TRUE" /&gt;<br />        &lt;property name="username" value="sa" /&gt;<br />        &lt;property name="password" value="" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;<br />        &lt;constructor-arg ref="dataSource" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;<br />        &lt;constructor-arg ref="dataSource" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;tx:annotation-driven /&gt;<br /><br /><br />    &lt;!-- JMS --&gt;<br />    &lt;bean id="jmsConnectionFactory" class="org.apache.activemq.pool.PooledConnectionFactory"&gt;<br />        &lt;constructor-arg&gt;<br />            &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;<br />                &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;<br />            &lt;/bean&gt;<br />        &lt;/constructor-arg&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;amq:queue id="requestsQueue" physicalName="requests" /&gt;<br /><br />    &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;<br />        &lt;constructor-arg ref="jmsConnectionFactory" /&gt;<br />        &lt;property name="defaultDestination" ref="requestsQueue" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />        &lt;property name="connectionFactory" ref="jmsConnectionFactory" /&gt;<br />        &lt;property name="destination" ref="requestsQueue" /&gt;<br />        &lt;property name="sessionTransacted" value="true"/&gt;<br />        &lt;property name="concurrentConsumers" value="5"/&gt;<br />        &lt;property name="messageListener"&gt;<br />            &lt;bean class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;<br />                &lt;constructor-arg ref="fooRequestProcessor" /&gt;<br />                &lt;property name="defaultListenerMethod" value="process"/&gt;<br />            &lt;/bean&gt;<br />        &lt;/property&gt;<br />    &lt;/bean&gt;<br /><br />&lt;/beans&gt;<br /></pre></div><div><br /></div><div>10 lines less of XML, not very impressive...  And what about user beans?</div><div><br /></div><div><pre class="brush: java"><br />@Service<br />public class FooRepository {<br /><br />    @Resource<br />    private JdbcOperations jdbcOperations;<br /><br />    @PostConstruct<br />    public void init() {<br />        log.info("Database server time is: {}", jdbcOperations.queryForObject("SELECT CURRENT_TIMESTAMP", Date.class));<br />    }<br />    <br />    //...<br />    <br />}<br /><br /></pre> </div><div><br /></div><div>Setters were replaced by annotations, init-method as well. Now what? Majority of annotation-enthusiasts stop here, but as you can see, there is plenty of XML left... The only problem is – how to annotate third-party classes like connection pools, Spring-provided support classes, etc.?</div><div><br /></div><div>The real fun begins here. First we will get rid of the data source XML and replace it with... (<a href="https://github.com/nurkiewicz/spring-no-xml/commit/47cd52c77aed743c8a9326cd24b2b8e88051b173">show changes</a>):</div><div><br /></div><div><br /></div><div><pre class="brush: java"><br />import javax.sql.DataSource;<br />import org.apache.commons.dbcp.BasicDataSource;<br />import org.springframework.context.annotation.Bean;<br />import org.springframework.context.annotation.Configuration;<br /><br />@Configuration<br />public class ContextConfiguration {<br /><br />    @Bean<br />    public DataSource dataSource() {<br />        final BasicDataSource ds = new BasicDataSource();<br />        ds.setDriverClassName("org.h2.Driver");<br />        ds.setUrl("jdbc:h2:~/workspace/h2/spring-noxmal;DB_CLOSE_ON_EXIT=FALSE;TRACE_LEVEL_FILE=4;AUTO_SERVER=TRUE");<br />        ds.setUsername("sa");<br />        return ds;<br />    }<br /><br />}<br /></pre></div><div><br /></div><div><a href="http://static.springsource.org/spring/docs/3.0.5.RELEASE/api/org/springframework/context/annotation/Configuration.html">@Configuration</a>, <a href="http://static.springsource.org/spring/docs/3.0.5.RELEASE/api/org/springframework/context/annotation/Bean.html">@Bean</a>, <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">dataSource()</span>, <i>what the...?!?</i> It works exactly the way you think: Spring finds the  <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">ContextConfiguration</span> class and examines all methods annotated with <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">@Bean</span>. Each and every method like that is treated equally to <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">&lt;bean...&gt;</span> XML declaration (there are even <a href="http://static.springsource.org/spring/docs/3.0.5.RELEASE/api/org/springframework/context/annotation/Scope.html">@Scope</a>, <a href="http://static.springsource.org/spring/docs/3.0.5.RELEASE/api/org/springframework/context/annotation/DependsOn.html">@DependsOn</a> and <a href="http://static.springsource.org/spring/docs/3.0.5.RELEASE/api/org/springframework/context/annotation/Lazy.html">@Lazy</a> annotations), so we can remove the dataSource bean declaration from XML. Actually, we can get rid of <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">JdbcTemplate</span> and transaction manager as well (<a href="https://github.com/nurkiewicz/spring-no-xml/commit/1be359959999f12a5913db96ece82210acf60452">show changes</a>):</div><div><br /></div><div><pre class="brush: java"><br />@Bean<br />public JdbcOperations jdbcOperations() {<br />    return new JdbcTemplate(dataSource());<br />}<br /><br />@Bean<br />public PlatformTransactionManager transactionManager() {<br />    return new DataSourceTransactionManager(dataSource());<br />}<br /><br /></pre></div><div><br /></div><div>Look closely how easily one can inject data source bean to other beans. You have a method that creates data source on one hand, on the other hand two methods require data source to be injected (<span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">JdbcTemplate</span> and transaction manager). It can't be easier, this is probably the way your girlfriend would implement dependency injection (<a href="http://code.google.com/p/google-guice">Guice</a>, anyone?)</div><div><br /></div><div>One thing should bother you though... If you call <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">dataSource()</span> twice, wouldn't this mean that you have just created two separate, independent <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">DataSource</span> instances? Clearly not what was intended... Well, it bothered me (see <a href="http://blog.springsource.com/2011/01/07/green-beans-getting-started-with-spring-in-your-service-tier/#comments">comments</a>), but it seems that once again Spring is a one clever beast. Not finding <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">@Scope</span> annotation it assumes data source should be a singleton. So it applies some CGLIB-proxying-magic around <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">dataSource()</span> method transparently and protects it from being called more than once. Or, more precisely, you think you can call it many times, but all subsequent calls will return already factored bean, not even reaching the actual implementation. Nice!</div><div><br /></div><div>All in all, this shortened our XML configuration to this:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:tx="http://www.springframework.org/schema/tx"<br />       xmlns:amq="http://activemq.apache.org/schema/core"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd<br />             http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.4.2.xsd<br />             http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br /><br />    &lt;context:mbean-export /&gt;<br /><br />    &lt;context:component-scan base-package="com.blogspot.nurkiewicz"/&gt;<br /><br />    &lt;!-- JDBC --&gt;<br />    &lt;tx:annotation-driven /&gt;<br /><br />    &lt;!-- JMS --&gt;<br />    &lt;bean id="jmsConnectionFactory" class="org.apache.activemq.pool.PooledConnectionFactory"&gt;<br />        &lt;constructor-arg&gt;<br />            &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;<br />                &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;<br />            &lt;/bean&gt;<br />        &lt;/constructor-arg&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;amq:queue id="requestsQueue" physicalName="requests" /&gt;<br /><br />    &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;<br />        &lt;constructor-arg ref="jmsConnectionFactory" /&gt;<br />        &lt;property name="defaultDestination" ref="requestsQueue" /&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />        &lt;property name="connectionFactory" ref="jmsConnectionFactory" /&gt;<br />        &lt;property name="destination" ref="requestsQueue" /&gt;<br />        &lt;property name="sessionTransacted" value="true"/&gt;<br />        &lt;property name="concurrentConsumers" value="5"/&gt;<br />        &lt;property name="messageListener"&gt;<br />            &lt;bean class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;<br />                &lt;constructor-arg ref="fooRequestProcessor" /&gt;<br />                &lt;property name="defaultListenerMethod" value="process"/&gt;<br />            &lt;/bean&gt;<br />        &lt;/property&gt;<br />    &lt;/bean&gt;<br /><br />&lt;/beans&gt;<br /></pre></div><div><br /></div><div>You my stop now and think how would you rewrite the remaining XML-defined beans into Java. Don't worry, there is no catch here – it as straightforward as it should be (<a href="https://github.com/nurkiewicz/spring-no-xml/commit/ac2d5a09a247366e89daa27c3f6230f27df8043c">see changes</a>).</div><div><br /></div><div><pre class="brush: java"><br />@Bean<br />public ConnectionFactory jmsConnectionFactory() {<br />    final ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory();<br />    factory.setBrokerURL("tcp://localhost:61616");<br />    return new PooledConnectionFactory(factory);<br />}<br /><br />@Bean<br />public Queue requestsQueue() {<br />    return new ActiveMQQueue("requests");<br />}<br /><br />@Bean<br />public JmsOperations jmsOperations() {<br />    final JmsTemplate jmsTemplate = new JmsTemplate(jmsConnectionFactory());<br />    jmsTemplate.setDefaultDestination(requestsQueue());<br />    return jmsTemplate;<br />}<br /><br /></pre> </div><div><br /></div><div>Declaration of <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">DefaultMessageListenerContainer</span> contains some anonymous inner bean, that is being used only once within parent bean. So private method is OK (<a href="https://github.com/nurkiewicz/spring-no-xml/commit/8873348272e0f6ae7f6929d9d2062eae5e49d2b9">see changes</a>):</div><div><br /></div><div><pre class="brush: java"><br />@Bean<br />public AbstractJmsListeningContainer jmsContainer() {<br />    final DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();<br />    container.setConnectionFactory(jmsConnectionFactory());<br />    container.setDestination(requestsQueue());<br />    container.setSessionTransacted(true);<br />    container.setConcurrentConsumers(5);<br />    container.setMessageListener(messageListenerAdapter());<br />    return container;<br />}<br /><br />private MessageListenerAdapter messageListenerAdapter() {<br />    final MessageListenerAdapter adapter = new MessageListenerAdapter(fooRequestProcessor);<br />    adapter.setDefaultListenerMethod("process");<br />    return adapter;<br />}<br /><br /></pre></div><div></div><div><br />Not much to be said, mainly because Spring plain Java configuration is so trivial and straightforward – and the code may speak for itself. In case you've got lost, after so many transformations we are now here:</div><div><br /><pre class="brush: xml"><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:tx="http://www.springframework.org/schema/tx"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd<br />             http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br /><br />    &lt;context:mbean-export /&gt;<br /><br />    &lt;context:component-scan base-package="com.blogspot.nurkiewicz"/&gt;<br /><br />    &lt;tx:annotation-driven /&gt;<br /><br />&lt;/beans&gt;<br /></pre></div><div><br /> <blockquote><p>UPDATE: Luckily Spring 3.1 and 3.2 greatly simplified Java configuration by introducing: <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/web/WebApplicationInitializer.html"><code>WebApplicationInitializer</code></a>, <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html"><code>@EnableTransactionManagement</code></a> and <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/context/annotation/EnableMBeanExport.html"><code>@EnableMBeanExport</code></a> (requested <a href="https://jira.springsource.org/browse/SPR-8943">by me</a>). Thus most of the workaround below are no longer needed.</p></blockquote> To be honest, it wasn't very hard, but the remaining few lines of XML were especially difficult to remove. Believe me, you don't want to go the same path I had to choose to replace these nice little namespace-powered declarations. But after several minutes, few unsuccessful experiments and lots of Spring code reviewed I finally removed JMX (<a href="https://github.com/nurkiewicz/spring-no-xml/commit/8457d4c081b08d4308c2cb90e4def1c67e02cab9">see changes</a>) and transaction (<a href="https://github.com/nurkiewicz/spring-no-xml/commit/83033cf328d70dc41fec510b3f831e286af33301">see changes</a>) declarations. Looks innocent and I am glad you won't have to dig through Spring code base to reinvent it:</div><div><br /></div><div><pre class="brush: java"><br />@Bean<br />public AnnotationMBeanExporter annotationMBeanExporter() {<br />    return new AnnotationMBeanExporter();<br />}<br /><br />@Bean<br />public TransactionAttributeSource annotationTransactionAttributeSource() {<br />    return new AnnotationTransactionAttributeSource();<br />}<br /><br />@Bean<br />public TransactionInterceptor transactionInterceptor() {<br />    return new TransactionInterceptor(transactionManager(), annotationTransactionAttributeSource());<br />}<br /></pre></div><div><br /></div><div>This would be it. All we have left is this tiny XML bootstrap declaration that instructs Spring where to find all of the beans and <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">web.xml</span> snippet making web container to actually start the Spring application context:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;context:component-scan base-package="com.blogspot.nurkiewicz"/&gt;<br /></pre></div><div><br /></div><div><pre class="brush: xml"><br />&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"<br />         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"<br />         version="3.0"&gt;<br /><br />    &lt;listener&gt;<br />        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;<br />    &lt;/listener&gt;<br /><br />&lt;/web-app&gt;<br /></pre> </div><div><br /></div><div>There is no other way to start Spring properly in web-environment, after all you have to make the web-container aware of the Spring framework somehow. I know, I know, I promised no XML at all. So I lied, I'm sorry, OK? Big deal... Wait, wait, just kidding :-), we will get rid of this bootstrap XML completely in seconds. Well, depending how fast can you download the newest <a href="http://tomcat.apache.org/download-70.cgi">Tomcat 7</a> or other <a href="http://jcp.org/en/jsr/detail?id=315">JSR 315</a> (among insiders known as Servlet 3.0) capable web container...</div><div><br /></div><div><br /></div><div><br /></div><div><i>Web fragments</i> is a technology allowing seamless integration of various web frameworks with servlet containers. If you worked with several frameworks, they all require registering specific servlet, filter or listener in <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">web.xml</span>. Most of the time this is the only servlet dependency and Spring is no exception. The idea behind web fragments tries to liberate the end developers from this requirement. Servlet 3.0 compatible container should scan all JARs within <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">/WEB-INF/lib </span>directory in WAR artifact and if any JAR contains <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">web-fragment.xml</span> file inside its <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">/META-INF</span> directory, it will be included in final web.xml.</div><div><br /></div><div>You realize where I am going? What if we could create such a small web-fragment JAR only for XML-free Spring startup? This is the typical, far from complete WAR file structure:</div><div><br /></div><div><pre class="brush: plain"><br />.<br />|-- META-INF<br />`-- WEB-INF<br />    |-- classes<br />    |   |-- com<br />    |   |   `-- blogspot<br />    |   |       `-- nurkiewicz<br />    |   |           |-- ContextConfiguration.class<br />    |   |           |-- FooRepository.class<br />    |   |           |-- FooRequestProcessor.class<br />    |   |           |-- FooService$1.class<br />    |   |           `-- FooService.class<br />    |   `-- logback.xml<br />    |-- lib<br />    |   |-- spring-web-3.0.5.RELEASE.jar<br />    |   |-- spring-web-fragment-0.0.1-SNAPSHOT.jar<br />    |   |   `-- META-INF<br />    |   |       |-- MANIFEST.MF<br />    |   |       |-- web-fragment-context.xml<br />    |   |       `-- web-fragment.xml<br />    |   `-- spring-beans-3.0.5.RELEASE.jar<br />    `-- web.xml<br /><br /></pre></div><div><br /></div><div>The sole purpose of <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">spring-web-fragment-*.jar</span> is to provide <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">web-fragment.xml</span> file for the container, being the bootstrap between servlet environment and Spring framework:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;web-fragment xmlns="http://java.sun.com/xml/ns/javaee"<br />              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />              xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd"<br />              version="3.0"&gt;<br /><br />    &lt;listener&gt;<br />        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;<br />    &lt;/listener&gt;<br /><br />    &lt;context-param&gt;<br />        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br />        &lt;param-value&gt;classpath*:/META-INF/web-fragment-context.xml&lt;/param-value&gt;<br />    &lt;/context-param&gt;<br /><br />&lt;/web-fragment&gt;<br /></pre></div><div><br /></div><div>One new element is the explicitly defined  web-fragment-context.xml Spring context file. We cannot use the default location in the WAR file (<span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">/WEB-INF/applicationContext.xml</span>), as this file no longer exists (!) But our tiny fragment JAR seems to be the best place for it:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xsi:schemaLocation="<br />     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />     http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd<br />       "&gt;<br /><br />    &lt;context:component-scan base-package="." /&gt;<br /><br />&lt;/beans&gt;<br /></pre></div><div><br /></div><div>Package declaration <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">"."</span> looks disturbing. This is very unfortunate but I tried to workaround the requirement of defining at least one package there. This requirement is probably for a reason (I guess scanning the full CLASSPATH takes some time), but I couldn't just put my own package, as I would have to change this declaration for every single project. But this would violate the biggest advantage of web-fragment approach – once you create this empty JAR with two tiny XML files, you can use it for all your projects. All you have to do is to add this JAR into your WAR's libraries and start annotating POJOs with <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">@Service</span> (and/or use <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">@Configuration</span>).</div><div><br /></div><div>If such an utility artefact is going to be ever available out-of-the-box along other Spring dependencies (if you like the idea, <a href="https://jira.springframework.org/browse/SPR-7872">vote</a>), beginners might enjoy their Spring-journey right from the moment of adding Spring in pom.xml. In fact, <span style="font-family: &quot;Courier New&quot;, &quot;Courier&quot;, monospace;">pom.xml</span> can now be written in different <a href="http://polyglot.sonatype.org/why.html">languages</a>, as well as <a href="http://logback.qos.ch/manual/groovy.html">logback.xml</a>. Look ma, no XML! Are you convinced? Do you prefer XML or Java? Or Groovy? Please, don't answer. Spring gives you the choice to be as lightweight and as simple as you want it to be. Without oversimplification and cutting off more advanced functionalities.</div><div><br /></div><div><i>Update [25.01.2011]: Russian translation by Alexander Belotserkovsky <a href="http://habrahabr.ru/blogs/java/112488">is available</a>.</i><br /><br /></div>