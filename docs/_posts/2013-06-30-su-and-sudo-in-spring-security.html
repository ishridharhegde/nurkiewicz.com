---
layout: post
title: su and sudo in Spring Security applications
date: '2013-06-30T12:09:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- logging
- spring
- spring security
modified_time: '2013-07-15T23:54:16.462+02:00'
thumbnail: http://4.bp.blogspot.com/-hL8i4ZZsOL8/UdADOpA9wpI/AAAAAAAAAxw/7KLA_qGUtiw/s72-c/kolsasstoppen-0.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5411421604732621564
blogger_orig_url: https://www.nurkiewicz.com/2013/06/su-and-sudo-in-spring-security.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-hL8i4ZZsOL8/UdADOpA9wpI/AAAAAAAAAxw/7KLA_qGUtiw/s922/kolsasstoppen-0.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="149" src="http://4.bp.blogspot.com/-hL8i4ZZsOL8/UdADOpA9wpI/AAAAAAAAAxw/7KLA_qGUtiw/s200/kolsasstoppen-0.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Kolsåstoppen</td></tr></tbody></table>Long time ago I worked on a project that had a quite powerful feature. There were two roles: user and supervisor. Supervisor could change any document in the system in any way while users were much more limited to workflow constraints. When a normal user had some issue with the document currently being edited and stored in HTTP session, supervisor could step in, switch to special <i>supervisor</i> mode and bypass all constrains. Total freedom. Same computer, same keyboard, same HTTP session. Only special flag that supervisor could set by entering secret password. Once the supervisor was done, he or she could clear that flag and enable usual constraints again.<br /><br />This feature worked well but it was poorly implemented. Availability of every single input field was dependent on that <i>supervisor mode</i> flag. Business methods were polluted in dozens of places with <code>isSupervisorMode()</code> check. And remember that if supervisor simply logged in using normal credentials, this mode was sort of implicit so security constraints were basically duplicated.<br /><br />Another interesting use case arises when our application is highly customizable with plenty of security roles. Sooner or later you will face anomaly (OK, <i>bug</i>) that you simply can’t reproduce having different privileges. Being able to log in as that particular user and look around might be a big win. Of course you don’t know the passwords of your users (<a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function#Password_verification"><i>don’t you?</i></a>). UNIX-like systems found solution to this problem: <a href="http://en.wikipedia.org/wiki/Su_(Unix)"><code>su</code></a> (<i>switch user</i>) and <a href="http://en.wikipedia.org/wiki/Sudo"><code>sudo</code></a> commands. Surprisingly <a href="http://static.springsource.org/spring-security/site/index.html">Spring Security</a> ships with built-in <a href="http://static.springsource.org/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/switchuser/SwitchUserFilter.html"><code>SwitchUserFilter</code></a> that in principle mimics <code>su</code> in web applications. Let’s give it a try!<br /><br />All you need is declaring custom filter:<br /><br /><pre class="brush: xml">&lt;bean id="switchUserProcessingFilter"<br />       class="org.springframework.security.web.authentication.switchuser.SwitchUserFilter"&gt;<br />    &lt;property name="userDetailsService" ref="userDetailsService"/&gt;<br />    &lt;property name="targetUrl" value="/"/&gt;<br />&lt;/b:bean&gt;<br /></pre>and pointing to it in <code>&lt;http&gt;</code> configuration:<br /><a name='more'></a><br /><br /><pre class="brush: xml">&lt;http auto-config="true" use-expressions="true"&gt;<br />    &lt;custom-filter position="SWITCH_USER_FILTER" ref="switchUserProcessingFilter" /&gt;<br />    &lt;intercept-url pattern="/j_spring_security_switch_user" access="hasRole('ROLE_SUPERVISOR')"/&gt;<br />    ...<br /></pre>That’s it! Notice that I secure <code>/j_spring_security_switch_user</code> URL pattern. You guessed it, that’s how you log in as a different user, thus we want this resource to be well protected. By default <code>j_username</code> parameter name is used. After applying changes above to your web application and logging in with a user having <code>ROLE_SUPERVISOR</code> one can simply browse to:<br /><br /><pre class="brush: plain">/j_spring_security_switch_user?j_username=bob<br /></pre>And automagically you become logged in as <code>bob</code> - assuming there exists such a user. No password required here. When you are done impersonating him, browsing to <code>/j_spring_security_exit_user</code> will restore your previous credentials. Of course all these URLs are configurable. <code>SwitchUserFilter</code> is not documented in <a href="http://static.springsource.org/spring-security/site/docs/current/reference/springsecurity.html"><i>Reference Documentation</i></a> but it is a very useful tool when used with caution.<br /><br />Indeed <i>with great power…</i>. Giving even most trusted user ability to log in as any other arbitrary user sounds quite risky. Imagine such a feature on Facebook, impossible! (<a href="http://therumpus.net/2010/01/conversations-about-the-internet-5-anonymous-facebook-employee/?all=1">well…</a>) Thus tracking and auditing becomes a major requirement. <br /><br />What I typically do in the first place is adding a small servlet filter right after Spring Security filter that adds user name to <a href="http://logback.qos.ch/manual/mdc.html">MDC</a>:<br /><br /><pre class="brush: java">import org.slf4j.MDC;<br /><br />public class UserNameFilter implements Filter {<br /><br />    @Override<br />    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {<br />        final Authentication authentication = SecurityContextHolder.getContext().getAuthentication();<br />        final String userName = authentication.getName();<br />        final String realName = findSwitchedUser(authentication);<br />        final String fullName = userName + (realName != null ? " (" + realName + ")" : "");<br /><br />        MDC.put("user", fullName);<br />        try {<br />            chain.doFilter(request, response);<br />        } finally {<br />            MDC.remove("user");<br />        }<br />    }<br /><br />    private String findSwitchedUser(Authentication authentication) {<br />        for (GrantedAuthority auth : authentication.getAuthorities()) {<br />            if (auth instanceof SwitchUserGrantedAuthority) {<br />                return ((SwitchUserGrantedAuthority)auth).getSource().getName();<br />            }<br />        }<br />        return null;<br />    }<br /><br />    //...<br />}<br /></pre>Just remember to add it to <code>web.xml</code> <b>after</b> Spring Security. At this point you can reference <code>"user"</code> key e.g. in <code>logback.xml</code>:<br /><br /><pre class="brush: xml">&lt;pattern&gt;%d{HH:mm:ss.SSS} | %-5level | %X{user} | %thread | %logger{1} | %m%n%rEx&lt;/pattern&gt;<br /></pre>See the <code>%X{user}</code> snippet? Every time logged in user does something in the system that triggers log statement, you will see that users’ name:<br /><br /><pre class="brush: plain">21:56:55.074 | DEBUG | alice | http-bio-8080-exec-9 | ...<br />//...<br />21:56:57.314 | DEBUG | bob (alice) | http-bio-8080-exec-3 | ...<br /></pre>The second log statement is interesting. If you look at <code>findSwitchedUser()</code> call above it becomes obvious that <code>alice</code>, being a supervisor, switched to user <code>bob</code> and now browses on behalf of him.<br /><br />Sometimes you need even stronger auditing system. Luckily Spring framework has built-in event infrastructure and we can take advantage of <a href="http://static.springsource.org/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/switchuser/AuthenticationSwitchUserEvent.html"><code>AuthenticationSwitchUserEvent</code></a> sent both when someone switches user and exits this mode:<br /><br /><pre class="brush: java">@Service<br />public class SwitchUserListener <br />       implements ApplicationListener&lt;AuthenticationSwitchUserEvent&gt; {<br /><br />    private static final Logger log = LoggerFactory.getLogger(SwitchUserListener.class);<br /><br />    @Override<br />    public void onApplicationEvent(AuthenticationSwitchUserEvent event) {<br />        log.info("User switch from {} to {}",<br />                event.getAuthentication().getName(),<br />                event.getTargetUser().getUsername());<br />    }<br />}<br /></pre>Of course you can replace simple logging with any business logic you desire, e.g. storing such event in database or sending an e-mail to security officer.<br /><br /><hr />So we know how to log in as a different user for a period of time and then exit such mode. But what if we need “<code>sudo</code>”, that is making just one HTTP request on behalf of some other user? Of course we can switch to that user, run that request and then exit. But that seems too heavyweight and cumbersome. Such a requirement may pop up when client program accesses our API and wants to see data as another user (think about testing complex ACLs).<br /><br />Adding custom HTTP header to denote such a special impersonating request sounds reasonable. It works only for the duration of one request, assuming the client is already authenticating, e.g. using JSESSIONID cookie. Unfortunately this is not supported by Spring Security, but easy to implement on top of <code>SwitchUserFilter</code>:<br /><br /><pre class="brush: java">public class SwitchUserOnceFilter extends SwitchUserFilter {<br /><br />    @Override<br />    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {<br />        HttpServletRequest request = (HttpServletRequest) req;<br /><br />        final String switchUserHeader = request.getHeader("X-Switch-User-Once");<br />        if (switchUserHeader != null) {<br />            trySwitchingUserForThisRequest(chain, request, res, switchUserHeader);<br />        } else {<br />            super.doFilter(req, res, chain);<br />        }<br />    }<br /><br />    private void trySwitchingUserForThisRequest(FilterChain chain, HttpServletRequest request, ServletResponse response, String switchUserHeader) throws IOException, ServletException {<br />        try {<br />            proceedWithSwitchedUser(chain, request, response, switchUserHeader);<br />        } catch (AuthenticationException e) {<br />            throw Throwables.propagate(e);<br />        }<br />    }<br /><br />    private void proceedWithSwitchedUser(FilterChain chain, HttpServletRequest request, ServletResponse response, String switchUserHeader) throws IOException, ServletException {<br />        final Authentication targetUser = attemptSwitchUser(new SwitchUserRequest(request, switchUserHeader));<br />        SecurityContextHolder.getContext().setAuthentication(targetUser);<br /><br />        try {<br />            chain.doFilter(request, response);<br />        } finally {<br />            final Authentication originalUser = attemptExitUser(request);<br />            SecurityContextHolder.getContext().setAuthentication(originalUser);<br />        }<br /><br />    }<br /><br />}<br /></pre>The only difference from original <code>SwitchUserFilter</code> is that if <code>"X-Switch-User-Once"</code> is present, we switch credentials to user denoted by the value of this header - however only for the duration of one HTTP request. <code>SwitchUserFilter</code> assumes user name to switch to is under <code>j_username</code> parameter so I had to cheat a bit with <code>SwitchUserRequest</code> wrapper:<br /><br /><pre class="brush: java">private class SwitchUserRequest extends HttpServletRequestWrapper {<br /><br />    private final String switchUserHeader;<br /><br />    public SwitchUserRequest(HttpServletRequest request, String switchUserHeader) {<br />        super(request);<br />        this.switchUserHeader = switchUserHeader;<br />    }<br /><br />    @Override<br />    public String getParameter(String name) {<br />        switch (name) {<br />            case SPRING_SECURITY_SWITCH_USERNAME_KEY:<br />                return switchUserHeader;<br />            default:<br />                return super.getParameter(name);<br />        }<br />    }<br />}<br /></pre>And our custom “<code>sudo</code>” is in place! You can test it e.g. using <code>curl</code>:<br /><br /><pre class="brush: plain">$ curl localhost:8080/books/rest/book \<br />    -H "X-Switch-User-Once: bob" \<br />    -b "JSESSIONID=..."<br /></pre>Of course without <code>JSESSIONID</code> cookie the system would not let us in. We have to be logged in first and have special privileges to access <code>sudo</code> functionality.<br /><br />Switching user is a handy and quite powerful tool. If you want to try it in practice, check out <a href="https://github.com/nurkiewicz/books">working example on GitHub</a>.<br /><br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>