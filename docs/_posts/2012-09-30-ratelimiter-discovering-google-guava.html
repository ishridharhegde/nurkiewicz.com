---
layout: post
title: RateLimiter - discovering Google Guava
date: '2012-09-30T23:35:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- guava
- servlets
- performance
modified_time: '2012-10-03T09:40:15.809+02:00'
thumbnail: http://4.bp.blogspot.com/-L3bacaum5aQ/UGi6L9h8T2I/AAAAAAAAAmo/hCYTZ658hIA/s72-c/100_8169.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-9215184737593243408
blogger_orig_url: https://www.nurkiewicz.com/2012/09/ratelimiter-discovering-google-guava.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-L3bacaum5aQ/UGi6L9h8T2I/AAAAAAAAAmo/hCYTZ658hIA/s1600/100_8169.JPG" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://4.bp.blogspot.com/-L3bacaum5aQ/UGi6L9h8T2I/AAAAAAAAAmo/hCYTZ658hIA/s320/100_8169.JPG" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Bogstadvannet, golf course</td></tr></tbody></table><a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/RateLimiter.html"><code>RateLimiter</code></a> class was recently added to <a href="https://code.google.com/p/guava-libraries/">Guava libraries</a> (since 13.0) and it is already among my favourite tools. Have a look what the JavaDoc says:<br /><blockquote>[...] rate limiter distributes permits at a configurable rate. Each <code>acquire()</code> blocks if necessary until a permit is available [...] Rate limiters are often used to restrict the rate at which some physical or logical resource is accessed</blockquote>Basically this small utility class can be used e.g. to limit the number of requests per second your API wishes to handle or to throttle your own client code, avoiding <a href="http://en.wikipedia.org/wiki/Denial-of-service_attack">denial of service</a> of someone else's API if we are hitting it too often.<br />Let's start from a simple example. Say we have a long running process that needs to broadcast its progress to supplied listener:<br /><pre class="brush: scala">def longRunning(listener: Listener) {<br />    var processed = 0<br />    for(item &lt;- items) {<br />        //..do work...<br />        processed += 1<br />        listener.progressChanged(100.0 * processed / items.size)<br />    }<br />}<br /><br />trait Listener {<br />    def progressChanged(percentProgress: Double)<br />}<br /></pre>Please forgive me the imperative style of this Scala code, but that's not the point. The problem I want to highlight becomes obvious once we start our application with some concrete listener:<br /><a name='more'></a><br /><pre class="brush: scala">class ConsoleListener extends Listener {<br />    def progressChanged(percentProgress: Double) {<br />        println("Progress: " + percentProgress)<br />    }<br />}<br /><br />longRunning(new ConsoleListener)<br /></pre>Imagine that <code>longRunning()</code> method processes millions of <code>items</code> but each iteration takes just a split of a second. The amount of logging messages is just insane, not to mention console output is probably taking much more time than processing itself. You've probably faced such a problem several times and have a simple workaround:<br /><pre class="brush: scala">if(processed % 100 == 0) {<br />    listener.progressChanged(100.0 * processed / items.size)<br />}<br /></pre><i>There, I Fixed It!</i> We only print progress every 100th iteration. However this approach has several drawbacks:<br /><ul><li>code is polluted with unrelated logic</li><li>there is no guarantee that every 100th iteration is slow enough...</li><li>... or maybe it's too slow?</li></ul>What we really want to achieve is to limit the frequency of progress updates (say: two times per second). OK, going deeper into the rabbit hole:<br /><pre class="brush: scala">def longRunning(listener: Listener) {<br />    var processed = 0<br />    var lastUpdateTimestamp = 0L<br />    for(item &lt;- items) {<br />        //..do work...<br />        processed += 1<br />        if(System.currentTimeMillis() - lastUpdateTimestamp &gt; 500) {<br />            listener.progressChanged(100.0 * processed / items.size)<br />            lastUpdateTimestamp = System.currentTimeMillis()<br />        }<br />    }<br />}<br /></pre>Do you also have a feeling that we are going in the wrong direction? Ladies and gentlemen, I give you <code>RateLimiter</code>:<br /><pre class="brush: scala">var processed = 0<br />val limiter = RateLimiter.create(2)<br />for (item &lt;- items) {<br />    //..do work...<br />    processed += 1<br />    if (limiter.tryAcquire()) {<br />        listener.progressChanged(100.0 * processed / items.size)<br />    }<br />}<br /></pre>Getting better? If the API is not clear: we are first creating a <code>RateLimiter</code> with 2 permits per second. This means we can <i>acquire</i> up to two permits during one second and if we try to do it more often <code>tryAcquire()</code> will return <code>false</code> (or thread will block if <code>acquire()</code> is used instead<sup>1</sup>). So the code above guarantees that the listener won't be called more that two times per second.<br />As a bonus, if you want to completely get rid of unrelated throttling code from the business logic, <a href="http://en.wikipedia.org/wiki/Decorator_pattern"><i>decorator</i> pattern</a> to the rescue. First let's create a listener that wraps another (concrete) listener and delegates to it only at a given rate:<br /><pre class="brush: scala">class RateLimitedListener(target: Listener) extends Listener {<br /><br />    val limiter = RateLimiter.create(2)<br /><br />    def progressChanged(percentProgress: Double) {<br />        if (limiter.tryAcquire()) {<br />            target.progressChanged(percentProgress)<br />        }<br />    }<br />}<br /></pre>What's best about the <i>decorator</i> pattern is that both the code using the listener and the concrete implementation are not aware of the decorator. Also the client code became much simpler (essentially we came back to original):<br /><pre class="brush: scala">def longRunning(listener: Listener) {<br />    var processed = 0<br />    for (item &lt;- items) {<br />        //..do work...<br />        processed += 1<br />        listener.progressChanged(100.0 * processed / items.size)<br />    }<br />}<br /><br />longRunning(new RateLimitedListener(new ConsoleListener))<br /></pre>But we've only scratched the surface of where <code>RateLimiter</code> can be used! Say we want to avoid aforementioned denial of service attack or slow down automated clients of our API. It's very simple with <code>RateLimiter</code> and servlet filter:<br /><pre class="brush: scala">@WebFilter(urlPatterns=Array("/*"))<br />class RateLimiterFilter extends Filter {<br /><br />    val limiter = RateLimiter.create(100)<br /><br />    def init(filterConfig: FilterConfig) {}<br /><br />    def doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {<br />        if(limiter.tryAcquire()) {<br />            chain.doFilter(request, response)<br />        } else {<br />            response.asInstanceOf[HttpServletResponse].sendError(SC_TOO_MANY_REQUESTS)<br />        }<br />    }<br /><br />    def destroy() {}<br />}<br /></pre>Another self-descriptive sample. This time we limit our API to handle not more than 100 requests per second (of course <code>RateLimiter</code> is thread safe). All HTTP requests that come through our filter are subject to rate limiting. If we cannot handle incoming request, we send <a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429">HTTP 429 - Too Many Requests </a> error code (not yet available in servlet spec). Alternatively you may wish to block the client for a while instead of eagerly rejecting it. That's fairly straightforward as well:<br /><pre class="brush: scala">def doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {<br />    limiter.acquire()<br />    chain.doFilter(request, response)<br />}<br /></pre><code>limiter.acquire()</code> will block as long as it's needed to keep desired 100 requests per second limit. Yet another alternative is to use <code>tryAcquire()</code> with timeout (blocking up to given amount of time). Blocking approach is better if you want to avoid sending errors to the client. However under high load it's easy to imagine almost all HTTP threads blocked waiting for <code>RateLimiter</code>, eventually causing servlet container to reject connections. So dropping of clients can be only partially avoided.<br />This filter is a good starting point to build more sophisticated solutions. Map of rate limiters by IP or user name are good examples.<br /><hr />What we haven't covered yet is acquiring more than one permit at a time. It turns out <code>RateLimiter</code> can also be used e.g. to limit network bandwidth or the amount of data being sent/received. Imagine you create a search servlet and you want to impose that no more than 1000 results are returned per second. In each request user decides how many results she wants to receive per response: it can be 500 requests each containing 2 results or 1 huge request asking for 1000 results at once. But never more than 1000 results within a second on average. Users are free to use their quota as they wish:<br /><pre class="brush: scala">@WebFilter(urlPatterns = Array ("/search"))<br />class SearchServlet extends HttpServlet {<br /><br />    val limiter = RateLimiter.create(1000)<br /><br />    override def doGet(req: HttpServletRequest, resp: HttpServletResponse) {<br />        val resultsCount = req.getParameter("results").toInt<br />        limiter.acquire(resultsCount)<br />        //process and return results...<br />    }<br />}<br /></pre>By default we <code>acquire()</code> one permit per invocation. Non-blocking servlet would call <code>limiter.tryAcquire(resultsCount)</code> and check the results, you know that by now. If you are interested in rate limiting of network traffic, don't forget to check out my <a href="http://nurkiewicz.blogspot.no/2011/03/tenfold-increase-in-server-throughput.html"><i>Tenfold increase in server throughput with Servlet 3.0 asynchronous processing</i></a>. <code>RateLimiter</code>, due to a blocking nature, is not very well suited to write scalable upload/download servers with throttling.<br /><hr />The last example I would like to share with you is throttling client code to avoid overloading the server we are talking to. Imagine a batch import/export process that calls some server thousands of times exchanging data. If we don't throttle the client and there is no rate limiting on the server side, server might get overloaded and crash. <code>RateLimiter</code> is once again very helpful:<br /><pre class="brush: scala">val limiter = RateLimiter.create(20)<br /><br />def longRunning() {<br />    for (item &lt;- items) {<br />        limiter.acquire()<br />        server.sync(item)<br />    }<br />}<br /></pre>This sample is very similar to the first one. Difference being that this time we block instead of discard missing permits. Thanks to blocking, external call to <code>server.sync(item)</code> won't overload the 3rd-party server, calling it at most 20 times per second. Of course if you have several threads interacting with the server, they can all share the same <code>RateLimiter</code>.<br /><hr />To wrap-up:<br /><ul><li><code>RateLimiter</code> allows you to perform certain actions not more often than with a given frequency</li><li>It's a small and lightweight class (no threads involved!) You can create thousands of rate limiters (per client?) or share one among several threads</li><li>We haven't covered <i>warm-up</i> functionality - if <code>RateLimiter</code> was completely idle for a long time, it will gradually increase allowed frequency over configured time up to configured maximum value instead of allowing maximum frequency from the very beginning</li></ul>I have a feeling that we'll go back to this class soon. I hope you'll find it useful in your next project!<br /><br /><sup>1</sup> - I am using Guava 14.0-SNAPSHOT. If 14.0 stable is not available by the time you are reading this, you must use more verbose <code>tryAcquire(1, 0, TimeUnit.MICROSECONDS)</code> instead of <code>tryAcquire()</code> and <code>acquire(1)</code> instead of <code>acquire()</code>.