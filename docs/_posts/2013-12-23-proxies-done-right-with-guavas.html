---
layout: post
title: Proxies done right with Guava's AbstractInvocationHandler
date: '2013-12-23T18:50:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- guava
- multithreading
- design patterns
modified_time: '2013-12-23T18:53:15.901+01:00'
thumbnail: http://2.bp.blogspot.com/-0YiGnMfVweI/Urh3kosNA5I/AAAAAAAAA5I/iopLTOLdqAI/s72-c/snaroya-4.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3034681858777650450
blogger_orig_url: https://www.nurkiewicz.com/2013/12/proxies-done-right-with-guavas.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-0YiGnMfVweI/Urh3kosNA5I/AAAAAAAAA5I/iopLTOLdqAI/s1600/snaroya-4.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-0YiGnMfVweI/Urh3kosNA5I/AAAAAAAAA5I/iopLTOLdqAI/s1600/snaroya-4.jpg" height="149" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Snar√∏ya</td></tr></tbody></table>Not too often but sometimes we are forced to write custom <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/reflection/proxy.html">dynamic proxy class</a> using <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html"><code>java.lang.reflect.Proxy</code></a>. There is really no magic in this mechanism and it's worth knowing even you will never really use it - because Java proxies are ubiquitous in various frameworks and libraries.<br /><br />The idea is quite simple: dynamically create an object that implements one or more interfaces but every time any method of these interfaces is called our custom callback handler is invoked. This handler receives a handle to a method that was called (<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Method.html"><code>java.lang.reflect.Method</code></a> instance) and is free to behave in any way. Proxies are often used to implement seamless mocking, caching, transactions, security - i.e. they are a foundation for AOP.<br /><br />Before I explain what the purpose of <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/reflect/AbstractInvocationHandler.html"><code>com.google.common.reflect.AbstractInvocationHandler</code></a> from the title, let's start from a simple example. Say we want to transparently run methods of given interface asynchronously in a thread pool. Popular stacks like Spring (see: <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html#scheduling-annotation-support-async"><code>27.4.3 The @Async Annotation</code></a>) and Java EE (see: <a href="http://docs.oracle.com/javaee/6/tutorial/doc/gkkqg.html"><code>Asynchronous Method Invocation</code></a>) already support this using the same technique.<br /><br />Imagine we have the following service:<br /><br /><pre class="brush: java">public interface MailServer {<br />    void send(String msg);<br />    int unreadCount();<br />}<br /></pre>Our goal is to run <code>send()</code> asynchronously so that several subsequent invocations are not blocking but queue up and are executed in external thread pool concurrently rather than in calling thread. First we need factory code that will create a proxy instance:<br /><br /><pre class="brush: java">public class  AsyncProxy {<br />    public static &lt;T&gt; T wrap(T underlying, ExecutorService pool) {<br />        final ClassLoader classLoader = underlying.getClass().getClassLoader();<br />        final Class&lt;T&gt; intf = (Class&lt;T&gt;) underlying.getClass().getInterfaces()[0];<br />        return (T)Proxy.newProxyInstance(<br />            classLoader, <br />            new Class&lt;?&gt;[] {intf}, <br />            new AsyncHandler&lt;T&gt;(underlying, pool));<br />    }<br />}<br /></pre>Code above makes few bold assumptions, for example that an <code>underlying</code> object (real instance that we are proxying) implements exactly one interface. In real life a class can of course implement multiple interfaces, so can proxies - but we simplify this a bit for educational purposes. Now for starters we shall create no-op proxy that delegates to underlying object without any added value:<br /><br /><pre class="brush: java">class AsyncHandler&lt;T&gt; implements InvocationHandler {<br /><br />    private static final Logger log = LoggerFactory.getLogger(AsyncHandler.class);<br /><br />    private final T underlying;<br />    private final ExecutorService pool;<br /><br />    AsyncHandler1(T underlying, ExecutorService pool) {<br />        this.underlying = underlying;<br />        this.pool = pool;<br />    }<br /><br />    @Override<br />    public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {<br />        return method.invoke(underlying, args);<br />    }<br /><br />}<br /></pre><code>ExecutorService pool</code> will be used later. The last line is crucial - we invoke <code>method</code> on <code>underlying</code> instance with the same <code>args</code>. At this point we can:<br /><br /><ul><li>invoke <code>underlying</code> or not (e.g. if given call is cached/memoized)</li><li>change arguments (i.e. for security purposes)</li><li>run code before/after/around/on exception</li><li>alter result by returning different value (it must match the type of <code>method.getReturnType()</code>)</li><li>...and much more</li></ul>In our case we will wrap <code>method.invoke()</code> with <code>Callable</code> and run it asynchronously:<br /><br /><pre class="brush: java">class AsyncHandler&lt;T&gt; implements InvocationHandler {<br /><br />    private final T underlying;<br />    private final ExecutorService pool;<br /><br />    AsyncHandler(T underlying, ExecutorService pool) {<br />        this.underlying = underlying;<br />        this.pool = pool;<br />    }<br /><br />    @Override<br />    public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {<br />        final Future&lt;Object&gt; future = pool.submit(new Callable&lt;Object&gt;() {<br />            @Override<br />            public Object call() throws Exception {<br />                return method.invoke(underlying, args);<br />            }<br />        });<br />        return handleResult(method, future);<br />    }<br /><br />    private Object handleResult(Method method, Future&lt;Object&gt; future) throws Throwable {<br />        if (method.getReturnType() == void.class)<br />            return null;<br />        try {<br />            return future.get();<br />        } catch (ExecutionException e) {<br />            throw e.getCause();<br />        }<br />    }<br />}<br /></pre>Extra <code>handleResult()</code> method was extracted in order to properly handle non-<code>void</code> methods. Using such a proxy is straightforward:<br /><br /><pre class="brush: java">final MailServer mailServer = new RealMailServer();<br /><br />final ExecutorService pool = Executors.newFixedThreadPool(10);<br />final MailServer asyncMailServer = AsyncProxy.wrap(mailServer, pool);<br /></pre>Now even if <code>RealMailServer.send()</code> takes a second to complete, invoking it twice via <code>asyncMailServer.send()</code> takes no time because both invocations run asynchronously in background.<br /><br /><h2>Broken <code>equals()</code>, <code>hashCode()</code> and <code>toString()</code></h2>Some developers are not aware of potential issues with default <code>InvocationHandler</code> implementation. Quoting the <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/reflection/proxy.html">official documentation</a>:<br /><br /><blockquote>An invocation of the <code>hashCode</code>, <code>equals</code>, or <code>toString</code> methods declared in <code>java.lang.Object</code> on a proxy instance will be encoded and dispatched to the invocation handler's <code>invoke</code> method in the same manner as interface method invocations are encoded and dispatched, as described above.<br /><br /></blockquote>In our case case this means that for example <code>toString()</code> is executed in the same thread pool as other methods of <code>MailServer</code>, quite surprising. Now imagine you have a local proxy where every method invocation triggers remote call. Dispatching <code>equals()</code>, <code>hashCode()</code> and <code>toString()</code> via network is definitely not what we want.<br /><br /><h2>Fixing with <code>AbstractInvocationHandler</code></h2><a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/reflect/AbstractInvocationHandler.html"><code>AbstractInvocationHandler</code></a> from Guava is a simple abstract class that correctly deals with issues above. By default it dispatches <code>equals()</code>, <code>hashCode()</code> and <code>toString()</code> to <code>Object</code> class rather than passing it to invocation handler. Refactoring from straight <code>InvocationHandler</code> to <code>AbstractInvocationHandler</code> is dead simple:<br /><br /><pre class="brush: java">import com.google.common.reflect.AbstractInvocationHandler;<br /><br />class AsyncHandler&lt;T&gt; extends AbstractInvocationHandler {<br /><br />    //...<br /><br />    @Override<br />    protected Object handleInvocation(Object proxy, final Method method, final Object[] args) throws Throwable {<br />        //...<br />    }<br /><br />    @Override<br />    public String toString() {<br />        return "Proxy of " + underlying;<br />    }<br />}<br /></pre>That's it! I decided to override <code>toString()</code> to help debugging. <code>equals()</code> and <code>hashCode()</code> are inherited from <code>Object</code> which is fine for the beginning. Now please look around your code base and search for custom proxies. If you were not using <code>AbstractInvocationHandler</code> or similar so far, chances are you introduces few subtle bugs.  <script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>