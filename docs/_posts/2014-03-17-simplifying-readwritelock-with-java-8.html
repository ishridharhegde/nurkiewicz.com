---
layout: post
title: Simplifying ReadWriteLock with Java 8 and lambdas
date: '2014-03-17T21:14:00.003+01:00'
author: Tomasz Nurkiewicz
tags:
- multithreading
- java 8
modified_time: '2014-04-22T23:07:28.455+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7481489635743481353
blogger_orig_url: https://www.nurkiewicz.com/2014/03/simplifying-readwritelock-with-java-8.html
---

Considering legacy Java code, no matter where you look, Java 8 with lambda expressions can definitely improve quality and readability. Today let us look at <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReadWriteLock.html"><code>ReadWriteLock</code></a> and how we can make using it simpler. Suppose we have a class called <code>Buffer</code> that remembers last couple of messages in a queue, counting and discarding old ones. The implementation is quite straightforward:<br /><br /><pre class="brush: java">public class Buffer {<br /><br />    private final int capacity;<br />    private final Deque&lt;String&gt; recent;<br />    private int discarded;<br /><br />    public Buffer(int capacity) {<br />        this.capacity = capacity;<br />        this.recent = new ArrayDeque&lt;&gt;(capacity);<br />    }<br /><br />    public void putItem(String item) {<br />        while (recent.size() &gt;= capacity) {<br />            recent.removeFirst();<br />            ++discarded;<br />        }<br />        recent.addLast(item);<br />    }<br /><br />    public List&lt;String&gt; getRecent() {<br />        final ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();<br />        result.addAll(recent);<br />        return result;<br />    }<br /><br />    public int getDiscardedCount() {<br />        return discarded;<br />    }<br /><br />    public int getTotal() {<br />        return discarded + recent.size();<br />    }<br /><br />    public void flush() {<br />        discarded += recent.size();<br />        recent.clear();<br />    }<br /><br />}<br /></pre>Now we can <code>putItem()</code> many times, but the internal <code>recent</code> queue will only keep last <code>capacity</code> elements. However it also remembers how many items it had to discard to avoid memory leak. This class works fine, but only in single-threaded environment. We use not thread-safe <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html"><code>ArrayDeque</code></a> and non-synchronized <code>int</code>. While reading and writing to <code>int</code> is atomic, changes are not guaranteed to be visible in different threads. Also even if we use <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingDeque.html">thread safe <code>BlockingDeque</code></a> together with <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicInteger.html"><code>AtomicInteger</code></a> we are still in danger of race condition because those two variables aren't synchronized with each other.<br /><br />One approach would be to <a href="http://memegenerator.net/instance/47255837"><code>synchronize</code> all the methods</a>, but that seems quite restrictive. Moreover we suspect that reads greatly outnumber writes. In such cases <code>ReadWriteLock</code> is a fantastic alternative. It actually consists of two locks - one for reading and one for writing. In reality they both compete for the same lock which can be obtained either by one writer or multiple readers at the same time. So we can have concurrent reads when no one is writing and only occasionally writer blocks all readers. Using <code>synchronized</code> will just always block all the others, no matter what they do. The sad part of <code>ReadWriteLock</code> is that it introduces a lot of boilerplate. You have to explicitly open a lock and remember to <code>unlock()</code> it in <code>finally</code> block. Our implementation becomes hard to read:<br /><br /><pre class="brush: java">public class Buffer {<br /><br />    private final int capacity;<br />    private final Deque&lt;String&gt; recent;<br />    private int discarded;<br /><br />    private final Lock readLock;<br />    private final Lock writeLock;<br /><br /><br />    public Buffer(int capacity) {<br />        this.capacity = capacity;<br />        recent = new ArrayDeque&lt;&gt;(capacity);<br />        final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();<br />        readLock = rwLock.readLock();<br />        writeLock = rwLock.writeLock();<br />    }<br /><br />    public void putItem(String item) {<br />        writeLock.lock();<br />        try {<br />            while (recent.size() &gt;= capacity) {<br />                recent.removeFirst();<br />                ++discarded;<br />            }<br />            recent.addLast(item);<br />        } finally {<br />            writeLock.unlock();<br />        }<br />    }<br /><br />    public List&lt;String&gt; getRecent() {<br />        readLock.lock();<br />        try {<br />            final ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();<br />            result.addAll(recent);<br />            return result;<br />        } finally {<br />            readLock.unlock();<br />}<br /><br />    public int getDiscardedCount() {<br />        readLock.lock();<br />        try {<br />            return discarded;<br />        } finally {<br />            readLock.unlock();<br />        }<br />    }<br /><br />    public int getTotal() {<br />        readLock.lock();<br />        try {<br />            return discarded + recent.size();<br />        } finally {<br />            readLock.unlock();<br />        }<br />    }<br /><br />    public void flush() {<br />        writeLock.lock();<br />        try {<br />            discarded += recent.size();<br />            recent.clear();<br />        } finally {<br />            writeLock.unlock();<br />        }<br />    }<br /><br />}  <br />        </pre>This is how it was done pre-Jave 8. Effective, safe and... ugly. However with lambda expressions we can wrap cross-cutting concerns in a utility class like this:<br /><br /><pre class="brush: java">public class FunctionalReadWriteLock {<br /><br />    private final Lock readLock;<br />    private final Lock writeLock;<br /><br />    public FunctionalReadWriteLock() {<br />        this(new ReentrantReadWriteLock());<br />    }<br /><br />    public FunctionalReadWriteLock(ReadWriteLock lock) {<br />        readLock = lock.readLock();<br />        writeLock = lock.writeLock();<br />    }<br /><br />    public &lt;T&gt; T read(Supplier&lt;T&gt; block) {<br />        readLock.lock();<br />        try {<br />            return block.get();<br />        } finally {<br />            readLock.unlock();<br />        }<br />    }<br /><br />    public void read(Runnable block) {<br />        readLock.lock();<br />        try {<br />            block.run();<br />        } finally {<br />            readLock.unlock();<br />        }<br />    }<br /><br />    public &lt;T&gt; T write(Supplier&lt;T&gt; block) {<br />        writeLock.lock();<br />        try {<br />            return block.get();<br />        } finally {<br />            writeLock.unlock();<br />        }</pre><pre class="brush: java"><pre class="brush: java">    }</pre>public void write(Runnable block) {         writeLock.lock();         try {             block.run();         } finally {             writeLock.unlock();         }     }  }     </pre>As you can see we wrap <code>ReadWriteLock</code> and provide a set of utility methods to work with. In principle we would like to pass a <code>Runnable</code> or <code>Supplier&lt;T&gt;</code> (interface having single <code>T get()</code> method) and make sure calling it is surrounded with proper lock. We could write the exact same wrapper class without lambdas, but having them greatly simplifies client code:<br /><br /><pre class="brush: java">public class Buffer {<br /><br />    private final int capacity;<br />    private final Deque&lt;String&gt; recent;<br />    private int discarded;<br /><br />    private final FunctionalReadWriteLock guard;<br /><br />    public Buffer(int capacity) {<br />        this.capacity = capacity;<br />        recent = new ArrayDeque&lt;&gt;(capacity);<br />        guard = new FunctionalReadWriteLock();<br />    }<br /><br />    public void putItem(String item) {<br />        guard.write(() -&gt; {<br />            while (recent.size() &gt;= capacity) {<br />                recent.removeFirst();<br />                ++discarded;<br />            }<br />            recent.addLast(item);<br />        });<br />    }<br /><br />    public List&lt;String&gt; getRecent() {<br />        return guard.read(() -&gt; {<br />            return recent.stream().collect(toList());<br />        });<br />    }<br /><br />    public int getDiscardedCount() {<br />        return guard.read(() -&gt; discarded);<br />    }<br /><br />    public int getTotal() {<br />        return guard.read(() -&gt; discarded + recent.size());<br />    }<br /><br />    public void flush() {<br />        guard.write(() -&gt; {<br />            discarded += recent.size();<br />            recent.clear();<br />        });<br />    }<br /><br />}<br /></pre>See how we invoke <code>guard.read()</code> and <code>guard.write()</code> passing pieces of code that should be guarded? Looks quite neat. BTW have you noticed how we can turn any collection into any other collection (here: <code>Deque</code> into <code>List</code>) using <code>stream()</code>? Now if we extract couple of internal methods we can use method references to even further simplify lambdas:<br /><br /><pre class="brush: java">public void flush() {<br />    guard.write(this::unsafeFlush);<br />}<br /><br />private void unsafeFlush() {<br />    discarded += recent.size();<br />    recent.clear();<br />}<br /><br />public List&lt;String&gt; getRecent() {<br />    return guard.read(this::defensiveCopyOfRecent);<br />}<br /><br />private List&lt;String&gt; defensiveCopyOfRecent() {<br />    return recent.stream().collect(toList());<br />}<br /></pre>This is just one of the many ways you can improve existing code and libraries by taking advantage of lambda expressions. We should be really happy that they finally made their way into Java language - while being already present in dozens of other JVM languages.<br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>