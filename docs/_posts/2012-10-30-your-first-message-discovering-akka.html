---
layout: post
title: Your first message - discovering Akka
date: '2012-10-30T00:02:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- akka
- scala
modified_time: '2012-11-05T19:35:46.879+01:00'
thumbnail: http://2.bp.blogspot.com/-PDV9COH3rgc/UI8KRFlG3mI/AAAAAAAAAo0/Ec6pMl7fazM/s72-c/100_8238.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-9180899552551171222
blogger_orig_url: https://www.nurkiewicz.com/2012/10/your-first-message-discovering-akka.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-PDV9COH3rgc/UI8KRFlG3mI/AAAAAAAAAo0/Ec6pMl7fazM/s1600/100_8238.JPG" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://2.bp.blogspot.com/-PDV9COH3rgc/UI8KRFlG3mI/AAAAAAAAAo0/Ec6pMl7fazM/s320/100_8238.JPG" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Holmenkollen seen from Grefsenkollen</td></tr></tbody></table><a href="http://akka.io/">Akka</a> is a platform (framework?) inspired by Erlang, promising easier development of scalable, multi-threaded and safe applications. While in most of the popular languages concurrency is based on memory shared between several threads, guarded by various synchronization mehods, Akka offers concurrency model based on actors. Actor is a lightweight object which you can interact with barely by sending messages to it. Each actor can process at most one message at a time and obviously can send messages to other actors. Within one Java virtual machine millions of actors can exist at the same time, building a hierarchical parent (<i>supervisor</i>) - children structure, where parent monitors the behaviour of children. If that's not enough, we can easily split our actors between several nodes in a cluster - without modifying a single line of code. Each actor can have internal state (set of fields/variables), but communication can only occur through message passing, never through shared data structures (counters, queues).<br /><br />A combination of the features above lead to a much safer, more stable and scalable code - for the price of a radical paradigm shift in concurrent programming model. So many buzzwords and promises, let's go forward with an example. And it's not going to be a "<i>Hello, world</i>" example, but we are going to try to build a small, but complete solution. In the next few articles we will implement integration with <a href="http://www.random.org/clients/http/">random.org API</a>. This web service allows us to fetch truly random numbers (as opposed to pseudo random generators) based on <i>atmospheric noise</i> (whatever that means). API isn't really that complicated, please visit the following website and refresh it couple times:<br /><br /><a href="https://www.random.org/integers/?num=20&amp;min=1000&amp;max=10000&amp;col=1&amp;base=10&amp;format=plain">https://www.random.org/integers/?num=20&amp;min=1000&amp;max=10000&amp;col=1&amp;base=10&amp;format=plain</a><br /><br />So where is the difficulty? Reading <a href="http://www.random.org/clients/">guidelines for automated clients</a> we learn that:<br /><a name='more'></a><br /><br /><ol><li>The client application should call the URL above at most from one thread - it's forbidden to concurrently fetch random numbers using several HTTP connections.<br /><br /> </li><li>We should load random numbers in batches, not one by one in every request. The request above takes <code>num=20</code> numbers in one call.<br /><br /> </li><li>We are warned about latency, response may arrive even after one minute<br /><br /> </li><li>The client should periodically check random number quota (the service is free only up to a given number of random bits per day)<br /><br /> </li></ol>All these requirements make integration with <code>random.org</code> non-trivial. In this series I have just begun we will gradually improve our application, learning new Akka features step by step. We will soon realize that quite steep learning curve pays of quickly once we understand the basic concepts of the platform. So, let's code!<br /><br />Today we will try to handle first two requirements, that is not more than one connection at any given point in time and loading numbers in batches. For this step we don't really need Akka, simple synchronization and a buffer is just about enough:<br /><br /><pre class="brush: scala">val buffer = new Queue[Int]<br /><br />def nextRandom(): Int = {<br />  this.synchronized {<br />    if(buffer.isEmpty) {<br />      buffer ++= fetchRandomNumbers(50)<br />    }<br />    buffer.dequeue()<br />  }<br />}<br /><br />def fetchRandomNumbers(count: Int) = {<br />  val url = new URL("https://www.random.org/integers/?num=" + count + "&amp;min=0&amp;max=65535&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new")<br />  val connection = url.openConnection()<br />  val stream = Source.fromInputStream(connection.getInputStream)<br />  val randomNumbers = stream.getLines().map(_.toInt).toList<br />  stream.close()<br />  randomNumbers<br />}<br /></pre>This code works and is equivalent to the <code>synchronized</code> keyword in Java. The way <code>nextRandom()</code> works should be obvious: if the buffer is empty, fill it with 50 random numbers fetched from the server. At the end take and return the first value from the buffer. This code has several disadvantages, starting from the <code>synchronized</code> block on the first place. Rather costly synchronization for each and every call seems like an overkill. And we aren't even in the cluster yet, where we would have to maintain one active connection per whole cluster, not only withing one JVM!<br /><br />We shall begin with implementing one actor. Actor is basically a class extending <code>Actor</code> trait and implementing <code>receive</code> method. This method is responsible for receiving and handling one message. Let's reiterate what we already said: each and every actor can handle at most one message at a time, thus <code>receive</code> method is <b>never</b> called concurrently. If the actor is already handling some message, the remaining messages are kept in a queue dedicated to each actor. Thanks to this rigorous rule, we can avoid <i>any</i> synchronization inside actor, which is always thread-safe.<br /><br /><pre class="brush: scala">case object RandomRequest<br /><br />class RandomOrgBuffer extends Actor {<br /><br />  val buffer = new Queue[Int]<br /><br />  def receive = {<br />    case RandomRequest =&gt;<br />      if(buffer.isEmpty) {<br />        buffer ++= fetchRandomNumbers(50)<br />      }<br />      println(buffer.dequeue())<br />  }<br /><br />}<br /></pre><code>fetchRandomNumbers()</code> method remains the same. Single-threaded access to <code>random.org</code> was achieved for free, since actor can only handle one message at a time. Speaking of messages, in this case <code>RandomRequest</code> is our message - empty object not conveying any information except its type. In Akka messages are almost always implemented using case classes or other immutable types. Thus, if we would like to support fetching arbitrary number of random numbers, we would have to include that as part of the message:<br /><br /><pre class="brush: scala">case class RandomRequest(howMany: Int)<br /><br />class RandomOrgBuffer extends Actor with ActorLogging {<br /><br />  val buffer = new Queue[Int]<br /><br />  def receive = {<br />    case RandomRequest(howMany) =&gt;<br />      if(buffer.isEmpty) {<br />        buffer ++= fetchRandomNumbers(50)<br />      }<br />      for(_ &lt;- 1 to (howMany min 50)) {<br />        println(buffer.dequeue())<br />      }<br />  }<br /></pre>Now we should try to send some message to our brand new actor. Obviously we cannot just call <code>receive</code> method passing message as an argument. First we have to start the Akka platform and ask for an actor reference. This reference is later used to send a message using slightly counter-intuitive at first <code>!</code> method, dating back to Erlang days:<br /><br /><pre class="brush: scala">object Bootstrap extends App {<br />  val system = ActorSystem("RandomOrgSystem")<br />  val randomOrgBuffer = system.actorOf(Props[RandomOrgBuffer], "buffer")<br /><br />  randomOrgBuffer ! RandomRequest(10)  //sending a message<br /><br />  system.shutdown()<br />}<br /></pre>After running the program we should see 10 random numbers on the console. Experiment a little bit with that simple application (full source code is <a href="https://github.com/nurkiewicz/learning-akka">available on GitHub</a>, <a href="https://github.com/nurkiewicz/learning-akka/commit/24b2f2ced653fadc391fbe50769b2b69e1b9a597"><code>request-response</code> tag</a>). In particular notice that sending a message is non-blocking and the message itself is handled in a different thread (big analogy to JMS). Try sending a message of different type and fix <code>receive</code> method so that it can handle more than one type.<br /><br />Our application is not very useful by now. We would like to access our random numbers somehow rather than printing them (asynchronously!) to standard output. As you can probably guess, since communication with an actor can only be established via asynchronous message passing (actor cannot "<i>return</i>" result, neither it shouldn't place it in any global, shared memory). Thus an actor will send the results back via reply message sent directly to us (to sender). But that will be part of the next article.<br /><br /><blockquote>This was a translation of my article <a href="http://scala.net.pl/poznajemy-akka-pierwszy-komunikat/">"<i>Poznajemy Akka: pierwszy komunikat</i>"</a> originally published on <a href="http://scala.net.pl/">scala.net.pl</a>.</blockquote>