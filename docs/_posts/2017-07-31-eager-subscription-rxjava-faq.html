---
layout: post
title: Eager subscription - RxJava FAQ
date: '2017-07-31T20:22:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- rxjava
modified_time: '2017-07-31T21:06:44.103+02:00'
thumbnail: https://3.bp.blogspot.com/-6T2p36k8o2c/WX9_c-KjltI/AAAAAAAAD9E/GgmkQK5Zczg-fKvkLw-dmPGEgAtj-iZ-gCLcBGAs/s72-c/2015-11-29%2B10.57.48.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-6661917617402010710
blogger_orig_url: https://www.nurkiewicz.com/2017/07/eager-subscription-rxjava-faq.html
---

<div class="separator" style="clear: both; text-align: center;"><br /></div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-6T2p36k8o2c/WX9_c-KjltI/AAAAAAAAD9E/GgmkQK5Zczg-fKvkLw-dmPGEgAtj-iZ-gCLcBGAs/s1600/2015-11-29%2B10.57.48.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="900" data-original-width="1600" height="112" src="https://3.bp.blogspot.com/-6T2p36k8o2c/WX9_c-KjltI/AAAAAAAAD9E/GgmkQK5Zczg-fKvkLw-dmPGEgAtj-iZ-gCLcBGAs/s200/2015-11-29%2B10.57.48.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Warsaw center from&nbsp;Park Szczęśliwicki</td></tr></tbody></table>While teaching and mentoring RxJava, as well as after <a href="http://shop.oreilly.com/product/0636920042228.do">authoring a book</a>, I noticed some areas are especially problematic. I decided to publish a bunch of short tips that address most common pitfalls. This is the first part.<br /><code>Observable</code>s and <code>Flowable</code>s are lazy by nature. This means no matter how heavy or long-running logic you place inside your <code>Flowable</code>, it will get evaluated only when someone subscribes. And also as many times as someone subscribes. This is illustrated by the following code snippet:<br /><br /><pre class="brush: java">private static String slow() throws InterruptedException {<br />    logger.info("Running");<br />    TimeUnit.SECONDS.sleep(1);<br />    return "abc";<br />}<br /><br />//...<br /><br />Flowable&lt;String&gt; flo = Flowable.fromCallable(this::slow);<br />logger.info("Created");<br />flo.subscribe();<br />flo.subscribe();<br />logger.info("Done");</pre>Such <code>Observable</code> or <code>Flowable</code> will inevitably print:<br /><br /><pre class="brush: java">19:37:57.368 [main] - Created<br />19:37:57.379 [main] - Running<br />19:37:58.383 [main] - Running<br />19:37:59.388 [main] - Done</pre>Notice that you pay the price of <code>sleep()</code> twice (double subscription). Moreover all logic runs in client (<code>main</code>) thread, there is no implicit threading in RxJava unless requested with <code>subscribeOn()</code> or implicitly available with asynchronous streams. The question is: can we force running subscription logic eagerly so that whenever someone subscribes the stream is already precomputed or at least the computation started?<br /><br /><h2 id="totally-eager-evaluation">Totally eager evaluation</h2>The most obvious, but flawed solution is to eagerly compute whatever the stream returns and simply wrap it with a fixed <code>Flowable</code>:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; eager() {<br />    final String slow = slow();<br />    return Flowable.just(slow);<br />}</pre>Unfortunately this substantially defeats the purpose of RxJava. First of all operators like <code>subscribeOn()</code> no longer work and it becomes impossible to off-load computation to a different thread. Even worse, even though <code>eager()</code> returns a <code>Flowable</code> it will always, by definition, block client thread. It is harder to reason, compose and manage such streams. You should generally avoid such pattern and prefer lazy-loading even when eager evaluation is necessary.<br /><br /><h2 id="using-cache-operator">Using <code>cache()</code> operator</h2>The next example does just that with <code>cache()</code> operator:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; eager3() throws InterruptedException {<br />    final Flowable&lt;String&gt; cached =<br />        Flowable<br />            .fromCallable(this::slow)<br />            .cache();<br />    cached.subscribe();<br />    return cached;<br />}</pre>The idea is simple: wrap computation with lazy <code>Flowable</code> and make it cached. What <code>cache()</code> operator does is it remembers all emitted events upon first subscription so that when second <code>Subscriber</code> appears, it will receive the same <em>cached</em> sequence of events. However <code>cache()</code> operator (like most others) is lazy so we must forcibly subscribe for the first time. Calling <code>subscribe()</code> will prepopulate cache, moreover if second subscriber appears before <code>slow()</code> computation finishes, it will wait for it as well rather than starting it for the second time.<br /><br />This solution works but keep in mind that <code>subscribe()</code> will actually block because no <code>Scheduler</code> was involved. If you want to prepopulate your <code>Flowable</code> in background, try <code>subscribeOn()</code>:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; eager3() throws InterruptedException {<br />    final Flowable&lt;String&gt; cached =<br />        Flowable<br />            .fromCallable(this::slow)<br />            .subscribeOn(justDontAlwaysUse_Schedulers.io())<br />            .cache();<br />    cached.subscribe();<br />    return cached;<br />}</pre>Yes, using <code>Schedulers.io()</code> is problematic and hard to maintain on production systems so please avoid it in favor of custom thread pools.<br /><br /><h2 id="error-handling">Error handling</h2>Sadly it's surprisingly easy to swallow exceptions in RxJava. That's what can happen in our last example if <code>slow()</code> method fails. The exception isn't swallowed entirely, but by default, if no-one was interested, it's stack trace is printed on <code>System.err</code>. Also unhandled exception is wrapped with <code>OnErrorNotImplementedException</code>. Not very convenient and most likely lost if you are doing any form of centralized logging. You can use <code>doOnError()</code> operator for logging but it still passes exception downstream and RxJava considers it unhandled as well, one more time wrapping with <code>OnErrorNotImplementedException</code>. So let's implement <code>onError</code> callback in <code>subscribe()</code>:<br /><br /><pre class="brush: java">Flowable&lt;String&gt; eager3() throws InterruptedException {<br />    final Flowable&lt;String&gt; cached =<br />        Flowable<br />            .fromCallable(this::slow)<br />            .cache();<br />    cached.subscribe(<br />            x -&gt; {/* ignore */},<br />            e -&gt; logger.error("Prepopulation error", e));<br />    return cached;<br />}</pre>We don't want to handle actual events, just errors in <code>subscribe()</code>. At this point you can safely return such <code>Flowable</code>. It's eager and chances are that whenever yuo subscribe to it, data will already be available. Notice that for example <code>observe()</code> method from Hystrix is eager as well, as opposed to <code>toObservable()</code>, which is lazy. The choice is yours.<br /><br /> <script>SyntaxHighlighter.highlight();</script>