---
layout: post
title: Turning recursive file system traversal into Stream
date: '2014-07-07T20:09:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- java 8
- functional programming
modified_time: '2014-07-07T20:13:24.415+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8912631488289942250
blogger_orig_url: https://www.nurkiewicz.com/2014/07/turning-recursive-file-system-traversal.html
---

When I was learning programming, back in the days of Turbo Pascal, I managed to list files in directory using <a href="http://www.freepascal.org/docs-html/rtl/sysutils/findfirst.html"><code>FindFirst</code></a>, <a href="http://www.freepascal.org/docs-html/rtl/sysutils/findnext.html"><code>FindNext</code></a> and <a href="http://www.freepascal.org/docs-html/rtl/sysutils/findclose.html"><code>FindClose</code></a> functions. First I came up with a procedure printing contents of a given directory. You can imagine how proud I was to discover I can actually call that procedure from itself to traverse file system recursively. Well, I didn't know the term <em>recursion</em> back then, but it worked. Similar code in Java would look something like this:<br /><br /><pre class="brush: java">public void printFilesRecursively(final File folder) {<br />    for (final File entry : listFilesIn(folder)) {<br />        if (entry.isDirectory()) {<br />            printFilesRecursively(entry);<br />        } else {<br />            System.out.println(entry.getAbsolutePath());<br />        }<br />    }<br />}<br /><br />private File[] listFilesIn(File folder) {<br />    final File[] files = folder.listFiles();<br />    return files != null ? files : new File[]{};<br />}<br /></pre>Didn't know <a href="http://docs.oracle.com/javase/8/docs/api/java/io/File.html#listFiles--"><code>File.listFiles()</code></a> can return <code>null</code>, did ya? That's how it signals I/O errors, like if <code>IOException</code> never existed. But that's not the point. <code>System.out.println()</code> is rarely what we need, thus this method is neither reusable nor composable. It is probably the best counterexample of <a href="http://en.wikipedia.org/wiki/Open/closed_principle">Open/Closed principle</a>. I can imagine several use cases for recursive traversal of file system:<br /><br /><ol><li>Getting a complete list of all files for display purposes</li><li>Looking for all files matching given pattern/property (also check out <a href="http://docs.oracle.com/javase/8/docs/api/java/io/File.html#list-java.io.FilenameFilter-"><code>File.list(FilenameFilter)</code></a>)</li><li>Searching for one particular file </li><li>Processing every single file, e.g. sending it over network</li></ol>Every use case above has a unique set of challenges. For example we don't want to build a list of all files because it will take a significant amount of time and memory before we can start processing it. We would like to process files as they are discovered and lazily - by pipe-lining computation (but without clumsy visitor pattern). Also we want to short-circuit searching to avoid unnecessary I/O. Luckily in Java 8 some of these issues can be addressed with streams:<br /><br /><pre class="brush: java">final File home = new File(FileUtils.getUserDirectoryPath());<br />final Stream&lt;Path&gt; files = Files.list(home.toPath());<br />files.forEach(System.out::println);<br /></pre>Remember that <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#list-java.nio.file.Path-"><code>Files.list(Path)</code></a> (new in Java 8) does not look into subdirectories - we'll fix that later. The most important lesson here is: <code>Files.list()</code> returns a <code>Stream&lt;Path&gt;</code> - a value that we can pass around, compose, map, filter, etc. It's extremely flexible, e.g. it's fairly simple to count how many files I have in a directory per extension:<br /><br /><pre class="brush: java">import org.apache.commons.io.FilenameUtils;<br /><br />//...<br /><br />final File home = new File(FileUtils.getUserDirectoryPath());<br />final Stream&lt;Path&gt; files = Files.list(home.toPath());<br />final Map&lt;String, List&lt;Path&gt;&gt; byExtension = files<br />        .filter(path -&gt; !path.toFile().isDirectory())<br />        .collect(groupingBy(path -&gt; getExt(path)));<br /><br />byExtension.<br />        forEach((extension, matchingFiles) -&gt;<br />                System.out.println(<br />                        extension + "\t" + matchingFiles.size()));<br /><br />//...<br /><br />private String getExt(Path path) {<br />    return FilenameUtils.getExtension(path.toString()).toLowerCase();<br />}<br /></pre>OK, just another API, you might say. But it becomes really interesting once <em>we need to go deeper</em>, recursively traversing subdirectories. One amazing feature of streams is that you can combine them with each other in various ways. Old Scala saying <a href="http://stackoverflow.com/questions/8559537"><em>"flatMap that shit"</em></a> is applicable here as well, check out this recursive Java 8 code:<br /><br /><pre class="brush: java">//WARNING: doesn't compile, yet:<br /><br />private static Stream&lt;Path&gt; filesInDir(Path dir) {<br />    return Files.list(dir)<br />            .flatMap(path -&gt;<br />                    path.toFile().isDirectory() ?<br />                            filesInDir(path) :<br />                            singletonList(path).stream());<br />}<br /></pre><code>Stream&lt;Path&gt;</code> lazily produced by <code>filesInDir()</code> contains all files within directory including subdirectories. You can use it as any other stream by calling <code>map()</code>, <code>filter()</code>, <code>anyMatch()</code>, <code>findFirst()</code>, etc. But how does it really work? <code>flatMap()</code> is similar to <code>map()</code> but while <code>map()</code> is a straightforward 1:1 transformation, <code>flatMap()</code> allows replacing single entry in input <code>Stream</code> with multiple entries. If we had used <code>map()</code>, we would have end up with <code>Stream&lt;Stream&lt;Path&gt;&gt;</code> (or maybe <code>Stream&lt;List&lt;Path&gt;&gt;</code>). But <code>flatMap()</code> flattens this structure, in a way exploding inner entries. Let's see a simple example. Imagine <code>Files.list()</code> returned two files and one directory. For files <code>flatMap()</code> receives a one-element stream with that file. We can't simply return that file, we have to wrap it, but essentially this is no-operation. It gets way more interesting for a directory. In that case we call <code>filesInDir()</code> recursively. As a result we get a stream of contents of that directory, which we inject into our outer stream.<br /><br />Code above is short, sweet and... doesn't compile. These pesky checked exceptions again. Here is a fixed code, wrapping checked exceptions for sanity:<br /><br /><pre class="brush: java">public static Stream&lt;Path&gt; filesInDir(Path dir) {<br />    return listFiles(dir)<br />            .flatMap(path -&gt;<br />                    path.toFile().isDirectory() ?<br />                            filesInDir(path) :<br />                            singletonList(path).stream());<br />}<br /><br />private static Stream&lt;Path&gt; listFiles(Path dir) {<br />    try {<br />        return Files.list(dir);<br />    } catch (IOException e) {<br />        throw Throwables.propagate(e);<br />    }<br />}<br /></pre>Unfortunately this quite elegant code is not lazy enough. <code>flatMap()</code> evaluates eagerly, thus it always traverses all subdirectories, even if we barely ask for first file. You can try with my tiny <a href="https://github.com/nurkiewicz/LazySeq"><code>LazySeq</code></a> library that tries to provide even lazier abstraction, similar to streams in Scala or <code>lazy-seq</code> in Clojure. But even standard JDK 8 solution might be really helpful and simplify your code significantly.<br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>