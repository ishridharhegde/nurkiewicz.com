---
layout: post
title: Grouping, sampling and batching - custom collectors in Java 8
date: '2014-07-17T23:20:00.001+02:00'
author: Tomasz Nurkiewicz
tags:
- groovy
- java8
- Spock
modified_time: '2016-10-29T14:45:02.763+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1716414012264105388
blogger_orig_url: https://www.nurkiewicz.com/2014/07/grouping-sampling-and-batching-custom.html
---

Continuing <a href="http://www.nurkiewicz.com/2014/07/introduction-to-writing-custom.html">first article</a>, this time we will write some more useful custom collectors: for grouping by given criteria, sampling input, batching and sliding over with fixed size window.<br /><br /><h2>Grouping (counting occurrences, histogram)</h2>Imagine you have a collection of some items and you want to calculate how many times each item (with respect to <code>equals()</code>) appears in this collection. This can be achieved using <a href="https://draft.blogger.com/CollectionUtils.html#getCardinalityMap(java.lang.Iterable)"><code>CollectionUtils.getCardinalityMap()</code></a> from Apache Commons Collections. This method takes an <code>Iterable&lt;T&gt;</code> and returns <code>Map&lt;T, Integer&gt;</code>, counting how many times each item appeared in the collection. However sometimes instead of using <code>equals()</code> we would like to group by an arbitrary attribute of input <code>T</code>. For example say we have a list of <code>Person</code> objects and we would like to compute the number of males vs. females (i.e. <code>Map&lt;Sex, Integer&gt;</code>) or maybe an age distribution. There is a built-in collector <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-"><code>Collectors.groupingBy(Function&lt;T, K&gt; classifier)</code></a> - however it returns a map from key to all items mapped to that key. See:<br /><br /><pre class="brush: java">import static java.util.stream.Collectors.groupingBy;<br /><br />//...<br /><br />final List&lt;Person&gt; people = //...<br />final Map&lt;Sex, List&lt;Person&gt;&gt; bySex = people<br />        .stream()<br />        .collect(groupingBy(Person::getSex));<br /></pre>It's valuable, but in our case unnecessarily builds two <code>List&lt;Person&gt;</code>. I only want to know the number of people. There is no such collector built-in, but we can compose it in a fairly simple manner:<br /><br /><pre class="brush: java">import static java.util.stream.Collectors.counting;<br />import static java.util.stream.Collectors.groupingBy;<br /><br />//...<br /><br />final Map&lt;Sex, Long&gt; bySex = people<br />        .stream()<br />        .collect(<br />                groupingBy(Person::getSex, HashMap::new, counting()));<br /></pre>This overloaded version of <code>groupingBy()</code> takes three parameters. First one is the key (<i>classifier</i>) function, as previously. Second argument creates a new map, we'll see shortly why it's useful. <code>counting()</code> is a nested collector that takes all people with same sex and combines them together - in our case simply counting them as they arrive. Being able to choose map implementation is useful e.g. when building age histogram. We would like to know how many people we have at given age - but age values should be sorted:<br /><br /><pre class="brush: java">final TreeMap&lt;Integer, Long&gt; byAge = people<br />    .stream()<br />    .collect(<br />            groupingBy(Person::getAge, TreeMap::new, counting()));<br /><br />byAge<br />        .forEach((age, count) -&gt;<br />                System.out.println(age + ":\t" + count));<br /></pre>We ended up with a <code>TreeMap</code> from age (sorted) to count of people having that age.<br /><br /><h2>Sampling, batching and sliding window</h2><a href="http://www.scala-lang.org/api/current/#scala.collection.IterableLike"><code>IterableLike.sliding()</code></a> method in Scala allows to view a collection through a sliding fixed-size window. This window starts at the beginning and in each iteration moves by given number of items. Such functionality, missing in Java 8, allows several useful operators like computing <a href="http://en.wikipedia.org/wiki/Moving_average">moving average</a>, splitting big collection into batches (compare with <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Lists.html#partition(java.util.List,%20int)"><code>Lists.partition()</code> in Guava</a>) or sampling every n-th element. We will implement collector for Java 8 providing similar behaviour. Let's start from unit tests, which should describe briefly what we want to achieve:<br /><br /><pre class="brush: groovy">import static com.nurkiewicz.CustomCollectors.sliding<br /><br />@Unroll<br />class CustomCollectorsSpec extends Specification {<br /><br />    def "Sliding window of #input with size #size and step of 1 is #output"() {<br />        expect:<br />        input.stream().collect(sliding(size)) == output<br /><br />        where:<br />        input  | size | output<br />        []     | 5    | []<br />        [1]    | 1    | [[1]]<br />        [1, 2] | 1    | [[1], [2]]<br />        [1, 2] | 2    | [[1, 2]]<br />        [1, 2] | 3    | [[1, 2]]<br />        1..3   | 3    | [[1, 2, 3]]<br />        1..4   | 2    | [[1, 2], [2, 3], [3, 4]]<br />        1..4   | 3    | [[1, 2, 3], [2, 3, 4]]<br />        1..7   | 3    | [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]]<br />        1..7   | 6    | [1..6, 2..7]<br />    }<br /><br />    def "Sliding window of #input with size #size and no overlapping is #output"() {<br />        expect:<br />        input.stream().collect(sliding(size, size)) == output<br /><br />        where:<br />        input | size | output<br />        []    | 5    | []<br />        1..3  | 2    | [[1, 2], [3]]<br />        1..4  | 4    | [1..4]<br />        1..4  | 5    | [1..4]<br />        1..7  | 3    | [1..3, 4..6, [7]]<br />        1..6  | 2    | [[1, 2], [3, 4], [5, 6]]<br />    }<br /><br />    def "Sliding window of #input with size #size and some overlapping is #output"() {<br />        expect:<br />        input.stream().collect(sliding(size, 2)) == output<br /><br />        where:<br />        input | size | output<br />        []    | 5    | []<br />        1..4  | 5    | [[1, 2, 3, 4]]<br />        1..7  | 3    | [1..3, 3..5, 5..7]<br />        1..6  | 4    | [1..4, 3..6]<br />        1..9  | 4    | [1..4, 3..6, 5..8, 7..9]<br />        1..10 | 4    | [1..4, 3..6, 5..8, 7..10]<br />        1..11 | 4    | [1..4, 3..6, 5..8, 7..10, 9..11]<br />    }<br /><br />    def "Sliding window of #input with size #size and gap of #gap is #output"() {<br />        expect:<br />        input.stream().collect(sliding(size, size + gap)) == output<br /><br />        where:<br />        input | size | gap | output<br />        []    | 5    | 1   | []<br />        1..9  | 4    | 2   | [1..4, 7..9]<br />        1..10 | 4    | 2   | [1..4, 7..10]<br />        1..11 | 4    | 2   | [1..4, 7..10]<br />        1..12 | 4    | 2   | [1..4, 7..10]<br />        1..13 | 4    | 2   | [1..4, 7..10, [13]]<br />        1..13 | 5    | 1   | [1..5, 7..11, [13]]<br />        1..12 | 5    | 3   | [1..5, 9..12]<br />        1..13 | 5    | 3   | [1..5, 9..13]<br />    }<br /><br />    def "Sampling #input taking every #nth th element is #output"() {<br />        expect:<br />        input.stream().collect(sliding(1, nth)) == output<br /><br />        where:<br />        input  | nth | output<br />        []     | 1   | []<br />        []     | 5   | []<br />        1..3   | 5   | [[1]]<br />        1..6   | 2   | [[1], [3], [5]]<br />        1..10  | 5   | [[1], [6]]<br />        1..100 | 30  | [[1], [31], [61], [91]]<br />    }<br />}<br /></pre>Using <a href="http://spock-framework.readthedocs.org/en/latest/data_driven_testing.html">data driven tests in Spock</a> I managed to write almost 40 test cases in no-time, succinctly describing all requirements. I hope these are clear for you, even if you haven't seen this syntax before. I already assumed existence of handy factory methods:<br /><br /><pre class="brush: java">public class CustomCollectors {<br /><br />    public static &lt;T&gt; Collector&lt;T, ?, List&lt;List&lt;T&gt;&gt;&gt; sliding(int size) {<br />        return new SlidingCollector&lt;&gt;(size, 1);<br />    }<br /><br />    public static &lt;T&gt; Collector&lt;T, ?, List&lt;List&lt;T&gt;&gt;&gt; sliding(int size, int step) {<br />        return new SlidingCollector&lt;&gt;(size, step);<br />    }<br /><br />}<br /></pre>The fact that collectors receive items one after another makes are job harder. Of course first collecting the whole list and sliding over it would have been easier, but sort of wasteful. Let's build result iteratively. I am not even pretending this task can be parallelized in general, so I'll leave <code>combiner()</code> unimplemented:<br /><br /><pre class="brush: java">public class SlidingCollector&lt;T&gt; implements Collector&lt;T, List&lt;List&lt;T&gt;&gt;, List&lt;List&lt;T&gt;&gt;&gt; {<br /><br />    private final int size;<br />    private final int step;<br />    private final int window;<br />    private final Queue&lt;T&gt; buffer = new ArrayDeque&lt;&gt;();<br />    private int totalIn = 0;<br /><br />    public SlidingCollector(int size, int step) {<br />        this.size = size;<br />        this.step = step;<br />        this.window = max(size, step);<br />    }<br /><br />    @Override<br />    public Supplier&lt;List&lt;List&lt;T&gt;&gt;&gt; supplier() {<br />        return ArrayList::new;<br />    }<br /><br />    @Override<br />    public BiConsumer&lt;List&lt;List&lt;T&gt;&gt;, T&gt; accumulator() {<br />        return (lists, t) -&gt; {<br />            buffer.offer(t);<br />            ++totalIn;<br />            if (buffer.size() == window) {<br />                dumpCurrent(lists);<br />                shiftBy(step);<br />            }<br />        };<br />    }<br /><br />    @Override<br />    public Function&lt;List&lt;List&lt;T&gt;&gt;, List&lt;List&lt;T&gt;&gt;&gt; finisher() {<br />        return lists -&gt; {<br />            if (!buffer.isEmpty()) {<br />                final int totalOut = estimateTotalOut();<br />                if (totalOut &gt; lists.size()) {<br />                    dumpCurrent(lists);<br />                }<br />            }<br />            return lists;<br />        };<br />    }<br /><br />    private int estimateTotalOut() {<br />        return max(0, (totalIn + step - size - 1) / step) + 1;<br />    }<br /><br />    private void dumpCurrent(List&lt;List&lt;T&gt;&gt; lists) {<br />        final List&lt;T&gt; batch = buffer.stream().limit(size).collect(toList());<br />        lists.add(batch);<br />    }<br /><br />    private void shiftBy(int by) {<br />        for (int i = 0; i &lt; by; i++) {<br />            buffer.remove();<br />        }<br />    }<br /><br />    @Override<br />    public BinaryOperator&lt;List&lt;List&lt;T&gt;&gt;&gt; combiner() {<br />        return (l1, l2) -&gt; {<br />            throw new UnsupportedOperationException("Combining not possible");<br />        };<br />    }<br /><br />    @Override<br />    public Set&lt;Characteristics&gt; characteristics() {<br />        return EnumSet.noneOf(Characteristics.class);<br />    }<br /><br />}<br /></pre>I spent quite some time writing this implementation, especially correct <code>finisher()</code> so don't be frightened. The crucial part is a <code>buffer</code> that collects items until it can form one sliding window. Then "oldest" items are discarded and window slides forward by <code>step</code>. I am not particularly happy with this implementation, but tests are passing. <code>sliding(N)</code> (synonym to <code>sliding(N, 1)</code>) will allow calculating moving average of <code>N</code> items. <code>sliding(N, N)</code> splits input into batches of size <code>N</code>. <code>sliding(1, N)</code> takes every N-th element (samples). I hope you'll find this collector useful, enjoy!<br /><br /><script>SyntaxHighlighter.highlight();</script>