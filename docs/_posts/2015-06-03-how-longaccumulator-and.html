---
layout: post
title: How LongAccumulator and DoubleAccumulator classes work?
date: '2015-06-03T23:21:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- multithreading
- java 8
- concurrency
modified_time: '2015-06-05T15:57:21.824+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3544067282361166774
blogger_orig_url: https://www.nurkiewicz.com/2015/06/how-longaccumulator-and.html
---

Two classes new in Java 8 deserve some attention: <code>LongAccumulator</code> and <code>DoubleAccumulator</code>. They are designed to <em>accumulate</em> (more on what does that mean later) values across threads safely while being extremely fast. A test is worth a thousand words, so here is how it works:<br/><br/> <pre class="brush: java">class AccumulatorSpec extends Specification {<br /><br />    public static final long A = 1<br />    public static final long B = 2<br />    public static final long C = 3<br />    public static final long D = -4<br />    public static final long INITIAL = 0L<br /><br />    def 'should add few numbers'() {<br />        given:<br />            LongAccumulator accumulator = new LongAccumulator({ long x, long y -&gt; x + y }, INITIAL)<br />        when:<br />            accumulator.accumulate(A)<br />            accumulator.accumulate(B)<br />            accumulator.accumulate(C)<br />            accumulator.accumulate(D)<br />        then:<br />            accumulator.get() == INITIAL + A + B + C + D<br />    }<br /></pre>So the accumulator takes a binary operator and combines initial value with every accumulated value. That means <code>((((0 + 1) + 2) + 3) + -4)</code> equals to <code>2</code>. Don't go away yet, there's much more than that. Accumulator can take other operators as well, as illustrated by this use case:<br/><br/> <pre class="brush: java">def 'should accumulate numbers using operator'() {<br />    given:<br />        LongAccumulator accumulator = new LongAccumulator(operator, initial)<br />    when:<br />        accumulator.accumulate(A)<br />        accumulator.accumulate(B)<br />        accumulator.accumulate(C)<br />        accumulator.accumulate(D)<br />    then:<br />        accumulator.get() == expected<br />    where:<br />        operator                 | initial           || expected<br />        {x, y -&gt; x + y}          | 0                 || A + B + C + D<br />        {x, y -&gt; x * y}          | 1                 || A * B * C * D<br />        {x, y -&gt; Math.max(x, y)} | Integer.MIN_VALUE || max(A, B, C, D)<br />        {x, y -&gt; Math.min(x, y)} | Integer.MAX_VALUE || min(A, B, C, D)<br />}<br /></pre>Obviously accumulator would work just as well under heavy multi-threaded environment - which it was designed for. Now the question is, what other operations are permitted in <code>LongAccumulator</code> (this applies to <code>DoubleAccumulator</code> as well) and why? JavaDoc is not very formal this time (bold mine):<br/><br/> <blockquote>The order of accumulation within or across threads is not guaranteed and cannot be depended upon, so this class is only applicable to <strong>functions for which the order of accumulation does not matter. The supplied accumulator function should be side-effect-free</strong>, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.<br/><br/> </blockquote>In order to understand how <code>LongAccumulator</code> works, what type of operations are permitted and why it's so fast (because it is, compared to e.g <code>AtomicLong</code>), let's start from the back, the <code>get()</code> method:<br/><br/> <pre class="brush: java">transient volatile long base;<br />transient volatile Cell[] cells;<br /><br />private final LongBinaryOperator function;<br /><br />public long get() {<br />    Cell[] as = cells; Cell a;<br />    long result = base;<br />    if (as != null) {<br />        for (int i = 0; i &lt; as.length; ++i) {<br />            if ((a = as[i]) != null)<br />                result = function.applyAsLong(result, a.value);<br />        }<br />    }<br />    return result;<br />}<br /></pre>Which can be rewritten to not-exactly-equivalent but easier to read:<br/><br/> <pre class="brush: java">public long get() {<br />    long result = base;<br />    for (Cell cell : cells)<br />        result = function.applyAsLong(result, cell.value);<br />    return result;<br />}<br /></pre>Or even more functionally without internal state:<br/><br/> <pre class="brush: java">public long get() {<br />    return Arrays.stream(cells)<br />            .map(s -&gt; s.value)<br />            .reduce(base, function::applyAsLong);<br />}<br /></pre>We clearly see that there is some internal <code>cells</code> array and that in the end we must go through that array and apply our operator function sequentially on each element. Turns out <code>LongAccumulator</code> has two mechanisms for accumulating values: a single <code>base</code> counter and an array of values in case of high lock thread contention. If <code>LongAccumulator</code> is used under no lock contention, only a single <code>volatile base</code> variable and CAS operations are used, just like in <code>AtomicLong</code>. However if CAS fails, this class falls back to an array of values. You don't want to see the implementation, it's 90 lines long, occasionally with 8 levels of nesting. What you need to know is that it uses simple algorithm to always assign given thread to the same cell (improves cache locality). From now on this thread has its own, almost private copy of counter. It shares this copy with couple of other threads, but not with all of them - they have their own cells. So what you end up in the end is an array of semi-calculated counters which must be aggregated. This is what you saw in <code>get()</code> method.<br/><br/> This brings us again to the question, what kind of operators (<code>op</code>) are permitted in <code>LongAccumulator</code>. We know that the same sequence of accumulations under low load will result e.g. in:<br/><br/> <pre class="brush: java">((I op A) op B)  //get()<br /></pre>Which means all values are aggregated in base variable and no counter array is used. However under high load, <code>LongAccumulator</code> will split work e.g. into two buckets (cells) and later accumulate buckets as well:<br/><br/> <pre class="brush: java">(I op A)              //cell 1<br />(I op B)              //cell 2<br /><br />(I op A) op (I op B)  //get()<br /></pre>or vice-versa:<br/><br/> <pre class="brush: java">(I op B)              //cell 1<br />(I op A)              //cell 2<br /><br />(I op B) op (I op A)  //get()<br /></pre>Clearly all invocations of <code>get()</code> should yield the same result, but it all depends on the properties of <code>op</code> operator being provided (<code>+</code>, <code>*</code>, <code>max</code>, etc.)<br/><br/> <h1>Commutative</h1>We have no control over the order of cells and how they are assigned. That's why <code>((I op A) op (I op B))</code> and <code>((I op B) op (I op A))</code> must return the same result. More compactly we are looking for such operators <code>op</code> where <code>X op Y = Y op X</code> for every <code>X</code> and <code>Y</code>. This means <code>op</code> must be <a href="http://en.wikipedia.org/wiki/Commutative_property"><strong>commutative</strong></a>.<br/><br/> <h1>Neutral element (identity)</h1>Cells are logically initialized with identity (initial) value <code>I</code>. We have no control over the number and order of cells, thus the identity value can be applied numerous times in any order. However this is an implementation detail, so it shouldn't affect the result. More precisely, for every <code>X</code> and any <code>op</code>:<br/><br/> <pre class="brush: java">X op I = I op X = X<br /></pre>Which means the identity (initial) value <code>I</code> must be a neutral value for every argument <code>X</code> to operator <code>op</code>.<br/><br/> <h1>Associativity</h1>Assume we have the following cells:<br/><br/> <pre class="brush: java">I op A                              // cell 1<br />I op B                              // cell 2<br />I op C                              // cell 3<br />((I op A) op (I op B)) op (I op C)  //get()<br /></pre>but the next time they were arranged differently<br/><br/> <pre class="brush: java">I op C                              // cell 1<br />I op B                              // cell 2<br />I op A                              // cell 2<br />((I op C) op (I op B)) op (I op A)  //get()<br /></pre>Knowing that <code>op</code> is commutative and <code>I</code> is a neutral element, we can prove that (for every <code>A</code>, <code>B</code> and <code>C</code>):<br/><br/> <pre class="brush: java">((I op A) op (I op B)) op (I op C) = ((I op C) op (I op B)) op (I op A)<br />(A op B) op C = (C op B) op A<br />(A op B) op C = A op (B op C)<br /></pre>Which proves that <code>op</code> must be <strong><a href="http://en.wikipedia.org/wiki/Associative_property">associative</a></strong> in order for <code>LongAccumulator</code> to actually work.<br/><br/> <h1>Wrap up</h1><code>LongAccumulator</code> and <code>DoubleAccumulator</code> are highly specialized classes new in JDK 8. JavaDoc is quite vaque but we tried to prove properties that an operator and initial value must fullfil in order for them to do their job. We know that the operator must be <em>associative</em>, <em>commutative</em> and have a neutral element. It would have been so much better if JavaDoc clearly stated that it must be an <a href="http://en.wikipedia.org/wiki/Monoid#Commutative_monoid">abelian monoid</a> ;-). Nevertheless for practical purposes these accumulators work only for adding, multiplying, min and max, as these are the only useful operators (with appropriate neutral element) that play well. Subtracting and dividing for example is not associative and commutative, thus can't possibly work. To make matters worse, accumulators would simply behave undeterministically.  <script>SyntaxHighlighter.highlight();</script>