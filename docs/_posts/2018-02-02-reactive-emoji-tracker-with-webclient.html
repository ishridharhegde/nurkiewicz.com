---
layout: post
title: 'Reactive emoji tracker with WebClient and Reactor: consuming SSE'
date: '2018-02-02T01:11:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- emojitracker
- reactor
- spring
- emoji
- webclient
modified_time: '2018-02-07T00:31:34.298+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1824214589404611048
blogger_orig_url: https://www.nurkiewicz.com/2018/02/reactive-emoji-tracker-with-webclient.html
---

In this article we will learn how to consume infinite <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">SSE (server-sent events)</a> stream with <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client">Spring's <code>WebClient</code></a> and <a href="https://projectreactor.io/">Project Reactor</a>. <code>WebClient</code> is a new HTTP client in Spring 5, entirely asynchronous and natively supporting <code>Flux</code> and <code>Mono</code> types. You can technically open thousands of concurrent HTTP connections with just a handful of threads. In standard <code>RestTemplate</code> one HTTP connection always needs at least one thread.<br /><br />As an example, let's connect to this cute little site called <a href="http://emojitracker.com/">emojitracker.com</a>. It shows emojis being used in real-time on Twitter. Looks quite cool! All credits go to <a href="http://mroth.info/">Matthew Rothenberg</a>, the creator of that site. It's very dynamic so there obviously has to be some push mechanism underneath. I wore my hacker glasses and after hours of penetration testing, I discovered the following URL in Chrome DevTools: <code>http://emojitrack-gostreamer.herokuapp.com/subscribe/eps</code>. If you connect to it, you'll get a fast stream of emoji counters:<br /><br /><pre class="prettyprint linenums">$ curl -v http://emojitrack-gostreamer.herokuapp.com/subscribe/eps<br />&gt; GET /subscribe/eps HTTP/1.1<br />&gt; Host: emojitrack-gostreamer.herokuapp.com<br />&gt; User-Agent: curl/7.54.0<br />&gt; Accept: */*<br />&gt; <br />&lt; HTTP/1.1 200 OK<br />&lt; Connection: keep-alive<br />&lt; Content-Type: text/event-stream; charset=utf-8<br />&lt; Transfer-Encoding: chunked<br />&lt;<br />data:{"1F3C6":1,"1F440":1,"1F64F":1}<br /><br />data:{"267B":1}<br /><br />data:{"1F4B0":1}<br /><br />data:{"267B":2}<br /><br />data:{"1F49B":1,"1F612":1}<br /><br />data:{"1F331":1,"1F44D":1,"1F49E":1,"1F4F9":1,"1F51E":1,"1F525":1}<br /><br />data:{"1F609":1}<br /><br />data:{"2764":1}<br /><br />data:{"1F331":1,"267B":2}<br /><br />data:{"1F498":1,"1F60A":1}</pre>Dozens of data points per second, ready to be consumed via convenient <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">SSE</a> stream. Each event represent the number of emojis that appeared on Twitter since last event. For example <code>{"1F604":1,"267B":2}</code> means "ðŸ˜„" once and "â™»" twice. We would like to read this stream in Java efficiently and make something useful out of it. Well, maybe not <em>useful</em> (it's emojis after all) but at least fun. Consuming SSE stream with <code>WebClient</code> is pretty simple:<br /><br /><pre class="prettyprint linenums">import org.springframework.http.codec.ServerSentEvent;<br />import org.springframework.web.reactive.function.client.WebClient;<br /><br />public static void main(String[] args) throws InterruptedException {<br />    final Flux&lt;ServerSentEvent&gt; stream = WebClient<br />            .create("http://emojitrack-gostreamer.herokuapp.com")<br />            .get().uri("/subscribe/eps")<br />            .retrieve()<br />            .bodyToFlux(ServerSentEvent.class);<br />    <br />    stream.subscribe(sse -&gt; log.info("Received: {}", sse));<br /><br />    TimeUnit.MINUTES.sleep(10);<br />}</pre><code>sleep(10)</code> is important. Otherwise the application terminates immediately because the only non-daemon thread (<code>main</code>) dies. In web applications this is not a problem.<br /><br />At this point you'll see a bunch of logs appearing on your console:<br /><br /><pre class="prettyprint linenums">Received: ServerSentEvent [... data={1F1EC-1F1E7=1, 1F614=1, 2764=1}]<br />Received: ServerSentEvent [... data={1F49C=1}]<br />Received: ServerSentEvent [... data={1F605=1, 1F60D=1, 1F60E=1, 2665=1}]<br />Received: ServerSentEvent [... data={267B=2}]<br />Received: ServerSentEvent [... data={1F1FA-1F1F8=1, 1F34B=1, 1F604=1, 1F608=1, 1F60A=1, 25B6=1}]<br />Received: ServerSentEvent [... data={1F525=1, 1F602=1, 25B6=1, 2705=1, 274C=1}]<br />Received: ServerSentEvent [... data={267B=1}]</pre>Being able to connect to live SSE stream, let's apply some transformations on top of it. First of all, we would like to parse JSON <code>data</code> inside of each message pushed from the server:<br /><br /><pre class="prettyprint linenums">final Flux&lt;Map&lt;String, Integer&gt;&gt; stream = WebClient<br />         //...see above for missing lines...<br />        .bodyToFlux(ServerSentEvent.class)<br />        .flatMap(e -&gt; Mono.justOrEmpty(e.data()))<br />        .map(x -&gt; (Map&lt;String, Integer&gt;)x);</pre>There's no JSON parsing, Spring does it's magic for us! At this point we have a stream of <code>Map&lt;String, Integer&gt;</code> instances, not raw <code>ServerSentEvent</code> classes. Two caveats. First of all we need <code>flatMap(e -&gt; Mono.justOrEmpty(e.data()))</code> rather than just a simple <code>map(ServerSentEvent::data)</code> because <code>ServerSentEvent.data()</code> sometimes returns <code>null</code>. Secondly <code>.map(x -&gt; (Map&lt;String, Integer&gt;)x)</code> needs to be used as opposed to simple <code>.cast(Map.class)</code> because of type erasure. Alright, our stream is a bit too complex right now. Rather than having three-dimensional data (event contains map, map contains entries, entries contain count) we'd like to have a single event per each emoji appearence. Easy!<br /><br /><pre class="prettyprint linenums">final Flux&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = WebClient<br />         //...see above for missing lines...<br />        .flatMap(e -&gt; Mono.justOrEmpty(e.data()))<br />        .map(x -&gt; (Map&lt;String, Integer&gt;) x)<br />        .flatMapIterable(Map::entrySet);</pre>We get stream of map entries (<code>Map.Entry&lt;String, Integer&gt;</code>), then...<br /><br /><pre class="prettyprint linenums">final Flux&lt;String&gt; stream = WebClient<br />         //...see above for missing lines...<br />        .map(x -&gt; (Map&lt;String, Integer&gt;) x)<br />        .flatMapIterable(Map::entrySet)<br />        .flatMap(entry -&gt; Flux.just(entry.getKey()).repeat(entry.getValue()));</pre>With just few lines of code we transformed one event: <code>{"1F604":1,"267B":2}</code> into three: <code>"1F604"</code>, <code>"267B"</code>, <code>"267B"</code>. I was feeling a bit guilty at this point, reverse-engineering the <a href="http://emojitracker.com/">emojitracker.com</a>. Then I discovered that the <a href="https://github.com/mroth/emojitracker">source code</a> of the website is on GitHub and the API <a href="https://github.com/mroth/emojitrack-streamer-spec">is documented</a>. Moreover, there is already an endpoint that sends individual emojis, as opposed to aggregated JSON maps:<br /><br /><pre class="prettyprint linenums">$ curl -v http://emojitrack-gostreamer.herokuapp.com/subscribe/raw<br />&gt; GET /subscribe/raw HTTP/1.1<br />&gt; Host: emojitrack-gostreamer.herokuapp.com<br />&gt; User-Agent: curl/7.54.0<br />&gt; Accept: */*<br />&gt; <br />&lt; HTTP/1.1 200 OK<br />&lt; Connection: keep-alive<br />&lt; Content-Type: text/event-stream; charset=utf-8<br />&lt; Transfer-Encoding: chunked<br />&lt; <br />data:1F604<br /><br />data:267B<br /><br />data:2665<br /><br />data:1F60E<br /><br />...</pre>You know what they say, hours of coding can save you from minutes of reading the documentation. But we had fun! The full source code we have so far looks as follows:<br /><br /><pre class="prettyprint linenums">final Flux&lt;String&gt; stream = WebClient<br />        .create("http://emojitrack-gostreamer.herokuapp.com")<br />        .get().uri("/subscribe/eps")<br />        .retrieve()<br />        .bodyToFlux(ServerSentEvent.class)<br />        .flatMap(e -&gt; Mono.justOrEmpty(e.data()))<br />        .map(x -&gt; (Map&lt;String, Integer&gt;) x)<br />        .flatMapIterable(Map::entrySet)<br />        .flatMap(entry -&gt; Flux.just(entry.getKey()).repeat(entry.getValue()));<br /><br />stream.subscribe(sse -&gt; log.info("Received: {}", sse));<br /><br />TimeUnit.SECONDS.sleep(10);</pre>In the <a href="http://www.nurkiewicz.com/2018/02/reactive-emoji-tracker-with-webclient_7.html">next part</a> we will parse the emoji data even further and run some aggregations on top of it. All using <code>Flux</code>es magic.<br /><br />