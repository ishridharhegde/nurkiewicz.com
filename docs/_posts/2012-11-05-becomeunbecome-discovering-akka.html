---
layout: post
title: become/unbecome - discovering Akka
date: '2012-11-05T19:43:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- akka
- scala
modified_time: '2012-11-05T21:33:40.651+01:00'
thumbnail: http://4.bp.blogspot.com/-CNxMpfMdGeM/UJgH3s1queI/AAAAAAAAAp8/LZUsnco5q5w/s72-c/100_8124.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3263728146289045454
blogger_orig_url: https://www.nurkiewicz.com/2012/11/becomeunbecome-discovering-akka.html
---

<h1></h1><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-CNxMpfMdGeM/UJgH3s1queI/AAAAAAAAAp8/LZUsnco5q5w/s1600/100_8124.JPG" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://4.bp.blogspot.com/-CNxMpfMdGeM/UJgH3s1queI/AAAAAAAAAp8/LZUsnco5q5w/s320/100_8124.JPG" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Oslo seen from Hoved√∏ya island</td></tr></tbody></table>Sometimes our actor needs to react differently based on its internal state. Typically receiving some specific message causes the state transition which, in turns, changes the way subsequent messages should be handled. Another message restores the original state and thus - the way messages were handled before. <a href="http://nurkiewicz.blogspot.no/2012/11/two-actors-discovering-akka.html">In the previous article</a> we implemented <code>RandomOrgBuffer</code> actor based on <code>waitingForResponse</code> flag. It unnecessarily complicated already complex message handling logic:<br /><pre class="brush: scala">var waitingForResponse = false<br /><br />def receive = {<br />    case RandomRequest =&gt;<br />        preFetchIfAlmostEmpty()<br />            if(buffer.isEmpty) {<br />                backlog += sender<br />            } else {<br />                sender ! buffer.dequeue()<br />            }<br />    case RandomOrgServerResponse(randomNumbers) =&gt;<br />        buffer ++= randomNumbers<br />        waitingForResponse = false<br />        while(!backlog.isEmpty &amp;&amp; !buffer.isEmpty) {<br />            backlog.dequeue() ! buffer.dequeue()<br />        }<br />        preFetchIfAlmostEmpty()<br />}<br /><br />private def preFetchIfAlmostEmpty() {<br />    if(buffer.size &lt;= BatchSize / 4 &amp;&amp; !waitingForResponse) {<br />        randomOrgClient ! FetchFromRandomOrg(BatchSize)<br />        waitingForResponse = true<br />    }<br />}<br /></pre>Wouldn't it be simpler to have two distinct <code>receive</code> methods - one used when we are awaiting for external server response (<code>waitingForResponse == true</code>) and the other when buffer is filled sufficiently and no request to <code>random.org</code> was yet issued? In such circumstances <code>become()</code> and <code>unbecome()</code> methods come very handy. By default <code>receive</code> method is used to handle all incoming messages. However at any time we can call <code>become()</code>, which accept any method compliant with <code>receive</code> signature as an argument. Every subsequent message will be handled by this new method. Calling <code>unbecome()</code> restores original <code>receive</code> method. Knowing this technique we can refactor our solution above to the following:<br /><a name='more'></a><br /><pre class="brush: scala">def receive = {<br />    case RandomRequest =&gt;<br />        preFetchIfAlmostEmpty()<br />        handleOrQueueInBacklog()<br />    }<br /><br />def receiveWhenWaiting = {<br />    case RandomRequest =&gt;<br />        handleOrQueueInBacklog()<br />    case RandomOrgServerResponse(randomNumbers) =&gt;<br />        buffer ++= randomNumbers<br />        context.unbecome()<br />        while(!backlog.isEmpty &amp;&amp; !buffer.isEmpty) {<br />            backlog.dequeue() ! buffer.dequeue()<br />        }<br />        preFetchIfAlmostEmpty()<br />}<br /><br />private def handleOrQueueInBacklog() {<br />    if (buffer.isEmpty) {<br />        backlog += sender<br />    } else {<br />        sender ! buffer.dequeue()<br />    }<br />}<br /><br />private def preFetchIfAlmostEmpty() {<br />    if(buffer.size &lt;= BatchSize / 4) {<br />        randomOrgClient ! FetchFromRandomOrg(BatchSize)<br />        context become receiveWhenWaiting<br />    }<br />}<br /></pre>We extracted code responsible for handling message while we wait for <code>random.org</code> response into a separate <code>receiveWhenWaiting</code> method. Notice the <code>become()</code> and <code>unbecome()</code> calls - they replaced no longer needed <code>waitingForResponse</code> flag. Instead we simply say: starting from next message please use this other method to handle (<i>become</i> slightly different actor). Later we say: OK, let's go back to the original state and receive messages as you used to (<i>unbecome</i>). But the most important change is the transition from one, big method into two, much smaller a better named ones.<br /><code>become()</code> and <code>unbecome()</code> methods are actually much more powerful since they internally maintain a <i>stack</i> of receiving methods. Every call to <code>become()</code> (with <code>discardOld = false</code> as a second parameter) pushes current receiving method onto a stack while <code>unbecome()</code> pops it and restores the previous one. Thus we can use <code>become()</code> to use several receiving methods and then gradually go back through all the changes. Moreover Akka also supports <a href="http://doc.akka.io/docs/akka/snapshot/scala/fsm.html"><i>finite state machine</i></a> pattern, but more on that maybe in the future.<br />Source code for this article is <a href="https://github.com/nurkiewicz/learning-akka">available on GitHub</a> in <a href="https://github.com/nurkiewicz/learning-akka/tree/become-unbecome"><code>become-unbecome</code> tag</a>.<br /><blockquote>This was a translation of my article <a href="http://scala.net.pl/poznajemy-akka-become-unbecome/">"<i>Poznajemy Akka: become/unbecome</i>"</a> originally published on <a href="http://scala.net.pl/">scala.net.pl</a>.</blockquote><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>