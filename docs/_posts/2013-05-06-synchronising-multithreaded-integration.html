---
layout: post
title: Synchronising Multithreaded Integration Tests revisited
date: '2013-05-06T19:27:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- testing
- multithreading
- java 8
- intellij idea
modified_time: '2013-05-06T19:27:58.480+02:00'
thumbnail: http://2.bp.blogspot.com/-3Fn91HMIPvc/UYfnp7lpN7I/AAAAAAAAAv0/t8O7Xgdowks/s72-c/lambda-intentions.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-476020086705871356
blogger_orig_url: https://www.nurkiewicz.com/2013/05/synchronising-multithreaded-integration.html
---

I recently stumbled upon an article <a href="http://www.captaindebug.com/2013/02/synchronising-multithreaded-integration.html"><i>Synchronising Multithreaded Integration Tests</i></a> on <a href="http://www.captaindebug.com/">Captain Debug's Blog</a>. That post emphasizes the problem of designing integration tests involving class under test running business logic asynchronously. This contrived example was given (I stripped some comments):<br /><br /><pre class="brush: java">public class ThreadWrapper {<br /><br />    public void doWork() {<br /><br />        Thread thread = new Thread() {<br />            @Override<br />            public void run() {<br /><br />                System.out.println("Start of the thread");<br />                addDataToDB();<br />                System.out.println("End of the thread method");<br />            }<br /><br />            private void addDataToDB() {<br />                // Dummy Code...<br />                try {<br />                    Thread.sleep(4000);<br />                } catch (InterruptedException e) {<br />                    e.printStackTrace();<br />                }<br />            }<br />        };<br /><br />        thread.start();<br />        System.out.println("Off and running...");<br />    }<br /><br />}<br /></pre>This is only an example of common pattern where business logic is delegated to some asynchronous job pool we have no control over. <a href="http://www.blogger.com/profile/07042290171112551665">Roger Hughes</a> (the author) enumerates few techniques of testing such code, including:<br /><a name='more'></a><br /><br /><ul><li>arbitrary ("long enough") <code>sleep()</code> in test method to make sure background logic finishes</li><li>refactoring <code>doWork()</code> so that it accepts <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html"><code>CountDownLatch</code></a> and agrees to notify it when job is done</li><li>making the method above package private and <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/annotations/VisibleForTesting.html"><code>@VisibleForTesting</code></a> only</li><li>"The" solution - refactoring <code>doWork()</code> so that it accepts arbitrary <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html"><code>Runnable</code></a>. In test we can wrap this <code>Runnable</code> (decorator pattern) and wait for inner <code>Runnable</code> to complete</li></ul>Last solution is not bad but it changes the responsibilities of <code>ThreadWrapper</code> significantly. Now it's up to the caller to decide what kind of job should be executed asynchronously while previously <code>ThreadWrapper</code> was encapsulating business logic completely. I am not saying it's a bad design, but it's drastically different from original method.<br /><br /><h1>Awaitility</h1>Can we write a test without such a massive refactoring? First solution involves handy library called <a href="https://code.google.com/p/awaitility/">Awaitility</a>. This library is not a silver bullet, it simply evaluates given condition periodically and makes sure it's fulfilled within given time. It's the kind of code you probably wrote once or twice - wrapped in a library with well designed API. So here is our initial approach:<br /><br /><pre class="brush: java">import static com.jayway.awaitility.Awaitility.await;<br />import static java.util.concurrent.TimeUnit.SECONDS;<br /><br />//...<br /><br />await().atMost(10, SECONDS).until(recordInserted());<br /><br />//...<br /><br />private Callable&lt;Boolean&gt; recordInserted() {<br />    return new Callable&lt;Boolean&gt;() {<br />        @Override<br />        public Boolean call() throws Exception {<br />            return dataExists();<br />        }<br />    };<br />}<br /></pre>I think there is nothing to explain here. <code>dataExists()</code> is simply a <code>boolean</code> method that initially returns <code>false</code> but will eventually return <code>true</code> once the background task (<code>addDataToDB()</code>) is done. In other words we assume that background task introduces some side effect and <code>dataExists()</code> can detect that side effect. BTW I happened to have JDK 8 with Lambda support installed and IntelliJ IDEA gives me this nice tooltip:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-3Fn91HMIPvc/UYfnp7lpN7I/AAAAAAAAAv0/t8O7Xgdowks/s1600/lambda-intentions.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-3Fn91HMIPvc/UYfnp7lpN7I/AAAAAAAAAv0/t8O7Xgdowks/s1600/lambda-intentions.png" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-RSNouUh07SE/UYfnrvUQutI/AAAAAAAAAv8/Z7Z2ULbnjk0/s1600/lambda-intentions2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><br /></a></div>Suddenly I get this Java 8-compatible alternative suggested:<br /><br /><pre class="brush: java">private Callable&lt;Boolean&gt; recordInserted() {<br />    return () -&gt; dataExists();<br />}<br /></pre>But there's more:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-RSNouUh07SE/UYfnrvUQutI/AAAAAAAAAv8/Z7Z2ULbnjk0/s1600/lambda-intentions2.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-RSNouUh07SE/UYfnrvUQutI/AAAAAAAAAv8/Z7Z2ULbnjk0/s1600/lambda-intentions2.png" /></a></div><br /><br />Which transforms my code to:<br /><br /><pre class="brush: java">private Callable&lt;Boolean&gt; recordInserted() {<br />    return this::dataExists;<br />}<br /></pre><code>this::</code> prefix means that <code>recordInsterted</code> is a method of current object. Just as well we can say <code>someDao::dataExists</code>. Simply put this syntax turns method into a function object we can pass around (this process is called <a href="http://nurkiewicz.blogspot.no/2012/04/eta-expansion-internals-in-scala.html"><i>eta expansion</i> in Scala</a>). By now <code>recordInsterted()</code> method is no longer that needed so I can inline it and remove it completely:<br /><br /><pre class="brush: java">await().atMost(10, SECONDS).until(this::dataExists);<br /></pre>I am not sure what I love more - the new lambda syntax or how IntelliJ IDEA takes pre-Java 8 code and retrofits it for me automatically (well, it's still a bit experimental, just reported <a href="http://youtrack.jetbrains.com/issue/IDEA-106670">IDEA-106670</a>). I can run this intention in IntelliJ project-wide, Lambda-enabling my whole code base in seconds. Sweet!<br /><br />But back to original problem. Awaitility helps a lot by providing decent API and some handy features. I use it extensively in combination with <a href="https://github.com/FluentLenium/FluentLenium">FluentLenium</a>. But periodically polling for state changes feels a bit like a workaround and still introduces minimal latency. But notice that running and synchronizing on asynchronous tasks is quite common and JDK already provides necessary facilities: <a href="http://nurkiewicz.blogspot.no/2013/02/javautilconcurrentfuture-basics.html"><code>Future</code> abstraction</a>! <br /><br /><h1><code>java.util.concurrent.Future</code></h1>To limit the scope of refactoring I will leave the original <code>new Thread()</code> approach for now and use <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/SettableFuture.html"><code>SettableFuture&lt;V&gt;</code> from Guava</a>. It is a <code>Future&lt;V&gt;</code> implementation that allows triggering completion or failure at any time, from any thread (see <a href="http://nurkiewicz.blogspot.no/2013/03/deferredresult-asynchronous-processing.html"><code>DeferredResult</code> - asynchronous processing in Spring MVC</a> for more advanced usage). As you can see the changes are quite small:<br /><br /><pre class="brush: java">public class ThreadWrapper {<br /><br />    public ListenableFuture&lt;Void&gt; doWork() {<br />        final SettableFuture&lt;Void&gt; future = SettableFuture.&lt;Void&gt;create();<br /><br />        Thread thread = new Thread() {<br /><br />            @Override<br />            public void run() {<br />                addDataToDB()<br />                //...<br /><br />                //last instruction<br />                future.set(null);<br />            }<br /><br />            private void addDataToDB() {<br />                // Dummy Code...<br />                // ...<br /><br />            }<br /><br />        };<br /><br />        thread.start();<br />        return future;<br />    }<br /><br />}<br /></pre><code>doWork()</code> now returns <a href="http://nurkiewicz.blogspot.no/2013/02/listenablefuture-in-guava.html"><code>ListenableFuture&lt;Void&gt;</code></a> with lifecycle controlled inside asynchronous task. We use <code>Void</code> but in reality you might want to return some asynchronous result instead. <code>future.set(null)</code> invocation in the end is crucial. It signals that future is fulfilled and all threads waiting for that future will be notified. Once again, in practice you would use e.g. <code>Future&lt;Integer&gt;</code> and then instead of <code>null</code> we would say <code>future.set(someInteger)</code>. Here <code>null</code> is just a placeholder for <code>Void</code> type.<br /><br />How does this help us? Test code can now rely on future completion:<br /><br /><pre class="brush: java">final ListenableFuture&lt;Void&gt; future = wrapper.doWork();<br />future.get(10, SECONDS);<br /></pre><code>future.get()</code> blocks until future is done (with timeout), i.e. until we call <code>future.set(...)</code>. BTW I use <code>ListenableFuture</code> from Guava but Java 8 introduces equivalent and standard <a href="http://download.java.net/lambda/b88/docs/api/java/util/concurrent/CompletableFuture.html"><code>CompletableFuture</code></a> - I will write about it soon.<br /><br />So, we are getting somewhere. <code>Future&lt;T&gt;</code> is a useful abstraction for waiting and signalling completion of background jobs. But there is also one immense advantage of <code>Future</code> which are not taking, <i>ekhm</i>, advantage from - exception handling and propagation. <code>Future.get()</code> will block until future is complete and return asynchronous result <i>or</i> throw an exception initially thrown from our job. This is really useful for asynchronous tests. Currently if <code>Thread.run()</code> throws an exception it may or may not be logged or visible to us and future will never be completed. With Awaitility it's slightly better - it will timeout without any meaningful reason, which have to be tracked down manually in console/logs. But with minor modification our test is much more verbose:<br /><br /><pre class="brush: java">public void run() {<br />    try {<br />        addDataToDB()<br />        //...<br />        future.set(null);<br />    } catch (Exception e) {<br />        future.setException(e);<br />    }<br />}<br /></pre>If some exception occurs in asynchronous job, it will pop-up and be shown as JUnit/TestNG failure reason.<br /><br /><h1><code>(Listening)ExecutorService</code></h1>That's it. If <code>addDataToDB()</code> throws an exception it will not be lost. Instead our <code>future.get()</code> in test will re-throw that exception for us. Our test won't simply timeout leaving us with no clue what went wrong. Great, but do we really have to create this special <code>SettableFuture&lt;T&gt;</code> instance, can't we just use existing libraries that already give us <code>Future&lt;T&gt;</code> with correct underlying implementation? Of course! By this requires further refactoring:<br /><br /><pre class="brush: java">import com.google.common.util.concurrent.ListeningExecutorService;<br />import com.google.common.util.concurrent.MoreExecutors;<br /><br />import java.util.concurrent.Executors;<br />import java.util.concurrent.Future;<br /><br />public class ThreadWrapper {<br /><br />    private final ListeningExecutorService executorService = <br />        MoreExecutors.listeningDecorator(<br />            Executors.newSingleThreadExecutor()<br />        );<br /><br />    public ListenableFuture&lt;?&gt; doWork() {<br />        Runnable job = new Runnable() {<br />            @Override<br />            public void run() {<br />                //...<br />            }<br />        };<br />        return executorService.submit(job);<br />    }<br /><br />}<br /></pre>This is what you've all been waiting for. Don't start new <code>Thread</code> all the time, use thread pool! I actually went one step further by using <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/ListeningExecutorService.html"><code>ListeningExecutorService</code></a> - an extension to <code>ExecutorService</code> that returns <code>ListenableFuture</code> instances (<a href="http://nurkiewicz.blogspot.no/2013/02/listenablefuture-in-guava.html">see why you want that</a>). But the solution doesn't require this, I just spread good practices. As you can see <code>Future</code> instance is now created and managed for us. The test is exactly the same but production code is cleaner and more robust.<br /><br /><h1><code>MoreExecutors.sameThreadExecutor()</code></h1>The final trick I want to show you involves dependency injection. First let's externalize the creation of a thread pool from <code>ThreadWrapper</code> class:<br /><br /><pre class="brush: java">private final ListeningExecutorService executorService;<br /><br />public ThreadWrapper() {<br />    this(Executors.newSingleThreadExecutor());<br />}<br /><br />public ThreadWrapper(ExecutorService executorService) {<br />    this.executorService = <br />        MoreExecutors.listeningDecorator(executorService);<br />}<br /></pre>We can now optionally supply custom <code>ExecutorService</code>. This is good for various other reasons, but for us it opens brand new testing opportunity: <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/MoreExecutors.html#sameThreadExecutor()"><code>MoreExecutors.sameThreadExecutor()</code></a>. This time we modify our test slightly:<br /><br /><pre class="brush: java">final ThreadWrapper wrapper = new ThreadWrapper(MoreExecutors.sameThreadExecutor());<br />wrapper.doWork().get();<br /></pre>See how we pass custom <code>ExecutorService</code>? It's a very special implementation that doesn't really maintain thread pool of any kind. Every time you <code>submit()</code> some task to that "pool" it will be executed in the same thread in a blocking manner. This means that we no longer have asynchronous test, even though the production code wasn't changed that much! <code>wrapper.doWork()</code> will block until "background" job finishes. The extra call to <code>get()</code> is still needed to make sure exceptions are propagated, but is guaranteed to never block (because the job is already done).<br /><br />Using the same thread to execute asynchronous task instead of a thread pool might have an unexpected results if you somehow depend on thread-based properties, e.g. transactions, security, <code>ThreadLocal</code>. However if you use standard <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html"><code>ThreadPoolExecutor</code></a> with <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html"><code>CallerRunsPolicy</code></a>, JDK already behaves this way if thread pool is overflowed. So it's not that unusual.<br /><br /><h1>Summary</h1>Testing asynchronous code is hard, but you have options. Several options. But one conclusion that strikes me is the side effect of our efforts. We refactored original code in order to make it testable. But the final production code is not only testable, but also much better structured and robust. Surprisingly it's even source-code compatible with previous version as we barely changed return type from <code>void</code> to <code>Future&lt;Void&gt;</code>.<br /><br />It seems to be a rule - testable code is often better designed and implemented. Unit test is the first client code using our library. It naturally forces us to to think more about consumers, not the implementation.<br /><br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>