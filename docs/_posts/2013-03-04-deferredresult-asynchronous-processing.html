---
layout: post
title: DeferredResult - asynchronous processing in Spring MVC
date: '2013-03-04T18:04:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- spring mvc
- multithreading
- spring
- concurrency
modified_time: '2013-03-04T18:06:04.755+01:00'
thumbnail: http://2.bp.blogspot.com/-tSz1Hu7uuIg/UTTTwyn1YII/AAAAAAAAAvc/owUHtCocfRU/s72-c/171343_128780373854441_7299017_o.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5027131012667709069
blogger_orig_url: https://www.nurkiewicz.com/2013/03/deferredresult-asynchronous-processing.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-tSz1Hu7uuIg/UTTTwyn1YII/AAAAAAAAAvc/owUHtCocfRU/s1600/171343_128780373854441_7299017_o.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://2.bp.blogspot.com/-tSz1Hu7uuIg/UTTTwyn1YII/AAAAAAAAAvc/owUHtCocfRU/s320/171343_128780373854441_7299017_o.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Bygd√∏y</td></tr></tbody></table><a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html"><code>DeferredResult</code></a> is a container for possibly not-yet-finished computation that will be available in future. Spring MVC uses it to represent asynchronous computation and take advantage of Servlet 3.0 <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html"><code>AsyncContext</code></a> asynchronous request handling. Just to give a quick impression how it works:<br /><br /><pre class="brush: java">@RequestMapping("/")<br />@ResponseBody<br />public DeferredResult&lt;String&gt; square() throws JMSException {<br />    final DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;&gt;();<br />    runInOtherThread(deferredResult);<br />    return deferredResult;<br />}<br /><br />private void runInOtherThread(DeferredResult&lt;String&gt; deferredResult) {<br />    //seconds later in other thread...<br />    deferredResult.setResult("HTTP response is: 42");<br />}<br /></pre>Normally once you leave controller handler method request processing is done. But not with <code>DeferredResult</code>. Spring MVC (using Servlet 3.0 capabilities) will hold on with the response, keeping idle HTTP connection. HTTP worker thread is no longer used, but HTTP connection is still open. Later some other thread will resolve <code>DeferredResult</code> by assigning some value to it. Spring MVC will immediately pick up this event and send response (<i>"HTTP response is: 42"</i> in this example) to the browser, finishing request processing.<br /><br />You might see some conceptual similarity between <code>Future&lt;V&gt;</code> and <code>DeferredResult</code> - they both represent computation with result available some time in the future. You might wonder, why Spring MVC doesn't allow us to simply return <code>Future&lt;V&gt;</code> but instead introduced new, proprietary abstraction? The reason is simply and once again shows <code>Future&lt;V&gt;</code> deficiencies. The whole point of asynchronous processing is avoid blocking threads. Standard <code>java.util.concurrent.Future</code> does not allow registering callbacks when computation is done - so you either need to devote one thread to block until future is done or use one thread to poll several futures periodically. However the latter option consumes more CPU and introduces latency. But <a href="http://nurkiewicz.blogspot.no/2013/02/listenablefuture-in-guava.html">superior <code>ListenableFuture&lt;V&gt;</code></a> from <a href="http://code.google.com/p/guava-libraries/">Guava</a> seems like a good fit? True, but Spring doesn't have a dependency on Guava, thankfully bridging these two APIs is pretty straightforward.<br /><br /><hr />But first have a look at previous part on <a href="http://nurkiewicz.blogspot.no/2013/02/implementing-custom-future.html">implementing custom <code>java.util.concurrent.Future&lt;V&gt;</code></a>. Admittedly it wasn't as simple as one might expect. Clean up, handling interruptions, locking and synchronization, maintaining state. A lot of boilerplate when everything we need is as simple as receiving a message and returning it from <code>get()</code>. Let us try to retrofit previous implementation of <code>JmsReplyFuture</code> to also implement more powerful <code>ListenableFuture</code> - so we can use it later in Spring MVC.<br /><br /><code>ListenableFuture</code> simply extends <i>standard</i> <code>Future</code> adding possibility to register callbacks (listeners). So an eager developer would simply sit down and add list of <code>Runnable</code> listeners to existing implementation:<br /><a name='more'></a><br /><br /><pre class="brush: java">public class JmsReplyFuture&lt;T extends Serializable&gt; implements ListenableFuture&lt;T&gt;, MessageListener {<br /><br />    private final List&lt;Runnable&gt; listeners = new ArrayList&lt;Runnable&gt;();<br /><br />    @Override<br />    public void addListener(Runnable listener, Executor executor) {<br />        listeners.add(listener);<br />    }<br /><br />    //...<br /></pre>But it's greatly oversimplified. Of course we must iterate over all listeners when future is done or exception occurs. If the future is already resolved when we add a listener, we must call that listener immediately. Moreover we ignore <code>executor</code> - according to API each listener may use a different thread pool supplied to <code>addListener()</code> so we must store pairs: <code>Runnable</code> + <code>Executor</code>. Last but not least <code>addListener()</code> is not thread safe. Eager developer would fix all this in a matter of an hour or two. And spend two more hours to fix bugs introduced in the meantime. And few more hours weeks later when another "impossible" bug pops-up on production. I am not eager. As a matter of fact, I am too lazy to write even the simplest implementation above. But I am desperate enough to hit <code>Ctrl</code> + <code>H</code> (<i>Subtypes</i> view in IntelliJ IDEA) on <code>ListenableFuture</code> and scan through available skeletal implementations tree. <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/AbstractFuture.html"><code>AbstractFuture&lt;V&gt;</code></a> - Bingo!<br /><br /><pre class="brush: java">public class JmsReplyListenableFuture&lt;T extends Serializable&gt; extends AbstractFuture&lt;T&gt; implements MessageListener {<br /><br />    private final Connection connection;<br />    private final Session session;<br />    private final MessageConsumer replyConsumer;<br /><br />    public JmsReplyListenableFuture(Connection connection, Session session, Queue replyQueue) throws JMSException {<br />        this.connection = connection;<br />        this.session = session;<br />        this.replyConsumer = session.createConsumer(replyQueue);<br />        this.replyConsumer.setMessageListener(this);<br />    }<br /><br />    @Override<br />    public void onMessage(Message message) {<br />        try {<br />            final ObjectMessage objectMessage = (ObjectMessage) message;<br />            final Serializable object = objectMessage.getObject();<br />            set((T) object);<br />            cleanUp();<br />        } catch (Exception e) {<br />            setException(e);<br />        }<br />    }<br /><br />    @Override<br />    protected void interruptTask() {<br />        cleanUp();<br />    }<br /><br />    private void cleanUp() {<br />        try {<br />            replyConsumer.close();<br />            session.close();<br />            connection.close();<br />        } catch (Exception e) {<br />            Throwables.propagate(e);<br />        }<br />    }<br />}<br /></pre>That's it, everything, compile and run. Almost 2x less code compared to <a href="http://nurkiewicz.blogspot.no/2013/02/implementing-custom-future.html">initial implementation</a> and we get much more powerful <code>ListenableFuture</code>. Most of the code is set up and clean up. <code>AbstractFuture</code> already implements <code>addListener()</code>, locking and state handling for us. All we have to do is call <code>set()</code> method when future is resolved (JMS reply arrives in our case). Moreover we finally support exceptions properly. Previously we simply ignored/rethrown them while now they are correctly wrapped and thrown from <code>get()</code> when accessed. Even if we weren't interested in <code>ListenableFuture</code> capabilities, <code>AbstractFuture</code> still helps us a lot. And we get <code>ListenableFuture</code> for free.<br /><br />Good programmers love writing code. Better ones <a href="http://devopsreactions.tumblr.com/post/44360857123">love <i>deleting</i> it</a>. Less to maintain, less to test, less to break. I am sometimes amazed how helpful Guava can be. Last time I was working with iterator-heavy piece of code. Data was generated dynamically and iterators could easily produce millions of items so I had no choice. Limited iterator API together with quite complex business logic is a recipe for endless amount of plumbing code. And then I found <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Iterators.html"><code>Iterators</code> utility class</a> and it saved my life. I suggest you to open <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/index.html">JavaDoc of Guava</a> and go through all packages, class by class. You'll thank me later.<br /><br /><hr />Once we have our custom <code>ListenableFuture</code> in place (obviously you can use any implementation) we can try integrating it with Spring MVC. Here is what we want to achieve:<br /><br /><ol><li>HTTP request comes in</li><li>We send a request to JMS queue</li><li>HTTP worker thread is no longer used, it can serve other requests</li><li>JMS listener asynchronously waits for a reply in temporary queue</li><li>Once the reply arrives we push it immediately as an HTTP response and the connection is done.</li></ol>First naive implementation using blocking <code>Future</code>:<br /><br /><pre class="brush: java">@Controller<br />public class JmsController {<br /><br />    private final ConnectionFactory connectionFactory;<br /><br />    public JmsController(ConnectionFactory connectionFactory) {<br />        this.connectionFactory = connectionFactory;<br />    }<br /><br />    @RequestMapping("/square/{value}")<br />    @ResponseBody<br />    public String square(@PathVariable double value) throws JMSException, ExecutionException, InterruptedException {<br />        final ListenableFuture&lt;Double&gt; responseFuture = request(value);<br />        return responseFuture.get().toString();<br />    }<br /><br />    //JMS API boilerplate<br />    private &lt;T extends Serializable&gt; ListenableFuture&lt;T&gt; request(Serializable request) throws JMSException {<br />        Connection connection = this.connectionFactory.createConnection();<br />        connection.start();<br />        final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);<br />        final Queue tempReplyQueue = session.createTemporaryQueue();<br />        final ObjectMessage requestMsg = session.createObjectMessage(request);<br />        requestMsg.setJMSReplyTo(tempReplyQueue);<br />        sendRequest(session.createQueue("square"), session, requestMsg);<br />        return new JmsReplyListenableFuture&lt;T&gt;(connection, session, tempReplyQueue);<br />    }<br /><br />    private void sendRequest(Queue queue, Session session, ObjectMessage requestMsg) throws JMSException {<br />        final MessageProducer producer = session.createProducer(queue);<br />        producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);<br />        producer.send(requestMsg);<br />        producer.close();<br />    }<br /><br />}<br /></pre>This implementation is not very fortunate. As a matter of fact we don't need <code>Future</code> at all as we are barely blocking on <code>get()</code>, synchronously waiting for a response. Let's try with <code>DeferredResult</code>:<br /><br /><pre class="brush: java">@RequestMapping("/square/{value}")<br />@ResponseBody<br />public DeferredResult&lt;String&gt; square(@PathVariable double value) throws JMSException {<br />    final DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;&gt;();<br />    final ListenableFuture&lt;Double&gt; responseFuture = request(value);<br />    Futures.addCallback(responseFuture, new FutureCallback&lt;Double&gt;() {<br />        @Override<br />        public void onSuccess(Double result) {<br />            deferredResult.setResult(result.toString());<br />        }<br /><br />        @Override<br />        public void onFailure(Throwable t) {<br />            deferredResult.setErrorResult(t);<br />        }<br />    });<br />    return deferredResult;<br />}<br /></pre>Much more complex, but will also be much more scalable. This method takes almost no time to execute and HTTP worker thread is shortly after ready to handle another request. The biggest observation to make is that <code>onSuccess()</code> and <code>onFailure()</code> are executed by another thread, seconds or even minutes later. But HTTP worker thread pool is not exhausted and application remains responsive.<br /><br />This was a school book example, but can we do better? First attempt is to write generic adapter from <code>ListenableFuture</code> to <code>DeferredResult</code>. These two abstractions represent exactly the same thing, but with different API. It's quite straightforward:<br /><br /><pre class="brush: java">public class ListenableFutureAdapter&lt;T&gt; extends DeferredResult&lt;String&gt; {<br /><br />    public ListenableFutureAdapter(final ListenableFuture&lt;T&gt; target) {<br />        Futures.addCallback(target, new FutureCallback&lt;T&gt;() {<br />            @Override<br />            public void onSuccess(T result) {<br />                setResult(result.toString());<br />            }<br /><br />            @Override<br />            public void onFailure(Throwable t) {<br />                setErrorResult(t);<br />            }<br />        });<br />    }<br />}<br /></pre>We simply extend <code>DeferredResult</code> and notify it using <code>ListenableFuture</code> callbacks. Usage is simple:<br /><br /><pre class="brush: java">@RequestMapping("/square/{value}")<br />@ResponseBody<br />public DeferredResult&lt;String&gt; square(@PathVariable double value) throws JMSException {<br />    final ListenableFuture&lt;Double&gt; responseFuture = request(value);<br />    return new ListenableFutureAdapter&lt;&gt;(responseFuture);<br />}<br /></pre>But we can do even better! If <code>ListenableFuture</code> and <code>DeferredResult</code> are so similar, why not simply return <code>ListenableFuture</code> from the controller handler method?<br /><br /><pre class="brush: java">@RequestMapping("/square/{value}")<br />@ResponseBody<br />public ListenableFuture&lt;Double&gt; square2(@PathVariable double value) throws JMSException {<br />    final ListenableFuture&lt;Double&gt; responseFuture = request(value);<br />    return responseFuture;<br />}<br /></pre>Well, it won't work because Spring doesn't understand <code>ListenableFuture</code> and will just blow up. Fortunately Spring MVC is very flexible and it allows us to easily register new <i>so-called</i> <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/web/method/support/HandlerMethodReturnValueHandler.html"><code>HandlerMethodReturnValueHandler</code></a>. There are 12 such built-in handlers and every time we return some object from a controller, Spring MVC examines them in predefined order and chooses the first one that can handle given type. One such handler is <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/web/context/request/async/DeferredResult.DeferredResultHandler.html"><code>DeferredResultHandler</code></a> (name says it all) which we will use as a reference:<br /><br /><pre class="brush: java">public class ListenableFutureReturnValueHandler implements HandlerMethodReturnValueHandler {<br /><br />    public boolean supportsReturnType(MethodParameter returnType) {<br />        Class&lt;?&gt; paramType = returnType.getParameterType();<br />        return ListenableFuture.class.isAssignableFrom(paramType);<br />    }<br /><br />    public void handleReturnValue(Object returnValue,<br />                                  MethodParameter returnType, ModelAndViewContainer mavContainer,<br />                                  NativeWebRequest webRequest) throws Exception {<br /><br />        if (returnValue == null) {<br />            mavContainer.setRequestHandled(true);<br />            return;<br />        }<br /><br />        final DeferredResult&lt;Object&gt; deferredResult = new DeferredResult&lt;&gt;();<br />        Futures.addCallback((ListenableFuture&lt;?&gt;) returnValue, new FutureCallback&lt;Object&gt;() {<br />            @Override<br />            public void onSuccess(Object result) {<br />                deferredResult.setResult(result.toString());<br />            }<br /><br />            @Override<br />            public void onFailure(Throwable t) {<br />                deferredResult.setErrorResult(t);<br />            }<br />        });<br />        WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer);<br />    }<br /><br />}<br /></pre>Running out of karma, installing this handler is not as straightforward as I had hoped. Technically there is <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurerAdapter.html#addReturnValueHandlers(java.util.List)"><code>WebMvcConfigurerAdapter.addReturnValueHandlers()</code></a> which we can easily override if using Java configuration for Spring MVC. But this method adds custom return value handler at the end of handlers chain and for reasons beyond the scope of this article we need to add it at the beginning (higher priority). Fortunately with a little bit of hacking we can achieve that as well:<br /><br /><pre class="brush: java">@Configuration<br />@EnableWebMvc<br />public class SpringConfig extends WebMvcConfigurerAdapter {<br /><br />    @Resource<br />    private RequestMappingHandlerAdapter requestMappingHandlerAdapter;<br /><br />    @PostConstruct<br />    public void init() {<br />        final List&lt;HandlerMethodReturnValueHandler&gt; originalHandlers = new ArrayList&lt;&gt;(requestMappingHandlerAdapter.getReturnValueHandlers().getHandlers());<br />        originalHandlers.add(0, listenableFutureReturnValueHandler());<br />        requestMappingHandlerAdapter.setReturnValueHandlers(originalHandlers);<br />    }<br /><br />    @Bean<br />    public HandlerMethodReturnValueHandler listenableFutureReturnValueHandler() {<br />        return new ListenableFutureReturnValueHandler();<br />    }<br /><br />}<br /></pre><h2>Summary</h2>In this article we familiarized ourselves with another incarnation of future/promise abstraction called <code>DeferredResult</code>. It is used to postpone handling of HTTP request until some asynchronous task finishes. Thus <code>DeferredResult</code> is great for web GUIs built on top of event-driven systems, message brokers, etc. It is not as powerful as raw Servlet 3.0 API though. For example we cannot stream multiple events as they arrive (e.g. new tweets) in long-running HTTP connection - Spring MVC is designed more toward request-response pattern.<br /><br />We also tweaked Spring MVC to allow returning <code>ListenableFuture</code> from Guava directly from controller method. It makes our code much cleaner and expressive.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>