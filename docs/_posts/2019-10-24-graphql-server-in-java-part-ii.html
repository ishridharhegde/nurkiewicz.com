---
layout: post
title: 'GraphQL server in Java: Part II: Understanding Resolvers'
date: '2019-10-24T20:43:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- graphql
modified_time: '2020-03-24T01:27:25.567+01:00'
thumbnail: https://1.bp.blogspot.com/-ejICtIh9pXE/XbHwMK0h6MI/AAAAAAAAwoM/sEPvhGE8MaYDNNKQN6_8an4VtBWzn31ywCLcBGAsYHQ/s72-c/IMG_0642.JPG
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2132388239224386004
blogger_orig_url: https://www.nurkiewicz.com/2019/10/graphql-server-in-java-part-ii.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-ejICtIh9pXE/XbHwMK0h6MI/AAAAAAAAwoM/sEPvhGE8MaYDNNKQN6_8an4VtBWzn31ywCLcBGAsYHQ/s1600/IMG_0642.JPG" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="1200" data-original-width="1600" height="150" src="https://1.bp.blogspot.com/-ejICtIh9pXE/XbHwMK0h6MI/AAAAAAAAwoM/sEPvhGE8MaYDNNKQN6_8an4VtBWzn31ywCLcBGAsYHQ/s200/IMG_0642.JPG" width="200" /></a></div>In <a href="{{ site.baseurl }}{% post_url 2019-10-01-graphql-server-in-java-part-i-basics %}">part I</a> we developed a really simple GraphQL server. That solution has a serious flaw: all fields are loaded eagerly on the backend, even if they weren’t requested by the front-end. We sort of accept this situation with RESTful services by not giving clients any choice. RESTful API always returns everything, which implies always loading everything. If, on the other hand, you split RESTful API into multiple smaller resources, you risk N+1 problem and multiple network round trips. GraphQL was specifically designed to address these issues:<br /><br /><ul><li>fetch only required data to avoid extra network traffic as well as unnecessary work on the backend</li><li>allow fetching as much data as needed by the client in a single request to reduce overall latency</li></ul>RESTful APIs make arbitrary decision how much data to return, therefore can hardly ever fix the aforementioned issues. It’s either over- or under-fetching. OK, that’s theory, but our implementation of GraphQL server doesn’t work this way. It still fetches all the data, irrespective whether it was requested or not. Sad.<br /><br /><h2 id="evolving-your-api">Evolving your API</h2>To <a href="{{ site.baseurl }}{% post_url 2019-10-01-graphql-server-in-java-part-i-basics %}">recap</a> our API returns an instance <code>Player</code> DTO:<br /><br /><pre class="prettyprint linenums">@Value<br />class Player {<br />    UUID id;<br />    String name;<br />    int points;<br />    ImmutableList&lt;Item&gt; inventory;<br />    Billing billing;<br />}</pre>that matches this GraphQL schema:<br /><br /><pre class="prettyprint linenums">type Player {<br />    id: String!<br />    name: String!<br />    points: Int!<br />    inventory: [Item!]!<br />    billing: Billing!<br />}</pre>By carefully profiling our application I realized that very few clients ask for <code>billing</code> in their queries, yet we must always ask <code>billingRepository</code> in order to create <code>Player</code> instance. A lot of eager, unneeded work:<br /><br /><pre class="prettyprint linenums">private final BillingRepository billingRepository;<br />private final InventoryClient inventoryClient;<br />private final PlayerMetadata playerMetadata;<br />private final PointsCalculator pointsCalculator;<br /><br />//...<br /><br />@NotNull<br />private Player somePlayer() {<br />    UUID playerId = UUID.randomUUID();<br />    return new Player(<br />            playerId,<br />            playerMetadata.lookupName(playerId),<br />            pointsCalculator.pointsOf(playerId),<br />            inventoryClient.loadInventory(playerId),<br />            billingRepository.forUser(playerId)<br />    );<br />}</pre>Fields like <code>billing</code> must only be loaded when requested! In order to understand how to make some parts of our object <em>graph</em> (<em>Graph</em>-QL! duh!) loaded lazily, let’s add a new property called <code>trustworthiness</code> on a <code>Player</code>:<br /><br /><pre class="prettyprint linenums">type Player {<br />    id: String!<br />    name: String!<br />    points: Int!<br />    inventory: [Item!]!<br />    billing: Billing!<br />    trustworthiness: Float!<br />}</pre>This change is backwards compatible. As a matter of fact, GraphQL doesn’t really have a notion of API versioning. What is the migration path then? There are a few scenarios:<br /><br /><ul><li>you mistakenly gave new schema to clients without implementing the server. In that case, the client fails fast because it requested <code>trustworthiness</code> field that the server is not yet capable of delivering. Good. With RESTful API, on the other hand, the client believes the server is going to return some data. This can lead to unexpected errors or assumptions that the server intentionally returned <code>null</code> (missing field)<br /><br /></li><li>you added <code>trustworthiness</code> field but did not distribute new schema. This is OK. Clients are unaware of <code>trustworthiness</code> so they don’t request it.<br /><br /></li><li>you distributed new schema to clients once the server was ready. Clients may or may not use new data. That’s OK.<br /><br /></li></ul>But what if you made a mistake and announced to all the clients that the new version of the server supports certain schema whereas in fact, it doesn’t? In other words, server pretends to support <code>trustworthiness</code>, but it doesn’t know how to calculate it when asked. Is this even possible? <strong>NO</strong>:<br /><br /><pre class="prettyprint linenums">Caused by: [...]FieldResolverError: No method or field found as defined in schema [...] with any of the following signatures [...], in priority order:<br /><br />  com.nurkiewicz.graphql.Player.trustworthiness()<br />  com.nurkiewicz.graphql.Player.getTrustworthiness()<br />  com.nurkiewicz.graphql.Player.trustworthiness</pre>This happens on startup of the server! If you change the schema without implementing the underlying server, it won’t even boot up! This is fantastic news. If you announce that you support certain schema, it’s impossible to ship an application that doesn’t. This is a safety net when evolving your API. You only deliver schema to clients when it’s supported on the server. And when the server announces certain schema, you can be 100% sure it’s working and properly formatted. No more missing fields in the response because you are asking the older version of the server. No more broken servers that pretend to support certain API version, whereas in reality, you forgot to add a field to a response object.<br /><br /><h2 id="replacing-eager-value-with-lazy-resolver">Replacing eager value with lazy <code>Resolver</code></h2>Alright, so how do I add <code>trustworthiness</code> to comply with the new schema? The <em>not-so-smart</em> tip is right there in the exception that prevented our application to start. It says it was trying to find a method, getter or field for <code>trustworthiness</code>. If we blindly add it to the <code>Player</code> class, API would work. What’s the problem then? Remember, when changing the schema, old clients are unaware of <code>trustworthiness</code>. New clients, even aware of it, may still never or rarely request it. In other words, the value of <code>trustworthiness</code> needs to be calculated for just a fraction of requests. Unfortunately, because <code>trustworthiness</code> is a field on a <code>Player</code> class, we must always calculate it eagerly. Otherwise, it’s impossible to instantiate and return response object. Interestingly with RESTful API, this is typically not a problem. Just load and return everything, let clients decide, what to ignore. But we can do better.<br /><br />First, remove <code>trustworthiness</code> field from <code>Player</code> DTO. We have to go deeper, I mean lazier. Instead, create the following component:<br /><br /><pre class="prettyprint linenums">import com.coxautodev.graphql.tools.GraphQLResolver;<br />import org.springframework.stereotype.Component;<br /><br />@Component<br />class PlayerResolver implements GraphQLResolver&lt;Player&gt; {<br /><br />}</pre>Keep it empty, GraphQL engine will guide us. When trying to run the application one more time, the exception is familiar, but not the same:<br /><br /><pre class="prettyprint linenums">FieldResolverError: No method or field found as defined in schema [...] with any of the following signatures [...], in priority order:<br /><br />  com.nurkiewicz.graphql.PlayerResolver.trustworthiness(com.nurkiewicz.graphql.Player)<br />  com.nurkiewicz.graphql.PlayerResolver.getTrustworthiness(com.nurkiewicz.graphql.Player)<br />  com.nurkiewicz.graphql.PlayerResolver.trustworthiness<br />  com.nurkiewicz.graphql.Player.trustworthiness()<br />  com.nurkiewicz.graphql.Player.getTrustworthiness()<br />  com.nurkiewicz.graphql.Player.trustworthiness</pre><code>trustworthiness</code> is looked for not only on the <code>Player</code> class, but also on <code>PlayerResolver</code> that we just created. Can you spot the difference between these signatures?<br /><br /><ul><li><code>PlayerResolver.getTrustworthiness(Player)</code></li><li><code>Player.getTrustworthiness()</code></li></ul>The former method takes <code>Player</code> as an argument whereas the latter is an instance method (getter) on <code>Player</code> itself. What is the purpose of <code>PlayerResolver</code>? By default, each type in your GraphQL schema uses default resolver. That resolver basically takes an instance of e.g.&nbsp;<code>Player</code> and examines getters, methods and fields. However, you can decorate that default resolver with a more sophisticated one. One, that can lazily calculate field for a given name. Especially when such field is absent in <code>Player</code> class. Most importantly, that resolver is only invoked when the client actually requested said field. Otherwise, we fall back to default resolver that expects all fields to be part of the <code>Player</code> object itself. So how do you implement a custom resolver for <code>trustworthiness</code>? The exception will guide you:<br /><br /><pre class="prettyprint linenums">@Component<br />class PlayerResolver implements GraphQLResolver&lt;Player&gt; {<br /><br />    float trustworthiness(Player player) {<br />        //slow and painful business logic here...<br />        return 42;<br />    }<br /><br />}</pre>Of course, in the real world, the implementation would do something clever. Take a <code>Player</code>, apply some business logic, etc. What’s really important is that if the client doesn’t want to know <code>trustworthiness</code>, this method is never called. Lazy! See for yourself by adding some logs or metrics. That’s right, metrics! This approach also gives you great insight into your API. Clients are very explicit, asking only for necessary fields. Therefore you can have metrics for each resolver and quickly figure out, which fields are used and which are dead and can be deprecated or removed. Also, you can easily discover which particular field is costly to load. Such fine-grained control is impossible with RESTful APIs, with their all-or-nothing approach. In order to decommission a field with RESTful API, you must create a new version of the resource and encourage all clients to migrate.<br /><br /><h2 id="lazy-all-the-things">Lazy all the things</h2>If you want to be extra lazy and consume as little resources as possible, every single field of the <code>Player</code> may be delegated to the resolver. The schema remains the same, but the <code>Player</code> class becomes hollow:<br /><br /><pre class="prettyprint linenums">@Value<br />class Player {<br />    UUID id;<br />}</pre>So how does GraphQL know how to calculate <code>name</code>, <code>points</code>, <code>inventory</code>, <code>billing</code> and <code>trustworthiness</code>? Well, there is a method on a resolver for each one of these:<br /><br /><pre class="prettyprint linenums">@Component<br />class PlayerResolver implements GraphQLResolver&lt;Player&gt; {<br /><br />    String name(Player player) {<br />        //...<br />    }<br /><br />    int points(Player player) {<br />        //...<br />    }<br /><br />    ImmutableList&lt;Item&gt; inventory(Player player) {<br />        //...<br />    }<br /><br />    Billing billing(Player player) {<br />        //...<br />    }<br /><br />    float trustworthiness(Player player) {<br />        //...<br />    }<br /><br />}</pre>The implementation is unimportant. What’s important is laziness: these methods are only invoked when certain field was requested. Each of these methods can be monitored, optimized and tested separately. Which is great from a performance perspective.<br /><br /><h2 id="performance-problem">Performance problem</h2>Did you notice that <code>inventory</code> and <code>billing</code> fields are unrelated to each other? I.e. fetching <code>inventory</code> may require calling some downstream service whereas <code>billing</code> needs an SQL query. Unfortunately, GraphQL engine assembles response in a sequential matter. We’ll fix that in the next instalment, stay tuned!<br /><br /> <ul><li><a href="{{ site.baseurl }}{% post_url 2019-10-01-graphql-server-in-java-part-i-basics %}">Part I: Basics</a></li><li>Part II: Understanding Resolvers</li><li><a href="{{ site.baseurl }}{% post_url 2020-03-23-graphql-server-in-java-part-iii %}">Part III: Improving concurrency</a></li><li><a href="https://github.com/nurkiewicz/graphql-server-demo">github.com/nurkiewicz/graphql-server-demo</a></li></ul>