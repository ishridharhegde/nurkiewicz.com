---
layout: post
title: Java features applicability
date: '2012-10-28T22:28:00.000+01:00'
author: Tomasz Nurkiewicz
tags: 
modified_time: '2012-10-28T23:38:14.725+01:00'
thumbnail: http://1.bp.blogspot.com/-d114xzObirE/UI2i1VPARNI/AAAAAAAAAog/ipIpS0hLNfE/s72-c/triangle.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4778318691311508573
blogger_orig_url: https://www.nurkiewicz.com/2012/10/java-features-applicability.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-d114xzObirE/UI2i1VPARNI/AAAAAAAAAog/ipIpS0hLNfE/s1600/triangle.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="256" src="http://1.bp.blogspot.com/-d114xzObirE/UI2i1VPARNI/AAAAAAAAAog/ipIpS0hLNfE/s320/triangle.png" width="320" /></a></div>Java language and standard library is powerful, but <a href="http://en.wikipedia.org/wiki/Uncle_Ben#.22With_great_power_comes_great_responsibility.22"><i>with great power comes great responsibility</i></a>. After seeing a lot of user code misusing or abusing rare Java features on one hand and completely forgetting about most basic feature on the other, I decided to compose this summary. This is <b>not</b> a list of requirements and areas every Java developer should explore, know and use. It's quite the opposite! I group Java features in three categories: <i>day to day</i>, <i>occasionally</i> and <i>never (frameworks and libraries only)</i>. The rule is simple: if you find yourself using given feature more often then suggested, you are probably over-engineering or trying to build something too general and too reusable. If you don't use given feature often enough (according to my subjective list), you're probably missing some really interesting and important opportunities.<br />Note that I only focus on Java, JVM and JDK. I do not suggest which frameworks and how likely you should use. Also I assume typical, server-side business-facing application.<br /><hr /><h4>Day to day</h4>The following features of the Java language are suppose to be used every day. If you have never seen some of them or find yourself using them very rarely, you might take a closer look, they are really helpful:<br /><a name='more'></a><br /><ul><li><b>classes, interfaces, packages</b> - seriously. Put your code in classes. You remember from the university that class is an encapsulated data + methods acting upon that data? Class with only state is barely a structure. Class with only methods is just a namespace enclosing functions. Also use interfaces whenever needed. But think twice before creating an interface with only one implementation. Maybe you don't need a middleman? Nevertheless, put everything in packages, following <a href="http://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html">well established naming convention</a>.<br /> </li><li><b>static methods</b> - don't be afraid of them. But use them only for stateless utility methods. Don't encode any business logic inside <code>static</code> method, ever.<br /> </li><li><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html"><b><code>ExecutorService</code> - thread pools</b></a> - creating and effectively using thread pools, understanding how queueing and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html"><code>Future&lt;T&gt;</code></a> works is a must. Don't reimplement thread pools, think about them every time someone says <i>producer-consumer</i>.<br /> </li><li><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html"><b><code>Atomic</code>-* family</b></a> - don't use <code>synchronized</code> to barely read/update some counter or reference atomically. <code>Atomic</code>-* family of classes use effective <a href="http://en.wikipedia.org/wiki/Compare-and-swap"><i>compare-and-swap</i></a> low-level instructions to be amazingly efficient. Make sure you understand the guarantees these classes provide.<br /> </li><li><b>design patterns</b> - Not technically a Java language part, but essential. You should, know, understand, and use them willingly but sparingly. Just like with interfaces - don't go overboard. <a href="http://www.amazon.com/gp/product/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;tag=javaandneighb-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0201633612">GoF</a> or even <a href="http://rcm.amazon.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=javaandneighb-20&amp;o=1&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=0321200683">EI patterns</a> should often occur in the code base. But let patterns emerge during your thought process, rather than you letting your thought process be driven by patterns.<br /> </li><li><b>built-in collections, including concurrent</b> - you absolutely must know and use built in collections, understanding the differences between <code>List</code>, <code>Map</code> and <code>Set</code>. Using thread-safe collections should not be an issue for you. Understand performance characteristics and have basic overview of the implementation behind them. This is really basic. Also know and use various <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a> implementations. Concurrency is hard, don't make it even harder by reimplementing some of this stuff yourself.<br /> </li><li><b>Built-in annotations</b> - annotations are here to stay, learn to use <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Override.html"><code>@Override</code></a> (and <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Deprecated.html"><code>@Deprecated</code></a> to some degree) every day consistently.<br /> </li><li><b>exceptions</b> - use unchecked exceptions to signal abnormal, exceptional failure that requires action being taken. Learn to live with checked exceptions. Learn to read stack traces.<br /> </li><li><a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html"><b>try-with-resources</b></a> - familiarize yourself with this fabulous language construct. Implement <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html"><code>AutoCloseable</code></a> if your class requires any cleanup.<br /> </li><li><b>Blocking IO</b> - using <a href="http://docs.oracle.com/javase/7/docs/api/java/io/Reader.html"><code>Reader</code></a>/<a href="http://docs.oracle.com/javase/7/docs/api/java/io/Writer.html"><code>Writer</code></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html"><code>InputStream</code></a>/<a href="http://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html"><code>OutputStream</code></a> classes is something you should be really familiar with. Understand the difference between them, using buffering and other decorators without fear.<br /> </li></ul>This ends the list of everyday tools you should use. If you've never heard of some of them or used them only occasionally, study them more carefully as they might become your lifesavers.<br /><hr /><h4>Occasionally</h4>Following are the language features you should not be afraid to use, but they should not be abused as well. If you find yourself exploiting them every day, if these are kind of features you see several times before lunch, there may be something wrong with your design. I am looking from a back-end, enterprise Java developer perspective. These types of features are useful, but not too often.<br /><ul><li><b>inheritance and abstract classes</b> - really, it turns out I don't use inheritance that often and I don't really miss it. Polymorphism driven by interfaces is by far more flexible, especially with a painful lack of traits in Java. Also prefer <a href="http://en.wikipedia.org/wiki/Composition_over_inheritance">composition over inheritance</a>. Too many levels of inheritance lead to very unmaintainable code.</li></ul><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-Qh7Yx5wvkEg/UI2i0dHdHhI/AAAAAAAAAoc/ezF1j5UUpT4/s1600/spring.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="175" src="http://1.bp.blogspot.com/-Qh7Yx5wvkEg/UI2i0dHdHhI/AAAAAAAAAoc/ezF1j5UUpT4/s400/spring.png" width="400" /></a></div><br /><ul><li><b>regular expressions</b> - <a href="http://en.wikiquote.org/wiki/Jamie_Zawinski"><i>Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.</i></a>. The world without regular expressions would be much more boring and cumbersome. They are wonderful for parsing regular languages (but <a href="http://stackoverflow.com/a/1732454">not HTML</a>) but its way too easy to overuse them. If you find yourself crafting, testing, fixing and coursing whole day in front of regular expressions, you are probably using wrong tool for the job. My all time favourite:<br /> <pre class="brush: java">public static boolean isNegative(int x) {<br />    return Integer.toString(x).matches("-[0-9]+");<br />}<br /></pre></li><li><b> <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html"><code>Semaphore</code></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html"><code>CountDownLatch</code></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html"><code>CyclicBarrier</code></a> and others</b> - they are all extremely useful better by an order of magnitude than infomous <code>wait()</code>/<code>notify()</code> pair. But even them won't prevent you from concurrency bugs when abused. Consider thread-safe collections or some frameworks when you see these synchronization mechanism too often.<br /> </li><li><b>generic types in user code</b> - using built-in collections and other classes that have generic types should not only be a day to day practice, it should be obvious for you. But I mean developing code yourself taking or returning generic types. Something like this:<br /> <pre class="brush: java">public &lt;T, F&gt; ContractValidator&lt;T extends Contract&gt; T validate(Validator&lt;T&gt;, F object)<br /></pre>It is sometimes necessary to use generics in your own code, but don't go too <i>meta-</i>. Of course static typing and type safety should be your priority, but maybe you can avoid too many generic, complex types?<br /> </li><li><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/scripting/programmer_guide/index.html"><b>Scripting languges in JVM</b></a> - do you know JDK has a built-in JavaScript interpreter? And that you can plug virtually any other language like Groovy or JRuby? Sometimes it's simpler to embed small script inside your application that can be changed even by the customer. It's not often, but in very fast changing markets redeploying might not be an option. Just remember that if the total number of lines of scripted code exceeds 1% of the total amount of your code, you should start worrying about maintenance.<br /> </li><li><a href="http://docs.oracle.com/javase/7/docs/api/java/nio/package-summary.html"><b>Java NIO</b></a> - it is hard to get it right and even harder to actually benefit from it. But in rare cases you actually have to use NIO to squeeze as much performance and scalability as you can. However prefer libraries that can do it for you. Also in normal circumstances blocking IO is typically enough.<br /> </li><li><b><code>synchronized</code> keyword</b> - you should not use it too often for a simple reason. The more often it's used, the more often it's executed, thus impacting performance. Consider thread-safe collections and atomic primitive wrappers instead. Also make sure you always understand which object is used as a mutex.<br /> </li></ul>I consider features above valuable and important, but not necessarily on a day-to-day basis. If you see any of them every single day it might be a sign of over-engineered design or... inexperienced developer. Simplicity comes with experience. However, you might also have very unusual requirements, which applies to the third group as well.<br /><hr /><h4>Never (think: framework and library developers only)</h4>You should know and understand the principles behind the features below in order to understand frameworks and libraries. And you must understand them to effectively us them, I see way too many questions on StackOverflow that could have been avoided if the person in question simply read the code of a library in use. But understanding doesn't mean use. You should almost never use them directly, they are mostly advanced, dirty and complicated. Even one occurrence of such feature can lead to major headaches.<br /><ul><li><b>sockets</b> - seriously, sockets. You must understand how TCP/IP stack works, be very conscious with regards to threading, careful when interpreting the data, vigilant with streams. Stay away from using pure sockets, there are hundreds of libraries wrapping them and providing higher level abstractions - HTTP, FTP, NTP, SMB, e-mail... (e.g. see <a href="http://commons.apache.org/net/">Apache Commons net</a>). You'll be amazed how hard it is to write decent HTTP client or server. And if you need to write a server for some proprietary protocol, definitely consider <a href="https://netty.io/">Netty</a>.<br /> </li><li><b>reflection</b> - there is no place for introspecting classes and methods in business code. Frameworks can't live without reflection, I can't live with. Reflection makes your code slower, unsafe and ugly. Typically AOP is just enough. I would even say that passing instances of <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html"><code>Class&lt;T&gt;</code></a> around is a code smell.<br /> </li><li><b>dynamic proxies and byte code manipulation</b> - <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html"><code>Proxy</code> class</a> is great, but just like reflection, should be used only by the frameworks and libraries that support you. They are a basic building block of lightweight AOP. If your business application (not framework or library, even <a href="http://code.google.com/p/mockito/">Mockito</a> uses these techniques!) requires byte code generation or manipulation (e.g. <a href="http://asm.ow2.org/">ASM</a> or <a href="http://cglib.sourceforge.net/">CGLIB</a>) - <del>you're in a deep sh**t</del> I will pray for you.<br /> </li><li><b>class loaders</b> - everything that has anything to do with class loaders. You must understand them, the hierarchy, bytecode, etc. But if you write your own class loaders, it's a road to hell. Not that it's so complicated, but it's probably unnecessary. Leave it to application servers.<br /> </li><li><b><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#clone()"><code>Object.html#clone()</code></a></b> - honestly, I don't remember if I ever used that method in my entire (Java developer's) life. I just... didn't... And I can't find any rationale behind using it. I either have an explicit copy constructor or better use immutable objects. Do you have any legitimate use cases for it? It seems so 1990s...<br /> </li><li><b>native methods</b> - there are a few in JDK, even for such small tasks like <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StrictMath.html#sin(double)">computing sine function</a>. But Java is no longer the slowest kid in the class, it's actually quite the opposite. Also I can't imagine what kind of logic you need that can't be achieved using standard library or 3rd-party libraries. Finally, native methods are quite hard to get right, and you can expect low-level, nasty errors, especially around memory management.<br /> </li><li><b>custom collections</b> - implementing brand new collection following all contracts defined in original JavaDoc is <a href="http://stackoverflow.com/questions/12761532">surprisingly hard</a>. Frameworks like Hibernate use special persistent collections. Very rarely you need a collection so specific to your requirements that none of the built-in ones are good enough.<br /> </li><li><b><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html"><code>ThreadLocal</code></a></b> - Libraries and frameworks use thread locals quite often. But you should never try to exploit them for two unrelated reasons. First of all, <code>ThreadLocal</code> is often a hidden semi-global parameter you want to sneak-in. This makes your code harder to reason about and test. Secondly, <code>ThreadLocal</code>s can easily introduce memory leaks when not cleaned up properly (see <a href="https://jira.mongodb.org/browse/JAVA-130">this</a>, <a href="http://stackoverflow.com/questions/5292349">this</a>, <a href="https://issues.apache.org/jira/browse/AXIS-935">this</a> and <a href="http://jira.qos.ch/browse/LOGBACK-450">this</a> and...)<br /> </li><li><b><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html">WeakReference</a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/ref/SoftReference.html">SoftReference</a></b> - these classes are quite low-level and are great when implementing caches playing well with garbage collection. Luckily there are plenty of open-source caching libraries, so you don't have to write one yourself. Understand what these classes do, but don't use them.<br /> </li><li><b><code>com.sun.*</code> and <code>sun.*</code> packages, especially <a href="http://www.docjar.com/docs/api/sun/misc/Unsafe.html"><code>sun.misc.Unsafe</code></a></b> - stay away from these packages, just... don't go there. There is no reason to explore these proprietary, undocumented and not guaranteed to preserve backward compatibility classes. Just pretend they're not there. And <a href="http://stackoverflow.com/questions/5574241">why would you use <code>Unsafe</code></a>?<br /> </li></ul><hr />Of course the list above is completely subjective and most likely not definitive. I encourage you to comment and suggest, if you feel some items are in wrong place or maybe something is missing entirely. I would like to build a summary that can be given as a reference during code review or when a project is evaluated.