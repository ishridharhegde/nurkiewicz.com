---
layout: post
title: Spring Data JDBC generic DAO implementation - most lightweight ORM ever
date: '2013-01-20T18:10:00.001+01:00'
author: Tomasz Nurkiewicz
tags:
- jdbc
- jpa
- orm
- spring
modified_time: '2013-01-20T18:11:13.470+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4712263257384501650
blogger_orig_url: https://www.nurkiewicz.com/2013/01/spring-data-jdbc-generic-dao.html
---

I am thrilled to announce first version of my <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository"><b>Spring Data JDBC repository</b></a> project. The purpose of this open source library is to provide generic, lightweight and easy to use DAO implementation for relational databases based on <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jdbc/core/JdbcTemplate.html"><code>JdbcTemplate</code></a> from <a href="http://www.springsource.org/spring-framework">Spring framework</a>, compatible with Spring Data umbrella of projects.<br /><br /><h2>Design objectives</h2><ul><li>Lightweight, fast and low-overhead. Only a handful of classes, <b>no XML, annotations, reflection</b></li><li><b>This is not full-blown ORM</b>. No relationship handling, lazy loading, dirty checking, caching</li><li>CRUD implemented in seconds</li><li>For small applications where JPA is an overkill</li><li>Use when simplicity is needed or when future migration e.g. to JPA is considered</li><li>Minimalistic support for database dialect differences (e.g. transparent paging of results)</li></ul><h2>Features</h2>Each DAO provides built-in support for:<br /><br /><ul><li>Mapping to/from domain objects through <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jdbc/core/RowMapper.html"><code>RowMapper</code></a> abstraction</li><li>Generated and user-defined primary keys</li><li>Extracting generated key</li><li>Compound (multi-column) primary keys</li><li>Immutable domain objects</li><li>Paging (requesting subset of results)</li><li>Sorting over several columns (database agnostic)</li><li>Optional support for <i>many-to-one</i> relationships</li><li>Supported databases (continuously tested):<ul><li>MySQL</li><li>PostgreSQL</li><li>H2</li><li>HSQLDB</li><li>Derby</li><li>...and most likely most of the others</li></ul></li><li>Easily extendable to other database dialects via <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/main/java/com/blogspot/nurkiewicz/jdbcrepository/sql/SqlGenerator.java"><code>SqlGenerator</code></a> class.</li><li>Easy retrieval of records by ID</li></ul><h2>API</h2>Compatible with Spring Data <a href="http://static.springsource.org/spring-data/data-commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html"><code>PagingAndSortingRepository</code></a> abstraction, <b>all these methods are implemented for you</b>:<br /><br /><pre class="brush: java">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; {<br />             T  save(T entity);<br />    Iterable&lt;T&gt; save(Iterable&lt;? extends T&gt; entities);<br />             T  findOne(ID id);<br />        boolean exists(ID id);<br />    Iterable&lt;T&gt; findAll();<br />           long count();<br />           void delete(ID id);<br />           void delete(T entity);<br />           void delete(Iterable&lt;? extends T&gt; entities);<br />           void deleteAll();<br />    Iterable&lt;T&gt; findAll(Sort sort);<br />        Page&lt;T&gt; findAll(Pageable pageable);<br />}<br /></pre><code>Pageable</code> and <code>Sort</code> parameters are also fully supported, which means you get <b>paging and sorting by arbitrary properties for free</b>. For example say you have <code>userRepository</code> extending <code>PagingAndSortingRepository&lt;User, String&gt;</code> interface (implemented for you by the library) and you request 5th page of <code>USERS</code> table, 10 per page, after applying some sorting:<br /><br /><pre class="brush: java">Page&lt;User&gt; page = userRepository.findAll(<br />    new PageRequest(<br />        5, 10, <br />        new Sort(<br />            new Order(DESC, "reputation"), <br />            new Order(ASC, "user_name")<br />        )<br />    )<br />);<br /></pre>Spring Data JDBC repository library will translate this call into (PostgreSQL syntax):<br /><br /><pre class="brush: sql">SELECT *<br />FROM USERS<br />ORDER BY reputation DESC, user_name ASC<br />LIMIT 50 OFFSET 10<br /></pre>...or even (Derby syntax):<br /><br /><pre class="brush: sql">SELECT * FROM (<br />    SELECT ROW_NUMBER() OVER () AS ROW_NUM, t.*<br />    FROM (<br />        SELECT * <br />        FROM USERS <br />        ORDER BY reputation DESC, user_name ASC<br />        ) AS t<br />    ) AS a <br />WHERE ROW_NUM BETWEEN 51 AND 60<br /></pre>No matter which database you use, you'll get <code>Page&lt;User&gt;</code> object in return (you still have to provide <code>RowMapper&lt;User&gt;</code> yourself to translate from <a href="http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html"><code>ResultSet</code></a> to domain object. If you don't know Spring Data project yet, <a href="http://static.springsource.org/spring-data/commons/docs/current/api/org/springframework/data/domain/Page.html"><code>Page&lt;T&gt;</code></a> is a wonderful abstraction, not only encapsulating <code>List&lt;User&gt;</code>, but also providing metadata such as total number of records, on which page we currently are, etc.<br /><br /><h2>Reasons to use</h2><ul><li>You consider migration to JPA or even some NoSQL database in the future.<br /><br /> Since your code will rely only on methods defined in <a href="http://static.springsource.org/spring-data/data-commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html"><code>PagingAndSortingRepository</code></a> and <a href="http://static.springsource.org/spring-data/data-commons/docs/current/api/org/springframework/data/repository/CrudRepository.html"><code>CrudRepository</code></a> from <a href="http://www.springsource.org/spring-data/commons">Spring Data Commons</a> umbrella project you are free to switch from <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/main/java/com/blogspot/nurkiewicz/jdbcrepository/JdbcRepository.java"><code>JdbcRepository</code></a> implementation (from this project) to: <a href="http://static.springsource.org/spring-data/data-jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html"><code>JpaRepository</code></a>, <a href="http://static.springsource.org/spring-data/data-mongodb/docs/current/api/org/springframework/data/mongodb/repository/MongoRepository.html"><code>MongoRepository</code></a>, <a href="http://static.springsource.org/spring-data-gemfire/docs/current/api/org/springframework/data/gemfire/repository/GemfireRepository.html"><code>GemfireRepository</code></a> or <a href="http://static.springsource.org/spring-data/data-graph/docs/current/api/org/springframework/data/neo4j/repository/GraphRepository.html"><code>GraphRepository</code></a>. They all implement the same common API. Of course don't expect that switching from JDBC to JPA or MongoDB will be as simple as switching imported JAR dependencies - but at least you minimize the impact by using same DAO API.<br /><br /> </li><li>You need a fast, simple JDBC wrapper library. JPA or even <a href="http://blog.mybatis.org/">MyBatis</a> is an overkill<br /><br /> </li><li>You want to have full control over generated SQL if needed<br /><br /> </li><li>You want to work with objects, but don't need lazy loading, relationship handling, multi-level caching, dirty checking... You need <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> and not much more<br /><br /> </li><li>You want to by <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself"><i>DRY</i></a><br /><br /> </li><li>You are already using Spring or maybe even <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jdbc/core/JdbcTemplate.html"><code>JdbcTemplate</code></a>, but still feel like there is too much manual work<br /><br /> </li><li>You have very few database tables<br /><br /> </li></ul><h2>Getting started</h2>For more examples and working code don't forget to examine <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/tree/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository">project tests</a>.<br /><br /><h3>Prerequisites</h3>Maven coordinates:<br /><br /><pre class="brush: xml">&lt;dependency&gt;<br />    &lt;groupId&gt;com.blogspot.nurkiewicz&lt;/groupId&gt;<br />    &lt;artifactId&gt;jdbcrepository&lt;/artifactId&gt;<br />    &lt;version&gt;0.1&lt;/version&gt;<br />&lt;/dependency&gt;<br /></pre>Unfortunately the project <b>is not yet in maven central repository</b>. For the time being you can install the library in your local repository by cloning it:<br /><br /><pre class="brush: java">$ git clone git://github.com/nurkiewicz/spring-data-jdbc-repository.git<br />$ git checkout 0.1<br />$ mvn javadoc:jar source:jar install<br /></pre><hr />In order to start your project must have <code>DataSource</code> bean present and transaction management enabled. Here is a minimal MySQL configuration:<br /><br /><pre class="brush: java">@EnableTransactionManagement<br />@Configuration<br />public class MinimalConfig {<br /><br />    @Bean<br />    public PlatformTransactionManager transactionManager() {<br />        return new DataSourceTransactionManager(dataSource());<br />    }<br /><br />    @Bean<br />    public DataSource dataSource() {<br />        MysqlConnectionPoolDataSource ds = new MysqlConnectionPoolDataSource();<br />        ds.setUser("user");<br />        ds.setPassword("secret");<br />        ds.setDatabaseName("db_name");<br />        return ds;<br />    }<br /><br />}<br /></pre><h3>Entity with auto-generated key</h3>Say you have a following database table with auto-generated key (MySQL syntax):<br /><br /><pre class="brush: sql">CREATE TABLE COMMENTS (<br />    id INT AUTO_INCREMENT,<br />    user_name varchar(256),<br />    contents varchar(1000),<br />    created_time TIMESTAMP NOT NULL,<br />    PRIMARY KEY (id)<br />);<br /></pre>First you need to create domain object <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository/repositories/User.java"><code>User</code></a> mapping to that table (just like in any other ORM):<br /><br /><pre class="brush: java">public class Comment implements Persistable&lt;Integer&gt; {<br /><br />    private Integer id;<br />    private String userName;<br />    private String contents;<br />    private Date createdTime;<br /><br />    @Override<br />    public Integer getId() {<br />        return id;<br />    }<br /><br />    @Override<br />    public boolean isNew() {<br />        return id == null;<br />    }<br /><br />    //getters/setters/constructors/...<br />}<br /></pre>Apart from standard Java boilerplate you should notice implementing <a href="http://static.springsource.org/spring-data/commons/docs/current/api/org/springframework/data/domain/Persistable.html"><code>Persistable&lt;Integer&gt;</code></a> where <code>Integer</code> is the type of primary key. <code>Persistable&lt;T&gt;</code> is an interface coming from Spring Data project and it's the only requirement we place on your domain object.<br /><br />Finally we are ready to create our <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository/repositories/CommentRepository.java"><code>CommentRepository</code></a> DAO:<br /><br /><pre class="brush: java">@Repository<br />public class CommentRepository extends JdbcRepository&lt;Comment, Integer&gt; {<br /><br />    public CommentRepository() {<br />        super(ROW_MAPPER, ROW_UNMAPPER, "COMMENTS");<br />    }<br /><br />    public static final RowMapper&lt;Comment&gt; ROW_MAPPER = //see below<br /><br />    private static final RowUnmapper&lt;Comment&gt; ROW_UNMAPPER = //see below<br /><br />    @Override<br />    protected Comment postCreate(Comment entity, Number generatedId) {<br />        entity.setId(generatedId.intValue());<br />        return entity;<br />    }<br />}<br /></pre>First of all we use <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/stereotype/Repository.html"><code>@Repository</code></a> annotation to mark DAO bean. It enables persistence exception translation. Also such annotated beans are discovered by CLASSPATH scanning.<br /><br />As you can see we extend <code>JdbcRepository&lt;Comment, Integer&gt;</code> which is the central class of this library, providing implementations of all <code>PagingAndSortingRepository</code> methods. Its constructor has three required dependencies: <code>RowMapper</code>, <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/main/java/com/blogspot/nurkiewicz/jdbcrepository/RowUnmapper.java"><code>RowUnmapper</code></a> and table name. You may also provide ID column name, otherwise default <code>"id"</code> is used.<br /><br />If you ever used <code>JdbcTemplate</code> from Spring, you should be familiar with <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jdbc/core/RowMapper.html"><code>RowMapper</code></a> interface. We need to somehow extract columns from <code>ResultSet</code> into an object. After all we don't want to work with raw JDBC results. It's quite straightforward:<br /><br /><pre class="brush: java">    public static final RowMapper&lt;Comment&gt; ROW_MAPPER = new RowMapper&lt;Comment&gt;() {<br /><br />        @Override<br />        public Comment mapRow(ResultSet rs, int rowNum) throws SQLException {<br />            return new Comment(<br />                    rs.getInt("id"),<br />                    rs.getString("user_name"),<br />                    rs.getString("contents"),<br />                    rs.getTimestamp("created_time")<br />            );<br />        }<br />    };<br /></pre><code>RowUnmapper</code> comes from this library and it's essentially the opposite of <code>RowMapper</code>: takes an object and turns it into a <code>Map</code>. This map is later used by the library to construct SQL <code>CREATE</code>/<code>UPDATE</code> queries:<br /><br /><pre class="brush: java">    private static final RowUnmapper&lt;Comment&gt; ROW_UNMAPPER = new RowUnmapper&lt;Comment&gt;() {<br />        @Override<br />        public Map&lt;String, Object&gt; mapColumns(Comment comment) {<br />            Map&lt;String, Object&gt; mapping = new LinkedHashMap&lt;String, Object&gt;();<br />            mapping.put("id", comment.getId());<br />            mapping.put("user_name", comment.getUserName());<br />            mapping.put("contents", comment.getContents());<br />            mapping.put("created_time", new java.sql.Timestamp(comment.getCreatedTime().getTime()));<br />            return mapping;<br />        }<br />    };<br /></pre>If you never update your database table (just reading some reference data inserted elsewhere) you may skip <code>RowUnmapper</code> parameter or use <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/main/java/com/blogspot/nurkiewicz/jdbcrepository/MissingRowUnmapper.java"><code>MissingRowUnmapper</code></a>.<br /><br />Last piece of the puzzle is the <code>postCreate()</code> callback method which is called after an object was inserted. You can use it to retrieve generated primary key and update your domain object (or return new one if your domain objects are immutable). If you don't need it, just don't override <code>postCreate()</code>.<br /><br />Check out <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository/JdbcRepositoryGeneratedKeyTest.java"><code>JdbcRepositoryGeneratedKeyTest</code></a> for a working code based on this example.<br /><br /><blockquote>By now you might have a feeling that, compared to JPA or Hibernate, there is quite a lot of manual work. However various JPA implementations and other ORM frameworks are notoriously known for introducing significant overhead and manifesting some learning curve. This tiny library intentionally leaves some responsibilities to the user in order to avoid complex mappings, reflection, annotations... all the implicitness that is not always desired.<br /><br />This project is not intending to replace mature and stable ORM frameworks. Instead it tries to fill in a niche between raw JDBC and ORM where simplicity and low overhead are key features.</blockquote><h3>Entity with manually assigned key</h3>In this example we'll see how entities with user-defined primary keys are handled. Let's start from database model:<br /><br /><pre class="brush: sql">CREATE TABLE USERS (<br />    user_name varchar(255),<br />    date_of_birth TIMESTAMP NOT NULL,<br />    enabled BIT(1) NOT NULL,<br />    PRIMARY KEY (user_name)<br />);<br /></pre>...and <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository/repositories/User.java"><code>User</code></a> domain model:<br /><br /><pre class="brush: java">public class User implements Persistable&lt;String&gt; {<br /><br />    private transient boolean persisted;<br /><br />    private String userName;<br />    private Date dateOfBirth;<br />    private boolean enabled;<br /><br />    @Override<br />    public String getId() {<br />        return userName;<br />    }<br /><br />    @Override<br />    public boolean isNew() {<br />        return !persisted;<br />    }<br /><br />    public User withPersisted(boolean persisted) {<br />        this.persisted = persisted;<br />        return this;<br />    }<br /><br />    //getters/setters/constructors/...<br /><br />}<br /></pre>Notice that special <code>persisted</code> transient flag was added. Contract of <a href="http://static.springsource.org/spring-data/data-commons/docs/current/api/org/springframework/data/repository/CrudRepository.html#save(S)"><code>CrudRepository.save()</code></a> from Spring Data project requires that an entity knows whether it was already saved or not (<code>isNew()</code>) method - there are no separate <code>create()</code> and <code>update()</code> methods. Implementing <code>isNew()</code> is simple for auto-generated keys (see <code>Comment</code> above) but in this case we need an extra transient field. If you hate this workaround and you only insert data and never update, you'll get away with return <code>true</code> all the time from <code>isNew()</code>.<br /><br />And finally our DAO, <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository/repositories/UserRepository.java"><code>UserRepository</code></a> bean:<br /><br /><pre class="brush: java">@Repository<br />public class UserRepository extends JdbcRepository&lt;User, String&gt; {<br /><br />    public UserRepository() {<br />        super(ROW_MAPPER, ROW_UNMAPPER, "USERS", "user_name");<br />    }<br /><br />    public static final RowMapper&lt;User&gt; ROW_MAPPER = //...<br /><br />    public static final RowUnmapper&lt;User&gt; ROW_UNMAPPER = //...<br /><br />    @Override<br />    protected User postUpdate(User entity) {<br />        return entity.withPersisted(true);<br />    }<br /><br />    @Override<br />    protected User postCreate(User entity, Number generatedId) {<br />        return entity.withPersisted(true);<br />    }<br />}<br /></pre><code>"USERS"</code> and <code>"user_name"</code> parameters designate table name and primary key column name. I'll leave the details of mapper and unmapper (see <a href="http://draft.blogger.com/(https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository/repositories/UserRepository.java)">source code</a>). But please notice <code>postUpdate()</code> and <code>postCreate()</code> methods. They ensure that once object was persisted, <code>persisted</code> flag is set so that subsequent calls to <code>save()</code> will update existing entity rather than trying to reinsert it.<br /><br />Check out <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository/JdbcRepositoryManualKeyTest.java"><code>JdbcRepositoryManualKeyTest</code></a> for a working code based on this example.<br /><br /><h3>Compound primary key</h3>We also support compound primary keys (primary keys consisting of several columns). Take this table as an example:<br /><br /><pre class="brush: sql">CREATE TABLE BOARDING_PASS (<br />    flight_no VARCHAR(8) NOT NULL,<br />    seq_no INT NOT NULL,<br />    passenger VARCHAR(1000),<br />    seat CHAR(3),<br />    PRIMARY KEY (flight_no, seq_no)<br />);<br /></pre>I would like you to notice the type of primary key in <code>Peristable&lt;T&gt;</code>:<br /><br /><pre class="brush: java">public class BoardingPass implements Persistable&lt;Object[]&gt; {<br /><br />    private transient boolean persisted;<br /><br />    private String flightNo;<br />    private int seqNo;<br />    private String passenger;<br />    private String seat;<br /><br />    @Override<br />    public Object[] getId() {<br />        return pk(flightNo, seqNo);<br />    }<br /><br />    @Override<br />    public boolean isNew() {<br />        return !persisted;<br />    }<br /><br />    //getters/setters/constructors/...<br /><br />}<br /></pre>Unfortunately we don't support small value classes encapsulating all ID values in one object (like JPA does with <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/IdClass.html"><code>@IdClass</code></a>), so you have to live with <code>Object[]</code> array. Defining DAO class is similar to what we've already seen:<br /><br /><pre class="brush: java">public class BoardingPassRepository extends JdbcRepository&lt;BoardingPass, Object[]&gt; {<br />    public BoardingPassRepository() {<br />        this("BOARDING_PASS");<br />    }<br /><br />    public BoardingPassRepository(String tableName) {<br />        super(MAPPER, UNMAPPER, new TableDescription(tableName, null, "flight_no", "seq_no")<br />        );<br />    }<br /><br />    public static final RowMapper&lt;BoardingPass&gt; ROW_MAPPER = //...<br /><br />    public static final RowUnmapper&lt;BoardingPass&gt; UNMAPPER = //...<br /><br />}<br /></pre>Two things to notice: we extend <code>JdbcRepository&lt;BoardingPass, Object[]&gt;</code> and we provide two ID column names just as expected: <code>"flight_no", "seq_no"</code>. We query such DAO by providing both <code>flight_no</code> and <code>seq_no</code> (necessarily in that order) values wrapped by <code>Object[]</code>:<br /><br /><pre class="brush: java">BoardingPass pass = repository.findOne(new Object[] {"FOO-1022", 42});<br /></pre>No doubts, this is cumbersome in practice, so we provide tiny helper method which you can statically import:<br /><br /><pre class="brush: java">import static com.blogspot.nurkiewicz.jdbcrepository.JdbcRepository.pk;<br />//...<br /><br />BoardingPass foundFlight = repository.findOne(pk("FOO-1022", 42));<br /></pre>Check out <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository/JdbcRepositoryCompoundPkTest.java"><code>JdbcRepositoryCompoundPkTest</code></a> for a working code based on this example.<br /><br /><h3>Transactions</h3>This library is completely orthogonal to transaction management. Every method of each repository requires running transaction and it's up to you to set it up. Typically you would place <code>@Transactional</code> on service layer (calling DAO beans). I don't recommend <a href="http://stackoverflow.com/questions/8993318/what-is-the-right-way-to-use-spring-mvc-with-hibernate-in-dao-sevice-layer-arch">placing <code>@Transactional</code> over every DAO bean</a>.<br /><br /><h2>Caching</h2>Spring Data JDBC repository library is not providing any caching abstraction or support. However adding <code>@Cacheable</code> layer on top of your DAOs or services using <a href="http://static.springsource.org/spring/docs/3.1.0.RELEASE/spring-framework-reference/html/cache.html">caching abstraction in Spring</a> is quite straightforward. See also: <a href="http://nurkiewicz.blogspot.no/2013/01/cacheable-overhead-in-spring.html"><i>@Cacheable overhead in Spring</i></a>.<br /><br /><h2>Contributions</h2>..are always welcome. Don't hesitate to <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/issues">submit bug reports</a> and <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/pulls">pull requests</a>. Biggest missing feature now is support for MSSQL and Oracle databases. It would be terrific if someone could have a look at it.<br /><br /><h3>Testing</h3>This library is continuously tested using Travis (<a href="https://travis-ci.org/nurkiewicz/spring-data-jdbc-repository"><img alt="Build Status" src="https://secure.travis-ci.org/nurkiewicz/spring-data-jdbc-repository.png?branch=master" /></a>). Test suite consists of <b>265 tests</b> (53 distinct tests each run against 5 different databases: MySQL, PostgreSQL, H2, HSQLDB and Derby.<br /><br />When filling <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/issues">bug reports</a> or submitting new features please try including supporting test cases. Each <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/pulls">pull request</a> is automatically tested on a separate branch.<br /><br /><h3>Building</h3>After forking the <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository">official repository</a> building is as simple as running:<br /><br /><pre class="brush: java">$ mvn install<br /></pre>You'll notice plenty of exceptions during JUnit test execution. This is normal. Some of the tests run against MySQL and PostgreSQL available only on Travis CI server. When these database servers are unavailable, whole test is simply <i>skipped</i>:<br /><br /><pre class="brush: plain">Results :<br /><br />Tests run: 265, Failures: 0, Errors: 0, Skipped: 106<br /></pre>Exception stack traces come from root <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/test/java/com/blogspot/nurkiewicz/jdbcrepository/AbstractIntegrationTest.java"><code>AbstractIntegrationTest</code></a>.<br /><br /><h2>Design</h2>Library consists of only a handful of classes, highlighted in the diagram below:<br /><br /><img alt="UML diagram" height="365" src="https://raw.github.com/nurkiewicz/spring-data-jdbc-repository/master/src/main/docs/classes.png" width="640" /><br /><br /><a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/main/java/com/blogspot/nurkiewicz/jdbcrepository/JdbcRepository.java"><code>JdbcRepository</code></a> is the most important class that implements all <a href="http://static.springsource.org/spring-data/data-commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html"><code>PagingAndSortingRepository</code></a> methods. Each user repository has to extend this class. Also each such repository must at least implement <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jdbc/core/RowMapper.html"><code>RowMapper</code></a> and <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/main/java/com/blogspot/nurkiewicz/jdbcrepository/RowUnmapper.java"><code>RowUnmapper</code></a> (only if you want to modify table data).<br /><br />SQL generation is delegated to <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/main/java/com/blogspot/nurkiewicz/jdbcrepository/sql/SqlGenerator.java"><code>SqlGenerator</code></a>. <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/main/java/com/blogspot/nurkiewicz/jdbcrepository/sql/PostgreSqlGenerator.java"><code>PostgreSqlGenerator.</code></a> and <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository/blob/master/src/main/java/com/blogspot/nurkiewicz/jdbcrepository/sql/DerbySqlGenerator.java"><code>DerbySqlGenerator</code></a> are provided for databases that don't work with standard generator.<br /><br /><h2>License</h2>This project is released under version 2.0 of the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License</a> (same as <a href="https://github.com/SpringSource/spring-framework">Spring framework</a>).<br /><br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>