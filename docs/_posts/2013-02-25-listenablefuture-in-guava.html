---
layout: post
title: ListenableFuture in Guava
date: '2013-02-25T23:37:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- guava
- multithreading
- concurrency
modified_time: '2013-02-25T23:37:55.592+01:00'
thumbnail: http://1.bp.blogspot.com/-RFR5pDq29CY/USvlR7Q3ouI/AAAAAAAAAu0/7J9HQ2NKk_g/s72-c/171343_128780363854442_8343979_o.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5416992373753251613
blogger_orig_url: https://www.nurkiewicz.com/2013/02/listenablefuture-in-guava.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-RFR5pDq29CY/USvlR7Q3ouI/AAAAAAAAAu0/7J9HQ2NKk_g/s1600/171343_128780363854442_8343979_o.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://1.bp.blogspot.com/-RFR5pDq29CY/USvlR7Q3ouI/AAAAAAAAAu0/7J9HQ2NKk_g/s320/171343_128780363854442_8343979_o.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fram Museum</td></tr></tbody></table><a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/ListenableFuture.html"><code>ListenableFuture</code></a> in Guava is an attempt to define consistent API for <code>Future</code> objects to register completion callbacks. With the ability to add callback when <code>Future</code> completes, we can asynchronously and effectively respond to incoming events. If your application is highly concurrent with lots of future objects, I strongly recommend using <code>ListenableFuture</code> whenever you can.<br /><br />Technically <code>ListenableFuture</code> extends <code>Future</code> interface by adding simple <br /><br /><pre class="brush: java">void addListener(Runnable listener, Executor executor)<br /></pre>method. That's it. If you get a hold of <code>ListenableFuture</code> you can register <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html"><code>Runnable</code></a> to be executed immediately when future in question completes. You must also supply <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html"><code>Executor</code></a> (<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html"><code>ExecutorService</code></a> extends it) that will be used to execute your listener - so that long-running listeners do not occupy your worker threads.<br /><br />Let's put that into action. We will start by refactoring our <a href="http://nurkiewicz.blogspot.no/2013/02/javautilconcurrentfuture-basics.html">first example of web crawler</a> to use <code>ListenableFuture</code>. Fortunately in case of thread pools it's just a matter of wrapping them using <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/MoreExecutors.html#listeningDecorator(java.util.concurrent.ExecutorService)"><code>MoreExecutors.listeningDecorator()</code></a>:<br /><a name='more'></a><br /><br /><pre class="brush: java">ListeningExecutorService pool = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));<br /><br />for (final URL siteUrl : topSites) {<br />    final ListenableFuture&lt;String&gt; future = pool.submit(new Callable&lt;String&gt;() {<br />        @Override<br />        public String call() throws Exception {<br />            return IOUtils.toString(siteUrl, StandardCharsets.UTF_8);<br />        }<br />    });<br /><br />    future.addListener(new Runnable() {<br />        @Override<br />        public void run() {<br />            try {<br />                final String contents = future.get();<br />                //...process web site contents<br />            } catch (InterruptedException e) {<br />                log.error("Interrupted", e);<br />            } catch (ExecutionException e) {<br />                log.error("Exception in task", e.getCause());<br />            }<br />        }<br />    }, MoreExecutors.sameThreadExecutor());<br />}<br /></pre>There are several interesting observations to make. First of all notice how <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/ListeningExecutorService.html"><code>ListeningExecutorService</code></a> wraps existing <code>Executor</code>. This is similar to <a href="http://nurkiewicz.blogspot.no/2013/02/executorcompletionservice-in-practice.html"><code>ExecutorCompletionService</code> approach</a>. Later on we register custom <code>Runnable</code> to be notified when each and every task finishes. Secondly notice how ugly error handling becomes: we have to handle <code>InterruptedException</code> (which should technically never happen as <code>Future</code> is already resolved and <code>get()</code> will never throw it) and <code>ExecutionException</code>. We haven't covered that yet, but <code>Future&lt;T&gt;</code> must somehow handle exceptions occurring during asynchronous computation. Such exceptions are wrapped in <code>ExecutionException</code> (thus the <code>getCause()</code> invocation during logging) thrown from <code>get()</code>.<br /><br />Finally notice <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/MoreExecutors.html#sameThreadExecutor()"><code>MoreExecutors.sameThreadExecutor()</code></a> being used. It's a handy abstraction which you can use every time some API wants to use an <code>Executor</code>/<code>ExecutorService</code> (presumably thread pool) while you are fine with using <i>current</i> thread. This is especially useful during unit testing - even if your production code uses asynchronous tasks, during tests you can run everything from the same thread. <br /><br />No matter how handy it is, whole code seems a bit cluttered. Fortunately there is a simple utility method in fantastic <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/Futures.html"><code>Futures</code></a> class:<br /><br /><pre class="brush: java">Futures.addCallback(future, new FutureCallback&lt;String&gt;() {<br />    @Override<br />    public void onSuccess(String contents) {<br />        //...process web site contents<br />    }<br /><br />    @Override<br />    public void onFailure(Throwable throwable) {<br />        log.error("Exception in task", throwable);<br />    }<br />});<br /></pre><a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/FutureCallback.html"><code>FutureCallback</code></a> is a much simpler abstraction to work with, resolves future and does exception handling for you. Also you can still supply custom thread pool for listeners if you want. If you are stuck with some legacy API that still returns <code>Future</code> you may try <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/JdkFutureAdapters.html#listenInPoolThread(java.util.concurrent.Future)"><code>JdkFutureAdapters.listenInPoolThread()</code></a> which is an adapter converting plain <code>Future&lt;V&gt;</code> to <code>ListenableFuture&lt;V&gt;</code>. But keep in mind that once you start using <code>addListener()</code>, each such adapter will require one thread exclusively to work so this solution doesn't scale at all and you should avoid it.<br /><br /><pre class="brush: java">Future&lt;String&gt; future = //...<br />ListenableFuture&lt;String&gt; listenableFuture =<br />        JdkFutureAdapters.listenInPoolThread(future);<br /></pre>Once we understand the basics we can dive deeply into biggest strength of listening futures: <b>transformations and chaining</b>. This is advanced stuff, you have been warned.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>