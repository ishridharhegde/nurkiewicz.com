---
layout: post
title: Macro lifecycle in Clojure
date: '2013-07-02T18:37:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- clojure
modified_time: '2013-07-02T18:37:25.829+02:00'
thumbnail: http://4.bp.blogspot.com/-VxJFk17ikss/UdMBUKRnC1I/AAAAAAAAAyc/zCad-LCKH6Y/s72-c/snaroya-3.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4472167425757743542
blogger_orig_url: https://www.nurkiewicz.com/2013/07/macro-lifecycle-in-clojure.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-VxJFk17ikss/UdMBUKRnC1I/AAAAAAAAAyc/zCad-LCKH6Y/s794/snaroya-3.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img alt="" border="0" height="153" src="http://4.bp.blogspot.com/-VxJFk17ikss/UdMBUKRnC1I/AAAAAAAAAyc/zCad-LCKH6Y/s200/snaroya-3.jpg" title="Oslofjord from Snarøya" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Oslofjord from Snarøya</td></tr></tbody></table>If you still struggle to understand what are macros in Clojure and why are they so useful, I will guide you through another example today. We will learn when macros are recognized, evaluated, expanded and executed. I believe the most important concept is their similarity to normal functions. As I described <a href="http://nurkiewicz.blogspot.no/2013/06/clojure-macros-for-beginners.html">last time</a>, macros are ordinary functions but executed at compile time and taking code rather than values as arguments. The second difference is slightly artificial since Clojure code <i>is</i> a value in sense that it can be passed around. So let us focus on when macros are actually expanded and executed.<br /><br />We will start from trivial <a href="http://rosettacode.org/wiki/Greatest_common_divisor#Clojure">GCD implementation in Clojure</a> as a normal function:<br /><br /><pre class="brush: java">(defn gcd [a b]<br />    (if (zero? b)<br />        a<br />        (recur b (mod a b))))<br /></pre>Calling this function will result in a tail-recursive loop executed <b>at runtime</b> every time it is encountered:<br /><br /><pre class="brush: java">user=&gt; (gcd 18 12)<br />6<br />user=&gt; (gcd 9 2)<br />1<br />user=&gt; (gcd 9 (inc 2))<br />3<br /></pre>Not very exciting. But what if we wrap reference to <code>gcd</code> inside a macro? <br /><br /><pre class="brush: java">(defmacro runtime-gcd [a b] (list 'gcd a b))<br /></pre>Or more concise syntax:<br /><br /><pre class="brush: java">(defmacro runtime-gcd-quote [a b] `(gcd ~a ~b))<br /></pre>Now look at the declaration of <code>runtime-gcd</code> but replace <code>defmacro</code> with <code>defn</code>, just as if it was a normal function:<br /><a name='more'></a><br /><br /><pre class="brush: java">(defn runtime-gcd-fun [a b] (list 'gcd a b))<br /></pre>Every time you call <code>runtime-gcd-fun</code> in your Clojure code, it gets replaced with the following list: <code>(gcd 12 8)</code>. As you can see it is basically a <code>gcd</code> function call. It is quoted, thus remains a list rather than invoking the actual function. You can evaluate this data structure by running <code>(eval)</code>:<br /><br /><pre class="brush: java">user=&gt; (eval '(gcd 12 8))<br />4<br />user=&gt; (eval (list 'gcd 12 8))<br />4<br />user=&gt; (eval (runtime-gcd-fun 12 8))<br />4<br /></pre>As you can see <code>runtime-gcd-fun</code> is a function that produces data structure (<code>list</code>) that happens to be valid Clojure <i>code</i>! <code>runtime-gcd-fun</code> does not call <code>(gcd a b)</code>, it returns code (expression) that invokes <code>gcd</code>. OK, but what does it have to do with macros? Let’s go back to our original <code>runtime-gcd</code> macro:<br /><br /><pre class="brush: java">user=&gt;     (defmacro runtime-gcd [a b] (list 'gcd a b))<br />#'user/runtime-gcd<br />user=&gt; (runtime-gcd 12 8)<br />4<br />user=&gt; (runtime-gcd 12 (inc 7))<br />4<br /></pre>Sooo… where is the difference? Nowhere, yet. <code>(defmacro)</code> is executed (<i>expanded</i>) at compile time. It is basically a function invoked during compilation. Just like an invocation of normal function is replaced with its value at runtime, value returned from a macro replaces every occurrence of that macro in code. Before it even gets compiled down to bytecode. So if <code>runtime-gcd</code> is encountered, compiler calls it and replaces it with its result, that is: <code>(gcd a b)</code>. This means we can simply replace e.g. <code>(runtime-gcd 12 8)</code> with <code>(gcd 12 8)</code> - this is what the compiler is doing for us anyway.<br /><br />What’s the big deal, then? So far macros are just fancy functions executed during compilation. But what if we skip quoting and define <code>compile-time-gcd</code> as follows?<br /><br /><pre class="brush: java">user=&gt; (defmacro compile-time-gcd [a b] (gcd a b))<br />#'user/compile-time-gcd<br />user=&gt; (compile-time-gcd 12 8)<br />4<br /></pre>Stay we me, you are <i>this</i> close to enlightenment. Notice that we no longer quote <code>gcd</code> invocation. This has tremendous consequences. This time when compiler encounters <code>compile-time-gcd</code> macro it executes its body (<i>expands it</i>). While body of <code>runtime-gcd</code> was calling <code>list</code> function (thus returning a list), body of <code>compile-time-gcd</code> calls <code>gcd</code> immediately - and remember this happens at compile time! <code>(gcd 12 8)</code> is executed by the compiler and its value (<code>4</code>) is returned as macro expansion result. This means that the whole <code>(compile-time-gcd 12 8)</code> is replaced <b>at compile time</b> with number <code>4</code>. In other words the computation was done during compilation and <code>gcd</code> overhead is non-existent at runtime. Check out the output of <code>macroexpand</code> that shows what macro returns without evaluating it:<br /><br /><pre class="brush: java">user=&gt; (macroexpand '(runtime-gcd 12 8))<br />(gcd 12 8)<br /><br />user=&gt; (macroexpand '(compile-time-gcd 12 8))<br />4<br /></pre>This is something you should really think about. Macros are not just advanced search-and-replace facilities built into the compiler. They are “real” Clojure functions that can have logic and conditions. The only difference is that they work at compile time and operate on code rather than on values. So why not use macros all the time if they can run the program at compile time and avoid runtime computations? Remember that macros live in the compiler only, they don’t know anything about your runtime environment:<br /><br /><pre class="brush: java">user=&gt; (compile-time-gcd 12 (inc 7))<br />ClassCastException clojure.lang.PersistentList cannot be cast to java.lang.Number  <br />    clojure.lang.Numbers.isZero (Numbers.java:90)<br /></pre>This error will actually pop-up during compilation, not at runtime! The compiler tries to run <code>(gcd 12 '(inc 7))</code>. Quoted <code>'(inc 7)</code> list is not equal to number 8. It’s a <code>list</code>! And when the compiler executes the condition <code>(zero? '(inc 7))</code> familiar  <code>ClassCastException</code> is thrown. Don’t confuse it with seemingly similar <code>(zero? (inc 7))</code> - incrementing <code>7</code> is not quoted and thus evaluates to <code>8</code>.<br /><br />Are you still confused? Let’s make it even more explicit:<br /><br /><pre class="brush: java">(defmacro printer [s]<br />    (println "Compile time:" s)<br />    (list 'println "Runtime:" s))<br /></pre>This macro is a function with two expressions. Now compile the following Clojure file:<br /><br /><pre class="brush: java">(printer "buzz")<br />(printer (str "foo" "bar"))<br /></pre>Look carefully at the <b>compiler</b> output, you will see the following two lines:<br /><br /><pre class="brush: java">Compile time: buzz<br />Compile time: (str foo bar)<br /></pre>This proves that macros are expanded and executed at compile time. But what happened with the second line? Well, value of last expression of any function (macros are not exception here) becomes value of that function. Thus every occurrence of <code>(printer s)</code> macro is replaced with <code>(println "Runtime:" s)</code> <i>list</i> - and this piece of code will be compiled just as if was <code>println</code> from the very beginning.<br /><br />In order to make sure you understand macros really well, switch statements in <code>printer</code> macro and try to figure out what will this macro do, both at compile- and run-time (hint: value of <code>println</code> is <code>nil</code>):<br /><br /><pre class="brush: java">(defmacro broken-printer [s]<br />    (list 'println "Runtime:" s)<br />    (println "Compile time:" s))<br /></pre>We are not even close to explaining all aspects of macros in Clojure. We have not covered various quoting quirks, <code>gensym</code>, splicing, etc. But I hope this article (together with <a href="http://nurkiewicz.blogspot.no/2013/06/clojure-macros-for-beginners.html">Clojure macros for beginners</a>) will give you some basic idea why macros are so essential in Lisp family of languages.<br /><br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>