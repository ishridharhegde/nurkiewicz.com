---
layout: post
title: ExecutorService - 10 tips and tricks
date: '2014-11-20T20:54:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- CompletableFuture
- multithreading
- concurrency
modified_time: '2015-11-29T23:38:58.154+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5591977136018012505
blogger_orig_url: https://www.nurkiewicz.com/2014/11/executorservice-10-tips-and-tricks.html
---

<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html"><code>ExecutorService</code></a> abstraction has been around since Java 5. We are talking about 2004 here. Just a quick reminder: both Java 5 and 6 are no longer supported, Java 7 <a href="http://www.oracle.com/technetwork/java/eol-135779.html">won't be in half a year</a>. The reason I'm bringing this up is that many Java programmers still don't fully understand how <code>ExecutorService</code> works. There are many places to learn that, today I wanted to share few lesser known features and practices. However this article is still aimed toward intermediate programmers, nothing especially advanced.<br /><br /><h1>1. Name pool threads</h1>I can't emphasize this. When dumping threads of a running JVM or during debugging, default thread pool naming scheme is <code>pool-N-thread-M</code>, where <code>N</code> stands for pool sequence number (every time you create a new thread pool, global <code>N</code> counter is incremented) and <code>M</code> is a thread sequence number within a pool. For example <code>pool-2-thread-3</code> means third thread in second pool created in the JVM lifecycle. See: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#defaultThreadFactory--"><code>Executors.defaultThreadFactory()</code></a>. Not very descriptive. JDK makes it slightly complex to properly name threads because naming strategy is hidden inside <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadFactory.html"><code>ThreadFactory</code></a>. Luckily Guava has a helper class for that:<br /><br /><pre class="brush: java">import com.google.common.util.concurrent.ThreadFactoryBuilder;<br /><br />final ThreadFactory threadFactory = new ThreadFactoryBuilder()<br />        .setNameFormat("Orders-%d")<br />        .setDaemon(true)<br />        .build();<br />final ExecutorService executorService = Executors.newFixedThreadPool(10, threadFactory);<br /></pre>By default thread pools create non-daemon threads, decide whether this suits you or not.<br /><br /><h1>2. Switch names according to context</h1>This is a trick I learnt from <a href="http://www.takipiblog.com/supercharged-jstack-how-to-debug-your-servers-at-100mph/"><em>Supercharged jstack: How to Debug Your Servers at 100mph</em></a>. Once we remember about thread names, we can actually change them at runtime whenever we want! It makes sense because thread dumps show classes and method names, not parameters and local variables. By adjusting thread name to keep some essential transaction identifier we can easily track which message/record/query/etc. is slow or caused deadlock. Example:<br /><br /><pre class="brush: java">private void process(String messageId) {<br />    executorService.submit(() -&gt; {<br />        final Thread currentThread = Thread.currentThread();<br />        final String oldName = currentThread.getName();<br />        currentThread.setName("Processing-" + messageId);<br />        try {<br />            //real logic here...<br />        } finally {<br />            currentThread.setName(oldName);<br />        }<br />    });<br />}<br /></pre>Inside <code>try</code>-<code>finally</code> block current thread is named <code>Processing-WHATEVER-MESSAGE-ID-IS</code>. This might come in handy when tracking down message flow through the system.<br /><br /><h1>3. Explicit and safe shutdown</h1>Between client threads and thread pool there is a queue of tasks. When your application shuts down, you must take care of two things: what is happening with queued tasks and how already running tasks are behaving (more on that later). Surprisingly many developers are not shutting down thread pool properly or consciously. There are two techniques: either let all queued tasks to execute (<code>shutdown()</code>) or drop them (<code>shutdownNow()</code>) - it totally depends on your use case. For example if we submitted a bunch of tasks and want to return as soon as all of them are done, use <code>shutdown()</code>:<br /><br /><pre class="brush: java">private void sendAllEmails(List&lt;String&gt; emails) throws InterruptedException {<br />    emails.forEach(email -&gt;<br />            executorService.submit(() -&gt;<br />                    sendEmail(email)));<br />    executorService.shutdown();<br />    final boolean done = executorService.awaitTermination(1, TimeUnit.MINUTES);<br />    log.debug("All e-mails were sent so far? {}", done);<br />}<br /></pre>In this case we send a bunch of e-mails, each as a separate task in a thread pool. After submitting these tasks we shut down pool so that it no longer accepts any new tasks. Then we wait at most one minute until all these tasks are completed. However if some tasks are still pending, <code>awaitTermination()</code> will simply return <code>false</code>. Moreover, pending tasks will continue processing. I know hipsters would go for:<br /><br /><pre class="brush: java">emails.parallelStream().forEach(this::sendEmail);<br /></pre>Call me old fashioned, but I like to control the number of parallel threads. Never mind, an alternative to graceful <code>shutdown()</code> is <code>shutdownNow()</code>:<br /><br /><pre class="brush: java">final List&lt;Runnable&gt; rejected = executorService.shutdownNow();<br />log.debug("Rejected tasks: {}", rejected.size());<br /></pre>This time all queued tasks are discarded and returned. Already running jobs are allowed to continue. <br /><br /><h1>4. Handle interruption with care</h1>Lesser known feature of <code>Future</code> interface is cancelling. Rather than repeating myself, check out my older article: <a href="http://www.nurkiewicz.com/2014/05/interruptedexception-and-interrupting.html"><em>InterruptedException and interrupting threads explained</em></a><br /><br /><h1>5. Monitor queue length and keep it bounded</h1>Incorrectly sized thread pools may cause slowness, instability and memory leaks. If you configure too few threads, the queue will build up, consuming a lot of memory. Too many threads on the other hand will slow down the whole system due to excessive context switches - and lead to same symptoms. It's important to look at depth of queue and keep it bounded, so that overloaded thread pool simply rejects new tasks temporarily:<br /><br /><pre class="brush: java">final BlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(100);<br />executorService = new ThreadPoolExecutor(n, n,<br />        0L, TimeUnit.MILLISECONDS,<br />        queue);<br /></pre>Code above is equivalent to <code>Executors.newFixedThreadPool(n)</code>, however instead of default unlimited <code>LinkedBlockingQueue</code> we use <code>ArrayBlockingQueue</code> with fixed capacity of <code>100</code>. This means that if 100 tasks are already queued (and <code>n</code> being executed), new task will be rejected with <code>RejectedExecutionException</code>. Also since <code>queue</code> is now available externally, we can periodically call <code>size()</code> and put it in logs/JMX/whatever monitoring mechanism you use.<br /><br /><h1>6. Remember about exception handling</h1>What will be the result of the following snippet?<br /><br /><pre class="brush: java">executorService.submit(() -&gt; {<br />    System.out.println(1 / 0);<br />});<br /></pre>I got bitten by that too many times: it won't print <strong>anything</strong>. No sign of <code>java.lang.ArithmeticException: / by zero</code>, nothing. Thread pool just swallows this exception, as if it never happened. If it was a good'ol <code>java.lang.Thread</code> created from scratch, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.UncaughtExceptionHandler.html"><code>UncaughtExceptionHandler</code></a> could work. But with thread pools you must be more careful. If you are submitting <code>Runnable</code> (without any result, like above), you <em>must</em> surround whole body with <code>try</code>-<code>catch</code> and at least log it. If you are submitting <code>Callable&lt;Integer&gt;</code>, ensure you always dereference it using blocking <code>get()</code> to re-throw exception:<br /><br /><pre class="brush: java">final Future&lt;Integer&gt; division = executorService.submit(() -&gt; 1 / 0);<br />//below will throw ExecutionException caused by ArithmeticException<br />division.get();<br /></pre>Interestingly even Spring framework made this bug with <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html"><code>@Async</code></a>, see: <a href="https://jira.spring.io/browse/SPR-8995">SPR-8995</a> and <a href="https://jira.spring.io/browse/SPR-12090">SPR-12090</a>.<br /><br /><h1>7. Monitor waiting time in a queue</h1>Monitoring work queue depth is one side. However when troubleshooting single transaction/task it's worthwhile to see how much time passed between submitting task and actual execution. This duration should preferably be close to 0 (when there was some idle thread in a pool), however it will grow when task has to be queued. Moreover if pool doesn't have a fixed number of threads, running new task might require spawning thread, also consuming short amount of time. In order to cleanly monitor this metric, wrap original <code>ExecutorService</code> with something similar to this:<br /><br /><pre class="brush: java">public class WaitTimeMonitoringExecutorService implements ExecutorService {<br /><br />    private final ExecutorService target;<br /><br />    public WaitTimeMonitoringExecutorService(ExecutorService target) {<br />        this.target = target;<br />    }<br /><br />    @Override<br />    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {<br />        final long startTime = System.currentTimeMillis();<br />        return target.submit(() -&gt; {<br />                    final long queueDuration = System.currentTimeMillis() - startTime;<br />                    log.debug("Task {} spent {}ms in queue", task, queueDuration);<br />                    return task.call();<br />                }<br />        );<br />    }<br /><br />    @Override<br />    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {<br />        return submit(() -&gt; {<br />            task.run();<br />            return result;<br />        });<br />    }<br /><br />    @Override<br />    public Future&lt;?&gt; submit(Runnable task) {<br />        return submit(new Callable&lt;Void&gt;() {<br />            @Override<br />            public Void call() throws Exception {<br />                task.run();<br />                return null;<br />            }<br />        });<br />    }<br /><br />    //...<br /><br />}<br /></pre>This is not a complete implementation, but you get the basic idea. The moment we submit a task to a thread pool, we immediately start measuring time. We stop as soon as task was picked up and begins execution. Don't be fooled by close proximity of <code>startTime</code> and <code>queueDuration</code> in source code. In fact these two lines are evaluated in different threads, probably milliseconds or even seconds apart, e.g.:<br /><br /><pre class="brush: java">Task com.nurkiewicz.MyTask@7c7f3894 spent 9883ms in queue<br /></pre><h1>8. Preserve client stack trace</h1>Reactive programming seems to get a lot of attention these days. <a href="http://www.reactivemanifesto.org/">Reactive manifesto</a>, <a href="http://www.reactive-streams.org/">reactive streams</a>, <a href="https://github.com/ReactiveX/RxJava">RxJava</a> (just released 1.0!), <a href="http://clojure.org/agents">Clojure agents</a>, <a href="https://github.com/lihaoyi/scala.rx">scala.rx</a>... They all work great, but stack trace are no longer your friend, they are at most useless. Take for example an exception happening in a task submitted to thread pool:<br /><br /><pre class="brush: plain">java.lang.NullPointerException: null<br />    at com.nurkiewicz.MyTask.call(Main.java:76) ~[classes/:na]<br />    at com.nurkiewicz.MyTask.call(Main.java:72) ~[classes/:na]<br />    at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0]<br />    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0]<br />    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0]<br />    at java.lang.Thread.run(Thread.java:744) ~[na:1.8.0]<br /></pre>We can easily discover that <code>MyTask</code> threw NPE at line 76. But we have no idea who submitted this task, because stack trace reveals only <code>Thread</code> and <code>ThreadPoolExecutor</code>. We can technically navigate through the source code in hope to find just one place where <code>MyTask</code> is created. But without threads (not to mention event-drivent, reactive, actor-ninja-programming) we would immediately see full picture. What if we could preserve stack trace of client code (the one which submitted task) and show it, e.g. in case of failure? The idea isn't new, for example <a href="http://hazelcast.com/">Hazelcast</a> propagates exceptions <a href="https://github.com/hazelcast/hazelcast/blob/7f8cd30e4e445473271d2e434ad939d156a151ca/hazelcast/src/main/java/com/hazelcast/util/ExceptionUtil.java#L29">from owner node to client code</a>. This is how naïve support for keeping client stack trace in case of failure could look:<br /><br /><pre class="brush: java">public class ExecutorServiceWithClientTrace implements ExecutorService {<br /><br />    protected final ExecutorService target;<br /><br />    public ExecutorServiceWithClientTrace(ExecutorService target) {<br />        this.target = target;<br />    }<br /><br />    @Override<br />    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {<br />        return target.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));<br />    }<br /><br />    private &lt;T&gt; Callable&lt;T&gt; wrap(final Callable&lt;T&gt; task, final Exception clientStack, String clientThreadName) {<br />        return () -&gt; {<br />            try {<br />                return task.call();<br />            } catch (Exception e) {<br />                log.error("Exception {} in task submitted from thrad {} here:", e, clientThreadName, clientStack);<br />                throw e;<br />            }<br />        };<br />    }<br /><br />    private Exception clientTrace() {<br />        return new Exception("Client stack trace");<br />    }<br /><br />    @Override<br />    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException {<br />        return tasks.stream().map(this::submit).collect(toList());<br />    }<br /><br />    //...<br /><br />}<br /></pre>This time in case of failure we will retrieve full stack trace and thread name of a place where task was submitted. Much more valuable compared to standard exception seen earlier: <br /><br /><pre class="brush: plain">Exception java.lang.NullPointerException in task submitted from thrad main here:<br />java.lang.Exception: Client stack trace<br />    at com.nurkiewicz.ExecutorServiceWithClientTrace.clientTrace(ExecutorServiceWithClientTrace.java:43) ~[classes/:na]<br />    at com.nurkiewicz.ExecutorServiceWithClientTrace.submit(ExecutorServiceWithClientTrace.java:28) ~[classes/:na]<br />    at com.nurkiewicz.Main.main(Main.java:31) ~[classes/:na]<br />    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0]<br />    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0]<br />    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0]<br />    at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0]<br />    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134) ~[idea_rt.jar:na]<br /></pre><h1>9. Prefer CompletableFuture</h1>In Java 8 more powerful <a href="http://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html"><code>CompletableFuture</code> was introduced</a>. Please use it whenever possible. <code>ExecutorService</code> wasn't extended to support this enhanced abstraction, so you have to take care of it yourself. Instead of:<br /><br /><pre class="brush: java">final Future&lt;BigDecimal&gt; future = <br />    executorService.submit(this::calculate);<br /></pre>do:<br /><br /><pre class="brush: java">final CompletableFuture&lt;BigDecimal&gt; future = <br />    CompletableFuture.supplyAsync(this::calculate, executorService);<br /></pre><code>CompletableFuture</code> extends <code>Future</code> so everything works as it used to. But more advanced consumers of your API will truly appreciate extended functionality given by <code>CompletableFuture</code>.<br /><br /><h1>10. Synchronous queue</h1><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html"><code>SynchronousQueue</code></a> is an interesting <code>BlockingQueue</code> that's not really a queue. It's not even a data structure <em>per se</em>. It's best explained as a queue with capacity of 0. Quoting JavaDoc:<br /><br /><blockquote>each <code>insert</code> operation must wait for a corresponding <code>remove</code> operation by another thread, and vice versa. A synchronous queue does not have any internal capacity, not even a capacity of one. You cannot peek at a synchronous queue because an element is only present when you try to remove it; you cannot insert an element (using any method) unless another thread is trying to remove it; you cannot iterate as there is nothing to iterate. [...]<br /><br />Synchronous queues are similar to rendezvous channels used in CSP and Ada.<br /><br /></blockquote>How is this related to thread pools? Try using <code>SynchronousQueue</code> with <code>ThreadPoolExecutor</code>:<br /><br /><pre class="brush: java">BlockingQueue&lt;Runnable&gt; queue = new SynchronousQueue&lt;&gt;();<br />ExecutorService executorService = new ThreadPoolExecutor(2, 2,<br />        0L, TimeUnit.MILLISECONDS,<br />        queue);<br /></pre>We created a thread pool with two threads and a <code>SynchronousQueue</code> in front of it. Because <code>SynchronousQueue</code> is essentially a queue with 0 capacity, such <code>ExecutorService</code> will only accept new tasks if there is an idle thread available. If all threads are busy, new task will be rejected immediately and will never wait. This behavior might be desirable when processing in background must start immediately or be discarded.<br /><br /><hr />That's it, I hope you found at least one interesting feature!<br /><br /><script type="text/javascript"> SyntaxHighlighter.highlight(); </script>