---
layout: post
title: Accessing Meetup's streaming API with RxNetty
date: '2014-12-08T23:20:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- Netty
- RxNetty
- Meetup
- JSON
- rxjava
modified_time: '2014-12-09T09:14:05.322+01:00'
thumbnail: http://1.bp.blogspot.com/-8b9LXp7ek8M/VIYkb3X-yNI/AAAAAAAABMw/EBZdoO7zQ8c/s72-c/St.split.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7106214796549101172
blogger_orig_url: https://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html
---

This article will touch upon multiple subjects: reactive programming, HTTP, parsing JSON and integrating with social API. All in one use case: we will load and process new <a href="http://www.meetup.com/">meetup.com</a> events in real time via non-bloking <a href="https://github.com/ReactiveX/RxNetty">RxNetty</a> library, combining the power of <a href="http://netty.io/">Netty</a> framework and flexibility of <a href="https://github.com/ReactiveX/RxJava">RxJava</a> library. Meetup provides publicly available <a href="http://www.meetup.com/meetup_api/docs/stream/2/open_events/">streaming API</a> that pushes every single Meetup registered all over the world in real-time. Just browse to <a href="https://stream.meetup.com/2/open_events">stream.meetup.com/2/open_events</a> and observe how chunks of JSON are slowly appearing on your screen. Every time someone creates new event, self-containing JSON is pushed from the server to your browser. This means such request never ends, instead we keep receiving partial data as long as we want. We already examined similar scenario in <a href="http://www.nurkiewicz.com/2014/01/turning-twitter4j-into-rxjavas.html"><em>Turning Twitter4J into RxJava's Observable</em></a>. Each new meetup event publishes a standalone JSON document, similar to this (lots of details omitted):<br /><br /><pre class="brush: javascript">{ "id" : "219088449",<br />  "name" : "Silver Wings Brunch",<br />  "time" : 1421609400000,<br />  "mtime" : 1417814004321,<br />  "duration" : 900000,<br />  "rsvp_limit" : 0,<br />  "status" : "upcoming",<br />  "event_url" : "http://www.meetup.com/Laguna-Niguel-Social-Networking-Meetup/events/219088449/",<br />  "group" : { "name" : "Former Flight Attendants South Orange and North San Diego Co",<br />              "state" : "CA"<br />              ...<br />  },<br />  "venue" : { "address_1" : "26860 Ortega Highway",<br />              "city" : "San Juan Capistrano",<br />              "country" : "US"<br />              ...<br />  },<br />  "venue_visibility" : "public",<br />  "visibility" : "public",<br />  "yes_rsvp_count" : 1<br />  ...<br />}<br /></pre>Every time our long-polling HTTP connection (with <code>Transfer-Encoding: chunked</code> response header) pushes such piece of JSON, we want to parse it and somehow pass further. We hate callbacks, thus RxJava seems like a reasonable alternative (think: <code>Observable&lt;Event&gt;</code>).<br /><br /><h1>Step 1: Receiving raw data with RxNetty</h1>We can't use ordinary HTTP client as they are focused on request-response semantics. There is no response here, we simply leave opened connection forever and consume data when it comes. RxJava has an out-of-the-box <a href="https://github.com/ReactiveX/RxApacheHttp">RxApacheHttp</a> library, but it assumes <a href="https://developer.mozilla.org/en-US/docs/Server-sent_events/Using_server-sent_events"><code>text/event-stream</code> content type</a>. Instead we will use quite low-level, versatile RxNetty library. It's a wrapper around Netty (duh!) and is capable of <a href="https://github.com/ReactiveX/RxNetty/tree/0.x/rxnetty-examples">implementing arbitrary</a> TCP/IP (including HTTP) and UDP clients and servers. If you don't know Netty, it's packet- rather than stream-oriented, so we can expect one Netty event per each Meetup push. The API certainly isn't straightforward, but makes sense once you grok it:<br /><br /><pre class="brush: java">HttpClient&lt;ByteBuf, ByteBuf&gt; httpClient = RxNetty.&lt;ByteBuf, ByteBuf&gt;newHttpClientBuilder("stream.meetup.com", 443)<br />        .pipelineConfigurator(new HttpClientPipelineConfigurator&lt;&gt;())<br />        .withSslEngineFactory(DefaultFactories.trustAll())<br />        .build();<br /><br />final Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; responses = <br />    httpClient.submit(HttpClientRequest.createGet("/2/open_events"));<br />final Observable&lt;ByteBuf&gt; byteBufs = <br />    responses.flatMap(AbstractHttpContentHolder::getContent);<br />final Observable&lt;String&gt; chunks = <br />    byteBufs.map(content -&gt; content.toString(StandardCharsets.UTF_8));<br /></pre>First we create <code>HttpClient</code> and set up SSL (keep in mind that <code>trustAll()</code> with regards to server certificates is probably not the best production setting). Later we <code>submit()</code> GET request and receive <code>Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;</code> in return. <code>ByteBuf</code> is Netty's abstraction over a bunch of bytes sent or received over the wire. This observable will tell us immediately about every piece of data received from Meetup. After extracting <code>ByteBuf</code> from response we turn it into a <code>String</code> containing aforementioned JSON. So far so good, it works.<br /><br /><h1>Step 2: Aligning packets with JSON documents</h1>Netty is very powerful because it doesn't hide inherent complexity over leaky abstractions. Every time <em>something</em> is received over the TCP/IP wire, we are notified. You might believe that when server sends 100 bytes, Netty on the client side will notify us about these 100 bytes received. However TCP/IP stack is free to split and merge data you send over wire, especially since it is suppose to be a stream, so how it is split into packets should be irrelevant. This caveat is greatly explained in <a href="http://netty.io/wiki/user-guide-for-4.x.html#wiki-h3-11">Netty's documentation</a>. What does it mean to us? When Meetup sends a single event, we might receive just one <code>String</code> in <code>chunks</code> observable. But just as well it can be divided into arbitrary number of packets, thus <code>chunks</code> will emit multiple <code>String</code>s. Even worse, if Meetup sends two events right after another, they might fit in one packet. In that case <code>chunks</code> will emit one <code>String</code> with two independent JSON documents. As a matter of fact we can't assume any alignment between JSON strings and networks packets received. All we know is that individual JSON documents representing events are separated by newlines. Amazingly, <a href="https://github.com/ReactiveX/RxJavaString"><code>RxJavaString</code></a> official add-on has a method precisely for that:<br /><br /><pre class="brush: java">Observable&lt;String&gt; jsonChunks = StringObservable.split(chunks, "\n");<br /></pre>Actually there is even simpler <code>StringObservable.byLine(chunks)</code>, but it uses platform-dependent end-of-line. What <code>split()</code> does is best explained in <a href="http://reactivex.io/documentation/string.html">official documentation</a>:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-8b9LXp7ek8M/VIYkb3X-yNI/AAAAAAAABMw/EBZdoO7zQ8c/s1600/St.split.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-8b9LXp7ek8M/VIYkb3X-yNI/AAAAAAAABMw/EBZdoO7zQ8c/s1600/St.split.png" height="294" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div>Now we can safely parse each <code>String</code> emitted by <code>jsonChunks</code>:<br /><br /><h1>Step 3: Parsing JSON</h1>Interestingly this step is not so straightforward. I admit, I <em>sort-of</em> enjoyed WSDL times because I could easily and predictably generate Java model that follows web-service's contract. JSON, especially taking marginal market penetration of <a href="http://json-schema.org/">JSON schema</a>, is basically the Wild West of integration. Typically you are left with informal documentation or samples of requests and responses. No type information or format, whether fields are mandatory, etc. Moreover because I reluctantly work with <em>maps of maps</em> (hi there, fellow Clojure programmers), in order to work with JSON based REST services I have to write mapping POJOs myself. Well, there are workarounds. First I took one representative example of JSON produced by Meetup streaming API and placed it in <code>src/main/json/meetup/event.json</code>. Then I used <a href="https://github.com/joelittlejohn/jsonschema2pojo"><code>jsonschema2pojo-maven-plugin</code></a> (<a href="http://www.jsonschema2pojo.org/">Gradle and Ant</a> versions exist as well). Plugin's name is confusing, it can also work with JSON example, not only schema, to produce Java models: <br /><br /><pre class="brush: xml">&lt;plugin&gt;<br />    &lt;groupId&gt;org.jsonschema2pojo&lt;/groupId&gt;<br />    &lt;artifactId&gt;jsonschema2pojo-maven-plugin&lt;/artifactId&gt;<br />    &lt;version&gt;0.4.7&lt;/version&gt;<br />    &lt;configuration&gt;<br />        &lt;sourceDirectory&gt;${basedir}/src/main/json/meetup&lt;/sourceDirectory&gt;<br />        &lt;targetPackage&gt;com.nurkiewicz.meetup.generated&lt;/targetPackage&gt;<br />        &lt;includeHashcodeAndEquals&gt;true&lt;/includeHashcodeAndEquals&gt;<br />        &lt;includeToString&gt;true&lt;/includeToString&gt;<br />        &lt;initializeCollections&gt;true&lt;/initializeCollections&gt;<br />        &lt;sourceType&gt;JSON&lt;/sourceType&gt;<br />        &lt;useCommonsLang3&gt;true&lt;/useCommonsLang3&gt;<br />        &lt;useJodaDates&gt;true&lt;/useJodaDates&gt;<br />        &lt;useLongIntegers&gt;true&lt;/useLongIntegers&gt;<br />        &lt;outputDirectory&gt;target/generated-sources&lt;/outputDirectory&gt;<br />    &lt;/configuration&gt;<br />    &lt;executions&gt;<br />        &lt;execution&gt;<br />            &lt;id&gt;generate-sources&lt;/id&gt;<br />            &lt;phase&gt;generate-sources&lt;/phase&gt;<br />            &lt;goals&gt;<br />                &lt;goal&gt;generate&lt;/goal&gt;<br />            &lt;/goals&gt;<br />        &lt;/execution&gt;<br />    &lt;/executions&gt;<br />&lt;/plugin&gt;<br /></pre>At this point Maven will create <code>Event.java</code>, <code>Venue.java</code>, <code>Group.java</code>, etc. compatible with Jackson:<br /><br /><pre class="brush: java">private Event parseEventJson(String jsonStr) {<br />    try {<br />        return objectMapper.readValue(jsonStr, Event.class);<br />    } catch (IOException e) {<br />        throw new UncheckedIOException(e);<br />    }<br />}<br /></pre>It just works, sweet:<br /><br /><pre class="brush: java">final Observable&lt;Event&gt; events = jsonChunks.map(this::parseEventJson);<br /></pre><h1>Step 4: ???<sup><a href="http://knowyourmeme.com/memes/profit">[1]</a></sup></h1><h1>Step 5: PROFIT!!!</h1>Having <code>Observable&lt;Event&gt;</code> we can implement some really interesting use cases. Want to find names of all meetups in Poland that were just created? Sure!<br /><br /><pre class="brush: java">events<br />        .filter(event -&gt; event.getVenue() != null)<br />        .filter(event -&gt; event.getVenue().getCountry().equals("pl"))<br />        .map(Event::getName)<br />        .forEach(System.out::println);<br /></pre>Looking for statistics how many events are created per minute? No problem!<br /><br /><pre class="brush: java">events<br />        .buffer(1, TimeUnit.MINUTES)<br />        .map(List::size)<br />        .forEach(count -&gt; log.info("Count: {}", count));<br /></pre>Or maybe you want to continually search for meetups furthest in the future, skipping those closer than ones already found?<br /><br /><pre class="brush: java">events<br />        .filter(event -&gt; event.getTime() != null)<br />        .scan(this::laterEventFrom)<br />        .distinct()<br />        .map(Event::getTime)<br />        .map(Instant::ofEpochMilli)<br />        .forEach(System.out::println);<br /><br />//...<br /><br />private Event laterEventFrom(Event first, Event second) {<br />    return first.getTime() &gt; second.getTime() ?<br />            first :<br />            second;<br />}<br /></pre>This code filters out events without known time, emits either current event or the previous one (<code>scan()</code>), depending on which one was later, filters out duplicates and displays time. This tiny program running for few minutes already found one just created meetup scheduled for November 2015 - and it's December 2014 as of this writing. Possibilities are endless.<br /><br />I hope I gave you a good grasp of how you can mashup various technologies together easily: reactive programming to write super fast networking code, type-safe JSON parsing without boiler-plate code and RxJava to quickly process streams of events. Enjoy!<br /><br /><script>SyntaxHighlighter.highlight();</script>