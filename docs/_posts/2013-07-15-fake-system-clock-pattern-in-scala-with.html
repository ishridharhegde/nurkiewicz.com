---
layout: post
title: Fake system clock pattern in Scala with implicit parameters
date: '2013-07-15T18:42:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- testing
- scala
modified_time: '2013-07-15T18:45:53.660+02:00'
thumbnail: http://1.bp.blogspot.com/-pyXI2F4U6Ls/UeQlZWk9ziI/AAAAAAAAAzE/zYx6o89hOr8/s72-c/oslo-6.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8053424634693693595
blogger_orig_url: https://www.nurkiewicz.com/2013/07/fake-system-clock-pattern-in-scala-with.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-pyXI2F4U6Ls/UeQlZWk9ziI/AAAAAAAAAzE/zYx6o89hOr8/s1600/oslo-6.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="149" src="http://1.bp.blogspot.com/-pyXI2F4U6Ls/UeQlZWk9ziI/AAAAAAAAAzE/zYx6o89hOr8/s200/oslo-6.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Sjømannsskolen</td></tr></tbody></table><a href="http://www.javapractices.com/topic/TopicAction.do?Id=234">Fake system clock</a> is a design pattern addressing testability issues of programs heavily relying on system time. If business logic flow depends on current system time, testing various flows becomes cumbersome or even impossible. Examples of such problematic scenarios include:<br /><br /><ol><li>certain business flow runs only (or is ignored) during weekends</li><li>some logic is triggered only after an hour since some other event</li><li>when two events occur at the exact same time (typically 1 ms precision), something should happen</li><li>…</li></ol>Each scenario above poses unique set of challenges. Taken literally our unit tests would have to run only on specific day (1) or sleep for an hour to observe some behaviour. Scenario (3) might even be impossible to test under some circumstances since system clock can tick 1 millisecond at any time, thus making test unreliable.<br /><br />Fake system clock addresses these issues by abstracting system time over simple interface. Essentially you never call <code>new Date()</code>, <code>new GregorianCalendar()</code> or <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#currentTimeMillis()"><code>System.currentTimeMillis()</code></a> but always rely on this:<br /><br /><pre class="brush: scala">import org.joda.time.{DateTime, Instant}<br /><br />trait Clock {<br /><br />    def now(): Instant<br /><br />    def dateNow(): DateTime<br /><br />}<br /></pre>As you can see I am depending on <a href="http://joda-time.sourceforge.net/">Joda Time</a> library. Since we are already in the Scala land, one might consider <a href="https://github.com/jorgeortiz85/scala-time">scala-time</a> or <a href="https://github.com/nscala-time/nscala-time">nscala-time</a> wrappers. Moreover the abstract name <code>Clock</code> is not a coincidence. It’s short and descriptive, but more importantly it mimics <a href="http://download.java.net/jdk8/docs/api/java/time/Clock.html"><code>java.time.Clock</code></a> class from Java 8 - that happens to address the same problem discussed here at the JDK level! But since Java 8 is still not here, let’s stay with our sweet and small abstraction.<br /><br />The standard implementation that you would normally use simply delegates to system time:<br /><a name='more'></a><br /><br /><pre class="brush: scala">import org.joda.time.{Instant, DateTime}<br /><br />object SystemClock extends Clock {<br /><br />    def now() = Instant.now()<br /><br />    def dateNow() = DateTime.now()<br /><br />}<br /></pre>For the purposes of unit testing we will develop other implementations, but first let’s focus on usage scenarios. In a typical Spring/JavaEE applications fake system clock can be turned into a dependency that the container can easily inject. This makes dependence on system time explicit and manageable, especially in tests:<br /><br /><pre class="brush: scala">@Controller<br />class FooController @Autowired() (fooService: FooService, clock: Clock) {<br /><br />    def postFoo(name: String) =<br />        fooService store new Foo(name, clock)<br /><br />}<br /></pre>Here I am using <a href="http://nurkiewicz.blogspot.no/2011/09/evolution-of-spring-dependency.html">Spring constructor injection</a> asking the container to provide some <code>Clock</code> implementation. Of course in this case <code>SystemClock</code> is marked as <code>@Service</code>. In unit tests I can pass fake implementation and in integration tests I can place another, <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/context/annotation/Primary.html"><code>@Primary</code></a> bean in the context, shadowing the <code>SystemClock</code>.<br /><br />This works great, but becomes painful for certain types of objects, namely entity/DTO beans and utility (<code>static</code>) classes. These are typically not managed by Spring so it can’t inject <code>Clock</code> bean to them. This forces us to pass <code>Clock</code> manually from the last “managed” layer:<br /><br /><pre class="brush: scala">class Foo(fooName: String, clock: Clock) {<br /><br />    val name = fooName<br />    val time = clock.dateNow()<br /><br />}<br /></pre>similarly:<br /><br /><pre class="brush: scala">object TimeUtil {<br /><br />    def firstFridayOfNextMonth(clock: Clock) = //...<br /><br />}<br /></pre>It’s not bad from design perspective. Both <code>Foo</code> constructor and <code>firstFridayOfNextMonth()</code> method do rely on system time so let’s make it explicit. On the other hand <code>Clock</code> dependency must be dragged, sometimes through many layers, just so that it can be used in one single method somewhere. Again, this is not bad <i>per se</i>. If your high level method has <code>Clock</code> parameter you know from the beginning that it relies on current time. But still is seems like a lot of boilerplate and overhead for little gain. Luckily Scala can help us here with:<br /><br /><h2><code>implicit</code> parameters</h2>Let us refactor our solution a little bit so that <code>Clock</code> is an implicit parameter:<br /><br /><pre class="brush: scala">@Controller<br />class FooController(fooService: FooService) {<br /><br />    def postFoo(name: String)(implicit clock: Clock) =<br />        fooService store new Foo(name)<br /><br />}<br /><br />@Service<br />class FooService(fooRepository: FooRepository) {<br /><br />    def store(foo: Foo)(implicit clock: Clock) =<br />        fooRepository storeInFuture foo<br /><br />}<br /><br />@Repository<br />class FooRepository {<br /><br />    def storeInFuture(foo: Foo)(implicit clock: Clock) = {<br />        val friday = TimeUtil.firstFridayOfNextMonth()<br />        //...<br />    }<br /><br />}<br /><br />object TimeUtil {<br /><br />    def firstFridayOfNextMonth()(implicit clock: Clock) = //...<br /><br />}<br /></pre>Notice how we call <code>fooRepository storeInFuture foo</code> ignoring second <code>clock</code> parameter. However this alone is not enough. We still have to provide some <code>Clock</code> instance as second parameter, otherwise compilation error strikes:<br /><br /><pre class="brush: scala">could not find implicit value for parameter clock: com.blogspot.nurkiewicz.foo.Clock<br />    controller.postFoo("Abc")<br />                      ^<br /><br />not enough arguments for method postFoo: (implicit clock: com.blogspot.nurkiewicz.foo.Clock)Unit.<br />Unspecified value parameter clock.<br />    controller.postFoo("Abc")<br />                      ^<br /></pre>The compiler tried to find implicit value for <code>Clock</code> parameter but failed. However we are really close, the simplest solution is to use <a href="http://www.scala-lang.org/docu/files/packageobjects/packageobjects.html">package object</a>:<br /><br /><pre class="brush: scala">package com.blogspot.nurkiewicz.foo<br /><br />package object foo {<br /><br />    implicit val clock = SystemClock<br /><br />}<br /></pre>Where <code>SystemClock</code> was defined earlier. Here is what happens: every time I call a function with <code>implicit clock: Clock</code> parameter inside <code>com.blogspot.nurkiewicz.foo</code> package, the compiler will discover <code>foo.clock</code> implicit variable and pass it transparently. In other words the following code snippets are equivalent but the second one provides explicit <code>Clock</code>, thus ignoring implicits:<br /><br /><pre class="brush: scala">TimeUtil.firstFridayOfNextMonth()<br />TimeUtil.firstFridayOfNextMonth()(SystemClock)<br /></pre>also equivalent (first form is turned into the second by the compiler):<br /><br /><pre class="brush: scala">fooService.store(foo)<br />fooService.store(foo)(SystemClock)<br /></pre>Interestingly in the bytecode level, implicit parameters aren’t any different from normal parameters so if you want to call such method from Java, passing <code>Clock</code> instance is mandatory and explicit.<br /><br /><code>implicit clock</code> parameter seems to work quite well. It hides ubiquitous dependency while still giving possibility to override it. For example in:<br /><br /><h2>Tests</h2>The whole point of abstracting system time was to enable unit testing by gaining full control over time flow. Let us begin with a simple fake system clock implementation that always returns the same, specified time:<br /><br /><pre class="brush: scala">class FakeClock(fixed: DateTime) extends Clock {<br />    def now() = fixed.toInstant<br /><br />    def dateNow() = fixed<br />}<br /></pre>Of course you are free to put any logic here: advancing time by arbitrary value, speeding it up, etc. You get the idea. Now remember, the reason for <code>implicit</code> parameter was to hide <code>Clock</code> from normal production code while still being able to supply alternative implementation. There are two approaches: either pass <code>FakeClock</code> explicitly in tests:<br /><br /><pre class="brush: scala">val fakeClock = new FakeClock(<br />   new DateTime(2013, 7, 15, 0, 0, DateTimeZone.UTC))<br /><br />controller.postFoo("Abc")(fakeClock)<br /></pre>or make it implicit but more specific to the compiler resolution mechanism:<br /><br /><pre class="brush: scala">implicit val fakeClock = new FakeClock(<br />   new DateTime(2013, 7, 15, 0, 0, DateTimeZone.UTC))<br /><br />controller.postFoo("Abc")<br /></pre>The latter approach is easier to maintain as you don’t have to remember about passing <code>fakeClock</code> to method under test all the time. Of course <code>fakeClock</code> can be defined more globally as a field or even inside test package object. No matter which technique of providing <code>fakeClock</code> we choose, it will be used throughout all calls to service, repository and utilities. The moment we given explicit value to this parameter, implicit parameter resolution is ignored.<br /><br /><h2>Problems and summary</h2>Solution above to testing systems heavily dependant on time is not free from issues on its own. First of all the implicit <code>Clock</code> parameter must be propagated throughout all the layers up to the client code. Notice that <code>Clock</code> is only needed in repository/utility layer while we had to drag it up to the controller layer. It’s not a big deal since the compiler will fill it in for us, but sooner or later most of our methods will include this extra parameter.<br /><br />Also Java and frameworks working on top of our code are not aware of Scala implicit resolution happening at compile time. Therefore e.g. our Spring MVC controller will not work as Spring is not aware of <code>SystemClock</code> implicit variable. It can be worked around though with <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/bind/support/WebArgumentResolver.html"><code>WebArgumentResolver</code></a>.<br /><br />Fake system clock pattern in general works only when used consistently. If you have even one place when real time is used directly as opposed to <code>Clock</code> abstraction, good luck in finding test failure reason. This applies equally to libraries and SQL queries. Thus if you are designing a library relying on current time, consider providing pluggable <code>Clock</code> abstraction so that client code can supply custom implementation like <code>FakeClock</code>. In SQL, on the other hand, do not rely on functions like <a href="http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_now"><code>NOW()</code></a> but always explicitly provide dates from your code (and thus from custom <code>Clock</code>).<br /><br /> <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>