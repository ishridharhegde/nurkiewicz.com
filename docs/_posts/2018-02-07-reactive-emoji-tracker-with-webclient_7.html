---
layout: post
title: 'Reactive emoji tracker with WebClient and Reactor: aggregating data'
date: '2018-02-07T00:30:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- emojitracker
- reactor
- spring
- emoji
- webclient
modified_time: '2018-02-07T00:30:40.049+01:00'
thumbnail: https://4.bp.blogspot.com/-aX6Rep5dq-w/Wno6AunIl2I/AAAAAAAAWLY/W_8YgUAScBI84yKGY-ssZF3_MYfUlNfbwCLcBGAs/s72-c/Screen%2BShot%2B2018-01-20%2Bat%2B18.32.30.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4884084632229804196
blogger_orig_url: https://www.nurkiewicz.com/2018/02/reactive-emoji-tracker-with-webclient_7.html
---

In the <a href="http://www.nurkiewicz.com/2018/02/reactive-emoji-tracker-with-webclient.html">first part</a> we managed to connect to <a href="http://emojitracker.com/">emojitracker.com</a> and consume SSE stream that looks like this:<br /><br /><pre class="prettyprint linenums">data:{"1F60D":1}<br /><br />data:{"1F3A8":1,"1F48B":1,"1F499":1,"1F602":1,"2764":1}<br /><br />data:{"1F607":1,"2764":2}</pre>Each message represents the number of various emojis that appeared on Twitter since the previous message. After a few transformations, we got a stream of hexadecimal Unicode values for each emoji. E.g. for <code>{"1F607":1,"2764":2}</code> we produce three events: <code>"1F607"</code>, <code>"2764"</code>, <code>"2764"</code>. This is how we achieved it:<br /><br /><pre class="prettyprint linenums">import org.springframework.http.codec.ServerSentEvent;<br />import org.springframework.web.reactive.function.client.WebClient;<br />import reactor.core.publisher.Flux;<br />import reactor.core.publisher.Mono;<br /><br />final Flux&lt;String&gt; stream = WebClient<br />        .create("http://emojitrack-gostreamer.herokuapp.com")<br />        .get().uri("/subscribe/eps")<br />        .retrieve()<br />        .bodyToFlux(ServerSentEvent.class)<br />        .flatMap(e -&gt; Mono.justOrEmpty(e.data()))<br />        .map(x -&gt; (Map&lt;String, Integer&gt;) x)<br />        .flatMapIterable(Map::entrySet)<br />        .flatMap(entry -&gt; Flux.just(entry.getKey()).repeat(entry.getValue()));</pre>Our next goal is to show the top 50 most popular emojis since we started the application. But first let's convert these boring Unicode hexadecimal values into, you know, emojis! This is pretty simple:<br /><br /><pre class="prettyprint linenums"> String hexToEmoji(String hex) {<br />    return new String(Character.toChars(Integer.parseInt(hex, 16)));<br />}</pre>Seems to work:<br /><br /><pre class="prettyprint linenums">@Unroll<br />class EmojiTrackerSpec extends Specification {<br /><br />    def 'translate #hex to #emoji'() {<br />        expect:<br />            hexToEmoji(hex) == emoji<br />        where:<br />            hex     || emoji<br />            '2611'  || '☑'<br />            '263A'  || '☺'<br />            '2764'  || '❤'<br />            '1F440' || '👀'<br />            '1F49E' || '💞'<br />            '1F605' || '😅'<br />            '1F60A' || '😊'<br />            '1F60D' || '😍'<br />            '1F60E' || '😎'<br />            '1F60F' || '😏'<br />            '1F61E' || '😞'<br />            '1F62D' || '😭'<br />            '1F646' || '🙆'<br />            '1F6B6' || '🚶'<br />    }<br /><br />}</pre>Apparently, this is the weirdest test case I ever wrote. Let's plug in <code>hexToEmoji()</code>:<br /><br /><pre class="prettyprint linenums">final Flux&lt;String&gt; stream = WebClient<br />         //...see above for missing lines...<br />        .map(ServerSentEvent::data)<br />        .map(x -&gt; (Map&lt;String, Integer&gt;) x)<br />        .flatMapIterable(Map::entrySet)<br />        .flatMap(entry -&gt; Flux.just(entry.getKey()).repeat(entry.getValue()))<br />        .map(Tracker::hexToEmoji);</pre>My terminal exploded with happy faces, hearts and other emojis:<br /><br /><pre class="prettyprint linenums">Received: 🎥<br />Received: 💙<br />Received: 😍<br />Received: 🚑<br />Received: 😂<br />Received: 😒<br />Received: 🎉<br />Received: 😉<br />Received: ❤<br />Received: ⚽<br />Received: 👐<br />Received: 😍<br />Received: ♻<br />Received: ♻<br />Received: 💙<br />Received: 🔥<br />Received: 😂<br />Received: 😅<br />Received: 😘<br />Received: 💪<br />Received: 😉<br />Received: ♻<br />Received: 😪<br />Received: 😃<br />Received: 🙏<br />Received: 💔<br />Received: 😂<br />Received: 😍<br />Received: 🎶<br />Received: 🎹<br />Received: 👍<br />Received: 🔥<br />Received: 😎</pre>Then it exploded for real with: <code>NumberFormatException: For input string: "1F1F5-1F1F1"</code>. Turns out some emojis are bigger than the other. For example, two individual characters: 🇵 and 🇱 when placed next to each other (🇵🇱) <em>may</em> be rendered as a flag. Polish flag in this case. A single emoji formed from two emojis. We need to enhance our parsing logic by parsing each hexadecimal number separated by dash (<code>-</code>) individually and concatenating characters. To be honest I started with something quite complex:<br /><br /><pre class="prettyprint linenums">private static String codeToEmoji(String hex) {<br />    return Arrays<br />            .stream(hex.split("-"))<br />            .map(Tracker::hexToEmoji)<br />            .collect(joining());<br />}<br /><br />private static String hexToEmoji(String hex) {<br />    return new String(Character.toChars(Integer.parseInt(hex, 16)));<br />}</pre>But it turns out the more straightforward solution is both more readable and most likely faster:<br /><br /><pre class="prettyprint linenums">private static String codeToEmoji(String hex) {<br />    final String[] codes = hex.split("-");<br />    if (codes.length == 2) {<br />        return hexToEmoji(codes[0]) + hexToEmoji(codes[1]);<br />    } else {<br />        return hexToEmoji(hex);<br />    }<br />}</pre>Maybe not as impressive, but I like it more. Few more test cases and we are free to go:<br /><br /><pre class="prettyprint linenums">'1F1F5-1F1F1' || '🇵🇱'<br />'1F1FA-1F1E6' || '🇺🇦'<br />'1F1FA-1F1F8' || '🇺🇸'</pre>OK, we are finally ready to aggregate individual events. We must somehow aggregate individual emojis into some sort of histogram (occurrence map). Basically, we want a <code>Map&lt;String, Long&gt;</code> of all emojis since the very beginning. The worst way to do this is global, mutable state:<br /><br /><pre class="prettyprint linenums">final ConcurrentHashMap&lt;String, Long&gt; histogram = new ConcurrentHashMap&lt;&gt;();<br /><br />final Flux&lt;String&gt; stream = WebClient<br />         //...see above for missing lines...<br />        .map(Tracker::codeToEmoji)<br />        .doOnNext(emoji -&gt; histogram.merge(emoji, 1L, Math::addExact));</pre>If you are still not aware of <code>Map.merge()</code> method, it does something quite common, that can be expressed like this:<br /><br /><pre class="prettyprint linenums">if(histogram.contains(emoji)) {<br />    histogram.put(emoji, Math.addExact(histogram.get(emoji), 1L)<br />} else {<br />    histogram.put(emoji(1L));<br />}</pre>After five seconds the <code>histogram</code> may look for example like this:<br /><br />{💸=1, ☀=1, ☁=1, ✅=2, ⬅=1, ✈=1, 💯=3, 🚮=1, ✋=2, ✌=2, 💲=1, 🚨=1, 💨=1, 🏆=1, 🚧=1, 💥=1, ✔=4, ☕=1, 💪=2, 🎼=1, 💡=1, 🏀=1, 📚=1, ✨=7, 📅=1, 📌=2, 🏨=1, ☺=6, ‼=2, 📷=5, 🌚=2, 📹=3, 📰=1, 🌍=1, 🌆=1, 🌊=1, ❗=1, 📞=2, 📝=1, 🇺🇸=2, 😘=5, 🌷=1, 😖=2, 😕=2, ❤=42, 😜=3, ♥=7, 😛=1, ♦=1, 🌹=3, 😚=1, 🌸=2, 😙=1, 🐐=2, 😐=2, 😏=11, 😎=2, 😍=12, 🔔=1, 😔=1, 🐓=1, 🌱=1, 😒=8, 🐒=1, 🔑=1, 😑=4, 🔈=1, 😈=1, 😇=2, 😆=2, 🐆=1, 😅=3, 😌=3, 😋=2, 😊=11, 😉=9, 🔉=1, 🌟=2, 😀=4, 🌞=2, ♻=9, 😄=8, 😃=1, 😂=75, 😁=9, 😸=1, 🐶=1, 😶=1, 😵=1, 😻=3, 😰=1, 😮=2, 😭=18, 🔴=2, 😴=3, 😳=1, 🐳=1, 😲=2, 😱=4, 😨=2, 🍄=1, 🔥=4, 😥=4, 😬=2, 🔫=1, 😫=2, ➕=1, 😩=7, 🌿=1, 😠=1, 😞=3, 🔞=1, 😝=2, 🌼=1, 😤=1, 😣=1, 😢=5, 🍁=1, 😡=4, ⚠=1, ➡=4, ⚡=2, 🍺=1, ©=1, 👏=6, 🙏=2, 👎=1, 👍=10, 👓=1, ®=1, 👑=2, 🙈=4, 👇=3, 🍫=1, 🙌=5, 👌=2, 👋=2, 🙋=1, 🙊=2, ▶=2, 👊=1, 👉=2, 👀=3, ⚽=3, ◀=1, 9⃣=1, 🆒=1, 🎉=2, 💘=3, 🎶=2, 💗=2, 🚗=1, 🚖=2, 🎵=1, 💕=6, 💜=2, 💛=7, 💙=8, 💎=1, 🎬=1, 💔=11, 🎲=1, 💓=2, 🎧=2, 💋=5, 💀=4, 💄=1, 💃=1}<br /><br />Within 5 seconds 😂 emoji was sent 75 times to Twitter! So why is this solution bad? Modifying global mutable state from within your reactive stream inevitably leads to race conditions and problems with synchronization. A much better solution is to aggregate events within the stream itself. It's a bit mind-bending. Basically, we turn a stream of individual events into a stream of gradually built aggregation. Every event is applied to our histogram and passed further downstream. Look:<br /><br /><pre class="prettyprint linenums">final Flux&lt;HashMap&lt;String, Long&gt;&gt; stream = WebClient<br />         //...see above for missing lines...<br />        .map(Tracker::codeToEmoji)<br />        .scan(new HashMap&lt;String, Long&gt;(), (histogram, emoji) -&gt; {<br />            histogram.merge(emoji, 1L, Math::addExact);<br />            return histogram;<br />        });</pre>See how a single emoji in the input stream (for example "💖") results in a histogram of "<code>{💖=1}</code>" on the output stream:<br /><br /><pre class="prettyprint linenums">💖   -&gt;  {💖=1}<br />🔝   -&gt;  {💖=1, 🔝=1}<br />😂   -&gt;  {💖=1, 🔝=1, 😂=1}<br />👀   -&gt;  {💖=1, 👀=1, 🔝=1, 😂=1}<br />😍   -&gt;  {💖=1, 👀=1, 😍=1, 🔝=1, 😂=1}<br />😂   -&gt;  {💖=1, 👀=1, 😍=1, 🔝=1, 😂=2}<br />😀   -&gt;  {💖=1, 😀=1, 👀=1, 😍=1, 🔝=1, 😂=2}<br />😂   -&gt;  {💖=1, 😀=1, 👀=1, 😍=1, 🔝=1, 😂=3}</pre>Notice how each individual emoji is either added to the map or increments existing entry. Theoretically, the occurrence map (histogram) can grow quite large. However, the number of different emojis is fixed and not that large (<a href="https://emojipedia.org/stats/">2666</a> as of this writing). Now we'd like to find the top 50 emojis - 50 map entries with highest occurrence count. This can easily be done with JDK 8 <code>Stream</code> API:<br /><br /><pre class="prettyprint linenums">import java.util.Comparator;<br />import static java.util.Comparator.comparing;<br /><br />String topEmojis(HashMap&lt;String, Long&gt; histogram, int max) {<br />    return histogram<br />            .entrySet()<br />            .stream()<br />            .sorted(comparing(Map.Entry&lt;String, Long&gt;::getValue).reversed())<br />            .limit(max)<br />            .map(Map.Entry::getKey)<br />            .collect(joining(" "));<br />}</pre>In the end we generate a <code>String</code> containing top 50 emojis, separated by spaces. We don't want to see the outcome after each and every emoji. Instead, let's sample the results 10 times a second:<br /><br /><pre class="prettyprint linenums">final Flux&lt;String&gt; stream = WebClient<br />         //...see above for missing lines...<br />        .scan(new HashMap&lt;String, Long&gt;(), (histogram, emoji) -&gt; {<br />            histogram.merge(emoji, 1L, Math::addExact);<br />            return histogram;<br />        })<br />        .map(hist -&gt; topEmojis(hist, 50))<br />        .sample(Duration.ofMillis(100));</pre>The full source code looks as follows:<br /><br /><pre class="prettyprint linenums">import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.http.codec.ServerSentEvent;<br />import org.springframework.web.reactive.function.client.WebClient;<br />import reactor.core.publisher.Flux;<br />import reactor.core.publisher.Mono;<br /><br />import java.time.Duration;<br />import java.util.Comparator;<br />import java.util.HashMap;<br />import java.util.Map;<br />import java.util.concurrent.TimeUnit;<br /><br />import static java.util.stream.Collectors.joining;<br />import static java.util.Comparator.comparing;<br /><br />public class Tracker {<br /><br />    private static final Logger log = LoggerFactory.getLogger(Tracker.class);<br />    <br />    public static void main(String[] args) throws InterruptedException {<br />        final Flux&lt;String&gt; stream = WebClient<br />                .create("http://emojitrack-gostreamer.herokuapp.com")<br />                .get().uri("/subscribe/eps")<br />                .retrieve()<br />                .bodyToFlux(ServerSentEvent.class)<br />                .flatMap(e -&gt; Mono.justOrEmpty(e.data()))<br />                .map(x -&gt; (Map&lt;String, Integer&gt;) x)<br />                .flatMapIterable(Map::entrySet)<br />                .flatMap(entry -&gt; Flux.just(entry.getKey()).repeat(entry.getValue()))<br />                .map(Tracker::codeToEmoji)<br />                .scan(new HashMap&lt;String, Long&gt;(), (histogram, emoji) -&gt; {<br />                    histogram.merge(emoji, 1L, Math::addExact);<br />                    return histogram;<br />                })<br />                .map(hist -&gt; topEmojis(hist, 50))<br />                .sample(Duration.ofMillis(100));<br /><br /><br />        stream.subscribe(sse -&gt; log.info("Received: {}", sse));<br /><br />        TimeUnit.MINUTES.sleep(10);<br />    }<br /><br />    private static String topEmojis(HashMap&lt;String, Long&gt; histogram, int max) {<br />        return histogram<br />                .entrySet()<br />                .stream()<br />                .sorted(comparing(Map.Entry&lt;String, Long&gt;::getValue).reversed())<br />                .limit(max)<br />                .map(Map.Entry::getKey)<br />                .collect(joining(" "));<br />    }<br /><br />    private static String codeToEmoji(String hex) {<br />        final String[] codes = hex.split("-");<br />        if (codes.length == 2) {<br />            return hexToEmoji(codes[0]) + hexToEmoji(codes[1]);<br />        } else {<br />            return hexToEmoji(hex);<br />        }<br />    }<br /><br />    private static String hexToEmoji(String hex) {<br />        return new String(Character.toChars(Integer.parseInt(hex, 16)));<br />    }<br /><br />}</pre>And the results are adorable:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-aX6Rep5dq-w/Wno6AunIl2I/AAAAAAAAWLY/W_8YgUAScBI84yKGY-ssZF3_MYfUlNfbwCLcBGAs/s1600/Screen%2BShot%2B2018-01-20%2Bat%2B18.32.30.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="519" data-original-width="1600" height="204" src="https://4.bp.blogspot.com/-aX6Rep5dq-w/Wno6AunIl2I/AAAAAAAAWLY/W_8YgUAScBI84yKGY-ssZF3_MYfUlNfbwCLcBGAs/s640/Screen%2BShot%2B2018-01-20%2Bat%2B18.32.30.png" width="640" /></a></div><br /><br />You might think this and the <a href="http://www.nurkiewicz.com/2018/02/reactive-emoji-tracker-with-webclient.html">previous article</a> aren't very practical. On the surface, yes. But we learned a few techniques that can be really valuable when dealing with real streams of data. Also producing and consuming SSE stream is the easiest way to enable streaming architecture in your ecosystem.