---
layout: post
title: Journey to idempotency and temporal decoupling
date: '2015-02-23T09:26:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- jms
- spring mvc
- HTTP
- rest
- spring
modified_time: '2015-02-23T09:26:25.741+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2596562119634320142
blogger_orig_url: https://www.nurkiewicz.com/2015/02/journey-to-idempotency-and-temporal.html
---

<em>Idempotency</em> in HTTP means that the same request can be performed multiple times with the same effect as if it was executed just once. If you replace current state of some resource with new one, no matter how many times you do so, in the end state will be the same as if you did it just once. To give more concrete example: deleting a user is idempotent because no matter how many times you delete given user by unique identifier, in the end this user will be deleted. On the other hand creating new user is not idempotent because requesting such operation twice will create two users. In HTTP terms here is what <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">RFC 2616: 9.1.2 Idempotent Methods</a> has to say:<br/><br/><blockquote><h3>9.1.2 Idempotent Methods</h3>Methods can also have the property of "<em>idempotence</em>" in that [...] the side-effects of N &gt; 0 identical requests is the same as for a single request. The methods GET, HEAD, PUT and DELETE share this property. Also, the methods OPTIONS and TRACE SHOULD NOT have side effects, and so are inherently idempotent.<br/><br/></blockquote><em>Temporal coupling</em> is an undesirable property of a system where the correct behaviour is implicitly dependent on time dimension. In plain English, it might mean that for example system only works when all components are present at the same time. Blocking request-response communication (ReST, SOAP or any other form of RPC) require both client and server to be available at the same time, which is an example of this effect.<br/><br/>Having basic understanding what these concepts mean, let's go through a simple case study - <a href="http://en.wikipedia.org/wiki/Massively_multiplayer_online_role-playing_game">massively multiplayer online role-playing game</a>. Our artificial use case is as follows: a player sends premium-rated SMS to purchase virtual sword inside game. Our HTTP gateway is called when SMS is delivered and we need to inform <code>InventoryService</code>, deployed on a different machine. Current API involves ReST and looks as follows:<br/><br/><pre class="brush: java">@Slf4j<br />@RestController<br />class SmsController {<br /><br />    private final RestOperations restOperations;<br /><br />    @Autowired<br />    public SmsController(RestOperations restOperations) {<br />        this.restOperations = restOperations;<br />    }<br /><br />    @RequestMapping(value = "/sms/{phoneNumber}", method = POST)<br />    public void handleSms(@PathVariable String phoneNumber) {<br />        Optional&lt;Player&gt; maybePlayer = phoneNumberToPlayer(phoneNumber);<br />        maybePlayer<br />                .map(Player::getId)<br />                .map(this::purchaseSword)<br />                .orElseThrow(() -&gt; new IllegalArgumentException("Unknown player for phone number " + phoneNumber));<br />    }<br /><br />    private long purchaseSword(long playerId) {<br />        Sword sword = new Sword();<br />        HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(sword.toJson(), jsonHeaders());<br />        restOperations.postForObject(<br />            "http://inventory:8080/player/{playerId}/inventory", <br />            entity, Object.class, playerId);<br />        return playerId;<br />    }<br /><br />    private HttpHeaders jsonHeaders() {<br />        HttpHeaders headers = new HttpHeaders();<br />        headers.setContentType(MediaType.APPLICATION_JSON);<br />        return headers;<br />    }<br /><br />    private Optional&lt;Player&gt; phoneNumberToPlayer(String phoneNumber) {<br />        //...<br />    }<br />}<br /></pre>Which in turns generates request similar to this:<br/><br/><pre class="brush: plain">&gt; POST /player/123123/inventory HTTP/1.1<br />&gt; Host: inventory:8080<br />&gt; Content-type: application/json<br />&gt;<br />&gt; {"type": "sword", "strength": 100, ...}<br /><br />&lt; HTTP/1.1 201 Created<br />&lt; Content-Length: 75<br />&lt; Content-Type: application/json;charset=UTF-8<br />&lt; Location: http://inventory:8080/player/123123/inventory/1<br /></pre>This is fairly straightforward. <code>SmsController</code> simply forwards appropriate data to <code>inventory:8080</code> service by POSTing sword that was purchased. This service, immediately or after a while, returns <code>201 Created</code> HTTP response confirming the operation was successful. Additionally link to resource is created and returned, so you can query it. One might say: ReST state of the art. However if you care at least a little about money of your customers and understand what ACID is (something that Bitcoin exchanges still have to learn: see <a href="http://hackingdistributed.com/2014/04/06/another-one-bites-the-dust-flexcoin/">[1]</a>, <a href="http://www.infoq.com/news/2014/04/bitcoin-banking-mongodb">[2]</a>, <a href="http://java.dzone.com/articles/mongodb-bitcoin-how-nosql">[3]</a> and <a href="http://scn.sap.com/community/hana-in-memory/blog/2013/12/21/the-problem-of-dropping-acid-non-acid-pos-is-unsuitable-for-bitcoin-and-financial-transactions">[4]</a>) - this API is too fragile and prone to errors. Imagine all these types of errors:<br/><br/><ol><li>your request never reached <code>inventory</code> server</li><li>your request reached server but it refused it</li><li>server accepted connection but failed to read request</li><li>server read request but hanged</li><li>server processed request but failed to send response</li><li>server sent 200 OK response but it was lost and you never received it</li><li>server's response was received but client failed to process it</li><li>server's response was sent but client timed-out earlier</li></ol>In all these cases you simply get an exception on the client side and you have no idea what's the server's state. Technically you should retry failed requests, but since POST is not idempotent, you might end up rewarding gamer with more than one sword (in cases 5-8). But without retry you might loose gamer's money without giving him his precious artifact. There must be a better way.<br/><br/><h1>Turning POST to idempotent PUT</h1>In some cases it's surprisingly simple to convert from POST to idempotent PUT by basically moving ID generation from server to client. With POST it was the server that generated sword's ID and sent it back to the client in <code>Location</code> header. Turns out eagerly generating UUID on the client side and changing the semantics a bit plus enforcing some constraints on the server side is enough:<br/><br/><pre class="brush: java">private long purchaseSword(long playerId) {<br />    Sword sword = new Sword();<br />    UUID uuid = sword.getUuid();<br />    HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(sword.toJson(), jsonHeaders());<br />    asyncRetryExecutor<br />            .withMaxRetries(10)<br />            .withExponentialBackoff(100, 2.0)<br />            .doWithRetry(ctx -&gt;<br />                    restOperations.put(<br />                            "http://inventory:8080/player/{playerId}/inventory/{uuid}",<br />                            entity, playerId, uuid));<br />    return playerId;<br />}<br /></pre>The API looks as follows:<br/><br/><pre class="brush: plain">&gt; PUT /player/123123/inventory/45e74f80-b2fb-11e4-ab27-0800200c9a66 HTTP/1.1<br />&gt; Host: inventory:8080<br />&gt; Content-type: application/json;charset=UTF-8<br />&gt;<br />&gt; {"type": "sword", "strength": 100, ...}<br /><br />&lt; HTTP/1.1 201 Created<br />&lt; Content-Length: 75<br />&lt; Content-Type: application/json;charset=UTF-8<br />&lt; Location: http://inventory:8080/player/123123/inventory/45e74f80-b2fb-11e4-ab27-0800200c9a66<br /></pre>Why it's such a big deal? Simply put (no pun intended) client can now retry PUT request as many times as he wants. When server receives PUT for the first time, it persists sword in the database with client-generated UUID (<code>45e74f80-b2fb-11e4-ab27-0800200c9a66</code>) as primary key. In case of second PUT attempt we can either update or reject such request. It wasn't possible with POST because every request was treated as a new sword purchase - now we can track whether such PUT came before or not. We just have to remember to subsequent PUT is not a bug, it's an update request:<br/><br/><pre class="brush: java">@RestController<br />@Slf4j<br />public class InventoryController {<br /><br />    private final PlayerRepository playerRepository;<br /><br />    @Autowired<br />    public InventoryController(PlayerRepository playerRepository) {<br />        this.playerRepository = playerRepository;<br />    }<br /><br />    @RequestMapping(value = "/player/{playerId}/inventory/{invId}", method = PUT)<br />    @Transactional<br />    public void addSword(@PathVariable UUID playerId, @PathVariable UUID invId) {<br />        playerRepository.findOne(playerId).addSwordWithId(invId);<br />    }<br /><br />}<br /><br />interface PlayerRepository extends JpaRepository&lt;Player, UUID&gt; {}<br /><br />@lombok.Data<br />@lombok.AllArgsConstructor<br />@lombok.NoArgsConstructor<br />@Entity<br />class Sword {<br /><br />    @Id<br />    @Convert(converter = UuidConverter.class)<br />    UUID id;<br />    int strength;<br /><br />    @Override<br />    public boolean equals(Object o) {<br />        if (this == o) return true;<br />        if (!(o instanceof Sword)) return false;<br />        Sword sword = (Sword) o;<br />        return id.equals(sword.id);<br /><br />    }<br /><br />    @Override<br />    public int hashCode() {<br />        return id.hashCode();<br />    }<br />}<br /><br />@Data<br />@Entity<br />class Player {<br /><br />    @Id<br />    @Convert(converter = UuidConverter.class)<br />    UUID id = UUID.randomUUID();<br /><br />    @OneToMany(cascade = ALL, fetch = EAGER)<br />    @JoinColumn(name="player_id")<br />    Set&lt;Sword&gt; swords = new HashSet&lt;&gt;();<br /><br />    public Player addSwordWithId(UUID id) {<br />        swords.add(new Sword(id, 100));<br />        return this;<br />    }<br /><br />}<br /></pre>Few shortcuts were made in code snippet above, like injecting repository directly to controller, as well as annotating is with <code>@Transactional</code>. But you get the idea. Also notice that this code is quite optimistic, assuming two swords with same UUID aren't inserted at exactly the same time. Otherwise constraint violation exception will occur.<br/><br/>Side note 1: I use <code>UUID</code> type in both controller and JPA models. They aren't supported out of the box, for JPA you need custom converter:<br/><br/><pre class="brush: java">public class UuidConverter implements AttributeConverter&lt;UUID, String&gt; {<br />    @Override<br />    public String convertToDatabaseColumn(UUID attribute) {<br />        return attribute.toString();<br />    }<br /><br />    @Override<br />    public UUID convertToEntityAttribute(String dbData) {<br />        return UUID.fromString(dbData);<br />    }<br />}<br /></pre>Similarly for Spring MVC (one-way only):<br/><br/><pre class="brush: java">@Bean<br />GenericConverter uuidConverter() {<br />    return new GenericConverter() {<br />        @Override<br />        public Set&lt;ConvertiblePair&gt; getConvertibleTypes() {<br />            return Collections.singleton(new ConvertiblePair(String.class, UUID.class));<br />        }<br /><br />        @Override<br />        public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {<br />            return UUID.fromString(source.toString());<br />        }<br />    };<br />}<br /></pre>Side note 2: if you can't change client, you can track duplicates by storing each requests' hash on the server side. This way when the same request is sent multiple times (retried by the client), it will be ignored. However sometimes we might have a legitimate use case for sending the exact same request twice (e.g. purchasing two swords within short period of time). <br/><br/><h1>Temporal coupling - client unavailability</h1>You think you're smart but PUT with retries is not enough. First of all a client can die while re-attempting failed requests. If server is severely damaged or down, retrying might take minutes or even hours. You can't simply block your incoming HTTP request just because one of your downstream dependencies is down - you must handle such requests asynchronously in background - if possible. But extending retry time increases probability of client dying or being restarted, which would loose our request. Imagine we received premium SMS but <code>InventoryService</code> is down at the moment. We can retry after second, two, four, etc., but what if <code>InventoryService</code> was down for couple of hours and it so happened that our service was restarted as well? We just lost that SMS and sword was never given to the gamer.<br/><br/>An answer to such issue is to persist pending request first and handle it later in background. Upon SMS receive we barely store player ID in database table called <code>pending_purchases</code>. A background scheduler or an event wakes up asynchronous thread that will collect all pending purchases and try to send them to <code>InventoryService</code> (maybe even in batch?) Periodic batch threads running every minute or even second and collecting all pending requests will unavoidably introduce latency and unneeded database traffic. Thus I'm going for a Quartz scheduler instead that will schedule retry job for each pending request:<br/><br/><pre class="brush: java">@Slf4j<br />@RestController<br />class SmsController {<br /><br />    private Scheduler scheduler;<br /><br />    @Autowired<br />    public SmsController(Scheduler scheduler) {<br />        this.scheduler = scheduler;<br />    }<br /><br />    @RequestMapping(value = "/sms/{phoneNumber}", method = POST)<br />    public void handleSms(@PathVariable String phoneNumber) {<br />        phoneNumberToPlayer(phoneNumber)<br />                .map(Player::getId)<br />                .map(this::purchaseSword)<br />                .orElseThrow(() -&gt; new IllegalArgumentException("Unknown player for phone number " + phoneNumber));<br />    }<br /><br />    private UUID purchaseSword(UUID playerId) {<br />        UUID swordId = UUID.randomUUID();<br />        InventoryAddJob.scheduleOn(scheduler, Duration.ZERO, playerId, swordId);<br />        return swordId;<br />    }<br /><br />    //...<br /><br />}<br /></pre>And job itself:<br/><br/><pre class="brush: java">@Slf4j<br />public class InventoryAddJob implements Job {<br /><br />    @Autowired private RestOperations restOperations;<br />    @lombok.Setter private UUID invId;<br />    @lombok.Setter private UUID playerId;<br /><br />    @Override<br />    public void execute(JobExecutionContext context) throws JobExecutionException {<br />        try {<br />            tryPurchase();<br />        } catch (Exception e) {<br />            Duration delay = Duration.ofSeconds(5);<br />            log.error("Can't add to inventory, will retry in {}", delay, e);<br />            scheduleOn(context.getScheduler(), delay, playerId, invId);<br />        }<br />    }<br /><br />    private void tryPurchase() {<br />        restOperations.put(/*...*/);<br />    }<br /><br />    public static void scheduleOn(Scheduler scheduler, Duration delay, UUID playerId, UUID invId) {<br />        try {<br />            JobDetail job = newJob()<br />                    .ofType(InventoryAddJob.class)<br />                    .usingJobData("playerId", playerId.toString())<br />                    .usingJobData("invId", invId.toString())<br />                    .build();<br />            Date runTimestamp = Date.from(Instant.now().plus(delay));<br />            Trigger trigger = newTrigger().startAt(runTimestamp).build();<br />            scheduler.scheduleJob(job, trigger);<br />        } catch (SchedulerException e) {<br />            throw new RuntimeException(e);<br />        }<br />    }<br /><br />}<br /></pre>Every time we receive premium SMS we schedule asynchronous job to be executed immediately. Quartz will take care of persistence (if application goes down, job will be executed as soon as possible after restart). Moreover if this particular instance goes down, another one can pick up this job - or we can form a cluster and load-balance requests between them: one instance receives SMS, another one requests sword in <code>InventoryService</code>. Obviously if HTTP call fails, retry is re-scheduled later, everything is transactional and fail-safe. In real code you would probably add max retry limit as well as exponential delay, but you get the idea.<br/><br/><h1>Temporal coupling - client and server can't meet</h1>Our struggle to implement retries correctly is a sign of obscure temporal coupling between client and server - they must live together at the same time. Technically this isn't necessary. Imagine gamer sending an e-mail with order to customer service which they handle within 48 hours, changing his inventory manually. The same can be applied to our case, but replacing e-mail server with some sort of message broker, e.g. JMS:<br/><br/><pre class="brush: java">@Bean<br />ActiveMQConnectionFactory activeMQConnectionFactory() {<br />    return new ActiveMQConnectionFactory("tcp://localhost:61616");<br />}<br /><br />@Bean<br />JmsTemplate jmsTemplate(ConnectionFactory connectionFactory) {<br />    return new JmsTemplate(connectionFactory);<br />}<br /></pre>Having ActiveMQ connection set up we can simply send purchase request to broker:<br/><br/><pre class="brush: java">private UUID purchaseSword(UUID playerId) {<br />    final Sword sword = new Sword(playerId);<br />    jmsTemplate.send("purchases", session -&gt; {<br />        TextMessage textMessage = session.createTextMessage();<br />        textMessage.setText(sword.toJson());<br />        return textMessage;<br />    });<br />    return sword.getUuid();<br />}<br /></pre>By entirely replacing synchronous request-response protocol with messaging over JMS topic we temporally decouple client from server. They no longer need to live at the same time. Moreover more than one producer and consumer can interact with each other. E.g. you can have multiple purchase channels and more importantly: multiple interested parties, not only <code>InventoryService</code>. Even better, if you use specialized messaging system like <a href="http://kafka.apache.org/">Kafka</a> you can technically keep days (months?) worth of messages without loosing performance. The benefit is that if you add another consumer of purchase events to the system next to <code>InventoryService</code> it will receive lots of historical data immediately. Moreover now your application is temporally coupled with broker so since Kafka is distributed and replicated, it works better in that case.<br/><br/><h1>Disadvantages of asynchronous messaging</h1>Synchronous data exchange, as used in ReST, SOAP or any form of RPC is easy to understand and implement. Who cares this abstraction insanely leaks from latency perspective (local method call is typically orders of magnitude faster compared to remote, not to mention it can fail for numerous reasons unknown locally), it's quick to develop. One true caveat of messaging is feedback channel. You can longer just "<em>send</em>" ("<em>return</em>") message back, as there is no response pipe. You either need response queue with some correlation ID or temporary one-off response queues per request. Also we lied a little bit claiming that putting a message broker between two systems fixes temporal coupling. It does, but now we are coupled to messaging bus - which can just as well go down, especially since it's often under high load and sometimes not replicated properly.<br/><br/>This article shows some challenges and partial solutions to provide guarantees in distributed systems. But in the end of the day, remember that "<em>exactly once</em>" semantics are nearly impossible to implement easily, so double check you really need them.<br/><br/> <script>SyntaxHighlighter.highlight();</script>