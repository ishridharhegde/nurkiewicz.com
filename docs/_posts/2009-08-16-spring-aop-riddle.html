---
layout: post
title: Spring AOP riddle
date: '2009-08-16T19:38:00.005+02:00'
author: Tomasz Nurkiewicz
tags:
- ejb
- aop
- spring
modified_time: '2009-09-20T17:12:21.951+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4947172745143790821
blogger_orig_url: https://www.nurkiewicz.com/2009/08/spring-aop-riddle.html
---

Spring support for aspect oriented programming is <a href="http://static.springsource.org/spring/docs/2.5.x/reference/aop.html">very wide</a>, but sometimes you may shoot yourself in the foot if you are not careful enough. Consider the following service interface:<br /><br /><pre name="code" class="java">public interface FoobarService {<br /><br /> void foo();<br /><br /> void bar();<br /><br />}</pre><br /><br />...and its implementation:<br /><br /><pre name="code" class="java">public class DefaultFoobarService implements FoobarService {<br /><br /> @Override<br /> @Transactional<br /> public void foo() {<br />   //some code requiring active transaction<br /> }<br /><br /> @Override<br /> public void bar() {<br />   foo();<br /> }<br />}</pre><br /><br />To keep things simple, assume that <span style="font-family:courier new;">foo()</span> throws exception if not run in context of active transaction. Since <span style="font-family:courier new;">main()</span> is so old-school, we’re going to test both methods through test case:<br /><br /><pre name="code" class="java">@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration<br />public class DefaultFoobarServiceTest {<br /><br /> @Autowired<br /> private FoobarService foobarService;<br /><br /> @Test<br /> public void testFoo() {<br />   foobarService.foo();<br /> }<br /><br /> @Test<br /> public void testBar() {<br />   foobarService.bar();<br /> }<br />}</pre><br /><br />Assuming <span style="font-family:courier new;">testFoo()</span> succeeded, will <span style="font-family:courier new;">testBar()</span> succeed as well? The trick part is transaction propagation...<br /><br /><br />...<br /><br /><br />The problem with <span style="font-family:courier new;">bar()</span> method is that it is not marked as transactional, but since it calls transactional method <span style="font-family:courier new;">foo()</span>, you may expect that <span style="font-family:courier new;">foo()</span> is called within a transaction... but it’s not! And since <span style="font-family:courier new;">foo()</span> called from <span style="font-family:courier new;">bar()</span> isn’t wrapped in a transaction, <span style="font-family:courier new;">foo()</span> will throw a exception and the test will fail.<br /><br />To explain this odd behavior, you must first understand how aspects (including declarative transactions) are applied to Spring beans. When we mark any of beans’ methods with <a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/transaction/annotation/Transactional.html">@Transactional</a> annotation, Spring automatically wraps the bean in Java dynamic proxy*. This proxy intercepts all method calls from other beans and if it encounters method marked as transactional, it performs special, transaction related routines (linking to existing or creating new transaction, rolling back on exception, etc.) Of course, the advice calls original method of wrapped object during its execution (like <span style="font-family:courier new;">foo()</span>). So as long as you are running foo(), Spring handles transactions transparently and smoothly.<br /><br />But think what happens when you call <span style="font-family:courier new;">bar()</span> method. Method is not marked as transactional, so even though transactional proxy will intercept the call, it will soon discover that method does not require transaction and simply delegate to original method <span style="font-family:courier new;">bar()</span>. Then the method invokes <span style="font-family:courier new;">foo()</span>. This is the place, where we expect the transaction to be started, but wait! – we are invoking <span style="font-family:courier new;">foo()</span> method on this reference, which points directly to the bean, not transactional aspect proxy. Spring does not know anything about this call, since you are calling method on Java object (POJO), not on a proxy instance wrapping this object. Declarative transaction management won’t be applied and <span style="font-family:courier new;">foo()</span> will throw unexpected exception.<br /><br />The answer is pretty obvious if you understand the mechanics of Spring AOP, because the same problem will occur in any code using aspects, not only transactions and not only via annotations. In fact, also the same problem has been solved in EJB by using <a style="font-family: courier new;" href="http://java.sun.com/javaee/5/docs/api/javax/ejb/SessionContext.html#getBusinessObject%28java.lang.Class%29">SessionContext.getBusinessObject()</a> method – passing this is forbidden by the specification. In Spring, the easiest way to avoid this particular bug in our code is to simply annotate <span style="font-family:courier new;">bar()</span> method as well.<br /><br />* If our bean does not implement any business interface, CGLIB will be used instead. Also, you must use &lt;tx:annotation-driven /&gt; to make this magic happen.<br /><br /><span style="font-weight: bold;">UPDATE:</span><br /><ul><li>More details: <a href="http://nurkiewicz.blogspot.com/2009/09/spring-aop-riddle-demystified.html">Spring AOP riddle demystified</a></li></ul>