---
layout: post
title: Hazelcast's MapLoader pitfalls
date: '2014-09-22T22:37:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- Hazelcast
modified_time: '2014-09-22T22:37:03.964+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8541208883980205872
blogger_orig_url: https://www.nurkiewicz.com/2014/09/hazelcasts-maploader-pitfalls.html
---

One of the core data structures provided by <a href="http://hazelcast.com/">Hazelcast</a> is <a href="http://hazelcast.org/docs/latest/javadoc/com/hazelcast/core/IMap.html"><code>IMap&lt;K, V&gt;</code></a> extending <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html"><code>java.util.concurrent.ConcurrentMap</code></a> - which is basically a distributed map, often used as cache. You can configure such map to use custom <a href="http://hazelcast.org/docs/3.3/javadoc/com/hazelcast/core/MapLoader.html"><code>MapLoader&lt;K, V&gt;</code></a> - piece of Java code that will be asked every time you try to <code>.get()</code> something from that map (by key) which is not yet there. This is especially useful when you use <code>IMap</code> as a distributed in-memory cache - if client code asks for something that wasn't cached yet, Hazelcast will transparently execute your <code>MapLoader.load(key)</code>:<br /><br /><pre class="brush: java">public interface MapLoader&lt;K, V&gt; {<br />    V load(K key);<br />    Map&lt;K, V&gt; loadAll(Collection&lt;K&gt; keys);<br />    Set&lt;K&gt; loadAllKeys();<br />}<br /></pre>The remaining two methods are used during startup to optionally warm-up cache by loading pre-defined set of keys. Your custom <code>MapLoader</code> can reach out to (No)SQL database, web-service, file-system, you name it. Working with such a cache is much more convenient because you don't have to implement tedious "<em>if not in cache load and put in cache</em>" cycle. Moreover, <code>MapLoader</code> has a fantastic feature - if many clients are asking at the same time for the same key (from different threads, or even different cluster members - thus machines), <code>MapLoader</code> is executed only once. This significantly decreases load on external dependencies, without introducing any complexity.<br /><br />In essence <code>IMap</code> with <code>MapLoader</code> is similar to <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/LoadingCache.html"><code>LoadingCache</code></a> found in <a href="https://code.google.com/p/guava-libraries/">Guava</a> - but distributed. However with great power comes great frustration, especially when you don't understand the peculiarities of API and inherent complexity of a distributed system.<br /><br />First let's see how to configure custom <code>MapLoader</code>. You can use <code>hazelcast.xml</code> for that (<code>&lt;map-store/&gt;</code> element), but you then have no control over life-cycle of your loader (e.g. you can't use Spring bean). A better idea is to configure Hazelcast directly from code and pass an instance of <code>MapLoader</code>:<br /><br /><pre class="brush: groovy">class HazelcastTest extends Specification {<br />    public static final int ANY_KEY = 42<br />    public static final String ANY_VALUE = "Forty two"<br /><br />    def 'should use custom loader'() {<br />        given:<br />        MapLoader loaderMock = Mock()<br />        loaderMock.load(ANY_KEY) &gt;&gt; ANY_VALUE<br />        def hz = build(loaderMock)<br />        IMap&lt;Integer, String&gt; emptyCache = hz.getMap("cache")<br /><br />        when:<br />        def value = emptyCache.get(ANY_KEY)<br /><br />        then:<br />        value == ANY_VALUE<br /><br />        cleanup:<br />        hz?.shutdown()<br />    }<br /></pre>Notice how we obtain an empty map, but when asked for <code>ANY_KEY</code>, we get <code>ANY_VALUE</code> in return. This is not a surprise, this is what our <code>loaderMock</code> was expected to do. I left Hazelcast configuration:<br /><br /><pre class="brush: groovy">def HazelcastInstance build(MapLoader&lt;Integer, String&gt; loader) {<br />    final Config config = new Config("Cluster")<br />    final MapConfig mapConfig = config.getMapConfig("default")<br />    final MapStoreConfig mapStoreConfig = new MapStoreConfig()<br />    mapStoreConfig.factoryImplementation = {name, props -&gt; loader } as MapStoreFactory<br />    mapConfig.mapStoreConfig = mapStoreConfig<br />    return Hazelcast.getOrCreateHazelcastInstance(config)<br />}<br /></pre>Any <code>IMap</code> (identified by name) can have a different configuration. However special <code>"default"</code> map specifies default configuration for all maps. Let's play a bit with custom loaders and see how they behave when <code>MapLoader</code> returns <code>null</code> or throws an exception:<br /><br /><pre class="brush: groovy">def 'should return null when custom loader returns it'() {<br />    given:<br />    MapLoader loaderMock = Mock()<br />    def hz = build(loaderMock)<br />    IMap&lt;Integer, String&gt; cache = hz.getMap("cache")<br /><br />    when:<br />    def value = cache.get(ANY_KEY)<br /><br />    then:<br />    value == null<br />    !cache.containsKey(ANY_KEY)<br /><br />    cleanup:<br />    hz?.shutdown()<br />}<br /><br />public static final String SOME_ERR_MSG = "Don't panic!"<br /><br />def 'should propagate exceptions from loader'() {<br />    given:<br />    MapLoader loaderMock = Mock()<br />    loaderMock.load(ANY_KEY) &gt;&gt; {throw new UnsupportedOperationException(SOME_ERR_MSG)}<br />    def hz = build(loaderMock)<br />    IMap&lt;Integer, String&gt; cache = hz.getMap("cache")<br /><br />    when:<br />    cache.get(ANY_KEY)<br /><br />    then:<br />    UnsupportedOperationException e = thrown()<br />    e.message.contains(SOME_ERR_MSG)<br /><br />    cleanup:<br />    hz?.shutdown()<br />}<br /></pre><h2><code>MapLoader</code> is executed in a separate thread</h2>So far nothing surprising. The first trap you might encounter is how threads interact here. <code>MapLoader</code> is never executed from client thread, always from a separate thread pool: <br /><br /><pre class="brush: groovy">def 'loader works in a different thread'() {<br />    given:<br />    MapLoader loader = Mock()<br />    loader.load(ANY_KEY) &gt;&gt; {key -&gt; "$key: ${Thread.currentThread().name}"}<br />    def hz = build(loader)<br />    IMap&lt;Integer, String&gt; cache = hz.getMap("cache")<br /><br />    when:<br />    def value = cache.get(ANY_KEY)<br /><br />    then:<br />    value != "$ANY_KEY: ${Thread.currentThread().name}"<br /><br />    cleanup:<br />    hz?.shutdown()<br />}<br /></pre>This test passes because current thread is <code>"main"</code> while loading occurs from within something like <code>"hz.Cluster.partition-operation.thread-10"</code>. This is an important observation and is actually quite obvious if you remember that when many threads try to access the same absent key, loader is called only once. But more needs to be explained here. Almost every operation on <code>IMap</code> is encapsulated into one of <a href="https://github.com/hazelcast/hazelcast/tree/v3.3/hazelcast/src/main/java/com/hazelcast/map/operation">operation objects</a> (see also: <a href="http://en.wikipedia.org/wiki/Command_pattern"><em>Command pattern</em></a>). This operation is later dispatched to one or all cluster members and executed remotely in a separate thread pool, or even on a different machine. Thus, don't expect loading to occur in the same thread, or even same JVM/server (!) <br /><br />This leads to an interesting situation where you request given key on one machine, but actual loading happens on the other. Or even more epic - machines A, B and C request given key whereas machine D physically loads value for that key. The decision which machine is responsible for loading is made based on <a href="http://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a> algorithm.<br /><br />One final remark - of course you can customize the size of thread pools running these operations, see <a href="https://github.com/hazelcast/hazelcast/blob/master/hazelcast-documentation/src/ConfigurationProperties.md">Advanced Configuration Properties</a>.<br /><br /><h1><code>IMap.remove()</code> calls <code>MapLoader</code></h1>This one is totally surprising and definitely to be expected once you think about it:<br /><br /><pre class="brush: groovy">def 'IMap.remove() on non-existing key still calls loader (!)'() {<br />    given:<br />    MapLoader loaderMock = Mock()<br />    def hz = build(loaderMock)<br />    IMap&lt;Integer, String&gt; emptyCache = hz.getMap("cache")<br /><br />    when:<br />    emptyCache.remove(ANY_KEY)<br /><br />    then:<br />    1 * loaderMock.load(ANY_KEY)<br /><br />    cleanup:<br />    hz?.shutdown()<br />}<br /></pre>Look carefully! All we do is removing absent key from a map. Nothing else. Yet, <code>loaderMock.load()</code> was executed. This is a problem especially when your custom loader is particularly slow or expensive. Why was it executed here? Look up the API of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#remove-java.lang.Object-">`java.util.Map#remove()</a>:<br /><br /><blockquote><code>V remove(Object key)</code><br /><br />[...]<br /><br />Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key.<br /><br /></blockquote>Maybe it's controversial but one might argue that Hazelcast is doing the right thing. If you consider our map with <code>MapLoader</code> attached as sort of like a view to external storage, it makes sense. When removing absent key, Hazelcast actually asks our <code>MapLoader</code>: what could have been a previous value? It pretends as if the map contained every single value returned from <code>MapLoader</code>, but loaded lazily. This is not a bug since there is a special method <a href="http://hazelcast.org/docs/3.3/javadoc/com/hazelcast/core/IMap.html#delete(java.lang.Object)"><code>IMap.delete()</code></a> that works just like <code>remove()</code>, but doesn't load "previous" value:<br /><br /><pre class="brush: groovy">@Issue("https://github.com/hazelcast/hazelcast/issues/3178")<br />def "IMap.delete() doesn't call loader"() {<br />    given:<br />    MapLoader loaderMock = Mock()<br />    def hz = build(loaderMock)<br />    IMap&lt;Integer, String&gt; cache = hz.getMap("cache")<br /><br />    when:<br />    cache.delete(ANY_KEY)<br /><br />    then:<br />    0 * loaderMock.load(ANY_KEY)<br /><br />    cleanup:<br />    hz?.shutdown()<br />}<br /></pre>Actually, there was a bug: <a href="https://github.com/hazelcast/hazelcast/issues/3178"><em><code>IMap.delete()</code> should not call <code>MapLoader.load()</code></em></a>, fixed in 3.2.6 and 3.3. If you haven't upgraded yet, even <code>IMap.delete()</code> will go to <code>MapLoader</code>. If you think <code>IMap.remove()</code> is surprising, check out how <code>put()</code> works!<br /><br /><h2><code>IMap.put()</code> calls MapLoader</h2>If you thought <code>remove()</code> loading value first is suspicious, what about explicit <code>put()</code> loading a value for a given key first? After all, we are <em>explicitly</em> putting something into a map by key, why Hazelcast loads this value first via <code>MapLoader</code>?<br /><br /><pre class="brush: groovy">def 'IMap.put() on non-existing key still calls loader (!)'() {<br />    given:<br />    MapLoader loaderMock = Mock()<br />    def hz = build(loaderMock)<br />    IMap&lt;Integer, String&gt; emptyCache = hz.getMap("cache")<br /><br />    when:<br />    emptyCache.put(ANY_KEY, ANY_VALUE)<br /><br />    then:<br />    1 * loaderMock.load(ANY_KEY)<br /><br />    cleanup:<br />    hz?.shutdown()<br />}<br /></pre>Again, let's restore to <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-"><code>java.util.Map.put()</code></a> JavaDoc:<br /><br /><blockquote>V put(K key, V value)<br /><br />[...]<br /><br />Returns:<br /><br />the previous value associated with key, or null if there was no mapping for key.<br /><br /></blockquote>Hazelcast pretends that <code>IMap</code> is just a lazy view over some external source, so when we <code>put()</code> something into an <code>IMap</code> that wasn't there before, it first loads the "previous" value so that it can return it. Again this is a big issue when <code>MapLoader</code> is slow or expensive - if we can explicitly put something into the map, why load it first? Luckily there is a straightforward workaround, <code>putTransient()</code>:<br /><br /><pre class="brush: groovy">def "IMap.putTransient() doesn't call loader"() {<br />    given:<br />    MapLoader loaderMock = Mock()<br />    def hz = build(loaderMock)<br />    IMap&lt;Integer, String&gt; cache = hz.getMap("cache")<br /><br />    when:<br />    cache.putTransient(ANY_KEY, ANY_VALUE, 1, TimeUnit.HOURS)<br /><br />    then:<br />    0 * loaderMock.load(ANY_KEY)<br /><br />    cleanup:<br />    hz?.shutdown()<br />}<br /></pre>One caveat is that you have to provide TTL explicitly, rather then relying on configured <code>IMap</code> defaults. But this also means you can assign arbitrary TTL to every map entry, not only globally to whole map - useful.<br /><br /><h2><code>IMap.containsKey()</code> involves <code>MapLoader</code>, can be slow or block</h2>Remember our analogy: <code>IMap</code> with backing <code>MapLoader</code> behaves like a view over external source of data. That's why it shouldn't be a surprise that <code>containsKey()</code> on an empty map will call <code>MapLoader</code>:<br /><br /><pre class="brush: groovy">def "IMap.containsKey() calls loader"() {<br />    given:<br />    MapLoader loaderMock = Mock()<br />    def hz = build(loaderMock)<br />    IMap&lt;Integer, String&gt; emptyMap = hz.getMap("cache")<br /><br />    when:<br />    emptyMap.containsKey(ANY_KEY)<br /><br />    then:<br />    1 * loaderMock.load(ANY_KEY)<br /><br />    cleanup:<br />    hz?.shutdown()<br />}<br /></pre>Every time we ask for a key that's not present in a map, Hazelcast will ask <code>MapLoader</code>. Again, this is not an issue as long as your loader is fast, side-effect free and reliable. If this is not the case, this will kill you:<br /><br /><pre class="brush: groovy">def "IMap.get() after IMap.containsKey() calls loader twice"() {<br />    given:<br />    MapLoader loaderMock = Mock()<br />    def hz = build(loaderMock)<br />    IMap&lt;Integer, String&gt; cache = hz.getMap("cache")<br /><br />    when:<br />    cache.containsKey(ANY_KEY)<br />    cache.get(ANY_KEY)<br /><br />    then:<br />    2 * loaderMock.load(ANY_KEY)<br /><br />    cleanup:<br />    hz?.shutdown()<br />}<br /></pre>Despite <code>containsKey()</code> calling <code>MapLoader</code>, it doesn't "cache" loaded value to use it later. That's why <code>containsKey()</code> followed by <code>get()</code> calls <code>MapLoader</code> two times, quite wasteful. Luckily if you call <code>containsKey()</code> on existing key, it runs almost immediately, although most likely will require network hop. What is not so fortunate is the behaviour of <code>keySet()</code>, <code>values()</code>, <code>entrySet()</code> and few other methods before version 3.3 of Hazelcast. These would all block in case <strong>any key</strong> is being loaded at a time. So if you have a map with thousands of keys and you ask for <code>keySet()</code>, one slow <code>MapLoader.load()</code> invocation will block whole cluster. This was fortunately fixed in 3.3, so that <code>IMap.keySet()</code>, <code>IMap.values()</code>, etc. do not block, even when some keys are being computed at the moment.<br /><br /><hr />As you can see <code>IMap</code> + <code>MapLoader</code> combo is powerful, but also filled with traps. Some of them are dictated by the API, osme by distributed nature of Hazelcast, finally some are implementation specific. Be sure you understand them before implementing loading cache feature. <br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>