---
layout: post
title: Simplifying trading system with Akka
date: '2014-05-29T23:20:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- akka
- multithreading
modified_time: '2014-05-29T23:20:23.356+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-10309046592518903
blogger_orig_url: https://www.nurkiewicz.com/2014/05/simplifying-trading-system-with-akka.html
---

My colleagues are developing a trading system that processes quite heavy stream of incoming transactions. Each transaction covers one <code>Instrument</code> (think bond or stock) and has some (now) unimportant properties. They are stuck with Java (&lt; 8), so let's stick to it: <br /><br /><pre class="brush: java">class Instrument implements Serializable, Comparable&lt;Instrument&gt; {<br />    private final String name;<br /><br />    public Instrument(String name) {<br />        this.name = name;<br />    }<br /><br />    //...Java boilerplate<br /><br />}<br /><br />public class Transaction {<br />    private final Instrument instrument;<br /><br />    public Transaction(Instrument instrument) {<br />        this.instrument = instrument;<br />    }<br /><br />    //...Java boilerplate<br /><br />}<br /></pre><code>Instrument</code> will later be used as a key in <code>HashMap</code>, so <a href="http://www.nurkiewicz.com/2014/04/hashmap-performance-improvements-in.html">for the future</a> we pro-actively implement <code>Comparable&lt;Instrument&gt;</code>. This is our domain, now the requirements:<br /><br /><ol><li>Transactions come into the system and need to be processed (whatever that means), as soon as possible</li><li>We are free to process them in any order</li><li>...however transactions for the same instrument need to be processed sequentially in the exact same order as they came in.</li></ol>Initial implementation was straightforward - put all incoming transactions into a queue (e.g. <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ArrayBlockingQueue.html"><code>ArrayBlockingQueue</code></a>) with a single consumer. This satisfies last requirement, since queue preserves strict FIFO ordering across all transactions. But such an architecture prevents concurrent processing of unrelated transactions for different instruments, thus wasting compelling throughput improvement. Not surprisingly this implementation, while undoubtedly simple, became a bottleneck.<br /><br />The first idea was to somehow split incoming transactions by instrument and process instruments individually. We came up with the following data structure:<br /><br /><pre class="brush: java">priavate final ConcurrentMap&lt;Instrument, Queue&lt;Transaction&gt;&gt; queues = <br />    new ConcurrentHashMap&lt;Instrument, Queue&lt;Transaction&gt;&gt;();<br /><br />public void accept(Transaction tx) {<br />    final Instrument instrument = tx.getInstrument();<br />    if (queues.get(instrument) == null) {<br />        queues.putIfAbsent(instrument, new LinkedBlockingQueue&lt;Transaction&gt;());<br />    }<br />    final Queue&lt;Transaction&gt; queue = queues.get(instrument);<br />    queue.add(tx);<br />}<br /></pre>Yuck! But worst is yet to come. How do you make sure at most one thread processes each queue at a time? After all, otherwise two threads could pick up items from one queue (one instrument) and process them in reversed order, which is not allowed. The simplest case is to have a <code>Thread</code> per queue - this won't scale, as we expect tens of thousands of different instruments. So we can have say <code>N</code> threads and let each of them handle a subset of queues, e.g. <code>instrument.hashCode() % N</code> tells us which thread takes care of given queue. But it's still not perfect for three reasons:<br /><br /><ol><li>One thread must "observe" many queues, most likely busy-waiting, iterating over them all the time. Alternatively queue might wake up its parent thread somehow</li><li>In worst case scenario all instruments will have conflicting hash codes, targeting only one thread - which is effectively the same as our initial solution</li><li>It's just damn complex! Beautiful code is not complex!</li></ol>Implementing this monstrosity is possible, but hard and error-prone. Moreover there is another non-functional requirement: instruments come and go and there are hundreds of thousands of them over time. After a while we should remove entries in our map representing instruments that were not seen lately. Otherwise we'll get a memory leak. <br /><br />If you can come up with some simpler solution, let me know. In the meantime let me tell you what I suggested my colleagues. As you can guess, it was Akka - and it turned out to be embarrassingly simple. We need two kinds of actors: <code>Dispatcher</code> and <code>Processor</code>. <code>Dispatcher</code> has one instance and receive all incoming transactions. Its responsibility is to find or spawn worker <code>Processor</code> actor for each <code>Instrument</code> and push transaction to it:<br /><br /><pre class="brush: java">public class Dispatcher extends UntypedActor {<br /><br />    private final Map&lt;Instrument, ActorRef&gt; instrumentProcessors = <br />        new HashMap&lt;Instrument, ActorRef&gt;();<br /><br />    @Override<br />    public void onReceive(Object message) throws Exception {<br />        if (message instanceof Transaction) {<br />            dispatch(((Transaction) message));<br />        } else {<br />            unhandled(message);<br />        }<br />    }<br /><br />    private void dispatch(Transaction tx) {<br />        final ActorRef processor = findOrCreateProcessorFor(tx.getInstrument());<br />        processor.tell(tx, self());<br />    }<br /><br />    private ActorRef findOrCreateProcessorFor(Instrument instrument) {<br />        final ActorRef maybeActor = instrumentProcessors.get(instrument);<br />        if (maybeActor != null) {<br />            return maybeActor;<br />        } else {<br />            final ActorRef actorRef = context().actorOf(<br />                Props.create(Processor.class), instrument.getName());<br />            instrumentProcessors.put(instrument, actorRef);<br />            return actorRef;<br />        }<br />    }<br />}<br /></pre>This is dead simple. Since our <code>Dispatcher</code> actor is effectively single-threaded, no synchronization is needed. We barely receive <code>Transaction</code>, lookup or create <code>Processor</code> and pass <code>Transaction</code> further. This is how <code>Processor</code> implementation could look like:<br /><br /><pre class="brush: java">public class Processor extends UntypedActor {<br /><br />    private final LoggingAdapter log = Logging.getLogger(getContext().system(), this);<br /><br />    @Override<br />    public void onReceive(Object message) throws Exception {<br />        if (message instanceof Transaction) {<br />            process(((Transaction) message));<br />        } else {<br />            unhandled(message);<br />        }<br />    }<br /><br />    private void process(Transaction tx) {<br />        log.info("Processing {}", tx);<br />    }<br />}<br /></pre>That's it! Interestingly our Akka implementation is almost identical to our first idea with map of queues. After all an actor is just a queue and a (logical) thread processing items in that queue. The difference is: Akka manages limited thread pool and shares it between maybe hundreds of thousands of actors. And because every instrument has its own dedicated (and "single-threaded") actor, sequential processing of transactions per instrument is guaranteed.<br /><br />One more thing. As stated earlier, there is an enormous amount of instruments and we don't want to keep actors for instruments that weren't seen for quite a while. Let's say that if a <code>Processor</code> didn't receive any transaction within an hour, it should be stopped and garbage collected. If later we receive new transaction for such instrument, we can always recreate it. This one is quite tricky - we must ensure that if transaction arrives when processor decided to delete itself, we can't loose that transaction. Rather than stopping itself, <code>Processor</code> signals its parent it was idle for too long. <code>Dispatcher</code> will then send <code>PoisonPill</code> to it. Because both <code>ProcessorIdle</code> and <code>Transaction</code> messages are processed sequentially, there is no risk of transaction being sent to no longer existing actor. <br /><br />Each actor manages its lifecycle independently by scheduling timeout using <code>setReceiveTimeout</code>:<br /><br /><pre class="brush: java">public class Processor extends UntypedActor {<br /><br />    @Override<br />    public void preStart() throws Exception {<br />        context().setReceiveTimeout(Duration.create(1, TimeUnit.HOURS));<br />    }<br /><br />    @Override<br />    public void onReceive(Object message) throws Exception {<br />        //...<br />        if (message instanceof ReceiveTimeout) {<br />            log.debug("Idle for two long, shutting down");<br />            context().parent().tell(ProcessorIdle.INSTANCE, self());<br />        } else {<br />            unhandled(message);<br />        }<br />    }<br /><br />}<br /><br />enum ProcessorIdle {<br />    INSTANCE<br />} <br /></pre>Clearly, when <code>Processor</code> did not receive any message for a period of one hour, it gently signals that to its parent (<code>Dispatcher</code>). But the actor is still alive and can handle transactions if they happen precisely after an hour. What <code>Dispatcher</code> does is it kills given <code>Processor</code> and removes it from a map:<br /><br /><pre class="brush: java">public class Dispatcher extends UntypedActor {<br /><br />    private final BiMap&lt;Instrument, ActorRef&gt; instrumentProcessors = HashBiMap.create();<br /><br />    public void onReceive(Object message) throws Exception {<br />        //...<br />        if (message == ProcessorIdle.INSTANCE) {<br />            removeIdleProcessor(sender());<br />            sender().tell(PoisonPill.getInstance(), self());<br />        } else {<br />            unhandled(message);<br />        }<br />    }<br /><br />    private void removeIdleProcessor(ActorRef idleProcessor) {<br />        instrumentProcessors.inverse().remove(idleProcessor);<br />    }<br /><br />    private void dispatch(Transaction tx) {<br />        final ActorRef processor = findOrCreateProcessorFor(tx.getInstrument());<br />        processor.tell(tx, self());<br />    }<br /><br />    //...<br /><br />}<br /></pre>There was a slight inconvenience. <code>instrumentProcessors</code> used to be a <code>Map&lt;Instrument, ActorRef&gt;</code>. This proved to be insufficient, since we suddenly have to remove an entry in this map by value. In other words we need to find a key (<code>Instrument</code>) that maps to a given <code>ActorRef</code> (<code>Processor</code>). There are different ways to handle it (e.g. idle <code>Processor</code> could send an <code>Instrumnt</code> it handles), but instead I used <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/BiMap.html"><code>BiMap&lt;K, V&gt;</code></a> from Guava. It works because both <code>Instrument</code>s and <code>ActorRef</code>s pointed are unique (actor-per-instrument). Having <code>BiMap</code> I could simply <code>inverse()</code> the map (from <code>BiMap&lt;Instrument, ActorRef&gt;</code> to <code>BiMap&lt;ActorRef, Instrument&gt;</code> and treat <code>ActorRef</code> as key.<br /><br />This Akka example is not more than "<em>hello, world</em>". But compared to convoluted solution we would have to write using concurrent queues, locks and thread pools, it's perfect. My team mates were so excited that by the end of the day they decided to rewrite their whole application to Akka.<br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>