---
layout: post
title: InterruptedException and interrupting threads explained
date: '2014-05-28T19:40:00.002+02:00'
author: Tomasz Nurkiewicz
tags:
- multithreading
modified_time: '2015-11-29T09:52:41.329+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-9001464640366716101
blogger_orig_url: https://www.nurkiewicz.com/2014/05/interruptedexception-and-interrupting.html
---

If <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html"><code>InterruptedException</code></a> wasn't checked exception, probably no one would even notice it - which would actually prevent couple of bugs throughout these years. But since it has to be handled, many handle it incorrectly or thoughtlessly. Let's take a simple example of a thread that periodically does some clean up, but in between sleeps most of the time.<br /><br /><pre class="brush: java">class Cleaner implements Runnable {<br /><br />  Cleaner() {<br />    final Thread cleanerThread = new Thread(this, "Cleaner");<br />    cleanerThread.start();<br />  }<br /><br />  @Override<br />  public void run() {<br />    while(true) {<br />      cleanUp();<br />      try {<br />        TimeUnit.SECONDS.sleep(1);<br />      } catch (InterruptedException e) {<br />        // TODO Auto-generated catch block<br />        e.printStackTrace();<br />      }<br />    }<br />  }<br /><br />  private void cleanUp() {<br />    //...<br />  }<br /><br />}<br /></pre>This code is wrong on so many layers! <br /><br /><ol><li>Starting <code>Thread</code> in a constructor might not be a good idea in some environments, e.g. some frameworks like Spring will create dynamic subclass to support method interception. We will end-up with two threads running from two instances.</li><li><code>InterruptedException</code> is swallowed, and the exception itself is not logged properly</li><li>This class starts a new thread for every instance, it should use <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html"><code>ScheduledThreadPoolExecutor</code></a> instead, shared among many instances (more robust and memory-effective)</li><li>Also with <code>ScheduledThreadPoolExecutor</code> we could avoid coding sleeping/working loop by ourselves, and also switch to fixed-rate as opposed to fixed-delay behaviour presented here.</li><li>Last but not least there is no way to get rid of this thread, even when <code>Cleaner</code> instance is no longer referenced by anything else</li></ol>All problems are valid, but swallowing <code>InterruptedException</code> is its biggest sin. Before we understand why, let us think for a while what does this exception mean and how we can take advantage of it to interrupt threads gracefully. Many blocking operations in JDK declare throwing <code>InterruptedException</code>, including:<br /><br /><ul><li><code>Object.wait()</code></li><li><code>Thread.sleep()</code></li><li><code>Process.waitFor()</code></li><li><code>AsynchronousChannelGroup.awaitTermination()</code></li><li>Various blocking methods in <code>java.util.concurrent.*</code>, e.g. <code>ExecutorService.awaitTermination()</code>, <code>Future.get()</code>, <code>BlockingQueue.take()</code>, <code>Semaphore.acquire()</code> <code>Condition.await()</code> and many, many others</li><li><code>SwingUtilities.invokeAndWait()</code></li></ul>Notice that blocking I/O does not throw <code>InterruptedException</code> (which is a shame). If all these classes declare <code>InterruptedException</code>, you might be wondering when is this exception ever thrown?<br /><br /><ul><li>When a thread is blocked on some method declaring <code>InterruptedException</code> and you call <code>Thread.interrupt()</code> on such thread, most likely blocked method will immediately throw <code>InterruptedException</code>.</li><li>If you submitted a task to a thread pool (<code>ExecutorService.submit()</code>) and you call <code>Future.cancel(true)</code> while the task was being executed. In that case the thread pool will try to interrupt thread running such task for you, effectively interrupting your task.</li></ul>Knowing what <code>InterruptedException</code> actually means, we are well equipped to handle it properly. If someone tries to interrupt our thread and we discovered it by catching <code>InterruptedException</code>, the most reasonable thing to do is letting said thread to finish, e.g.:<br /><br /><pre class="brush: java">class Cleaner implements Runnable, AutoCloseable {<br /><br />  private final Thread cleanerThread;<br /><br />  Cleaner() {<br />    cleanerThread = new Thread(this, "Cleaner");<br />    cleanerThread.start();<br />  }<br /><br />  @Override<br />  public void run() {<br />    try {<br />      while (true) {<br />        cleanUp();<br />        TimeUnit.SECONDS.sleep(1);<br />      }<br />    } catch (InterruptedException ignored) {<br />      log.debug("Interrupted, closing");<br />    }<br />  }<br /><br />  //...   <br /><br />  @Override<br />  public void close() {<br />    cleanerThread.interrupt();<br />  }<br />}<br /></pre>Notice that <code>try-catch</code> block now surrounds <code>while</code> loop. This way if <code>sleep()</code> throws <code>InterruptedException</code>, we will break out of the loop. You might argue that we should log <code>InterruptedException</code>'s stack-trace. This depends on the situation, as in this case interrupting a thread is something we really expect, not a failure. But it's up to you. The bottom-line is that if <code>sleep()</code> is interrupted by another thread, we quickly escape from <code>run()</code> altogether. If you are very careful you might ask what happens if we interrupt thread while it's in <code>cleanUp()</code> method rather than sleeping? Often you'll come across manual flag like this:<br /><br /><pre class="brush: java">private volatile boolean stop = false;<br /><br />@Override<br />public void run() {<br />  while (!stop) {<br />    cleanUp();<br />    TimeUnit.SECONDS.sleep(1);<br />  }<br />}<br /><br />@Override<br />public void close() {<br />  stop = true;<br />}<br /></pre>However notice that <code>stop</code> flag (it has to be <code>volatile</code>!) won't interrupt blocking operations, we have to wait until <code>sleep()</code> finishes. On the other side one might argue that explicit <code>flag</code> gives us better control since we can monitor its value at any time. It turns out thread interruption works the same way. If someone interrupted thread while it was doing non-blocking computation (e.g. inside <code>cleanUp()</code>) such computations aren't interrupted immediately. However thread is marked as <i>interrupted</i> and every subsequent blocking operation (e.g. <code>sleep()</code>) will simply throw <code>InterruptedException</code> immediately - so we won't loose that signal. <br /><br />We can also take advantage of that fact if we write non-blocking thread that still wants to take advantage of thread interruption facility. Instead of relying on <code>InterruptedException</code> we simply have to check for <code>Thread.isInterrupted()</code> periodically:<br /><br /><pre class="brush: java">public void run() {<br />  while (!Thread.currentThread().isInterrupted()) {<br />    someHeavyComputations();<br />  }<br />}<br /></pre>Above, if someone interrupts our thread, we will abandon computation as soon as <code>someHeavyComputations()</code> returns. If it runs for two long or infinitely, we will never discover interruption flag. Interestingly <code>interrupted</code> flag is not a <i>one-time pad</i>. We can call <code>Thread.interrupted()</code> instead of <code>isInterrupted()</code>, which will reset <code>interrupted</code> flag and we can continue. Occasionally you might want to ignore interrupted flag and continue running. In that case <code>interrupted()</code> might come in handy. BTW I (imprecisely) call "getters" that <a href="http://en.wikipedia.org/wiki/Observer_effect_(physics)">change the state of object being observed</a> "<i>Heisengetters</i>".<br /><br /><h2>Note on <code>Thread.stop()</code></h2>If you are old-school programmer, you may recall <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#stop--"><code>Thread.stop()</code></a> method, which has been <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/misc/threadPrimitiveDeprecation.html">deprecated for 10 years now</a>. In Java 8 there were plans to <a href="http://cs.oswego.edu/pipermail/concurrency-interest/2013-December/012028.html">"de-implement it"</a>, but in 1.8u5 it's still there. Nevertheless, don't use it and refactor any code using <code>Thread.stop()</code> into <code>Thread.interrupt()</code>.   <br /><br /><h2><code>Uninterruptibles</code> from Guava</h2>Rarely you might want to ignore <code>InterruptedException</code> altogether. In that case have a look at <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/Uninterruptibles.html"><code>Uninterruptibles</code></a> from Guava. It has plenty of utility methods like <code>sleepUninterruptibly()</code> or <code>awaitUninterruptibly(CountDownLatch)</code>. Just be careful with them. I know they don't declare <code>InterruptedException</code> (which might be handful), but they also completely prevent current thread from being interrupted - which is quite unusual.<br /><br /><h2>Summary</h2>By now I hope you have some understanding why certain methods throw <code>InterruptedException</code>. The main takeaways are:<br /><br /><ul><li>Caught <code>InterruptedException</code> should be handled <i>properly</i> - most of the time it means breaking out of the current task/loop/thread entirely</li><li>Swallowing <code>InterruptedException</code> is rarely a good idea</li><li>If thread was interrupted while it wasn't in a blocking call, use <code>isInterrupted()</code>. Also entering blocking method when thread was already interrupted should immediately throw <code>InterruptedException</code></li></ul><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script> <script>SyntaxHighlighter.highlight();</script>