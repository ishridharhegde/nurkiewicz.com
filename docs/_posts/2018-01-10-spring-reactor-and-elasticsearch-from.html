---
layout: post
title: 'Spring, Reactor and Elasticsearch: from callbacks to reactive streams'
date: '2018-01-10T00:58:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- CompletableFuture
- Netty
- elasticsearch
- mongodb
- redis
- reactor
- spring
- cassandra
modified_time: '2018-01-25T09:18:22.129+01:00'
thumbnail: https://2.bp.blogspot.com/-2ADAdXIHWG4/WlVW84NUN9I/AAAAAAAAVho/HLbg1K38V0YNuDNI6u2YLDTY4zmuwn0vQCLcBGAs/s72-c/2016-10-23%2B11.13.41.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1053604385907462269
blogger_orig_url: https://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch-from.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-2ADAdXIHWG4/WlVW84NUN9I/AAAAAAAAVho/HLbg1K38V0YNuDNI6u2YLDTY4zmuwn0vQCLcBGAs/s1600/2016-10-23%2B11.13.41.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="901" data-original-width="1600" height="112" src="https://2.bp.blogspot.com/-2ADAdXIHWG4/WlVW84NUN9I/AAAAAAAAVho/HLbg1K38V0YNuDNI6u2YLDTY4zmuwn0vQCLcBGAs/s200/2016-10-23%2B11.13.41.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Bieszczady mountains</td></tr></tbody></table>Spring 5 (and Boot 2, when it arrives in a <a href="https://github.com/spring-projects/spring-boot/milestones">couple of weeks</a>) is a revolution. Not the "<em>annotations over XML</em>" or "<em>Java classes over annotations</em>" type of revolution. It's truly a revolutionary framework that enables writing a brand new class of applications. Over the recent years, I became a little bit intimidated by this framework. "Spring Cloud being framework that simplifies the usage of Spring Boot, being a framework that simplifies the usage of Spring, being a framework, that simplifies enterprise development." <a href="https://start.spring.io/">start.spring.io</a> (also known as "<em>start... dot spring... dot I... O</em>") lists 120 different modules (!) that you can add to your service. Spring these days became an enormous umbrella project and I can imagine why some people (still!) prefer Java EE (or whatever it's called these days).<br /><br />But Spring 5 brings the reactive revolution. It's no longer only a wrapper around blocking servlet API and various web frameworks. Spring 5, on top of <a href="https://projectreactor.io/">Project Reactor</a> allows writing high-performance, extremely fast and scalable servers, avoiding the servlet stack altogether. Damn, there is no Jetty or even servlet API on the CLASSPATH! At the heart of Spring 5 web-flux we will find <a href="https://netty.io/">Netty</a>, a low-level framework for writing asynchronous clients and servers. Finally, Spring becomes first-class citizen in the family of reactive frameworks. Java developers can implement fast services without leaving their comfort zone and going for <a href="https://draft.blogger.com/Akka%20HTTP">https://doc.akka.io/docs/akka-http/current/</a> or <a href="https://draft.blogger.com/Play%20framework">https://www.playframework.com/</a>. Spring 5 is a fully reactive, modern tool for building highly-scalable and resilient applications. Nevertheless, the underlying principles like controllers, beans, dependency injection are all the same. Moreover, upgrade path is smooth and we can gradually add features, rather than learning brand new, alien framework. Enough of talking, let's write some code.<br /><br />In this article, we will write a simple headless application that indexes documents in <a href="https://www.elastic.co/products/elasticsearch">ElasticSearch</a> in large volume. We aim for thousands of concurrent connections with just a handful of threads, even when the server becomes slow. However, unlike e.g. Spring Data MongoDB, <a href="https://projects.spring.io/spring-data-elasticsearch/">Spring Data ElasticSearch</a> does not natively support non-blocking repositories. Well, the latter doesn't even seem to be maintained anymore, with current version being 3 years old. Many articles target Spring 5 + MongoDB with its repositories returning non-blocking streams (<code>Flux</code> or <code>Flowable</code> from RxJava). This one will be a little bit more advanced.<br /><br />The <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/index.html">ElasticSearch 6 Java API</a> uses RESTful interface and is implemented using non-blocking HTTP client. Unfortunately, it uses callbacks rather than something sane like <code>CompletableFuture</code>. So let's build the client adapter ourselves.<br /><br /><h1 id="elasticsearch-client-using-fluxes-and-monos">ElasticSearch client using Fluxes and Monos</h1>Source code for this article is available at <a href="https://github.com/nurkiewicz">github.com/nurkiewicz/elastic-flux</a> on <a href="https://github.com/nurkiewicz/elastic-flux/tree/reactive-elastic-search"><code>reactive-elastic-search</code></a> branch.<br /><br />We would like to build an ElasticSearch Java client that supports Project Reactor by returning <code>Flux</code> or <code>Mono</code>. Of course, we get the greatest benefit if the underlying stream is fully asynchronous and does not consume threads. Luckily the Java API is just like that. First, let's setup ElasticSearch's client as a Spring bean:<br /><br /><pre class="brush: java">import org.apache.http.HttpHost;<br />import org.elasticsearch.client.RestClient;<br />import org.elasticsearch.client.RestHighLevelClient;<br /><br />@Bean<br />RestHighLevelClient restHighLevelClient() {<br />    return new RestHighLevelClient(<br />            RestClient<br />                    .builder(new HttpHost("localhost", 9200))<br />                    .setRequestConfigCallback(config -&gt; config<br />                            .setConnectTimeout(5_000)<br />                            .setConnectionRequestTimeout(5_000)<br />                            .setSocketTimeout(5_000)<br />                    )<br />                    .setMaxRetryTimeoutMillis(5_000));<br />}</pre>In real life, we would obviously parametrize most of this stuff. We will be indexing simple JSON documents, for the time being, their contents is not important:<br /><br /><pre class="brush: java">@Value<br />class Doc {<br />    private final String username;<br />    private final String json;<br />}</pre>The code we will write wraps <code>RestHighLevelClient</code> and makes it even more <em>high-level</em> by returning <code>Mono&lt;IndexResponse&gt;</code>. <code>Mono</code> is pretty much like <code>CompletableFuture</code> but with two exceptions:<br /><br /><ul><li>it's lazy - as long as you don't subscribe, no computation is started</li><li>unlike <code>CompletableFuture</code>, <code>Mono</code> can complete normally without emitting any value</li></ul>The second difference was always a bit misleading to me. In RxJava 2.x there are two distinct types: <code>Single</code> (always completes with value or error) and <code>Maybe</code> (like <code>Mono</code>). Too bad Reactor doesn't make this distinction. Nevermind, how the adapter layer looks like? The plain Elastic's API looks as follows:<br /><br /><pre class="brush: java">client.indexAsync(indexRequest, new ActionListener&lt;IndexResponse&gt;() {<br />    @Override<br />    public void onResponse(IndexResponse indexResponse) {<br />        //got response<br />    }<br /><br />    @Override<br />    public void onFailure(Exception e) {<br />        //got error<br />    }<br />});</pre>You can see where this is going: <a href="http://callbackhell.com/"><em>callback hell</em></a>. Rather than exposing custom <code>ActionListener</code> as an argument to this logic, let's wrap it in <code>Mono</code>:<br /><br /><pre class="brush: java">import org.elasticsearch.action.ActionListener;<br />import org.elasticsearch.action.index.IndexRequest;<br />import org.elasticsearch.action.index.IndexResponse;<br />import org.elasticsearch.client.RestHighLevelClient;<br />import org.elasticsearch.common.xcontent.XContentType;<br /><br />import reactor.core.publisher.Mono;<br />import reactor.core.publisher.MonoSink;<br /><br />private Mono&lt;IndexResponse&gt; indexDoc(Doc doc) {<br />    return Mono.create(sink -&gt; {<br />        IndexRequest indexRequest = new IndexRequest("people", "person", doc.getUsername());<br />        indexRequest.source(doc.getJson(), XContentType.JSON);<br />        client.indexAsync(indexRequest, new ActionListener&lt;IndexResponse&gt;() {<br />            @Override<br />            public void onResponse(IndexResponse indexResponse) {<br />                sink.success(indexResponse);<br />            }<br /><br />            @Override<br />            public void onFailure(Exception e) {<br />                sink.error(e);<br />            }<br />        });<br />    });<br />}</pre>We must create <code>IndexRequest</code> wrapping JSON document and send it over RESTful API. But that's not the point. We are using <code>Mono.create()</code> method, it has some drawbacks, but more on that later. <code>Mono</code> is lazy, so barely calling <code>indexDoc()</code> doesn't suffice, no HTTP request was made to ElasticSearch. However every time someone subscribes to this one-element source, the logic inside <code>create()</code> will be executed. Crucial lines are <code>sink.success()</code> and <code>sink.error()</code>. They propagate results from ElasticSearch (coming from the background, asynchronous thread) into the stream. How to use such method in practice? It's very simple!<br /><br /><pre class="brush: java">Doc doc = //...<br />indexDoc(doc)<br />        .subscribe(<br />                indexResponse -&gt; log.info("Got response")<br />        );</pre>Of course the true power of reactive stream processing comes from composing multiple streams. But we made our first steps: transforming callback-based asynchronous API into a generic stream. If you are (un)lucky to use MongoDB, it has <a href="https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#mongo.reactive">built-in</a> support for reactive types like <code>Mono</code> or <code>Flux</code> right in the repositories. The same goes for <a href="https://docs.spring.io/spring-data/cassandra/docs/current/reference/html/#cassandra.reactive">Cassandra</a> and <a href="https://docs.spring.io/spring-data/redis/docs/current/reference/html/#redis:reactive">Redis</a>. In the next article, we will learn <a href="http://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch.html">how to generate some fake data</a> and index it concurrently.<br /><br /><p>This is part of a longer series:</p> <ul> <li>Spring, Reactor and ElasticSearch: from callbacks to reactive streams</li> <li><a href="http://www.nurkiewicz.com/2018/01/spring-reactor-and-elasticsearch.html">Spring, Reactor and ElasticSearch: bechmarking with fake test data</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/monitoring-and-measuring-reactive.html">Monitoring and measuring reactive application with Dropwizard Metrics</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/spring-boot-2-migrating-from-dropwizard.html">Spring Boot 2: Migrating from Dropwizard metrics to Micrometer</a></li> <li><a href="http://www.nurkiewicz.com/2018/01/spring-boot-2-fluxes-from-elasticsearch.html">Spring Boot 2: Fluxes, from Elasticsearch to controller</a></li></ul>  <script>SyntaxHighlighter.highlight();</script>