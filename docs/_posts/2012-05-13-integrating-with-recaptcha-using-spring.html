---
layout: post
title: Integrating with reCAPTCHA using... Spring Integration
date: '2012-05-13T18:26:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- esb
- captcha
- spring
- spring-integration
modified_time: '2012-05-13T18:27:38.410+02:00'
thumbnail: http://1.bp.blogspot.com/-eOLPm4NQrGE/T6_dwMxTQtI/AAAAAAAAAlE/-9Wsv05IYtM/s72-c/validation.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-6572921503208772516
blogger_orig_url: https://www.nurkiewicz.com/2012/05/integrating-with-recaptcha-using-spring.html
---

Sometimes we just need <a href="http://en.wikipedia.org/wiki/Captcha">CAPTCHA</a>, that's a sad fact. Today we will learn how to integrate with <a href="http://www.google.com/recaptcha">reCAPTCHA</a>. Because the topic itself isn't particularly interesting and advanced, we will overengineer a bit (?) by using <a href="http://www.springsource.org/spring-integration">Spring Integration</a> to handle low-level details. The decision to use reCAPTCHA by Google was dictated by two factors: (1) it is a moderately good CAPTCHA implementation with decent images with built-in support for visually impaired people and (2) outsourcing CAPTCHA allows us to remain stateless on the server side. Not to mention we help in digitalizing books.<br /><br />The second reason is actually quite important. Typically you have to generate CAPTCHA on the server side and store the expected result e.g. in user session. When the response comes back you compare expected and entered CAPTCHA solution. Sometimes we don't want to store any state on the server side, not to mention implementing CAPTCHA isn't particularly rewarding task. So it is nice to have something ready-made and acceptable.<br /><br />The <a href="https://github.com/nurkiewicz/recaptcha-spring-integration">full source code</a> is as always available, we are starting from a <a href="https://github.com/nurkiewicz/recaptcha-spring-integration/tree/no-recaptcha">simple Spring MVC web application</a> without any CAPTCHA. reCAPTCHA is free but requires registration, so the first step is to <a href="https://www.google.com/recaptcha/admin/create">sing-up and generate your public/private keys</a> and fill-in <a href="https://github.com/nurkiewicz/recaptcha-spring-integration/blob/master/src/main/resources/app.properties"><code>app.properties</code></a> configuration file in our sample project.<br /><br />To display and include reCAPTCHA on your form all you have to do is add JavaScript library:<br /><pre class="brush: js">&lt;div id="recaptcha"&gt;&nbsp;&lt;/div&gt;<br />...<br />&lt;script src="http://www.google.com/recaptcha/api/js/recaptcha_ajax.js"&gt;&lt;/script&gt;<br /></pre>And place reCAPTCHA widget anywhere you like:  <br /><pre class="brush: js">Recaptcha.create("${recaptcha_public_key}",<br />  "recaptcha",<br />  {<br />    theme: "white",<br />    lang : 'en'<br />  }<br />);<br /></pre>The <a href="https://developers.google.com/recaptcha/docs/display">official documentation</a> is very concise and descriptive, so I am not diving into details of that. When you include this widget inside your <code>&lt;form/&gt;</code> you will receive two extra fields when user submits: <code>recaptcha_response_field</code> and <code>recaptcha_challenge_field</code>. The first is the actual text typed by the user and the second is a hidden token generated per request. It is probably used by reCAPTCHA servers as a session key, but we don't care, all we have to do is <a href="https://developers.google.com/recaptcha/docs/verify">passing this fields further to reCAPTCHA server</a>. I will use <a href="http://hc.apache.org/httpcomponents-client-ga/">HttpClient 4</a> to perform HTTP request to external server and some clever pattern matching in Scala to parse the response:<br /><a name='more'></a><br /><pre class="brush: scala">trait ReCaptchaVerifier {<br />  def validate(reCaptchaRequest: ReCaptchaSecured): Boolean<br /><br />}<br /><br />@Service<br />class HttpClientReCaptchaVerifier @Autowired()(<br />                                                  httpClient: HttpClient,<br />                                                  servletRequest: HttpServletRequest,<br />                                                  @Value("${recaptcha_url}") recaptchaUrl: String,<br />                                                  @Value("${recaptcha_private_key}") recaptchaPrivateKey: String<br />                                                  ) extends ReCaptchaVerifier {<br /><br />  def validate(reCaptchaRequest: ReCaptchaSecured): Boolean = {<br />    val post = new HttpPost(recaptchaUrl)<br />    post.setEntity(new UrlEncodedFormEntity(List(<br />      new BasicNameValuePair("privatekey", recaptchaPrivateKey),<br />      new BasicNameValuePair("remoteip", servletRequest.getRemoteAddr),<br />      new BasicNameValuePair("challenge", reCaptchaRequest.recaptchaChallenge),<br />      new BasicNameValuePair("response", reCaptchaRequest.recaptchaResponse)))<br />    )<br />    val response = httpClient.execute(post)<br />    isReCaptchaSuccess(response.getEntity.getContent)<br />  }<br /><br />  private def isReCaptchaSuccess(response: InputStream) = {<br />    val responseLines = Option(response) map {<br />      Source.fromInputStream(_).getLines().toList<br />    } getOrElse Nil<br />    responseLines match {<br />      case "true" :: _ =&gt; true<br />      case "false" :: "incorrect-captcha-sol" :: _=&gt; false<br />      case "false" :: msg :: _ =&gt; throw new ReCaptchaException(msg)<br />      case resp =&gt; throw new ReCaptchaException("Unrecognized response: " + resp.toList)<br />    }<br />  }<br /><br />}<br /><br />class ReCaptchaException(msg: String) extends RuntimeException(msg)<br /></pre>The only missing piece is the <code>ReCaptchaSecured</code> trait encapsulating two reCAPTCHA fields mentioned earlier. In order to secure any web form with reCAPTCHA I am simply extending this model:  <br /><pre class="brush: scala">trait ReCaptchaSecured {<br />  @BeanProperty var recaptchaChallenge = ""<br />  @BeanProperty var recaptchaResponse = ""<br />}<br /><br />class NewComment extends ReCaptchaSecured {<br />  @BeanProperty var name = ""<br />  @BeanProperty var contents = ""<br />}<br /></pre>The whole <a href="https://github.com/nurkiewicz/recaptcha-spring-integration/blob/master/src/main/scala/com/blogspot/nurkiewicz/web/CommentsController.scala"><code>CommentsController.scala</code></a> is not that relevant. But the result is!<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-eOLPm4NQrGE/T6_dwMxTQtI/AAAAAAAAAlE/-9Wsv05IYtM/s1600/validation.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://1.bp.blogspot.com/-eOLPm4NQrGE/T6_dwMxTQtI/AAAAAAAAAlE/-9Wsv05IYtM/s400/validation.png" width="321" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-v3FQyw_-bOQ/T6_d0_tobsI/AAAAAAAAAlQ/W1KL8v4tMZ8/s1600/recaptcha-failure.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://1.bp.blogspot.com/-v3FQyw_-bOQ/T6_d0_tobsI/AAAAAAAAAlQ/W1KL8v4tMZ8/s400/recaptcha-failure.png" width="321" /></a></div><br /><br />So it works, but obviously it wasn't really spectacular. What would you say about replacing the low-level HttpClient call with Spring Integration? The <code>ReCaptchaVerifier</code>  interface (trait) remains the same so the client code doesn't have to be changed. But we refactor <a href="https://github.com/nurkiewicz/recaptcha-spring-integration/blob/raw-http-client/src/main/scala/com/blogspot/nurkiewicz/recaptcha/HttpClientReCaptchaVerifier.scala"><code>HttpClientReCaptchaVerifier</code></a> into two separate, small, relatively high-level and abstract classes:  <br /><pre class="brush: scala">@Service<br />class ReCaptchaFormToHttpRequest @Autowired() (servletRequest: HttpServletRequest, @Value("${recaptcha_private_key}") recaptchaPrivateKey: String) {<br /><br />  def transform(form: ReCaptchaSecured) = Map(<br />    "privatekey" -&gt; recaptchaPrivateKey,<br />    "remoteip" -&gt; servletRequest.getRemoteAddr,<br />    "challenge" -&gt; form.recaptchaChallenge,<br />    "response" -&gt; form.recaptchaResponse).asJava<br /><br />}<br /><br />@Service<br />class ReCaptchaServerResponseToResult {<br /><br />  def transform(response: String) = {<br />    val responseLines = response.split('\n').toList<br />    responseLines match {<br />      case "true" :: _ =&gt; true<br />      case "false" :: "incorrect-captcha-sol" :: _=&gt; false<br />      case "false" :: msg :: _ =&gt; throw new ReCaptchaException(msg)<br />      case resp =&gt; throw new ReCaptchaException("Unrecognized response: " + resp.toList)<br />    }<br />  }<br /><br />}<br /></pre>Note that we no longer have to implement <code>ReCaptchaVerifier</code>, Spring Integration will do it for us. We only have to tell how is the framework suppose to use building blocks we have extracted above. I think I haven't yet described what Spring Integration is and how it works. In few words it is a very pure implementation of <a href="http://www.amazon.com/gp/product/0321200683/ref=as_li_ss_il?ie=UTF8&amp;tag=javaandneighb-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0321200683">enterprise integration patterns</a> (some may call it ESB). The message flows are described using XML and can be embedded inside standard Spring XML configuration:  <br /><pre class="brush: xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns="http://www.springframework.org/schema/integration"<br />       xmlns:http="http://www.springframework.org/schema/integration/http"<br />       xsi:schemaLocation="<br />           http://www.springframework.org/schema/integration<br />           http://www.springframework.org/schema/integration/spring-integration.xsd<br />           http://www.springframework.org/schema/beans<br />           http://www.springframework.org/schema/beans/spring-beans.xsd<br />           http://www.springframework.org/schema/integration/http<br />           http://www.springframework.org/schema/integration/http/spring-integration-http.xsd<br />           "&gt;<br /><br />       &lt;!-- configuration here --&gt;    <br /><br />&lt;/beans:beans&gt;<br /></pre>In our case we will describe a message flow from <code>HttpClientReCaptchaVerifier</code> Java interface/Scala trait to the reCAPTCHA server and back. On the way the <code> ReCaptchaSecured</code> object must be translated into HTTP request and the HTTP response should be translated into meaningful result, returned transparently from the interface.  <br /><pre class="brush: xml">&lt;gateway id="ReCaptchaVerifier" service-interface="com.blogspot.nurkiewicz.recaptcha.ReCaptchaVerifier" default-request-channel="reCaptchaSecuredForm"/&gt;<br /><br />&lt;channel id="reCaptchaSecuredForm" datatype="com.blogspot.nurkiewicz.web.ReCaptchaSecured"/&gt;<br /><br />&lt;transformer input-channel="reCaptchaSecuredForm" output-channel="reCaptchaGoogleServerRequest" ref="reCaptchaFormToHttpRequest"/&gt;<br /><br />&lt;channel id="reCaptchaGoogleServerRequest" datatype="java.util.Map"/&gt;<br /><br />&lt;http:outbound-gateway<br />    request-channel="reCaptchaGoogleServerRequest"<br />    reply-channel="reCaptchaGoogleServerResponse"<br />    url="${recaptcha_url}"<br />    http-method="POST"<br />    extract-request-payload="true"<br />    expected-response-type="java.lang.String"/&gt;<br /><br />&lt;channel id="reCaptchaGoogleServerResponse" datatype="java.lang.String"/&gt;<br /><br />&lt;transformer input-channel="reCaptchaGoogleServerResponse" ref="reCaptchaServerResponseToResult"/&gt;<br /></pre>Despite the amount of XML, the overall message flow is quite simple. First we define <a href="http://www.eaipatterns.com/MessagingGateway.html">gateway</a>, which is a bridge between Java interface and Spring Integration message flow. The argument of <code>ReCaptchaVerifier.validate()</code> later becomes a <a href="http://www.eaipatterns.com/Message.html">message</a> that is sent to <code>reCaptchaSecuredForm</code> <a href="http://www.eaipatterns.com/MessageChannel.html">channel</a>. From that channel <code>ReCaptchaSecured</code> object is passed to a <code>ReCaptchaFormToHttpRequest</code> <a href="http://www.eaipatterns.com/MessageChannel.html">transformer</a>. The purpose of the transformer is two translate from <code>ReCaptchaSecured</code> object to Java map representing a set of key-value pairs. Later this map is passed (through <code>reCaptchaGoogleServerRequest</code> channel) to <code>http:outbound-gateway</code>. The responsibility of this component is to translate previously created map into an HTTP request and send it to specified address.<br /><br />When the response comes back, it is sent to <code>reCaptchaGoogleServerResponse</code> channel. There <code>ReCaptchaServerResponseToResult</code> transformer takes action, translating HTTP response to business result (boolean). Finally the transformer result is routed back to the gateway. Everything happens synchronously by default so we can still use simple Java interface for reCAPTCHA validation.<br /><br />Believe it or not, this all works. We no longer use <code>HttpClient</code> (guess everything is better compared to HttpClient 4 API...) and instead of one "huge" class we have a set of smaller, focused, easy to test classes. The framework handles wiring up and the low-level details. Wonderful?<br /><br /><h4><a href="http://www.debs.msrg.utoronto.ca/hohpe.pdf">Architect's Dream or Developer's Nightmare?</a></h4><br />Let me summarize our efforts by quoting the conclusions from the presentation above: <i>balance architectural benefits with development effectiveness</i>. Spring Integration is capable of receiving data from various heterogeneous sources like JMS, relational database or even FTP, aggregating, splitting, parsing and filtering messages in multiple ways and finally sending them further with the most exotic protocols. Coding all this by hand is a really tedious and error-prone task. On the other hand sometimes we just don't need all the fanciness and getting our hands dirty (e.g. by doing a manual HTTP request and parsing the response) is much simpler and easier to understand. Before you blindly base your whole architecture either on very high-level abstractions or on hand-coded low-level procedures: think about the consequences and balance. No solution fits all problems. Which version of reCAPTCHA integration do you find better?