---
layout: post
title: Building extremely large in-memory InputStream for testing purposes
date: '2014-07-21T19:33:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- guava
modified_time: '2014-07-21T22:21:01.303+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8706947186580666617
blogger_orig_url: https://www.nurkiewicz.com/2014/07/building-extremely-large-in-memory.html
---

For some reason I needed extremely large, possibly even infinite <code>InputStream</code> that would simply return the same <code>byte[]</code> over and over. This way I could produce insanely big stream of data by repeating small sample. Sort of similar functionality can be found in Guava: <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Iterables.html#cycle(java.lang.Iterable)"><code>Iterable&lt;T&gt; Iterables.cycle(Iterable&lt;T&gt;)</code></a> and <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Iterators.html#cycle(java.lang.Iterable)"><code>Iterator&lt;T&gt; Iterators.cycle(Iterator&lt;T&gt;)</code></a>. For example if you need an infinite source of <code>0</code> and <code>1</code>, simply say <code>Iterables.cycle(0, 1)</code> and get <code>0, 1, 0, 1, 0, 1...</code> infinitely. Unfortunately I haven't found such utility for <code>InputStream</code>, so I jumped into writing my own. This article documents many mistakes I made during that process, mostly due to overcomplicating and overengineering straightforward solution.<br /><br />We don't really need an infinite <code>InputStream</code>, being able to create very large one (say, 32 GiB) is enough. So we are after the following method:<br /><br /><pre class="brush: java">public static InputStream repeat(byte[] sample, int times)<br /></pre>It basically takes <code>sample</code> array of bytes and returns an <code>InputStream</code> returning these bytes. However when <code>sample</code> runs out, it rolls over, returning the same bytes again - this process is repeated given number of times, until <code>InputStream</code> signals end. One solution that I haven't really tried but which seems most obvious:<br /><br /><pre class="brush: java">public static InputStream repeat(byte[] sample, int times) {<br />    final byte[] allBytes = new byte[sample.length * times];<br />    for (int i = 0; i &lt; times; i++) {<br />        System.arraycopy(sample, 0, allBytes, i * sample.length, sample.length);<br />    }<br />    return new ByteArrayInputStream(allBytes);<br />}<br /></pre>I see you laughing there! If <code>sample</code> is 100 bytes and we need 32 GiB of input repeating these 100 bytes, generated <code>InputStream</code> shouldn't really allocate 32 GiB of memory, we must be more clever here. As a matter of fact <code>repeat()</code> above has another subtle bug. Arrays in Java are limited to 2<sup>31</sup>-1 entries (<code>int</code>), 32 GiB is way above that. The reason this program compiles is a silent integer overflow here: <code>sample.length * times</code>. This multiplication doesn't fit in <code>int</code>.<br /><br />OK, let's try something that at least theoretically can work. My first idea was as follows: what if I create many <code>ByteArrayInputStream</code>s sharing the same <code>byte[] sample</code> (they don't do an eager copy) and somehow join them together? Thus I needed some <code>InputStream</code> adapter that could take arbitrary number of underlying <code>InputStream</code>s and chain them together - when first stream is exhausted, switch to next one. This awkward moment when you look for something in Apache Commons or Guava and apparently <a href="http://stackoverflow.com/a/14295156">it was in the JDK forever</a>... <a href="http://docs.oracle.com/javase/8/docs/api/java/io/SequenceInputStream.html"><code>java.io.SequenceInputStream</code></a>  is almost ideal. However it can only chain precisely two underlying <code>InputStream</code>s. Of course since <code>SequenceInputStream</code> is an <code>InputStream</code> itself, we can use it recursively as an argument to outer <code>SequenceInputStream</code>. Repeating this process we can chain arbitrary number of <code>ByteArrayInputStream</code>s together:<br /><br /><pre class="brush: java">public static InputStream repeat(byte[] sample, int times) {<br />    if (times &lt;= 1) {<br />        return new ByteArrayInputStream(sample);<br />    } else {<br />        return new SequenceInputStream(<br />                new ByteArrayInputStream(sample),<br />                repeat(sample, times - 1)<br />        );<br />    }<br />}<br /></pre>If <code>times</code> is 1, just wrap <code>sample</code> in <code>ByteArrayInputStream</code>. Otherwise use <code>SequenceInputStream</code> recursively. I think you can immediately spot what's wrong with this code: too deep recursion. Nesting level is the same as <code>times</code> argument, which will reach millions or even billions. There must be a better way. Luckily minor improvement changes recursion depth from O(n) to O(logn):<br /><br /><pre class="brush: java">public static InputStream repeat(byte[] sample, int times) {<br />    if (times &lt;= 1) {<br />        return new ByteArrayInputStream(sample);<br />    } else {<br />        return new SequenceInputStream(<br />                repeat(sample, times / 2),<br />                repeat(sample, times - times / 2)<br />        );<br />    }<br />}<br /></pre>Honestly this was the first implementation I tried. It's a simple <a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">application of <i>divide and conquer</i></a> principle, where we produce result by evenly splitting it into two smaller sub-problems. Looks clever, but there is one issue: it's easy to prove we create t (<code>t = times</code>) <code>ByteArrayInputStreams</code> and O(t) <code>SequenceInputStream</code>s. While <code>sample</code> byte array is shared, millions of various <code>InputStream</code> instances are wasting memory. This leads us to alternative implementation, creating just one <code>InputStream</code>, regardless value of <code>times</code>:<br /><br /><pre class="brush: java">import com.google.common.collect.Iterators;<br />import org.apache.commons.lang3.ArrayUtils;<br /><br />public static InputStream repeat(byte[] sample, int times) {<br />    final Byte[] objArray = ArrayUtils.toObject(sample);<br />    final Iterator&lt;Byte&gt; infinite = Iterators.cycle(objArray);<br />    final Iterator&lt;Byte&gt; limited = Iterators.limit(infinite, sample.length * times);<br />    return new InputStream() {<br />        @Override<br />        public int read() throws IOException {<br />            return limited.hasNext() ?<br />                    limited.next() &amp; 0xFF :<br />                    -1;<br />        }<br />    };<br />}<br /></pre>We will use <code>Iterators.cycle()</code> after all. But before we have to translate <code>byte[]</code> into <code>Byte[]</code> since iterators can only work with objets, not primitives. There is no idiomatic way to turn array of primitives to array of boxed types, so I use <a href="http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/ArrayUtils.html#toObject(byte[])"><code>ArrayUtils.toObject(byte[])</code></a> from Apache Commons Lang. Having an array of objects we can create an <code>infinite</code> iterator that cycles through values of <code>sample</code>. Since we don't want an infinite stream, we cut off infinite iterator using <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Iterators.html#limit(java.util.Iterator,%20int)"><code>Iterators.limit(Iterator&lt;T&gt;, int)</code></a>, again from Guava. Now we just have to bridge from <code>Iterator&lt;Byte&gt;</code> to <code>InputStream</code> - after all semantically they represent the same thing.<br /><br />This solution suffers two problems. First of all it produces tons of garbage due to unboxing. Garbage collection is not that much concerned about dead, short-living objects, but still seems wasteful. Second issue we already faced previously: <code>sample.length * times</code> multiplication can cause integer overflow. It can't be fixed because <code>Iterators.limit()</code> takes <code>int</code>, not <code>long</code> - for no good reason. BTW we avoided third problem by doing bitwise <i>and</i> with <code>0xFF</code> - otherwise <code>byte</code> with value <code>-1</code> would signal end of stream, which is not the case. <code>x &amp; 0xFF</code> is correctly translated to unsigned <code>255</code> (<code>int</code>). <br /><br />So even though implementation above is short and sweet, declarative rather than imperative, it's too slow and limited. If you have a C background, I can imagine how uncomfortable you were seeing me struggle. After all the most straightforward, painfully simple and low-level implementation was the one I came up with last:<br /><br /><pre class="brush: java">public static InputStream repeat(byte[] sample, int times) {<br />    return new InputStream() {<br />        private long pos = 0;<br />        private final long total = (long)sample.length * times;<br /><br />        public int read() throws IOException {<br />            return pos &lt; total ?<br />                    sample[(int)(pos++ % sample.length)] :<br />                    -1;<br />        }<br />    };<br />}<br /></pre>GC free, pure JDK, fast and simple to understand. Let this be a lesson for you: start with the simplest solution that jumps to your mind, don't overengineer and don't be too smart. My previous solutions, declarative, functional, immutable, etc. - maybe they looked clever, but they were neither fast nor easy to understand.<br /><br />The utility we just developed was not just a toy project, it will be used later in <a href="http://www.nurkiewicz.com/2014/07/testing-code-for-excessively-large.html">subsequent article</a>. <br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>