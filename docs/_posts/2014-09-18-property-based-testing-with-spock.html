---
layout: post
title: Property-based testing with Spock
date: '2014-09-18T11:43:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- testing
- groovy
- Spock
modified_time: '2014-09-19T11:53:02.030+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3940304002295354954
blogger_orig_url: https://www.nurkiewicz.com/2014/09/property-based-testing-with-spock.html
---

<i>Property based testing</i> is an alternative approach to testing, complementing <i>example based testing</i>. The latter is what we've been doing all our lives: exercising production code against "examples" - inputs we think are representative. Picking these examples is an art on its own: "ordinary" inputs, edge cases, malformed inputs, etc. But why are we limiting ourselves to just few examples? Why not test hundreds, millions... <b>ALL</b> inputs? There are at least two difficulties with that approach:<br /><br /><ol><li>Scale. A pure function taking just one <code>int</code> input would require 4 billion tests. This means few hundred gigabytes of test source code and several months of execution time. Square it if a function takes two <code>int</code>s. For <code>String</code> it practically goes to infinity.<br /><br /></li><li>Assume we have these tests, executed on a quantum computer or something. How do you know the expected result for each particular input? You either enter it by hand (good luck) or generate expected output. By <i>generate</i> I mean write a program that produces expected value for every input. But aren't we testing such program already in the first place? Are we suppose to write better, error-free version of code under test just to test it? Also known as <a href="http://jasonrudolph.com/blog/2008/07/30/testing-anti-patterns-the-ugly-mirror/">ugly mirror antipattern</a>.<br /><br /></li></ol>So you understand testing every single input, although ideal, is just a mental experiment, impossible to implement. That being said property based testing tries to get as close as possible to this testing nirvana. Issue #1 is solved by slamming code under test with hundreds or thousands of random inputs. Not all of them, not even a fraction. But a good, <i>random</i> representation. <br /><br />Issue #2 is surprisingly harder. Property based testing can generate random arguments, but it can't figure out what should be the expected outcome for that random input. Thus we need a different mechanism, giving name to whole philosophy. We have to come up with properties (invariants, behaviours) that code under test exhibits no matter what the input is. This sounds very theoretically, but there are many such properties in various scenarios:<br /><br /><ol><li><a href="http://en.wikipedia.org/wiki/Absolute_value">Absolute value</a> of <i>any number</i> should never be negative</li><li>Encoding and decoding <i>any string</i> should yield the same <code>String</code> back for every symmetric encoding</li><li>Optimized version of some old algorithm should produce the same result as the old one <i>for any input</i></li><li>Total money in a bank should remain the same after <i>arbitrary number</i> of intra-bank transactions in <i>any order</i></li></ol>As you can see there are many properties we can think of that do not mention specific example inputs. This is not exhaustive and strict testing. It's more like sampling and making sure samples are "sane". There are many, many libraries supporting property based testing for virtually every language. In this article we will explore Spock and ScalaCheck later.<br /><br /><h1>Spock + custom data generators</h1>Spock does not support property based testing out-of-the-box. However with help from <a href="http://spock-framework.readthedocs.org/en/latest/data_driven_testing.html">data driven testing</a> and 3rd-party data generators we can go quite far. Data tables in Spock can be generalized into so-called <a href="http://spock-framework.readthedocs.org/en/latest/data_driven_testing.html#data-pipes">data pipes</a>:<br /><br /><pre class="brush: groovy">def 'absolute value of #value should not be negative'() {<br />    expect:<br />    value.abs() &gt;= 0<br /><br />    where:<br />    value &lt;&lt; randomInts(100)<br />}<br /><br />private static def List&lt;Integer&gt; randomInts(int count) {<br />    final Random random = new Random()<br />    (1..count).collect { random.nextInt() }<br />}<br /></pre>Code above will generate 100 random integers and make sure for all of them <code>.abs()</code> is non-negative. You might think this test is quite dumb, but to a great surprise it actually discovers one bug! But first let's kill some boilerplate code. Generating random inputs, especially more complex, is cumbersome and boring. I found two libraries that can help us. <a href="https://github.com/Bijnagte/spock-genesis">spock-genesis</a>:<br /><br /><pre class="brush: groovy">import spock.genesis.Gen<br /><br />def 'absolute value of #value should not be negative'() {<br />    expect:<br />    value.abs() &gt;= 0<br /><br />    where:<br />    value &lt;&lt; Gen.int.take(100)<br />}<br /></pre>Looks great, but if you want to generate e.g. lists of random integers, <code>net.java.quickcheck</code> has nicer API and is not Groovy-specific: <br /><br /><pre class="brush: groovy">import static net.java.quickcheck.generator.CombinedGeneratorsIterables.someLists<br />import static net.java.quickcheck.generator.PrimitiveGenerators.integers<br /><br />def 'sum of non-negative numbers from #list should not be negative'() {<br />    expect:<br />    list.findAll{it &gt;= 0}.sum() &gt;= 0<br /><br />    where:<br />    list &lt;&lt; someLists(integers(), 100)<br />}<br /></pre>This test is interesting. It makes sure sum of non-negative numbers is never negative - by generating 100 lists of randoms <code>int</code>s. Sounds reasonable. However multiple tests are failing. First of all due to integer overflow sometimes two positive <code>int</code>s add up to a negative one. Duh! Another type of failure that was discovered is actually frightening. While <code>[1,2,3].sum()</code> is 6, obviously, <code>[].sum()</code> is... <code>null</code> (<a href="http://jira.codehaus.org/browse/GROOVY-2411">WAT?</a>)<br /><br />As you can see even silliest and most basic property based tests can be useful in finding unusual corner cases in your data. But wait, I said testing absolute of <code>int</code> discovered one bug. Actually it didn't, because of poor (too "random") data generators, not returning known edge values in the first place. We will fix that in the <a href="http://www.nurkiewicz.com/2014/09/property-based-testing-with-scalacheck.html">next article</a>.<br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>