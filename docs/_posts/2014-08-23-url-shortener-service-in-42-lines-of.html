---
layout: post
title: URL shortener service in 42 lines of code in... Java (?!) Spring Boot + Redis
date: '2014-08-23T23:20:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- gradle
- spring boot
- redis
- microservices
- spring
modified_time: '2014-08-27T21:08:59.812+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3324150641380244499
blogger_orig_url: https://www.nurkiewicz.com/2014/08/url-shortener-service-in-42-lines-of.html
---

Apparently writing a URL shortener service is the new "<i>Hello, world!</i>" in the IoT/microservice/era world. It all started with <a href="http://grasswire-engineering.tumblr.com/post/94043813041/a-url-shortener-service-in-45-lines-of-scala"><i>A URL shortener service in 45 lines of Scala</i></a> - neat piece of Scala, flavoured with Spray and Redis for storage. This was quickly followed with <a href="http://adambard.com/blog/a-clojure-url-shortener-service/"><i>A url shortener service in 35 lines of Clojure</i></a> and even <a href="http://bitemyapp.com/posts/2014-08-22-url-shortener-in-haskell.html"><i>URL Shortener in 43 lines of Haskell</i></a>. So my inner anti-hipster asked: how long would it be in Java? But not plain Java, for goodness' sake. <a href="http://projects.spring.io/spring-boot/">Spring Boot</a> with <a href="http://projects.spring.io/spring-data-redis/">Spring Data Redis</a> are a good starting point. All we need is a simple controller handling GET and POST:<br /><pre class="brush: java">import com.google.common.hash.Hashing;<br />import org.apache.commons.validator.routines.UrlValidator;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.boot.SpringApplication;<br />import org.springframework.data.redis.core.StringRedisTemplate;<br />import org.springframework.http.*;<br />import org.springframework.web.bind.annotation.*;<br /><br />import javax.servlet.http.*;<br />import java.nio.charset.StandardCharsets;<br /><br />@org.springframework.boot.autoconfigure.EnableAutoConfiguration<br />@org.springframework.stereotype.Controller<br />public class UrlShortener {<br />    public static void main(String[] args) {<br />        SpringApplication.run(UrlShortener.class, args);<br />    }<br /><br />    @Autowired private StringRedisTemplate redis;<br /><br />    @RequestMapping(value = "/{id}", method = RequestMethod.GET)<br />    public void redirect(@PathVariable String id, HttpServletResponse resp) throws Exception {<br />        final String url = redis.opsForValue().get(id);<br />        if (url != null)<br />            resp.sendRedirect(url);<br />        else<br />            resp.sendError(HttpServletResponse.SC_NOT_FOUND);<br />    }<br /><br />    @RequestMapping(method = RequestMethod.POST)<br />    public ResponseEntity&lt;String&gt; save(HttpServletRequest req) {<br />        final String queryParams = (req.getQueryString() != null) ? "?" + req.getQueryString() : "";<br />        final String url = (req.getRequestURI() + queryParams).substring(1);<br />        final UrlValidator urlValidator = new UrlValidator(new String[]{"http", "https"});<br />        if (urlValidator.isValid(url)) {<br />            final String id = Hashing.murmur3_32().hashString(url, StandardCharsets.UTF_8).toString();<br />            redis.opsForValue().set(id, url);<br />            return new ResponseEntity&lt;&gt;("http://mydomain.com/" + id, HttpStatus.OK);<br />        } else<br />            return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);<br />    }<br />}<br /></pre>The code is nicely self-descriptive and is functionally equivalent to a version in Scala. I didn't try to it squeeze too much to keep line count as short as possible, code above is quite typical with few details: <br /><br /><ul><li>I don't normally use wildcard imports</li><li>I don't use fully qualified class names (I wanted to save one <code>import</code> line, I admit) </li><li>I surround <code>if</code>/<code>else</code> blocks with braces</li><li>I almost never use field injection, ugliest brother in inversion of control family. Instead I would go for constructor to allow testing with mocked Redis:<br /><br /><pre class="brush: java">private final StringRedisTemplate redis;<br /><br />@Autowired<br />public UrlShortener(StringRedisTemplate redis) {<br />    this.redis = redis;<br />}<br /></pre></li></ul>The thing I struggled the most was... obtaining the original, full URL. Basically I needed everything after <code>.com</code> or port. No bloody way (neither servlets, nor Spring MVC), hence the awkward <code>getQueryString()</code> fiddling. You can use the service as follows - creating shorter URL:<br /><br /><pre class="brush: plain">$ curl -vX POST localhost:8080/https://www.google.pl/search?q=tomasz+nurkiewicz<br /><br />&gt; POST /https://www.google.pl/search?q=tomasz+nurkiewicz HTTP/1.1<br />&gt; User-Agent: curl/7.30.0<br />&gt; Host: localhost:8080<br />&gt; Accept: */*<br />&gt;<br />&lt; HTTP/1.1 200 OK<br />&lt; Server: Apache-Coyote/1.1<br />&lt; Content-Type: text/plain;charset=ISO-8859-1<br />&lt; Content-Length: 28<br />&lt; Date: Sat, 23 Aug 2014 20:47:40 GMT<br />&lt;<br />http://mydomain.com/50784f51<br /></pre>Redirecting through shorter URL:<br /><br /><pre class="brush: plain">$ curl -v localhost:8080/50784f51<br /><br />&gt; GET /50784f51 HTTP/1.1<br />&gt; User-Agent: curl/7.30.0<br />&gt; Host: localhost:8080<br />&gt; Accept: */*<br />&gt;<br />&lt; HTTP/1.1 302 Found<br />&lt; Server: Apache-Coyote/1.1<br />&lt; Location: https://www.google.pl/search?q=tomasz+nurkiewicz<br />&lt; Content-Length: 0<br />&lt; Date: Sat, 23 Aug 2014 20:48:00 GMT<br />&lt;<br /></pre>For completeness, here is a build file in Gradle (maven would work as well), skipped in all previous solutions:<br /><br /><pre class="brush: groovy">buildscript {<br />    repositories {<br />        mavenLocal()<br />        maven { url "http://repo.spring.io/libs-snapshot" }<br />        mavenCentral()<br />    }<br />    dependencies {<br />        classpath 'org.springframework.boot:spring-boot-gradle-plugin:1.1.5.RELEASE'<br />    }<br />}<br /><br />apply plugin: 'java'<br />apply plugin: 'spring-boot'<br /><br />sourceCompatibility = '1.8'<br /><br />repositories {<br />    mavenLocal()<br />    maven { url 'http://repository.codehaus.org' }<br />    maven { url 'http://repo.spring.io/milestone' }<br />    mavenCentral()<br />}<br /><br />dependencies {<br />    compile "org.springframework.boot:spring-boot-starter-web:1.1.5.RELEASE"<br />    compile "org.springframework.boot:spring-boot-starter-redis:1.1.5.RELEASE"<br />    compile 'com.google.guava:guava:17.0'<br />    compile 'org.apache.commons:commons-lang3:3.3.2'<br />    compile 'commons-validator:commons-validator:1.4.0'<br />    compile 'org.apache.tomcat.embed:tomcat-embed-el:8.0.9'<br />    compile "org.aspectj:aspectjrt:1.8.1"<br /><br />    runtime "cglib:cglib-nodep:3.1"<br />}<br /><br />tasks.withType(GroovyCompile) {<br />    groovyOptions.optimizationOptions.indy = true<br />}<br /><br />task wrapper(type: Wrapper) {<br />    gradleVersion = '2.0'<br />}<br /></pre><i>Actually also <a href="http://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life.2C_the_Universe.2C_and_Everything_.2842.29">42</a> lines...</i> That's the whole application, no XML, no descriptors, not setup.<br /><br />I don't treat this exercise as just a dummy code golf for shortest, most obfuscated working code. URL shortener web service with Redis back-end is an interesting showcase of syntax and capabilities of a given language and ecosystem. Much more entertaining then a bunch of algorithmic problems, e.g. found in <a href="http://rosettacode.org/wiki/Category:Programming_Tasks">Rosetta code</a>. Also it's a good bare minimum template for writing a REST service.<br /><br />One important feature of <a href="http://grasswire-engineering.tumblr.com/post/94043813041/a-url-shortener-service-in-45-lines-of-scala">original Scala implementation</a>, that was somehow silently forgotten in all implementations, including this one, is that it's non-blocking. Both HTTP and Redis access is event-driven (<i>reactive</i>, all right, I said it), thus I suppose it can handle tens of thousands of clients simultaneously. This can't be achieved with blocking controllers backed by Tomcat. But still you have to admit such a service written in Java (not even Java 8!) is surprisingly concise, easy to follow and straightforward - none of the other solutions are that readable (this is of course subjective). <br /><br />Waiting for others!<br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>