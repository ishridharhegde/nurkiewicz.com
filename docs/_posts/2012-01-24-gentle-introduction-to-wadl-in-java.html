---
layout: post
title: Gentle introduction to WADL (in Java)
date: '2012-01-24T18:57:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- jaxb
- wadl
- rest
modified_time: '2012-01-24T19:06:29.515+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5305414479093175056
blogger_orig_url: https://www.nurkiewicz.com/2012/01/gentle-introduction-to-wadl-in-java.html
---

WADL (<a href="http://en.wikipedia.org/wiki/Web_Application_Description_Language">Web Application Description Language</a>) is to REST what WSDL is to SOAP. The mere existence of this language causes a lot of controversy (see: <a href="http://bitworking.org/news/193/Do-we-need-WADL">Do we need WADL?</a> and <a href="http://bill.burkecentral.com/2009/05/21/to-wadl-or-not-to-wadl/">To WADL or not to WADL</a>). I can think of few legitimate use cases for using WADL, but if you are here already, you are probably not seeking for yet another discussion. So let us move forward to the WADL itself.<br /><br />In principle WADL is similar to WSDL, but the structure of the language is much different. Whilst WSDL defines a flat list of messages and operations either consuming or producing some of them, WADL emphasizes the hierarchical nature of RESTful web services. In REST, the primary artifact is the resource. Each resource (noun) is represented as an URI. Every resource can define both CRUD operations (verbs, implemented as HTTP methods) and nested resources. The nested resource has a strong relationship with a parent resource, typically representing an ownership.<br /><br />A simple example would be <code>http://example.com/api/books</code> resource representing a list of books. You can (HTTP) GET this resource, meaning to retrieve the whole list. You can also GET the <code>http://example.com/api/books/7</code> resource, fetching the details of 7th book inside <code>books</code> resource. Or you can even PUT new version or DELETE the resource altogether using the same URI. You are not limited to a single level of nesting: GETting <code>http://example.com/api/books/7/reviews?page=2&amp;size=10</code> will retrieve the second page (up to 10 items) of reviews of 7th book. Obviously you can also place other resources next to <code>books</code>, like <code>http://example.com/api/readers</code><br /><br />The requirement arose to formally and precisely describe every available resource, method, request and response, just like WSDL guys were able to do. WADL is one of the options to describe “available URIs", although some believe that well-written REST service should be self-descriptive (see <a href="http://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>). Nevertheless here is a simple, empty WADL document:<br /><br /><pre class="brush: xml">&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;<br />    &lt;resources base="http://example.com/api"/&gt;<br />&lt;/application&gt;<br /></pre>Nothing fancy here. Note that the <code>&lt;resources&gt;</code> tag defines base API address. All named resources, which we are just about to add, are relative to this address. Also you can define several <code>&lt;resources&gt;</code> tags to describe more than one APIs. So, let's add a simple resource:<br /><br /><a name='more'></a><br /><br /><pre class="brush: xml; highlight: 3">&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;<br />    &lt;resources base="http://example.com/api"&gt;<br />        &lt;resource path="books"&gt;<br />            &lt;method name="GET"/&gt;<br />            &lt;method name="POST"/&gt;<br />        &lt;/resource&gt;<br />    &lt;/resources&gt;<br />&lt;/application&gt;<br /></pre>This defines resource under <code>http://example.com/api/books</code> with two methods possible: GET to retrieve the whole list and POST to create (add) new item. Depending on your requirements you might want to allow DELETE method as well (to delete <b>all</b> items), and it is the responsibility of WADL to document what is allowed.<br /><br />Remember our example at the beginning: <code>/books/7</code>? Obviously 7 is just an example and we won't declare every possible book id in WADL. Instead there is a handy placeholder syntax:<br /><br /><pre class="brush: xml; highlight: [5,6]">&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;<br />    &lt;resources base="http://example.com/api"&gt;<br />        &lt;resource path="books"&gt;<br />            &lt;method name="GET"/&gt;<br />            &lt;resource path="{bookId}"&gt;<br />                &lt;param required="true" style="template" name="bookId"/&gt;<br />                &lt;method name="GET"/&gt;<br />            &lt;/resource&gt;<br />        &lt;/resource&gt;<br />    &lt;/resources&gt;<br />&lt;/application&gt;<br /></pre>There are two important aspects you should note: first, The <code>{bookId}</code> place-holder was used in place of <i>nested</i> resource. Secondly, to make it clear, we are documenting this place-holder using <code>&lt;param/&gt;</code> tag. We will see soon how it can be used in combination with methods. Just to make sure you are still with me, the document above describes <code>GET /books</code> and <code>GET /books/some_id</code> resources.<br /><br /><pre class="brush: xml; highlight: [12,13, 19]">&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;<br />    &lt;resources base="http://example.com/api"&gt;<br />        &lt;resource path="books"&gt;<br />            &lt;method name="GET"/&gt;<br />            &lt;resource path="{bookId}"&gt;<br />                &lt;param required="true" style="template" name="bookId"/&gt;<br />                &lt;method name="GET"/&gt;<br />                &lt;method name="DELETE"/&gt;<br />                &lt;resource path="reviews"&gt;<br />                    &lt;method name="GET"&gt;<br />                        &lt;request&gt;<br />                            &lt;param name="page" required="false" default="1" style="query"/&gt;<br />                            &lt;param name="size" required="false" default="20" style="query"/&gt;<br />                        &lt;/request&gt;<br />                    &lt;/method&gt;<br />                &lt;/resource&gt;<br />            &lt;/resource&gt;<br />        &lt;/resource&gt;<br />        &lt;resource path="readers"&gt;<br />            &lt;method name="GET"/&gt;<br />        &lt;/resource&gt;<br />    &lt;/resources&gt;<br />&lt;/application&gt;<br /></pre>The web service is getting complex, however it describes quite a lot of operations. First of  all <code>GET /books/42/reviews</code> is a valid operation. But the interesting part is the nested <code>&lt;request/&gt;</code> tag. As you can see we can describe parameters of each method independently. In our case optional <code>query</code> parameters (as opposed to <code>template</code> parameters used previously for URI place-holders) were defined. This gives the client additional knowledge about acceptable <code>page</code> and <code>size</code> query parameters. This means that <code>/books/7/reviews?page=2&amp;size=10</code> is a valid resource identifier. And did I mention that every resource, method and parameter can have documentation attached as per the WADL specification?<br /><br />We will stop here and only mention about remaining pieces of WADL. First of all, as you have probably guessed so far, there is also a <code>&lt;response/&gt;</code> child tag possible for each <code>&lt;method/&gt;</code>. Both request and response can define exact grammar (e.g. in XML Schema) that either the request or the response must follow. The response can also document possible HTTP response codes. But since we will be using the knowledge you have gained so far in a code-first application, I intentionally left the <code>&lt;grammars/&gt;</code> definition. WADL is agile and it allows you to define as little (or as much) information as you need.<br /><br />So we know the basics of WADL, now we would like to use it, maybe as a consumer or as a producer in a Java-based application. Fortunately there is a <a href="http://www.w3.org/Submission/wadl/wadl.xsd"><code>wadl.xsd</code></a> XML Schema description of the language itself, which we can use to generate JAXB-annotated POJOs to work with (using <code>xjc</code> tool in the JDK):<br /><br /><pre class="brush: plain">$ wget http://www.w3.org/Submission/wadl/wadl.xsd<br />$ xjc wadl.xsd<br /></pre>And there it... hangs! The life of a software developer is full of challenges and non-trivial problems. And sometimes it is just an annoying network filter that makes suspicious packets (together with half hour of your life) disappear. It is not hard to spot the problem, once you recall that article written around 2008: <a href="http://www.w3.org/blog/systeam/2008/02/08/w3c_s_excessive_dtd_traffic/">W3C’s Excessive DTD Traffic</a>:<br /><br /><pre class="brush: xml">  &lt;xs:import namespace="http://www.w3.org/XML/1998/namespace" <br />    schemaLocation="http://www.w3.org/2001/xml.xsd"/&gt; <br /></pre>Accessing <a href="http://www.w3.org/2001/xml.xsd"><code>xml.xsd</code></a> from the browser returns an HTML page instantly, but <code>xjc</code> tool waits forever. Downloading this file locally and correcting the <code>schemaLocation</code> attribute in <code>wadl.xsd</code> helped. It's always the little things...<br /><br /><pre class="brush: plain">$ xjc wadl.xsd <br />parsing a schema... <br />compiling a schema... <br />net/java/dev/wadl/_2009/_02/Application.java <br />net/java/dev/wadl/_2009/_02/Doc.java <br />net/java/dev/wadl/_2009/_02/Grammars.java <br />net/java/dev/wadl/_2009/_02/HTTPMethods.java <br />net/java/dev/wadl/_2009/_02/Include.java <br />net/java/dev/wadl/_2009/_02/Link.java <br />net/java/dev/wadl/_2009/_02/Method.java <br />net/java/dev/wadl/_2009/_02/ObjectFactory.java <br />net/java/dev/wadl/_2009/_02/Option.java <br />net/java/dev/wadl/_2009/_02/Param.java <br />net/java/dev/wadl/_2009/_02/ParamStyle.java <br />net/java/dev/wadl/_2009/_02/Representation.java <br />net/java/dev/wadl/_2009/_02/Request.java <br />net/java/dev/wadl/_2009/_02/Resource.java <br />net/java/dev/wadl/_2009/_02/ResourceType.java <br />net/java/dev/wadl/_2009/_02/Resources.java <br />net/java/dev/wadl/_2009/_02/Response.java <br />net/java/dev/wadl/_2009/_02/package-info.java</pre>Since we'll be using these classes in a maven based project (and I hate committing generated classes to source repository), let's move <code>xjc</code> execution to maven lifecycle:<br /><br /><pre class="brush: xml; highlight: [27, 28]">&lt;plugin&gt;<br />    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br />    &lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;<br />    &lt;version&gt;1.3&lt;/version&gt;<br />    &lt;dependencies&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;net.java.dev.jaxb2-commons&lt;/groupId&gt;<br />            &lt;artifactId&gt;jaxb-fluent-api&lt;/artifactId&gt;<br />            &lt;version&gt;2.0.1&lt;/version&gt;<br />            &lt;exclusions&gt;<br />                &lt;exclusion&gt;<br />                    &lt;groupId&gt;com.sun.xml&lt;/groupId&gt;<br />                    &lt;artifactId&gt;jaxb-xjc&lt;/artifactId&gt;<br />                &lt;/exclusion&gt;<br />            &lt;/exclusions&gt;<br />        &lt;/dependency&gt;<br />    &lt;/dependencies&gt;<br />    &lt;executions&gt;<br />        &lt;execution&gt;<br />            &lt;goals&gt;<br />                &lt;goal&gt;xjc&lt;/goal&gt;<br />            &lt;/goals&gt;<br />        &lt;/execution&gt;<br />    &lt;/executions&gt;<br />    &lt;configuration&gt;<br />        &lt;arguments&gt;-Xfluent-api&lt;/arguments&gt;<br />        &lt;bindingFiles&gt;bindings.xjb&lt;/bindingFiles&gt;<br />        &lt;packageName&gt;net.java.dev.wadl&lt;/packageName&gt;<br />    &lt;/configuration&gt;<br />&lt;/plugin&gt;<br /></pre>Well, <code>pom.xml</code> isn't the most concise format ever... Never mind, this will generate WADL XML classes during every build, before the source code is compiled. I also love the <code>fluent-api</code> plugin that adds <code>with*()</code> methods along with ordinary setters, returning <code>this</code> to allow chaining. Pretty convenient. Finally we define more pleasant package name for generated artifacts (if you find <code>net.java.dev.wadl._2009._02</code> package name pleasant enough, you can skip this step) and add <code>Wadl</code> prefix to all generated classes <code>bindings.xjb</code> file:<br /><br /><pre class="brush: xml; highlight: [10, 11, 12]">&lt;jxb:bindings version="1.0"<br />  xmlns:jxb="http://java.sun.com/xml/ns/jaxb"<br />  xmlns:xs="http://www.w3.org/2001/XMLSchema"<br />  xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"<br />  jxb:extensionBindingPrefixes="xjc"&gt;<br /><br />    &lt;jxb:bindings schemaLocation="../xsd/wadl.xsd" node="/xs:schema"&gt;<br />        &lt;jxb:schemaBindings&gt;<br />            &lt;jxb:nameXmlTransform&gt;<br />                &lt;jxb:typeName prefix="Wadl"/&gt;<br />                &lt;jxb:anonymousTypeName prefix="Wadl"/&gt;<br />                &lt;jxb:elementName prefix="Wadl"/&gt;<br />            &lt;/jxb:nameXmlTransform&gt;<br />        &lt;/jxb:schemaBindings&gt;<br />    &lt;/jxb:bindings&gt;<br /><br />&lt;/jxb:bindings&gt;<br /></pre>We are now ready to produce and consume WADL in XML format using JAXB and POJO classes. Equipped with that knowledge and the foundation we are ready to develop some interesting library – which will be the subject of the next article.