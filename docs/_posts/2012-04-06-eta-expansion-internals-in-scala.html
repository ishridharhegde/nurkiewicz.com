---
layout: post
title: eta-expansion (internals) in Scala explained
date: '2012-04-06T11:03:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
- spring
modified_time: '2012-04-07T22:54:46.300+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-6619693093259505249
blogger_orig_url: https://www.nurkiewicz.com/2012/04/eta-expansion-internals-in-scala.html
---

Today we will learn how Scala compiler implements very important aspect of the language known as an <i>eta-expansion</i>. We will see how <code>scalac</code> works around the limitations of JVM, in particular with the lack of higher-order functions. But before we begin, to a great surprise, we shall see how these limitations are bypassed by... the Java language itself!<br /><br />Here is the easiest piece of code taking full advantage of anonymous inner classes in Java: the inner class calls method from an outer class. As you probably know every inner class has an implicit hidden <code>Parent.this</code> reference to an outer (<i>parent</i>) class. This is illustrated by the following example:  <br /><pre class="brush: java">public class TestJ {<br />  public Runnable foo() {<br />    return new Runnable() {<br />      public void run() {<br />        inc(5);<br />      }<br />    };<br />  }<br /><br />  private int inc(int x) {<br />    return x + 1;<br />  }<br /><br />}<br /></pre>Anonymous inner class calls private method of its parent completely transparently. Have you ever wondered how does an inner class get access to private methods and fields of its parent? It is not because an inner class is defined inside parent - from the JVM point of view these are two completely independent classes where the anonymous one is named <code>TestJ$1</code>. It is also not a result of the JVM support for inner classes - because there is no such. So how come some arbitrary class can call private methods of <code>TestJ</code>? Let us see what is under the hood:<br /><a name='more'></a> <br /><pre class="brush: plain; highlight: 8">$ javac TestJ.java<br />$ javap -private TestJ<br />Compiled from "TestJ.java"<br />public class TestJ extends java.lang.Object{<br />    public TestJ();<br />    public java.lang.Runnable foo();<br />    private int inc(int);<br />    static int access$000(TestJ, int);<br />}<br /></pre>Isn't oddly named static <code>access$000(TestJ, int)</code> method a bit disturbing? Superficial decompilation reveals unexpected and possibly dangerous <i>back door</i> in <code>TestJ</code>:  <br /><pre class="brush: java">static int access$000(TestJ testJ, int x) {<br />  return testJ.inc(x);<br />}<br /></pre>And in the inner class itself:  <br /><pre class="brush: java">class TestJ$1 implements java.lang.Runnable {<br /><br />  final TestJ parent;<br /><br />  TestJ$1(TestJ parent) {<br />    this. parent = parent;<br />  }<br /><br />  public void run() {<br />    TestJ.access$000(parent, 5)<br />  }<br />}<br /></pre>Inner classes (including anonymous) are in fact emulated by the JVM/compiler using very simple techniques: the inner class receives a reference to its parent via constructor argument and instead of calling private methods of a parent it calls a special, invisible static method passing that parent. Accessing private parents' fields uses the same approach.  <br /><pre class="brush: java">public class TestJ {<br />  public Runnable foo() {<br />    return new TestJ$1(this);<br />  }<br /><br />  private int inc(int x) {<br />    return x + 1;<br />  }<br /><br />}<br /></pre>Is this behaviour safe or not transparent in any way? No, because synthetic <code>access...()</code> methods are invisible for reflection and only sometimes appear in stack traces. So what does it all have to do with Scala and aforementioned <i>eta-expansion</i>? And what it really is?<br /><br />In Scala there is a distinction between methods and functions. Methods in Scala and methods in Java are compiled to exactly same bytecode:  <br /><pre class="brush: scala">class Test {<br />  private def inc(x: Int) = x + 1<br />}<br /></pre>After compiling and decompiling back to Java we will see something familiar:  <br /><pre class="brush: java">public class Test {<br />  private int inc(int x) {<br />    return x + 1;<br />  }<br />}<br /></pre>Unfortunately neither in JVM nor in Java we can pass methods as arguments of other methods or return them (this is called <i>higher-order function</i> - and even JavaScript can do this!) But in Scala we can write:  <br /><pre class="brush: scala">def inc(x: Int) = x + 1<br /><br />List(1, 2) map inc  //returns List(2, 3)<br /></pre>This trivial idiom passes <code>inc()</code> method as an argument of <code>List.map()</code>. In order to make this to work the compiler performs a process called <i>eta-expansion</i> for us. Basically it wraps the execution of <code>inc()</code> inside an object. This object has a single significant method named <code>apply()</code> which calls <code>inc()</code>. As you probably guessed it is also an anonymous inner class:  <br /><pre class="brush: scala">List(1,2) map new Function1[Int, Int] {<br />  def apply(x: Int) = inc(x)<br />}<br /><br />private def inc(x: Int) = x + 1<br /></pre>This is (more or less) compilable Scala code without syntactic sugar. See how dangerously close we are to a way one would implement <code>map()</code> in Java - anonymous inner class with a single method.<br /><br />Fortunately this process is completely transparent and we almost never have to bother about it. However I would like to mention about subtle implementation difference with regards to accessing private method from the inner class:  <br /><pre class="brush: plain; highlight: 5">$ scalac Test.scala<br />$ javap -private Test<br />Compiled from "Test.scala"<br />public class Test extends java.lang.Object implements scala.ScalaObject{<br />    public final int Test$$inc(int);<br />    public Test();<br />}<br /></pre>Previously private <code>inc()</code> method suddenly changed the name, became public and final. As you can see it serves the same purpose as <code>access$000()</code> in anonymous (inner) classes in Java, however instead of special static methods Scala developers decided to bypass standard encapsulation methods in a more object-oriented manner. This is how the “<i>real</i>" code looks like:  <br /><pre class="brush: java">public final class Test$$anonfun$1 implements Function1 {<br /><br />  private final Test parent;<br /><br />  public int apply(int x) {<br />    return parent.Test$$inc(x);  //calling Test.inc()<br />  }<br /><br />  public Test$$anonfun$1(Test parent);<br />    this. parent = parent;<br />  }<br />}<br /></pre>And usage:  <br /><pre class="brush: scala">List(1,2).map(new Test$$anonfun$1(this))<br /></pre>Why do we even bother about such subtle and internal matters in generated bytecode? It turns out that the Scala way of compiling inner classes confuses the Spring framework. Here is a very short working Spring application (no need for XML, this is the whole code):  <br /><pre class="brush: scala">case class OrderLine(name: String, count: Int)<br />case class Order(customerName: String, lines: Seq[OrderLine])<br /><br />@Service<br />@Transactional<br />class OrderValidator {<br /><br />  def allOrderLinesValid(order: Order): Boolean = order.lines forall valid<br />  def valid(line: OrderLine) = line.count &gt; 0<br /><br />}<br /><br />@Configuration<br />@EnableTransactionManagement(proxyTargetClass = true)<br />class SpringBootstrap {<br /><br />  @Bean<br />  def orderValidator() = new OrderValidator()<br /><br />  @Bean<br />  def transactionManager() = Mockito mock classOf[PlatformTransactionManager]<br /><br />}<br /><br />object SpringBootstrap extends App {<br />  val context = new AnnotationConfigApplicationContext(classOf[SpringBootstrap])<br />  context.close()<br />}<br /></pre>For simplicity I mock transaction manager so that I can use <code>@Transactional</code>. Everything works as expected, however after changing the access modifier of <code>valid()</code> method from <code>public</code> (default) to <code>private</code> we get unexpected warning printed during startup:  <pre class="brush: plain">o.s.a.f.Cglib2AopProxy | Unable to proxy method [public final boolean OrderValidator.OrderValidator$$valid(OrderLine)] because it is final: All calls to this method via a proxy will be routed directly to the proxy.</pre> The meaning of this error is now irrelevant. But what is this <code> public final OrderValidator$$valid(OrderLine)</code> method doing here? IT turns out that after hiding <code>valid()</code> under <code>private</code> modifier the eta-expansion mechanism had to somehow made it public again - by also obfuscating the original name. However, in contrary to Java compiler (generating static methods following <code>access$000</code> naming convention), the ones generated by <code>scalac</code> aren't “protected" by the JVM and hidden from reflection. Spring sees them, although we don't.<br /><br />It is an open question whether this implementation is a potential security hole in generated classes. If that is the case, fortunately the fix is simple (?) - <code>scalac</code> should follow naming conventions compatible with <code>javac</code>.  <blockquote>This was a translation of my article <a href="http://scala.net.pl/jak-dziala-eta-expansion/">"Jak działa (i czym jest) eta expansion?"</a> originally published on <a href="http://scala.net.pl">scala.net.pl</a>. </blockquote>