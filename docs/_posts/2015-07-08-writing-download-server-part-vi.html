---
layout: post
title: 'Writing a download server. Part VI: Describe what you send (Content-type,
  et.al.)'
date: '2015-07-08T23:28:00.001+02:00'
author: Tomasz Nurkiewicz
tags:
- spring mvc
- HTTP
- spring
modified_time: '2015-07-08T23:34:55.522+02:00'
thumbnail: http://3.bp.blogspot.com/-_9XtiRceS2s/VZ2VyiC9FAI/AAAAAAAABTU/UzRX0HdVc7I/s72-c/pdf_binary.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8422472443255424527
blogger_orig_url: https://www.nurkiewicz.com/2015/07/writing-download-server-part-vi.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-_9XtiRceS2s/VZ2VyiC9FAI/AAAAAAAABTU/UzRX0HdVc7I/s1600/pdf_binary.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="179" src="http://3.bp.blogspot.com/-_9XtiRceS2s/VZ2VyiC9FAI/AAAAAAAABTU/UzRX0HdVc7I/s320/pdf_binary.png" width="320" /></a></div>As far as HTTP is concerned, what client is downloading is just a bunch of bytes. However client would really like to know how to interpret these bytes. Is it an image? Or maybe a ZIP file? The last part of this series describes how to give a hint to the client what she downloads.<br /><br /><h1>Set <code>Content-type</code> response header</h1>Content type describes <a href="https://en.wikipedia.org/wiki/Internet_media_type">MIME type</a> of resource being returned. This header instructs web browser how to treat stream of bytes flowing from the download server. Without this header browser is clueless of what it actually received and simply displays content as if it was a text file. Needless to say binary PDF (see screenshot above), image or video displayed like a text file doesn't look good. The hardest part is to actually obtain media type somehow. Luckily Java itself has a tool for guessing media type based on extension and/or contents of the resource:<br /><br /><pre class="brush: java">import com.google.common.net.MediaType;<br />import java.io.*;<br />import java.time.Instant;<br /><br />public class FileSystemPointer implements FilePointer {<br /><br />    private final MediaType mediaTypeOrNull;<br /><br />    public FileSystemPointer(File target) {<br />        final String contentType = java.nio.file.Files.probeContentType(target.toPath());<br />        this.mediaTypeOrNull = contentType != null ?<br />                MediaType.parse(contentType) :<br />                null;<br />    }<br /></pre>Note that it's not idiomatic to use <code>Optional&lt;T&gt;</code> as a class field, because it's not <code>Serializable</code> and we avoid potential issues. Knowing the media type we must return it in the response. Notice that this small snippet of code uses both <code>Optional</code> from JDK 8 and Guava, as well as <code>MediaType</code> class from both Spring framework and Guava. What a type system mess!<br /><br /><pre class="brush: java">private ResponseEntity&lt;Resource&gt; response(FilePointer filePointer, HttpStatus status, Resource body) {<br />    final ResponseEntity.BodyBuilder responseBuilder = ResponseEntity<br />            .status(status)<br />            .eTag(filePointer.getEtag())<br />            .contentLength(filePointer.getSize())<br />            .lastModified(filePointer.getLastModified().toEpochMilli());<br />    filePointer<br />            .getMediaType()<br />            .map(this::toMediaType)<br />            .ifPresent(responseBuilder::contentType);<br />    return responseBuilder.body(body);<br />}<br /><br />private MediaType toMediaType(com.google.common.net.MediaType input) {<br />    return input.charset()<br />            .transform(c -&gt; new MediaType(input.type(), input.subtype(), c))<br />            .or(new MediaType(input.type(), input.subtype()));<br />}<br /><br />@Override<br />public Optional&lt;MediaType&gt; getMediaType() {<br />    return Optional.ofNullable(mediaTypeOrNull);<br />}<br /></pre><h1>Preserve original file name and extension</h1>While <code>Content-type</code> works great when you open a document straight in a web browser, imagine your user stores this document on disk. Whether the browser decides to display or store a downloaded file is beyond the scope of this article - but we should be prepared for both. If browser simply stores file on disk, it has to save it under some name. Firefox by default will use the last part of URL, which happens to be UUID of the resource in our case. Not very user friendly. Chrome is a bit better - knowing the MIME type from <code>Content-type</code> header it will heuristically add appropriate extension, e.g. <code>.zip</code> in case of <code>application/zip</code>. But still the file name is a random UUID, while what the user uploaded might have been <code>cats.zip</code>. Thus if you are aiming toward browsers and not automated clients, it would be desirable to use real name as last part of the URL. We still want to use UUIDs to distinguish between resources internally, avoid collision and not expose our internal storage structure. But externally we can redirect to user-friendly URL, but keeping UUID for safety. First of all we need one extra endpoint:<br /><br /><pre class="brush: java">@RequestMapping(method = {GET, HEAD}, value = "/{uuid}")<br />public ResponseEntity&lt;Resource&gt; redirect(<br />        HttpMethod method,<br />        @PathVariable UUID uuid,<br />        @RequestHeader(IF_NONE_MATCH) Optional&lt;String&gt; requestEtagOpt,<br />        @RequestHeader(IF_MODIFIED_SINCE) Optional&lt;Date&gt; ifModifiedSinceOpt<br />        ) {<br />    return findExistingFile(method, uuid)<br />            .map(file -&gt; file.redirect(requestEtagOpt, ifModifiedSinceOpt))<br />            .orElseGet(() -&gt; new ResponseEntity&lt;&gt;(NOT_FOUND));<br />}<br /><br />@RequestMapping(method = {GET, HEAD}, value = "/{uuid}/{filename}")<br />public ResponseEntity&lt;Resource&gt; download(<br />        HttpMethod method,<br />        @PathVariable UUID uuid,<br />        @RequestHeader(IF_NONE_MATCH) Optional&lt;String&gt; requestEtagOpt,<br />        @RequestHeader(IF_MODIFIED_SINCE) Optional&lt;Date&gt; ifModifiedSinceOpt<br />        ) {<br />    return findExistingFile(method, uuid)<br />            .map(file -&gt; file.handle(requestEtagOpt, ifModifiedSinceOpt))<br />            .orElseGet(() -&gt; new ResponseEntity&lt;&gt;(NOT_FOUND));<br />}<br /><br />private Optional&lt;ExistingFile&gt; findExistingFile(HttpMethod method, @PathVariable UUID uuid) {<br />    return storage<br />            .findFile(uuid)<br />            .map(pointer -&gt; new ExistingFile(method, pointer, uuid));<br />}<br /></pre>If you look closely, <code>{filename}</code> is not even used, it's merely a hint for the browser. If you want extra security, you might compare supplied file name with the one mapped to given <code>UUID</code>. What's really important here is that just asking for <code>UUID</code> will redirect us:<br /><br /><pre class="brush: java">$ curl -v localhost:8080/download/4a8883b6-ead6-4b9e-8979-85f9846cab4b<br />&gt; GET /download/4a8883b6-ead6-4b9e-8979-85f9846cab4b HTTP/1.1<br />...<br />&lt; HTTP/1.1 301 Moved Permanently<br />&lt; Location: /download/4a8883b6-ead6-4b9e-8979-85f9846cab4b/cats.zip<br /></pre>And you need one extra network trip to fetch actual file:<br /><br /><pre class="brush: java">&gt; GET /download/4a8883b6-ead6-4b9e-8979-85f9846cab4b/cats.zip HTTP/1.1<br />...<br />&gt; <br />HTTP/1.1 200 OK<br />&lt; ETag: "be20c3b1...fb1a4"<br />&lt; Last-Modified: Thu, 21 Aug 2014 22:44:37 GMT<br />&lt; Content-Type: application/zip;charset=UTF-8<br />&lt; Content-Length: 489455<br /></pre>The implementation is straightforward, but it was refactored a bit to avoid duplication:<br /><br /><pre class="brush: java">public ResponseEntity&lt;Resource&gt; redirect(Optional&lt;String&gt; requestEtagOpt, Optional&lt;Date&gt; ifModifiedSinceOpt) {<br />    if (cached(requestEtagOpt, ifModifiedSinceOpt))<br />        return notModified(filePointer);<br />    return redirectDownload(filePointer);<br />}<br /><br />public ResponseEntity&lt;Resource&gt; handle(Optional&lt;String&gt; requestEtagOpt, Optional&lt;Date&gt; ifModifiedSinceOpt) {<br />    if (cached(requestEtagOpt, ifModifiedSinceOpt))<br />        return notModified(filePointer);<br />    return serveDownload(filePointer);<br />}<br /><br />private boolean cached(Optional&lt;String&gt; requestEtagOpt, Optional&lt;Date&gt; ifModifiedSinceOpt) {<br />    final boolean matchingEtag = requestEtagOpt<br />            .map(filePointer::matchesEtag)<br />            .orElse(false);<br />    final boolean notModifiedSince = ifModifiedSinceOpt<br />            .map(Date::toInstant)<br />            .map(filePointer::modifiedAfter)<br />            .orElse(false);<br />    return matchingEtag || notModifiedSince;<br />}<br /><br />private ResponseEntity&lt;Resource&gt; redirectDownload(FilePointer filePointer) {<br />    try {<br />        log.trace("Redirecting {} '{}'", method, filePointer);<br />        return ResponseEntity<br />                .status(MOVED_PERMANENTLY)<br />                .location(new URI("/download/" + uuid + "/" + filePointer.getOriginalName()))<br />                .body(null);<br />    } catch (URISyntaxException e) {<br />        throw new IllegalArgumentException(e);<br />    }<br />}<br /><br />private ResponseEntity&lt;Resource&gt; serveDownload(FilePointer filePointer) {<br />    log.debug("Serving {} '{}'", method, filePointer);<br />    final InputStreamResource resource = resourceToReturn(filePointer);<br />    return response(filePointer, OK, resource);<br />}<br /></pre>You can even go further with higher-order functions to avoid little duplication:<br /><br /><pre class="brush: java">public ResponseEntity&lt;Resource&gt; redirect(Optional&lt;String&gt; requestEtagOpt, Optional&lt;Date&gt; ifModifiedSinceOpt) {<br />    return serveWithCaching(requestEtagOpt, ifModifiedSinceOpt, this::redirectDownload);<br />}<br /><br />public ResponseEntity&lt;Resource&gt; handle(Optional&lt;String&gt; requestEtagOpt, Optional&lt;Date&gt; ifModifiedSinceOpt) {<br />    return serveWithCaching(requestEtagOpt, ifModifiedSinceOpt, this::serveDownload);<br />}<br /><br />private ResponseEntity&lt;Resource&gt; serveWithCaching(<br />        Optional&lt;String&gt; requestEtagOpt, Optional&lt;Date&gt; ifModifiedSinceOpt, <br />        Function&lt;FilePointer, ResponseEntity&lt;Resource&gt;&gt; notCachedResponse) {<br />    if (cached(requestEtagOpt, ifModifiedSinceOpt))<br />        return notModified(filePointer);<br />    return notCachedResponse.apply(filePointer);<br />}<br /></pre>Obviously one extra redirect is an extra cost one must pay for each download, so it's a trade-off. You may consider heuristics based on <code>User-agent</code> (redirect if browser, server directly if automated client) to avoid redirect in case of non-human clients. This concludes our series about file downloading. The emerge of HTTP/2 will definitely bring more improvements and techniques, like prioritizing.<br /><br /><hr /><h2>Writing a download server</h2><ul><li><a href="http://www.nurkiewicz.com/2015/06/writing-download-server-part-i-always.html">Part I: Always stream, never keep fully in memory</a></li><li><a href="http://www.nurkiewicz.com/2015/06/writing-download-server-part-ii-headers.html">Part II: headers: Last-Modified, ETag and If-None-Match</a></li><li><a href="http://www.nurkiewicz.com/2015/06/writing-download-server-part-iii.html">Part III: headers: Content-length and Range</a></li><li><a href="http://www.nurkiewicz.com/2015/07/writing-download-server-part-iv.html">Part IV: Implement <code>HEAD</code> operation (efficiently)</a></li><li><A href="http://www.nurkiewicz.com/2015/07/writing-download-server-part-v-throttle.html">Part V: Throttle download speed</a></li><li><a href="http://www.nurkiewicz.com/2015/07/writing-download-server-part-vi.html"><strong>Part VI: Describe what you send (Content-type, et.al.)</strong></a></li></ul>The <a href="https://github.com/nurkiewicz/download-server">sample application</a> developed throughout these articles is available on GitHub.<br /><br /><script>SyntaxHighlighter.highlight();</script>